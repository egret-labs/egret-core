{
  "Unterminated_string_literal_1002": "未终止的字符串文本。",
  "Identifier_expected_1003": "应为标识符。",
  "_0_expected_1005": "应为“{0}”。",
  "A_file_cannot_have_a_reference_to_itself_1006": "文件不能引用自身。",
  "Trailing_comma_not_allowed_1009": "不允许使用尾随逗号。",
  "Asterisk_Slash_expected_1010": "应为 \"*/\"。",
  "Unexpected_token_1012": "意外的标记。",
  "A_rest_parameter_must_be_last_in_a_parameter_list_1014": "rest 参数必须是参数列表中的最后一个参数。",
  "Parameter_cannot_have_question_mark_and_initializer_1015": "参数不能包含问号和初始化表达式。",
  "A_required_parameter_cannot_follow_an_optional_parameter_1016": "必选参数不能位于可选参数后。",
  "An_index_signature_cannot_have_a_rest_parameter_1017": "索引签名不能包含 rest 参数。",
  "An_index_signature_parameter_cannot_have_an_accessibility_modifier_1018": "索引签名参数不能具有可访问性修饰符。",
  "An_index_signature_parameter_cannot_have_a_question_mark_1019": "索引签名参数不能包含问号。",
  "An_index_signature_parameter_cannot_have_an_initializer_1020": "索引签名参数不能具有初始化表达式。",
  "An_index_signature_must_have_a_type_annotation_1021": "索引签名必须具有类型批注。",
  "An_index_signature_parameter_must_have_a_type_annotation_1022": "索引签名参数必须具有类型批注。",
  "An_index_signature_parameter_type_must_be_string_or_number_1023": "索引签名参数类型必须为 \"string\" 或 \"number\"。",
  "readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature_1024": "\"readonly\" 仅可出现在属性声明或索引签名中。",
  "Accessibility_modifier_already_seen_1028": "已看到可访问性修饰符。",
  "_0_modifier_must_precede_1_modifier_1029": "“{0}”修饰符必须位于“{1}”修饰符之前。",
  "_0_modifier_already_seen_1030": "已看到“{0}”修饰符。",
  "_0_modifier_cannot_appear_on_a_class_element_1031": "“{0}”修饰符不能出现在类元素上。",
  "super_must_be_followed_by_an_argument_list_or_member_access_1034": "\"super\" 的后面必须是参数列表或成员访问。",
  "Only_ambient_modules_can_use_quoted_names_1035": "仅环境模块可使用带引号的名称。",
  "Statements_are_not_allowed_in_ambient_contexts_1036": "不允许在环境上下文中使用语句。",
  "A_declare_modifier_cannot_be_used_in_an_already_ambient_context_1038": "不能在已有的环境上下文中使用 \"declare\" 修饰符。",
  "Initializers_are_not_allowed_in_ambient_contexts_1039": "不允许在环境上下文中使用初始化表达式。",
  "_0_modifier_cannot_be_used_in_an_ambient_context_1040": "“{0}”修饰符不能在环境上下文中使用。",
  "_0_modifier_cannot_be_used_with_a_class_declaration_1041": "“{0}”修饰符不能与类声明一起使用。",
  "_0_modifier_cannot_be_used_here_1042": "“{0}”修饰符不能在此处使用。",
  "_0_modifier_cannot_appear_on_a_data_property_1043": "“{0}”修饰符不能出现在数据属性上。",
  "_0_modifier_cannot_appear_on_a_module_or_namespace_element_1044": "“{0}”修饰符不可出现在模块或命名空间元素上。",
  "A_0_modifier_cannot_be_used_with_an_interface_declaration_1045": "“{0}”修饰符不能与接口声明一起使用。",
  "A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file_1046": "在 .d.ts 文件中的顶层声明需要 \"declare\" 修饰符。",
  "A_rest_parameter_cannot_be_optional_1047": "rest 参数不能为可选参数。",
  "A_rest_parameter_cannot_have_an_initializer_1048": "rest 参数不能具有初始化表达式。",
  "A_set_accessor_must_have_exactly_one_parameter_1049": "\"set\" 访问器必须正好具有一个参数。",
  "A_set_accessor_cannot_have_an_optional_parameter_1051": "\"set\" 访问器不能具有可选参数。",
  "A_set_accessor_parameter_cannot_have_an_initializer_1052": "\"set\" 访问器参数不能包含初始化表达式。",
  "A_set_accessor_cannot_have_rest_parameter_1053": "\"set\" 访问器不能具有 rest 参数。",
  "A_get_accessor_cannot_have_parameters_1054": "\"get\" 访问器不能具有参数。",
  "Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Prom_1055": "类型“{0}”不是 ES5/ES3 中的有效异步函数返回类型，因为其未引用与 Promise 相符的构造函数值。",
  "Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher_1056": "访问器仅在面向 ECMAScript 5 和更高版本时可用。",
  "An_async_function_or_method_must_have_a_valid_awaitable_return_type_1057": "异步函数或方法必须具有有效的可等待返回类型。",
  "Operand_for_await_does_not_have_a_valid_callable_then_member_1058": "\"await\" 的操作数不具有有效的可调用 \"then\" 成员。",
  "Return_expression_in_async_function_does_not_have_a_valid_callable_then_member_1059": "异步函数中的返回表达式不具有有效的可调用 \"then\" 成员。",
  "Expression_body_for_async_arrow_function_does_not_have_a_valid_callable_then_member_1060": "异步箭头函数的表达式主体不具有有效的可调用 \"then\" 成员。",
  "Enum_member_must_have_initializer_1061": "枚举成员必须具有初始化表达式。",
  "_0_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method_1062": "{0} 在其自身的 \"then\" 方法的 fulfillment 回调中得到直接或间接引用。",
  "An_export_assignment_cannot_be_used_in_a_namespace_1063": "不能在命名空间中使用导出分配。",
  "The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_1064": "异步函数或方法的返回类型必须为全局 Promise<T> 类型。",
  "In_ambient_enum_declarations_member_initializer_must_be_constant_expression_1066": "在环境枚举声明中，成员初始化表达式必须是常数表达式。",
  "Unexpected_token_A_constructor_method_accessor_or_property_was_expected_1068": "意外的标记。应为构造函数、方法、访问器或属性。",
  "_0_modifier_cannot_appear_on_a_type_member_1070": "“{0}”修饰符不可出现在类型成员上。",
  "_0_modifier_cannot_appear_on_an_index_signature_1071": "“{0}”修饰符不可出现在索引签名上。",
  "A_0_modifier_cannot_be_used_with_an_import_declaration_1079": "“{0}”修饰符不能与导入声明一起使用。",
  "Invalid_reference_directive_syntax_1084": "\"reference\" 指令语法无效。",
  "Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_1085": "面向 ECMAScript 5 和更高版本时，八进制文本不可用。",
  "An_accessor_cannot_be_declared_in_an_ambient_context_1086": "不能在环境上下文中声明访问器。",
  "_0_modifier_cannot_appear_on_a_constructor_declaration_1089": "“{0}”修饰符不能出现在构造函数声明中。",
  "_0_modifier_cannot_appear_on_a_parameter_1090": "“{0}”修饰符不能出现在参数中。",
  "Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement_1091": "\"for...in\" 语句中只允许单个变量声明。",
  "Type_parameters_cannot_appear_on_a_constructor_declaration_1092": "类型参数不能出现在构造函数声明中。",
  "Type_annotation_cannot_appear_on_a_constructor_declaration_1093": "类型批注不能出现在构造函数声明中。",
  "An_accessor_cannot_have_type_parameters_1094": "访问器不能具有类型参数。",
  "A_set_accessor_cannot_have_a_return_type_annotation_1095": "\"set\" 访问器不能具有返回类型批注。",
  "An_index_signature_must_have_exactly_one_parameter_1096": "索引签名必须正好具有一个参数。",
  "_0_list_cannot_be_empty_1097": "“{0}”列表不能为空。",
  "Type_parameter_list_cannot_be_empty_1098": "类型参数列表不能为空。",
  "Type_argument_list_cannot_be_empty_1099": "类型参数列表不能为空。",
  "Invalid_use_of_0_in_strict_mode_1100": "严格模式下“{0}”的使用无效。",
  "with_statements_are_not_allowed_in_strict_mode_1101": "严格模式下不允许使用 \"with\" 语句。",
  "delete_cannot_be_called_on_an_identifier_in_strict_mode_1102": "在严格模式下，无法对标识符调用 \"delete\"。",
  "A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement_1104": "\"continue\" 语句只能在封闭迭代语句内使用。",
  "A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement_1105": "\"break\" 语句只能在封闭迭代或 switch 语句内使用。",
  "Jump_target_cannot_cross_function_boundary_1107": "跳转目标不能跨越函数边界。",
  "A_return_statement_can_only_be_used_within_a_function_body_1108": "\"return\" 语句只能在函数体中使用。",
  "Expression_expected_1109": "应为表达式。",
  "Type_expected_1110": "应为类型。",
  "A_default_clause_cannot_appear_more_than_once_in_a_switch_statement_1113": "\"default\" 子句在 \"switch\" 语句中只能出现一次。",
  "Duplicate_label_0_1114": "标签“{0}”重复",
  "A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement_1115": "\"continue\" 语句只能跳转到封闭迭代语句的标签。",
  "A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement_1116": "\"break\" 语句只能跳转到封闭语句的标签。",
  "An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode_1117": "严格模式下，对象文字不能包含多个具有相同名称的属性。",
  "An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name_1118": "对象文字不能具有多个具有相同名称的 get/set 访问器。",
  "An_object_literal_cannot_have_property_and_accessor_with_the_same_name_1119": "对象文字不能包含具有相同名称的属性和访问器。",
  "An_export_assignment_cannot_have_modifiers_1120": "导出分配不能具有修饰符。",
  "Octal_literals_are_not_allowed_in_strict_mode_1121": "严格模式下不允许使用八进制文本。",
  "A_tuple_type_element_list_cannot_be_empty_1122": "元组类型元素列表不能为空。",
  "Variable_declaration_list_cannot_be_empty_1123": "变量声明列表不能为空。",
  "Digit_expected_1124": "应为数字。",
  "Hexadecimal_digit_expected_1125": "应为十六进制数字。",
  "Unexpected_end_of_text_1126": "文本意外结束。",
  "Invalid_character_1127": "无效的字符。",
  "Declaration_or_statement_expected_1128": "应为声明或语句。",
  "Statement_expected_1129": "应为语句。",
  "case_or_default_expected_1130": "应为 \"case\" 或 \"default\"。",
  "Property_or_signature_expected_1131": "应为属性或签名。",
  "Enum_member_expected_1132": "应为枚举成员。",
  "Variable_declaration_expected_1134": "应为变量声明。",
  "Argument_expression_expected_1135": "应为参数表达式。",
  "Property_assignment_expected_1136": "应为属性分配。",
  "Expression_or_comma_expected_1137": "应为表达式或逗号。",
  "Parameter_declaration_expected_1138": "应为参数声明。",
  "Type_parameter_declaration_expected_1139": "应为类型参数声明。",
  "Type_argument_expected_1140": "应为类型参数。",
  "String_literal_expected_1141": "应为字符串文本。",
  "Line_break_not_permitted_here_1142": "不允许在此处换行。",
  "or_expected_1144": "应为 \"{\" 或 \";\"。",
  "Declaration_expected_1146": "应为声明。",
  "Import_declarations_in_a_namespace_cannot_reference_a_module_1147": "命名空间中的导入声明不能引用模块。",
  "Cannot_use_imports_exports_or_module_augmentations_when_module_is_none_1148": "当 \"--module\" 为 \"none\" 时无法使用导入、导出或模块扩大。",
  "File_name_0_differs_from_already_included_file_name_1_only_in_casing_1149": "文件名“{0}”仅在大小写方面与包含的文件名“{1}”不同",
  "new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead_1150": "\"new T[]\" 不能用于创建数组。请改用 \"new Array<T>()\"。",
  "const_declarations_must_be_initialized_1155": "必须初始化 \"const\" 声明",
  "const_declarations_can_only_be_declared_inside_a_block_1156": "\"const\" 声明只能在块的内部声明。",
  "let_declarations_can_only_be_declared_inside_a_block_1157": "\"let\" 声明只能在块的内部声明。",
  "Unterminated_template_literal_1160": "未终止的模板文本。",
  "Unterminated_regular_expression_literal_1161": "未终止的正则表达式文本。",
  "An_object_member_cannot_be_declared_optional_1162": "对象成员无法声明为可选。",
  "A_yield_expression_is_only_allowed_in_a_generator_body_1163": "只允许在生成器正文中使用 \"yield\" 表达式。",
  "Computed_property_names_are_not_allowed_in_enums_1164": "枚举中不允许计算属性名。",
  "A_computed_property_name_in_an_ambient_context_must_directly_refer_to_a_built_in_symbol_1165": "环境上下文中的计算属性名必须直接引用内置符号。",
  "A_computed_property_name_in_a_class_property_declaration_must_directly_refer_to_a_built_in_symbol_1166": "类属性声明中的计算属性名必须直接引用内置符号。",
  "A_computed_property_name_in_a_method_overload_must_directly_refer_to_a_built_in_symbol_1168": "方法重载中的计算属性名必须直接引用内置符号。",
  "A_computed_property_name_in_an_interface_must_directly_refer_to_a_built_in_symbol_1169": "接口中的计算属性名必须直接引用内置符号。",
  "A_computed_property_name_in_a_type_literal_must_directly_refer_to_a_built_in_symbol_1170": "类型文本中的计算属性名必须直接引用内置符号。",
  "A_comma_expression_is_not_allowed_in_a_computed_property_name_1171": "计算属性名中不允许逗号表达式。",
  "extends_clause_already_seen_1172": "已看到 \"extends\" 子句。",
  "extends_clause_must_precede_implements_clause_1173": "\"extends\" 子句必须位于 \"implements\" 子句之前。",
  "Classes_can_only_extend_a_single_class_1174": "类只能扩展一个类。",
  "implements_clause_already_seen_1175": "已看到 \"implements\" 子句。",
  "Interface_declaration_cannot_have_implements_clause_1176": "接口声明不能有 \"implements\" 子句。",
  "Binary_digit_expected_1177": "需要二进制数字。",
  "Octal_digit_expected_1178": "需要八进制数字。",
  "Unexpected_token_expected_1179": "意外标记。应为 \"{\"。",
  "Property_destructuring_pattern_expected_1180": "应为属性析构模式。",
  "Array_element_destructuring_pattern_expected_1181": "应为数组元素析构模式。",
  "A_destructuring_declaration_must_have_an_initializer_1182": "析构声明必须具有初始化表达式。",
  "An_implementation_cannot_be_declared_in_ambient_contexts_1183": "不能在环境上下文中声明实现。",
  "Modifiers_cannot_appear_here_1184": "修饰符不能出现在此处。",
  "Merge_conflict_marker_encountered_1185": "遇到合并冲突标记。",
  "A_rest_element_cannot_have_an_initializer_1186": "rest 元素不能具有初始化表达式。",
  "A_parameter_property_may_not_be_declared_using_a_binding_pattern_1187": "不能使用绑定模式声明参数属性。",
  "Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement_1188": "\"for...of\" 语句中只允许单个变量声明。",
  "The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer_1189": "\"for...in\" 语句的变量声明不能有初始化表达式。",
  "The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer_1190": "\"for...of\" 语句的变量声明不能有初始化表达式。",
  "An_import_declaration_cannot_have_modifiers_1191": "导入声明不能有修饰符。",
  "Module_0_has_no_default_export_1192": "模块“{0}”没有默认导出。",
  "An_export_declaration_cannot_have_modifiers_1193": "导出声明不能有修饰符。",
  "Export_declarations_are_not_permitted_in_a_namespace_1194": "命名空间中不允许有导出声明。",
  "Catch_clause_variable_cannot_have_a_type_annotation_1196": "Catch 子句变量不能有类型批注。",
  "Catch_clause_variable_cannot_have_an_initializer_1197": "Catch 子句变量不能有初始化表达式。",
  "An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive_1198": "扩展的 Unicode 转义值必须介于(含) 0x0 和 0x10FFFF 之间。",
  "Unterminated_Unicode_escape_sequence_1199": "未终止的 Unicode 转义序列。",
  "Line_terminator_not_permitted_before_arrow_1200": "箭头前不允许有行终止符。",
  "Import_assignment_cannot_be_used_when_targeting_ECMAScript_2015_modules_Consider_using_import_Asteri_1202": "当面向 ECMAScript 2015 模块时，不能使用导入分配。请考虑改用 \"import * as ns from \"mod\"\"、\"import {a} from \"mod\"\"、\"import d from \"mod\"\" 或另一种模块格式。",
  "Export_assignment_cannot_be_used_when_targeting_ECMAScript_2015_modules_Consider_using_export_defaul_1203": "当面向 ECMAScript 2015 模块时，不能使用导出分配。请考虑改用 \"export default\" 或另一种模块格式。",
  "Decorators_are_not_valid_here_1206": "修饰器在此处无效。",
  "Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name_1207": "不能向多个同名的 get/set 访问器应用修饰器。",
  "Cannot_compile_namespaces_when_the_isolatedModules_flag_is_provided_1208": "提供 \"--isolatedModules\" 标志时无法编译命名空间。",
  "Ambient_const_enums_are_not_allowed_when_the_isolatedModules_flag_is_provided_1209": "提供 \"--isolatedModules\" 标志的情况下不允许使用环境常数枚举。",
  "Invalid_use_of_0_Class_definitions_are_automatically_in_strict_mode_1210": "“{0}”的使用无效。类定义自动处于严格模式。",
  "A_class_declaration_without_the_default_modifier_must_have_a_name_1211": "不带 \"default\" 修饰符的类声明必须具有名称",
  "Identifier_expected_0_is_a_reserved_word_in_strict_mode_1212": "应为标识符。“{0}”在严格模式下是保留字",
  "Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_stric_1213": "应为标识符。“{0}”在严格模式下是保留字。类定义自动处于严格模式。",
  "Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode_1214": "应为标识符。“{0}”是严格模式下的保留字。模块自动处于严格模式。",
  "Invalid_use_of_0_Modules_are_automatically_in_strict_mode_1215": "“{0}”的使用无效。模块自动处于严格模式。",
  "Export_assignment_is_not_supported_when_module_flag_is_system_1218": "当 \"--module\" 标志是 \"system\" 时不支持导出分配。",
  "Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_t_1219": "对修饰器的实验支持是一项将在将来版本中更改的功能。设置 \"experimentalDecorators\" 选项以删除此警告。",
  "Generators_are_only_available_when_targeting_ECMAScript_2015_or_higher_1220": "仅当面向 ECMAScript 2015 或更高版本时，生成器才可用。",
  "Generators_are_not_allowed_in_an_ambient_context_1221": "不允许在环境上下文中使用生成器。",
  "An_overload_signature_cannot_be_declared_as_a_generator_1222": "重载签名无法声明为生成器。",
  "_0_tag_already_specified_1223": "已指定“{0}”标记。",
  "Signature_0_must_have_a_type_predicate_1224": "签名“{0}”必须具有类型谓词。",
  "Cannot_find_parameter_0_1225": "找不到参数“{0}”。",
  "Type_predicate_0_is_not_assignable_to_1_1226": "类型谓词“{0}”不可分配给“{1}”。",
  "Parameter_0_is_not_in_the_same_position_as_parameter_1_1227": "参数“{0}”和参数“{1}”的位置不一样。",
  "A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods_1228": "只允许在函数和方法的返回类型位置使用类型谓词。",
  "A_type_predicate_cannot_reference_a_rest_parameter_1229": "类型谓词无法引用 rest 参数。",
  "A_type_predicate_cannot_reference_element_0_in_a_binding_pattern_1230": "类型谓词无法在绑定模式中引用元素“{0}”。",
  "An_export_assignment_can_only_be_used_in_a_module_1231": "导出分配只能在模块中使用。",
  "An_import_declaration_can_only_be_used_in_a_namespace_or_module_1232": "导入声明只能在命名空间或模块中使用。",
  "An_export_declaration_can_only_be_used_in_a_module_1233": "导出声明只能在模块中使用。",
  "An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file_1234": "只允许在文件的顶层中使用环境模块声明。",
  "A_namespace_declaration_is_only_allowed_in_a_namespace_or_module_1235": "只允许在命名空间或模块中使用命名空间声明。",
  "The_return_type_of_a_property_decorator_function_must_be_either_void_or_any_1236": "属性修饰器函数的返回类型必须为 \"void\" 或 \"any\"。",
  "The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any_1237": "参数修饰器函数的返回类型必须为 \"void\" 或 \"any\"。",
  "Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression_1238": "作为表达式调用时，无法解析类修饰器的签名。",
  "Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression_1239": "作为表达式调用时，无法解析参数修饰器的签名。",
  "Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression_1240": "作为表达式调用时，无法解析属性修饰器的签名。",
  "Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression_1241": "作为表达式调用时，无法解析方法修饰器的签名。",
  "abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration_1242": "\"abstract\" 修饰符仅可出现在类、方法或属性声明中。",
  "_0_modifier_cannot_be_used_with_1_modifier_1243": "“{0}”修饰符不能与“{1}”修饰符一起使用。",
  "Abstract_methods_can_only_appear_within_an_abstract_class_1244": "抽象方法只能出现在抽象类中。",
  "Method_0_cannot_have_an_implementation_because_it_is_marked_abstract_1245": "方法“{0}”不能具有实现，因为它标记为抽象。",
  "An_interface_property_cannot_have_an_initializer_1246": "接口函数不能具有初始化表达式。",
  "A_type_literal_property_cannot_have_an_initializer_1247": "类型文字数据不可具有初始化表达式。",
  "A_class_member_cannot_have_the_0_keyword_1248": "类成员不可具有“{0}”关键字。",
  "A_decorator_can_only_decorate_a_method_implementation_not_an_overload_1249": "修饰器仅可修饰方法实现，而不可修饰重载。",
  "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_1250": "面向 \"ES3\" 或 \"ES5\" 时，在严格模式下，块内不允许函数声明。",
  "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_d_1251": "面向 \"ES3\" 或 \"ES5\" 时，在严格模式下，块内不允许函数声明。类定义自动处于严格模式。",
  "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_1252": "面向 \"ES3\" 或 \"ES5\" 时，在严格模式下，块内不允许函数声明。模块自动处于严格模式。",
  "_0_tag_cannot_be_used_independently_as_a_top_level_JSDoc_tag_1253": "“{0}”标记无法单独用作顶级 JSDoc 标记。",
  "A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_1254": "环境上下文中的 \"const\" 初始化表达式必须为字符串或数字参数。",
  "with_statements_are_not_allowed_in_an_async_function_block_1300": "不允许在异步函数块中使用 \"with\" 语句。",
  "await_expression_is_only_allowed_within_an_async_function_1308": "只允许在异步函数中使用 \"await\" 表达式。",
  "can_only_be_used_in_an_object_literal_property_inside_a_destructuring_assignment_1312": "\"=\" 只可在重构赋值内部的对象文字属性中使用。",
  "The_body_of_an_if_statement_cannot_be_the_empty_statement_1313": "\"if\" 语句的正文不能为空语句。",
  "Global_module_exports_may_only_appear_in_module_files_1314": "全局模块导出仅可出现模块文件中。",
  "Global_module_exports_may_only_appear_in_declaration_files_1315": "全局模块导出仅可出现声明文件中。",
  "Global_module_exports_may_only_appear_at_top_level_1316": "全局模块导出仅可出现在顶层级别中。",
  "A_parameter_property_cannot_be_declared_using_a_rest_parameter_1317": "不能使用 rest 参数声明参数属性。",
  "An_abstract_accessor_cannot_have_an_implementation_1318": "An abstract accessor cannot have an implementation.",
  "Duplicate_identifier_0_2300": "标识符“{0}”重复。",
  "Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2301": "实例成员变量“{0}”的初始化表达式不能引用构造函数中声明的标识符“{1}”。",
  "Static_members_cannot_reference_class_type_parameters_2302": "静态成员不能引用类类型参数。",
  "Circular_definition_of_import_alias_0_2303": "导入别名“{0}”的循环定义。",
  "Cannot_find_name_0_2304": "找不到名称“{0}”。",
  "Module_0_has_no_exported_member_1_2305": "模块“{0}”没有导出的成员“{1}”。",
  "File_0_is_not_a_module_2306": "文件“{0}”不是模块。",
  "Cannot_find_module_0_2307": "找不到模块“{0}”。",
  "Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambig_2308": "模块 {0} 已导出一个名为“{1}”的成员。请考虑重新显式导出以解决歧义。",
  "An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements_2309": "不能在具有其他导出元素的模块中使用导出分配。",
  "Type_0_recursively_references_itself_as_a_base_type_2310": "类型“{0}”以递归方式将自身引用为基类。",
  "A_class_may_only_extend_another_class_2311": "类只能扩展其他类。",
  "An_interface_may_only_extend_a_class_or_another_interface_2312": "接口只能扩展类或其他接口。",
  "Type_parameter_0_has_a_circular_constraint_2313": "类型参数“{0}”具有循环约束。",
  "Generic_type_0_requires_1_type_argument_s_2314": "泛型类型“{0}”需要 {1} 个类型参数。",
  "Type_0_is_not_generic_2315": "类型“{0}”不是泛型类型。",
  "Global_type_0_must_be_a_class_or_interface_type_2316": "全局类型“{0}”必须为类或接口类型。",
  "Global_type_0_must_have_1_type_parameter_s_2317": "全局类型“{0}”必须具有 {1} 个类型参数。",
  "Cannot_find_global_type_0_2318": "找不到全局类型“{0}”。",
  "Named_property_0_of_types_1_and_2_are_not_identical_2319": "“{1}”和“{2}”类型的命名属性“{0}”不完全相同。",
  "Interface_0_cannot_simultaneously_extend_types_1_and_2_2320": "接口“{0}”不能同时扩展类型“{1}”和“{2}”。",
  "Excessive_stack_depth_comparing_types_0_and_1_2321": "与类型“{0}”和“{1}”相比，堆栈深度过高。",
  "Type_0_is_not_assignable_to_type_1_2322": "不能将类型“{0}”分配给类型“{1}”。",
  "Cannot_redeclare_exported_variable_0_2323": "无法重新声明导出的变量“{0}”。",
  "Property_0_is_missing_in_type_1_2324": "类型“{1}”中缺少属性“{0}”。",
  "Property_0_is_private_in_type_1_but_not_in_type_2_2325": "属性“{0}”在类型“{1}”中是私有属性，但在类型“{2}”中不是。",
  "Types_of_property_0_are_incompatible_2326": "属性“{0}”的类型不兼容。",
  "Property_0_is_optional_in_type_1_but_required_in_type_2_2327": "属性“{0}”在类型“{1}”中为可选，但在类型“{2}”中为必选。",
  "Types_of_parameters_0_and_1_are_incompatible_2328": "参数“{0}”和“{1}” 的类型不兼容。",
  "Index_signature_is_missing_in_type_0_2329": "类型“{0}”中缺少索引签名。",
  "Index_signatures_are_incompatible_2330": "索引签名不兼容。",
  "this_cannot_be_referenced_in_a_module_or_namespace_body_2331": "不能在模块或命名空间体中引用 \"this\"。",
  "this_cannot_be_referenced_in_current_location_2332": "不能在当前位置引用 \"this\"。",
  "this_cannot_be_referenced_in_constructor_arguments_2333": "不能在构造函数参数中引用 \"this\"。",
  "this_cannot_be_referenced_in_a_static_property_initializer_2334": "不能在静态属性初始化表达式中引用 \"this\"。",
  "super_can_only_be_referenced_in_a_derived_class_2335": "只能在派生类中引用 \"super\"。",
  "super_cannot_be_referenced_in_constructor_arguments_2336": "不能在构造函数参数中引用 \"super\"。",
  "Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors_2337": "不允许在构造函数外部或在构造函数内的嵌套函数中进行 Super 调用。",
  "super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_der_2338": "只有构造函数、成员函数或派生类的成员访问器中才允许 \"super\" 属性访问。",
  "Property_0_does_not_exist_on_type_1_2339": "类型“{1}”上不存在属性“{0}”。",
  "Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword_2340": "通过 \"super\" 关键字只能访问基类的公共方法和受保护方法。",
  "Property_0_is_private_and_only_accessible_within_class_1_2341": "属性“{0}”为私有属性，只能在类“{1}”中访问。",
  "An_index_expression_argument_must_be_of_type_string_number_symbol_or_any_2342": "索引表达式参数必须为 \"string\"、\"number\"、\"symbol\" 或 \"any\" 类型。",
  "This_syntax_requires_an_imported_helper_named_1_but_module_0_has_no_exported_member_1_2343": "This syntax requires an imported helper named '{1}', but module '{0}' has no exported member '{1}'.",
  "Type_0_does_not_satisfy_the_constraint_1_2344": "类型“{0}”不满足约束“{1}”。",
  "Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_2345": "类型“{0}”的参数不能赋给类型“{1}”的参数。",
  "Supplied_parameters_do_not_match_any_signature_of_call_target_2346": "提供的参数与调用目标的任何签名都不匹配。",
  "Untyped_function_calls_may_not_accept_type_arguments_2347": "非类型化函数调用不能接受类型参数。",
  "Value_of_type_0_is_not_callable_Did_you_mean_to_include_new_2348": "类型“{0}”的值不可调用。是否希望包括 \"new\"?",
  "Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatur_2349": "无法调用类型缺少调用签名的表达式。类型“{0}”没有兼容的调用签名。",
  "Only_a_void_function_can_be_called_with_the_new_keyword_2350": "使用 \"new\" 关键字只能调用 void 函数。",
  "Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature_2351": "其类型缺少调用或构造签名的表达式无法使用 \"new\"。",
  "Type_0_cannot_be_converted_to_type_1_2352": "类型“{0}”不可转换为类型“{1}”。",
  "Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1_2353": "对象文字可以只指定已知属性，并且“{0}”不在类型“{1}”中。",
  "This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found_2354": "This syntax requires an imported helper but module '{0}' cannot be found.",
  "A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_2355": "其声明类型不为 \"void\" 或 \"any\" 的函数必须返回值。",
  "An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type_2356": "算术操作数必须为类型 \"any\"、\"number\" 或枚举类型。",
  "The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access_2357": "递增或递减运算符的操作数必须是变量或属性访问。",
  "The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_paramete_2358": "\"instanceof\" 表达式左侧必须是 \"any\" 类型、对象类型或类型参数。",
  "The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_F_2359": "\"instanceof\" 表达式的右侧必须属于类型 \"any\"，或属于可分配给 \"Function\" 接口类型的类型。",
  "The_left_hand_side_of_an_in_expression_must_be_of_type_any_string_number_or_symbol_2360": "\"in\" 表达式左侧的类型必须为 \"any\"、\"string\"、\"number\" 或 \"symbol\"。",
  "The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter_2361": "\"in\" 表达式的右侧必须是 \"any\" 类型、对象类型或类型参数",
  "The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type_2362": "算术运算左侧必须是 \"any\"、\"number\" 或枚举类型。",
  "The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type_2363": "算术运算右侧必须是 \"any\"、\"number\" 或枚举类型。",
  "The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access_2364": "赋值表达式的左侧必须是变量或属性访问。",
  "Operator_0_cannot_be_applied_to_types_1_and_2_2365": "运算符“{0}”不能应用于类型“{1}”和“{2}”。",
  "Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined_2366": "函数缺少结束返回语句，返回类型不包括 \"undefined\"。",
  "Type_parameter_name_cannot_be_0_2368": "类型参数名称不能为“{0}”",
  "A_parameter_property_is_only_allowed_in_a_constructor_implementation_2369": "只允许在构造函数实现中使用参数属性。",
  "A_rest_parameter_must_be_of_an_array_type_2370": "rest 参数必须是数组类型。",
  "A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation_2371": "只允许在函数或构造函数实现中使用参数初始化表达式。",
  "Parameter_0_cannot_be_referenced_in_its_initializer_2372": "参数“{0}”的初始化表达式中不能引用该参数自身。",
  "Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it_2373": "参数“{0}”的初始化表达式不能引用在它之后声明的标识符“{1}”。",
  "Duplicate_string_index_signature_2374": "字符串索引签名重复。",
  "Duplicate_number_index_signature_2375": "数字索引签名重复。",
  "A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_proper_2376": "当类包含初始化的属性或参数属性时，\"super\" 调用必须是构造函数中的第一个语句。",
  "Constructors_for_derived_classes_must_contain_a_super_call_2377": "派生类的构造函数必须包含 \"super\" 调用。",
  "A_get_accessor_must_return_a_value_2378": "\"get\" 访问器必须返回值。",
  "Getter_and_setter_accessors_do_not_agree_in_visibility_2379": "Getter 和 setter 访问器在可见性上不一致。",
  "get_and_set_accessor_must_have_the_same_type_2380": "\"get\" 和 \"set\" 访问器必须属于同一类型。",
  "A_signature_with_an_implementation_cannot_use_a_string_literal_type_2381": "具有实现的签名不能使用字符串文本类型。",
  "Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature_2382": "指定的重载签名不可分配给任何非专用化签名。",
  "Overload_signatures_must_all_be_exported_or_non_exported_2383": "重载签名必须均导出或均不导出。",
  "Overload_signatures_must_all_be_ambient_or_non_ambient_2384": "重载签名必须全部为环境签名或非环境签名。",
  "Overload_signatures_must_all_be_public_private_or_protected_2385": "重载签名必须全部是公共签名、私有签名或受保护签名。",
  "Overload_signatures_must_all_be_optional_or_required_2386": "重载签名必须全部为可选签名或必需签名。",
  "Function_overload_must_be_static_2387": "函数重载必须为静态。",
  "Function_overload_must_not_be_static_2388": "函数重载不能为静态。",
  "Function_implementation_name_must_be_0_2389": "函数实现名称必须为“{0}”。",
  "Constructor_implementation_is_missing_2390": "缺少构造函数实现。",
  "Function_implementation_is_missing_or_not_immediately_following_the_declaration_2391": "函数实现缺失或未立即出现在声明之后。",
  "Multiple_constructor_implementations_are_not_allowed_2392": "不允许存在多个构造函数实现。",
  "Duplicate_function_implementation_2393": "函数实现重复。",
  "Overload_signature_is_not_compatible_with_function_implementation_2394": "重载签名与函数实现不兼容。",
  "Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local_2395": "合并声明“{0}”中的单独声明必须全为导出或全为局部声明。",
  "Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters_2396": "标识符 \"arguments\" 重复。编译器使用 \"arguments\" 初始化 rest 参数。",
  "Declaration_name_conflicts_with_built_in_global_identifier_0_2397": "声明名称与内置全局标识符“{0}”冲突。",
  "Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference_2399": "标识符 \"_this\" 重复。编译器使用变量声明 \"_this\" 来捕获 \"this\" 引用。",
  "Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference_2400": "表达式解析为编译器用于捕获 \"this\" 引用的变量声明 \"_this\"。",
  "Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference_2401": "标识符 \"_super\" 重复。编译器使用 \"_super\" 获取基类引用。",
  "Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference_2402": "表达式解析为 \"_super\"，编译器使用 \"_super\" 获取基类引用。",
  "Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_t_2403": "后续变量声明必须属于同一类型。变量“{0}”必须属于类型“{1}”，但此处却为类型“{2}”。",
  "The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation_2404": "\"for...in\" 语句的左侧不能使用类型批注。",
  "The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any_2405": "\"for...in\" 语句的左侧必须是 \"string\" 或 \"any\" 类型。",
  "The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access_2406": "\"for...in\" 语句的左侧必须是变量或属性访问。",
  "The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_2407": "\"for...in\" 语句右侧必须是 \"any\" 类型、对象类型或类型参数。",
  "Setters_cannot_return_a_value_2408": "Setter 不能返回值。",
  "Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class_2409": "构造函数签名的返回类型必须可赋给类的实例类型",
  "The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any_2410": "不支持 \"with\" 语句。\"with\" 程序块中的所有符号都将具有类型 \"any\"。",
  "Property_0_of_type_1_is_not_assignable_to_string_index_type_2_2411": "类型“{1}”的属性“{0}”不能赋给字符串索引类型“{2}”。",
  "Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2_2412": "类型“{1}”的属性“{0}”不能赋给数值索引类型“{2}”。",
  "Numeric_index_type_0_is_not_assignable_to_string_index_type_1_2413": "数字索引类型“{0}”不能赋给字符串索引类型“{1}”。",
  "Class_name_cannot_be_0_2414": "类名不能为“{0}”",
  "Class_0_incorrectly_extends_base_class_1_2415": "类“{0}”错误扩展基类“{1}”。",
  "Class_static_side_0_incorrectly_extends_base_class_static_side_1_2417": "类静态侧“{0}”错误扩展基类静态侧“{1}”。",
  "Class_0_incorrectly_implements_interface_1_2420": "类“{0}”错误实现接口“{1}”。",
  "A_class_may_only_implement_another_class_or_interface_2422": "类只能实现其他类或接口。",
  "Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_access_2423": "类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员访问器。",
  "Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_proper_2424": "类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员属性。",
  "Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_functi_2425": "类“{0}”将“{1}”定义为实例成员属性，但扩展类“{2}”将其定义为实例成员函数。",
  "Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_functi_2426": "类“{0}”将“{1}”定义为实例成员访问器，但扩展类“{2}”将其定义为实例成员函数。",
  "Interface_name_cannot_be_0_2427": "接口名不能为“{0}”",
  "All_declarations_of_0_must_have_identical_type_parameters_2428": "“{0}”的所有声明都必须具有相同的类型参数。",
  "Interface_0_incorrectly_extends_interface_1_2430": "接口“{0}”错误扩展接口“{1}”。",
  "Enum_name_cannot_be_0_2431": "枚举名不能为“{0}”",
  "In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enu_2432": "在包含多个声明的枚举中，只有一个声明可以省略其第一个枚举元素的初始化表达式。",
  "A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merg_2433": "命名空间声明不能位于与之合并的类或函数中的其他文件内",
  "A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged_2434": "命名空间声明不能位于与之合并的类或函数前",
  "Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces_2435": "环境模块不能嵌套在其他模块或命名空间中。",
  "Ambient_module_declaration_cannot_specify_relative_module_name_2436": "环境模块声明无法指定相对模块名。",
  "Module_0_is_hidden_by_a_local_declaration_with_the_same_name_2437": "模块“{0}”被具有相同名称的局部声明隐藏",
  "Import_name_cannot_be_0_2438": "导入名称不能为“{0}”",
  "Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relati_2439": "环境模块声明中的导入或导出声明不能通过相对模块名引用模块。",
  "Import_declaration_conflicts_with_local_declaration_of_0_2440": "导入声明与“{0}”的局部声明冲突",
  "Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_2441": "标识符“{0}”重复。编译器在模块的顶层范围中保留名称“{1}”。",
  "Types_have_separate_declarations_of_a_private_property_0_2442": "类型具有私有属性“{0}”的单独声明。",
  "Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2_2443": "属性“{0}”受保护，但类型“{1}”并不是从“{2}”派生的类。",
  "Property_0_is_protected_in_type_1_but_public_in_type_2_2444": "属性“{0}”在类型“{1}”中受保护，但在类型“{2}”中为公共属性。",
  "Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses_2445": "属性“{0}”受保护，只能在类“{1}”及其子类中访问。",
  "Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_2446": "属性“{0}”受保护，只能通过类“{1}”的实例访问。",
  "The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead_2447": "“{0}”运算符不允许用于布尔类型。请考虑改用“{1}”。",
  "Block_scoped_variable_0_used_before_its_declaration_2448": "声明之前已使用的块范围变量“{0}”。",
  "Cannot_redeclare_block_scoped_variable_0_2451": "无法重新声明块范围变量“{0}”。",
  "An_enum_member_cannot_have_a_numeric_name_2452": "枚举成员不能具有数值名。",
  "The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_typ_2453": "无法从用法推断类型形参“{0}”的类型实参。可以考虑显式指定类型实参。",
  "Variable_0_is_used_before_being_assigned_2454": "在赋值前使用了变量“{0}”。",
  "Type_argument_candidate_1_is_not_a_valid_type_argument_because_it_is_not_a_supertype_of_candidate_0_2455": "候选类型参数“{1}”不是有效的类型参数，因为它不是候选“{0}”的超类型。",
  "Type_alias_0_circularly_references_itself_2456": "类型别名“{0}”循环引用自身。",
  "Type_alias_name_cannot_be_0_2457": "类型别名不能为“{0}”",
  "An_AMD_module_cannot_have_multiple_name_assignments_2458": "AMD 模块无法拥有多个名称分配。",
  "Type_0_has_no_property_1_and_no_string_index_signature_2459": "类型“{0}”不具有属性“{1}”和字符串索引签名。",
  "Type_0_has_no_property_1_2460": "类型“{0}”不具有属性“{1}”。",
  "Type_0_is_not_an_array_type_2461": "类型“{0}”不是数组类型。",
  "A_rest_element_must_be_last_in_a_destructuring_pattern_2462": "rest 元素必须在析构模式中位于最末",
  "A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature_2463": "绑定模式参数在实现签名中不能为可选参数。",
  "A_computed_property_name_must_be_of_type_string_number_symbol_or_any_2464": "计算属性名的类型必须为 \"string\"、\"number\"、\"symbol\" 或 \"any\"。",
  "this_cannot_be_referenced_in_a_computed_property_name_2465": "不能在计算属性名中引用 \"this\"。",
  "super_cannot_be_referenced_in_a_computed_property_name_2466": "不能在计算属性名中引用 \"super\"。",
  "A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type_2467": "计算属性名无法从其包含的类型引用类型参数。",
  "Cannot_find_global_value_0_2468": "找不到全局值“{0}”。",
  "The_0_operator_cannot_be_applied_to_type_symbol_2469": "“{0}”运算符不能应用于类型 \"symbol\"。",
  "Symbol_reference_does_not_refer_to_the_global_Symbol_constructor_object_2470": "\"Symbol\" 引用不是指全局符号构造函数对象。",
  "A_computed_property_name_of_the_form_0_must_be_of_type_symbol_2471": "窗体“{0}”的计算属性名必须是 \"symbol\" 类型。",
  "Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher_2472": "仅当面向 ECMAScript 5 和更高版本时，\"new\" 表达式中的展开运算符才可用。",
  "Enum_declarations_must_all_be_const_or_non_const_2473": "枚举声明必须全为常数或非常数。",
  "In_const_enum_declarations_member_initializer_must_be_constant_expression_2474": "在 \"const\" 枚举声明中，成员初始化表达式必须是常数表达式。",
  "const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_im_2475": "\"const\" 枚举仅可在属性、索引访问表达式、导入声明的右侧或导出分配中使用。",
  "A_const_enum_member_can_only_be_accessed_using_a_string_literal_2476": "只有使用字符串文本才能访问常数枚举成员。",
  "const_enum_member_initializer_was_evaluated_to_a_non_finite_value_2477": "\"const\" 枚举成员初始化表达式的求值结果为非有限值。",
  "const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN_2478": "\"const\" 枚举成员初始化表达式的求值结果为不允许使用的值 \"NaN\"。",
  "Property_0_does_not_exist_on_const_enum_1_2479": "\"const\" 枚举“{1}”上不存在属性“{0}”。",
  "let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations_2480": "\"let\" 不能用作 \"let\" 或 \"const\" 声明中的名称。",
  "Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1_2481": "无法在块范围声明“{1}”所在的范围内初始化外部范围变量“{0}”。",
  "The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation_2483": "\"for...of\" 语句的左侧不能使用类型批注。",
  "Export_declaration_conflicts_with_exported_declaration_of_0_2484": "导出声明与“{0}”的导出声明冲突",
  "The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access_2487": "\"for...of\" 语句的左侧必须是变量或属性访问。",
  "Type_must_have_a_Symbol_iterator_method_that_returns_an_iterator_2488": "类型必须具有返回迭代器的 \"[Symbol.iterator]()\" 方法。",
  "An_iterator_must_have_a_next_method_2489": "迭代器必须具有 \"next()\" 方法。",
  "The_type_returned_by_the_next_method_of_an_iterator_must_have_a_value_property_2490": "迭代器的 \"next()\" 方法返回的类型必须具有 \"value\" 属性。",
  "The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern_2491": "\"for...in\" 语句的左侧不能为析构模式。",
  "Cannot_redeclare_identifier_0_in_catch_clause_2492": "无法在 catch 子句中重新声明标识符“{0}”",
  "Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2_2493": "不能将长度为“{1}”的元组类型“{0}”分配给长度为“{2}”的元组。",
  "Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher_2494": "仅 ECMAScript 5 和更高版本支持在 \"for...of\" 语句中使用字符串。",
  "Type_0_is_not_an_array_type_or_a_string_type_2495": "类型“{0}”不是数组类型或字符串类型。",
  "The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_stand_2496": "ES3 和 ES5 中的箭头函数不能引用 \"arguments\" 对象。请考虑使用标准函数表达式。",
  "Module_0_resolves_to_a_non_module_entity_and_cannot_be_imported_using_this_construct_2497": "模块“{0}”解析为非模块实体，且不能使用此构造导入。",
  "Module_0_uses_export_and_cannot_be_used_with_export_Asterisk_2498": "模块“{0}”使用 \"export =\" 且无法与 \"export *\" 一起使用。",
  "An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments_2499": "接口只能扩展具有可选类型参数的标识符/限定名称。",
  "A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments_2500": "类只能实现具有可选类型参数的标识符/限定名称。",
  "A_rest_element_cannot_contain_a_binding_pattern_2501": "rest 元素不能包含绑定模式。",
  "_0_is_referenced_directly_or_indirectly_in_its_own_type_annotation_2502": "“{0}”在其自身的类型批注中得到直接或间接引用。",
  "Cannot_find_namespace_0_2503": "找不到命名空间“{0}”。",
  "A_generator_cannot_have_a_void_type_annotation_2505": "生成器不能具有 \"void\" 类型批注。",
  "_0_is_referenced_directly_or_indirectly_in_its_own_base_expression_2506": "“{0}”在其自身的基表达式中得到直接或间接引用。",
  "Type_0_is_not_a_constructor_function_type_2507": "类型“{0}”不是构造函数类型。",
  "No_base_constructor_has_the_specified_number_of_type_arguments_2508": "没有任何基构造函数具有指定数量的类型参数。",
  "Base_constructor_return_type_0_is_not_a_class_or_interface_type_2509": "基构造函数返回类型“{0}”不是类或接口类型。",
  "Base_constructors_must_all_have_the_same_return_type_2510": "所有的基构造函数必须具有相同的返回类型。",
  "Cannot_create_an_instance_of_the_abstract_class_0_2511": "无法创建抽象类“{0}”的实例。",
  "Overload_signatures_must_all_be_abstract_or_non_abstract_2512": "重载签名必须都是抽象的或都是非抽象的。",
  "Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression_2513": "无法通过 super 表达式访问“{1}”类中的“{0}”抽象方法。",
  "Classes_containing_abstract_methods_must_be_marked_abstract_2514": "包含抽象方法的类必须标记为抽象。",
  "Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2_2515": "非抽象类“{0}”不会实现继承自“{2}”类的抽象成员“{1}”。",
  "All_declarations_of_an_abstract_method_must_be_consecutive_2516": "抽象方法的所有声明必须是连续的。",
  "Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type_2517": "无法将抽象构造函数类型分配给非抽象构造函数类型。",
  "A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard_2518": "基于 \"this\" 的类型防护与基于参数的类型防护不兼容。",
  "Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions_2520": "标识符“{0}”重复。编译器使用“{1}”声明来支持异步函数。",
  "Expression_resolves_to_variable_declaration_0_that_compiler_uses_to_support_async_functions_2521": "表达式解析为编译器用于支持异步函数的变量声明“{0}”。",
  "The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_usi_2522": "ES3 和 ES5 中的异步函数或方法不能引用“参数”对象。请考虑使用标准函数或方法。",
  "yield_expressions_cannot_be_used_in_a_parameter_initializer_2523": "不能在参数初始化表达式中使用 \"yield\" 表达式。",
  "await_expressions_cannot_be_used_in_a_parameter_initializer_2524": "不能在参数初始化表达式中使用 \"await\" 表达式。",
  "Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value_2525": "初始化表达式没有为此绑定元素提供此任何值，且该绑定元素没有默认值。",
  "A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface_2526": "\"this\" 类型仅在类或接口的非静态成员中可用。",
  "The_inferred_type_of_0_references_an_inaccessible_this_type_A_type_annotation_is_necessary_2527": "“{0}”的推断类型引用不可访问的 \"this\" 类型。需要类型批注。",
  "A_module_cannot_have_multiple_default_exports_2528": "一个模块不能具有多个默认导出。",
  "Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_func_2529": "标识符“{0}”重复。编译器在包含异步函数的模块的顶层范围中保留名称“{1}”。",
  "Property_0_is_incompatible_with_index_signature_2530": "属性“{0}”与索引签名不兼容。",
  "Object_is_possibly_null_2531": "对象可能为 \"null\"。",
  "Object_is_possibly_undefined_2532": "对象可能为“未定义”。",
  "Object_is_possibly_null_or_undefined_2533": "对象可能为 \"null\" 或“未定义”。",
  "A_function_returning_never_cannot_have_a_reachable_end_point_2534": "返回“从不”的函数不能具有可访问的终结点。",
  "Enum_type_0_has_members_with_initializers_that_are_not_literals_2535": "枚举类型“{0}”包含具有不是文本的初始值设定项的成员。",
  "Type_0_cannot_be_used_to_index_type_1_2536": "类型“{0}”无法用于索引类型“{1}”。",
  "Type_0_has_no_matching_index_signature_for_type_1_2537": "类型“{0}”没有匹配的类型“{1}”的索引签名。",
  "Type_0_cannot_be_used_as_an_index_type_2538": "类型“{0}”不能作为索引类型使用。",
  "Cannot_assign_to_0_because_it_is_not_a_variable_2539": "无法分配到“{0}”，因为它不是变量。",
  "Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property_2540": "无法分配到“{0}”，因为它是常数或只读属性。",
  "The_target_of_an_assignment_must_be_a_variable_or_a_property_access_2541": "赋值的目标必须是变量或属性访问。",
  "Index_signature_in_type_0_only_permits_reading_2542": "类型“{0}”中的索引签名仅允许读取。",
  "JSX_element_attributes_type_0_may_not_be_a_union_type_2600": "JSX 元素属性类型“{0}”可能不是联合类型。",
  "The_return_type_of_a_JSX_element_constructor_must_return_an_object_type_2601": "JSX 元素构造函数的返回类型必须返回对象类型。",
  "JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist_2602": "JSX 元素隐式具有类型 \"any\"，因为不存在全局类型 \"JSX.Element\"。",
  "Property_0_in_type_1_is_not_assignable_to_type_2_2603": "类型“{1}”中的属性“{0}”不可分配给类型“{2}”",
  "JSX_element_type_0_does_not_have_any_construct_or_call_signatures_2604": "JSX 元素类型“{0}”不具有任何构造签名或调用签名。",
  "JSX_element_type_0_is_not_a_constructor_function_for_JSX_elements_2605": "JSX 元素类型“{0}”不是 JSX 元素的构造函数。",
  "Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property_2606": "JSX 展开特性的“{0}”属性不能分配给目标属性。",
  "JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property_2607": "JSX 元素类不支持特性，因为它不具有“{0}”属性",
  "The_global_type_JSX_0_may_not_have_more_than_one_property_2608": "全局类型“JSX.{0}”不可以具有多个属性",
  "Cannot_emit_namespaced_JSX_elements_in_React_2650": "无法发出 React 中带命名空间的 JSX 元素",
  "A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_memb_2651": "枚举声明中的成员初始化表达式不能引用在其后声明的成员(包括在其他枚举中定义的成员)。",
  "Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_d_2652": "合并声明“{0}”不能包含默认导出声明。请考虑改为添加一个独立的“导出默认 {0}”声明。",
  "Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1_2653": "非抽象类表达式不会实现继承自“{1}”类的抽象成员“{0}”。",
  "Exported_external_package_typings_file_cannot_contain_tripleslash_references_Please_contact_the_pack_2654": "导出的外部包键入文件不能包含三斜线引用。请与包作者联系或更新包定义。",
  "Exported_external_package_typings_file_0_is_not_a_module_Please_contact_the_package_author_to_update_2656": "导出的外部包键入文件“{0}”不是一个模块。请与包作者联系或更新包定义。",
  "JSX_expressions_must_have_one_parent_element_2657": "JSX 表达式必须具有一个父元素",
  "Type_0_provides_no_match_for_the_signature_1_2658": "类型“{0}”提供程序与签名“{1}”不匹配",
  "super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_highe_2659": "\"target\" 选项为 \"ES2015\" 或更高版本时，仅对象文字表达式的成员中允许 \"super\"。",
  "super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions_2660": "仅可在派生类或对象文字表达式的成员中引用 \"super\"。",
  "Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module_2661": "无法导出“{0}”。仅可从模块中导出本地声明。",
  "Cannot_find_name_0_Did_you_mean_the_static_member_1_0_2662": "找不到名称“{0}”。你的意思是静态成员“{1}.{0}”?",
  "Cannot_find_name_0_Did_you_mean_the_instance_member_this_0_2663": "找不到名称“{0}”。你的意思是实例成员“this.{0}”?",
  "Invalid_module_name_in_augmentation_module_0_cannot_be_found_2664": "扩大中的模块名无效，找不到模块“{0}”。",
  "Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augm_2665": "扩大中的模块名称无效。模块“{0}”解析到位于“{1}”处的非类型化模块，其无法扩大。",
  "Exports_and_export_assignments_are_not_permitted_in_module_augmentations_2666": "模块扩大中不允许导出和导出分配。",
  "Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_mod_2667": "模块扩大中不允许导入。请考虑将它们移动到封闭的外部模块。",
  "export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always__2668": "\"export\" 修饰符不可用于环境模块和模块扩大，因为它们始终可见。",
  "Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_2669": "全局范围的扩大仅可直接嵌套在外部模块中或环境模块声明中。",
  "Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambien_2670": "全局范围的扩大应具有 \"declare\" 修饰符，除非它们显示在已有的环境上下文中。",
  "Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity_2671": "无法扩大模块“{0}”，因为它解析为非模块实体。",
  "Cannot_assign_a_0_constructor_type_to_a_1_constructor_type_2672": "不可将“{0}”构造函数类型分配给“{1}”构造函数类型。",
  "Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration_2673": "类“{0}”的构造函数是私有的，仅可在类声明中访问。",
  "Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration_2674": "类“{0}”的构造函数是受保护的，仅可在类声明中访问。",
  "Cannot_extend_a_class_0_Class_constructor_is_marked_as_private_2675": "无法扩展类“{0}”。类构造函数标记为私有。",
  "Accessors_must_both_be_abstract_or_non_abstract_2676": "两个取值函数必须都是抽象的或都是非抽象的。",
  "A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type_2677": "类型谓词的类型不可赋给其参数的类型。",
  "Type_0_is_not_comparable_to_type_1_2678": "类型“{0}”不可与类型“{1}”进行比较。",
  "A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void_2679": "使用 \"new\" 关键字调用的函数不可具有“失效”的 \"this\" 类型。",
  "A_this_parameter_must_be_the_first_parameter_2680": "\"this\" 参数必须是第一个参数。",
  "A_constructor_cannot_have_a_this_parameter_2681": "构造函数不可具有 \"this\" 参数。",
  "get_and_set_accessor_must_have_the_same_this_type_2682": "\"get\" 和 \"set\" 访问器必须拥有相同的 \"this\" 类型。",
  "this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_2683": "\"this\" 隐式具有类型 \"any\"，因为它没有类型注释。",
  "The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1_2684": "类型为“{0}”的 \"this\" 上下文不能分配给类型为“{1}”的方法的 \"this\"。",
  "The_this_types_of_each_signature_are_incompatible_2685": "每个签名的 \"this\" 类型不兼容。",
  "_0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead_2686": "“{0}”指 UMD 全局，但当前文件是模块。请考虑改为添加导入。",
  "All_declarations_of_0_must_have_identical_modifiers_2687": "“{0}”的所有声明必须具有相同的修饰符。",
  "Cannot_find_type_definition_file_for_0_2688": "找不到“{0}”的类型定义文件。",
  "Cannot_extend_an_interface_0_Did_you_mean_implements_2689": "无法扩展接口‘{0}’。您的意思是‘实施’吗？",
  "A_class_must_be_declared_after_its_base_class_2690": "类必须在其基类后声明。",
  "An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead_2691": "导入路径不能以“{0}”扩展名结束。考虑改为导入“{1}”。",
  "_0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible_2692": "“{0}”是基元，但“{1}”是包装器对象。如可能首选使用“{0}”。",
  "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_2693": "“{0}”仅表示类型，但在此处却作为值使用。",
  "Namespace_0_has_no_exported_member_1_2694": "命名空间“{0}”没有已导出的成员“{1}”。",
  "Left_side_of_comma_operator_is_unused_and_has_no_side_effects_2695": "逗号运算符的左侧未使用，没有任何副作用。",
  "The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead_2696": "\"Object\" 类型可分配给极少数其他类型。是否想要改用“任意”类型?",
  "An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_in_2697": "异步函数或方法必须返回 \"Promise\"。请确保具有对 \"Promise\" 的声明或在 `--lib` 选项中包括 \"ES2015\"。",
  "Spread_types_may_only_be_created_from_object_types_2698": "spread 类型只能从对象类型创建。",
  "Rest_types_may_only_be_created_from_object_types_2700": "rest 类型只能从对象类型创建。",
  "The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access_2701": "对象的其余分配目标必须是变量或属性访问。",
  "_0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here_2702": "“{0}”仅指类型，但在此用作命名空间。",
  "Import_declaration_0_is_using_private_name_1_4000": "导入声明“{0}”使用的是专用名称“{1}”。",
  "Type_parameter_0_of_exported_class_has_or_is_using_private_name_1_4002": "导出类的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1_4004": "导出接口的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4006": "导出接口中的构造函数签名的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4008": "导出接口中的调用签名的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4010": "导出类中的公共静态方法的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4012": "导出类中的公共方法的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4014": "导出接口中的方法的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Type_parameter_0_of_exported_function_has_or_is_using_private_name_1_4016": "导出函数的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Implements_clause_of_exported_class_0_has_or_is_using_private_name_1_4019": "导出的类“{0}”的 Implements 子句具有或正在使用专用名称“{1}”。",
  "Extends_clause_of_exported_class_0_has_or_is_using_private_name_1_4020": "导出的类“{0}”的 extends 子句具有或正在使用专用名称“{1}”。",
  "Extends_clause_of_exported_interface_0_has_or_is_using_private_name_1_4022": "导出接口“{0}”的 extends 子句具有或正在使用专用名称“{1}”。",
  "Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4023": "导出的变量“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "Exported_variable_0_has_or_is_using_name_1_from_private_module_2_4024": "导出的变量“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Exported_variable_0_has_or_is_using_private_name_1_4025": "导出的变量“{0}”具有或正在使用专用名称“{1}”。",
  "Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot__4026": "导出类的公共静态属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4027": "导出类的公共静态属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”。",
  "Public_static_property_0_of_exported_class_has_or_is_using_private_name_1_4028": "导出类的公共静态属性“{0}”具有或正在使用专用名称“{1}”。",
  "Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_name_4029": "导出类的公共属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4030": "导出类的公共属性“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Public_property_0_of_exported_class_has_or_is_using_private_name_1_4031": "导出类的公共属性“{0}”具有或正在使用专用名称“{1}”。",
  "Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4032": "导出接口的属性“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Property_0_of_exported_interface_has_or_is_using_private_name_1_4033": "导出接口的属性“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_name_1_from_private_4034": "导出类中的公共静态属性 setter 的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_name_1_4035": "导出类中的公共静态属性 setter 的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_4036": "导出类中的公共属性 setter 的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_name_1_4037": "导出类中的公共属性 setter 的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_externa_4038": "导出类中的公共静态属性 getter 的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_private_4039": "导出类中的公共静态属性 getter 的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_name_0_4040": "导出类中的公共静态属性 getter 的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_external_modul_4041": "导出类中的公共属性 getter 的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_4042": "导出类中的公共属性 getter 的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_name_0_4043": "导出类中的公共属性 getter 的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_mod_4044": "导出接口中的构造函数签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0_4045": "导出接口中的构造函数签名的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4046": "导出接口中的调用签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0_4047": "导出接口中的调用签名的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4048": "导出接口中的索引签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0_4049": "导出接口中的索引签名的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module__4050": "导出类中的公共静态方法的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4051": "导出类中的公共静态方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0_4052": "导出类中的公共静态方法的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_c_4053": "导出类中的公共方法的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4054": "导出类中的公共方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0_4055": "导出类中的公共方法的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4056": "导出接口中的方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0_4057": "导出接口中的方法的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named_4058": "导出函数的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1_4059": "导出函数的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_exported_function_has_or_is_using_private_name_0_4060": "导出函数的返回类型具有或正在使用专用名称“{0}”。",
  "Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_can_4061": "导出类中的构造函数的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2_4062": "导出类中的构造函数的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1_4063": "导出类中的构造函数的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_mod_4064": "导出接口中的构造函数签名的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4065": "导出接口中的构造函数签名的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4066": "导出接口中的调用签名的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4067": "导出接口中的调用签名的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module__4068": "导出类中的公共静态方法的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4069": "导出类中的公共静态方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4070": "导出类中的公共静态方法的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_c_4071": "导出类中的公共方法的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4072": "导出类中的公共方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4073": "导出类中的公共方法的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4074": "导出接口中的方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4075": "导出接口中的方法的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4076": "导出函数的参数“{0}”具有或正在使用外部模块 {2} 中的名称“{1}”，但不能为其命名。",
  "Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2_4077": "导出函数的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_exported_function_has_or_is_using_private_name_1_4078": "导出函数的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Exported_type_alias_0_has_or_is_using_private_name_1_4081": "导出的类型别名“{0}”已经或正在使用专用名称“{1}”。",
  "Default_export_of_the_module_has_or_is_using_private_name_0_4082": "模块的默认导出具有或正在使用专用名称“{0}”。",
  "Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1_4083": "已导出类型别名的类型参数“{0}”具有或正使用专用名称“{1}”。",
  "Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_librar_4090": "“{1}”和“{2}”处找到的“{0}”的定义具有冲突。请考虑安装此库的特定版本以解决冲突。",
  "Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4091": "Parameter '{0}' of index signature from exported interface has or is using name '{1}' from private module '{2}'.",
  "Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1_4092": "Parameter '{0}' of index signature from exported interface has or is using private name '{1}'.",
  "The_current_host_does_not_support_the_0_option_5001": "当前主机不支持“{0}”选项。",
  "Cannot_find_the_common_subdirectory_path_for_the_input_files_5009": "找不到输入文件的公共子目录路径。",
  "File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0_5010": "文件规范不能以递归目录通配符结尾(\"**\"):“{0}”。",
  "File_specification_cannot_contain_multiple_recursive_directory_wildcards_Asterisk_Asterisk_Colon_0_5011": "文件规范不能包含多个递归目录通配符(\"**\"):“{0}”。",
  "Cannot_read_file_0_Colon_1_5012": "无法读取文件“{0}”: {1}",
  "Unsupported_file_encoding_5013": "文件编码不受支持。",
  "Failed_to_parse_file_0_Colon_1_5014": "未能分析文件“{0}”: {1}。",
  "Unknown_compiler_option_0_5023": "未知的编译器选项“{0}”。",
  "Compiler_option_0_requires_a_value_of_type_1_5024": "编译器选项“{0}”需要类型 {1} 的值。",
  "Could_not_write_file_0_Colon_1_5033": "无法写入文件“{0}”: {1}",
  "Option_project_cannot_be_mixed_with_source_files_on_a_command_line_5042": "选项 \"project\" 在命令行上不能与源文件混合使用。",
  "Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES_5047": "选项 \"isolatedModules\" 只可在提供了选项 \"--module\" 或者选项 \"target\" 是 \"ES2015\" 或更高版本时使用。",
  "Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided_5051": "仅当提供了选项 \"--inlineSourceMap\" 或选项 \"--sourceMap\" 时，才能使用选项“{0}”。",
  "Option_0_cannot_be_specified_without_specifying_option_1_5052": "无法在不指定选项“{1}”的情况下指定选项“{0}”。",
  "Option_0_cannot_be_specified_with_option_1_5053": "选项“{0}”不能与选项“{1}”同时指定。",
  "A_tsconfig_json_file_is_already_defined_at_Colon_0_5054": "已在“{0}”中定义了 \"tsconfig.json\" 文件。",
  "Cannot_write_file_0_because_it_would_overwrite_input_file_5055": "无法写入文件“{0}”，因为它会覆盖输入文件。",
  "Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files_5056": "无法写入文件“{0}”，因为它会被多个输入文件覆盖。",
  "Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0_5057": "无法在指定目录找到 tsconfig.json 文件:“{0}”",
  "The_specified_path_does_not_exist_Colon_0_5058": "指定的路径不存在:“{0}”",
  "Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier_5059": "\"--reactNamespace\" 的值无效。“{0}”不是有效的标识符。",
  "Option_paths_cannot_be_used_without_specifying_baseUrl_option_5060": "在未指定 \"--baseUrl\" 选项的情况下，无法使用选项 \"paths\"。",
  "Pattern_0_can_have_at_most_one_Asterisk_character_5061": "模式“{0}”最多只可具有一个 \"*\" 字符",
  "Substitution_0_in_pattern_1_in_can_have_at_most_one_Asterisk_character_5062": "模式“{1}”中的替换“{0}”最多只可具有一个 \"*\" 字符",
  "Substitutions_for_pattern_0_should_be_an_array_5063": "模式“{0}”的替代应为数组。",
  "Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2_5064": "模式“{1}”的替换“{0}”类型不正确，应为 \"string\"，实际为“{2}”。",
  "File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildca_5065": "文件规范不能包含出现在递归目录通配符(\"*\"): “{0}”后的父目录(\"..\")。",
  "Substitutions_for_pattern_0_shouldn_t_be_an_empty_array_5066": "模式“{0}”的替换模式不应为空数组。",
  "Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name_5067": "\"jsxFactory\" 的值无效。“{0}”不是有效的标识符或限定名称。",
  "Concatenate_and_emit_output_to_single_file_6001": "连接输出并将其发出到单个文件。",
  "Generates_corresponding_d_ts_file_6002": "生成相应的 \".d.ts\" 文件。",
  "Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations_6003": "指定调试程序应将映射文件放置到的位置而不是生成的位置。",
  "Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations_6004": "指定调试调试程序应将 TypeScript 文件放置到的位置而不是源位置。",
  "Watch_input_files_6005": "监视输入文件。",
  "Redirect_output_structure_to_the_directory_6006": "将输出结构重定向到目录。",
  "Do_not_erase_const_enum_declarations_in_generated_code_6007": "请勿清除生成代码中的常数枚举声明。",
  "Do_not_emit_outputs_if_any_errors_were_reported_6008": "如果报告了任何错误，请不要发出输出。",
  "Do_not_emit_comments_to_output_6009": "请勿将注释发出到输出。",
  "Do_not_emit_outputs_6010": "请勿发出输出。",
  "Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typech_6011": "允许从不带默认输出的模块中默认输入。这不会影响代码发出，只是类型检查。",
  "Skip_type_checking_of_declaration_files_6012": "跳过声明文件的类型检查。",
  "Specify_ECMAScript_target_version_Colon_ES3_default_ES5_ES2015_ES2016_ES2017_or_ESNEXT_6015": "Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'",
  "Specify_module_code_generation_Colon_commonjs_amd_system_umd_or_es2015_6016": "指定模块代码生成: \"commonjs\"、\"amd\"、\"system\"、\"umd\" 或 \"es2015\"",
  "Print_this_message_6017": "打印此消息。",
  "Print_the_compiler_s_version_6019": "打印编译器的版本。",
  "Compile_the_project_in_the_given_directory_6020": "在指定目录中编译项目。",
  "Syntax_Colon_0_6023": "语法: {0}",
  "options_6024": "选项",
  "file_6025": "文件",
  "Examples_Colon_0_6026": "示例: {0}",
  "Options_Colon_6027": "选项:",
  "Version_0_6029": "版本 {0}",
  "Insert_command_line_options_and_files_from_a_file_6030": "从文件插入命令行选项和文件。",
  "File_change_detected_Starting_incremental_compilation_6032": "检测到文件更改。正在启动增量编译...",
  "KIND_6034": "种类",
  "FILE_6035": "文件",
  "VERSION_6036": "版本",
  "LOCATION_6037": "位置",
  "DIRECTORY_6038": "目录",
  "STRATEGY_6039": "策略",
  "Compilation_complete_Watching_for_file_changes_6042": "编译完成。查看文件更改。",
  "Generates_corresponding_map_file_6043": "生成相应的 \".map\" 文件。",
  "Compiler_option_0_expects_an_argument_6044": "编译器选项“{0}”需要参数。",
  "Unterminated_quoted_string_in_response_file_0_6045": "响应文件“{0}”中引号不配对。",
  "Argument_for_0_option_must_be_Colon_1_6046": "“{0}”选项的参数必须为: {1}",
  "Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1_6048": "区域设置必须采用 <语言> 或 <语言>-<区域> 形式。例如“{0}”或“{1}”。",
  "Unsupported_locale_0_6049": "区域设置“{0}”不受支持。",
  "Unable_to_open_file_0_6050": "无法打开文件“{0}”。",
  "Corrupted_locale_file_0_6051": "区域设置文件 {0} 已损坏。",
  "Raise_error_on_expressions_and_declarations_with_an_implied_any_type_6052": "对具有隐式 \"any\" 类型的表达式和声明引发错误。",
  "File_0_not_found_6053": "找不到文件“{0}”。",
  "File_0_has_unsupported_extension_The_only_supported_extensions_are_1_6054": "不支持文件“{0}”的扩展名。唯一支持的扩展名为 {1}。",
  "Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures_6055": "抑制缺少索引签名的索引对象的 noImplicitAny 错误。",
  "Do_not_emit_declarations_for_code_that_has_an_internal_annotation_6056": "请勿对具有 \"@internal\" 注释的代码发出声明。",
  "Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir_6058": "指定输入文件的根目录。与 --outDir 一起用于控制输出目录结构。",
  "File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files_6059": "文件“{0}”不在 \"rootDir\"“{1}”下。\"rootDir\" 应包含所有源文件。",
  "Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix_6060": "指定发出文件时要使用的行序列结尾: \"CRLF\" (dos)或 \"LF\" (unix)。",
  "NEWLINE_6061": "换行符",
  "Option_0_can_only_be_specified_in_tsconfig_json_file_6064": "仅可在 \"tsconfig.json\" 文件中指定选项“{0}”。",
  "Enables_experimental_support_for_ES7_decorators_6065": "对 ES7 修饰器启用实验支持。",
  "Enables_experimental_support_for_emitting_type_metadata_for_decorators_6066": "对发出修饰器的类型元数据启用实验支持。",
  "Enables_experimental_support_for_ES7_async_functions_6068": "对 ES7 异步函数启用实验支持。",
  "Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6_6069": "指定模块解析策略: \"node\" (Node.js)或 \"classic\" (TypeScript pre-1.6)。",
  "Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file_6070": "初始化 TypeScript 项目并创建 tsconfig.json 文件。",
  "Successfully_created_a_tsconfig_json_file_6071": "已成功创建 tsconfig.json 文件。",
  "Suppress_excess_property_checks_for_object_literals_6072": "取消对象文字的多余属性检查。",
  "Stylize_errors_and_messages_using_color_and_context_experimental_6073": "使用颜色和上下文风格化错误和消息。(实验)",
  "Do_not_report_errors_on_unused_labels_6074": "不报告有关未使用的标签的错误。",
  "Report_error_when_not_all_code_paths_in_function_return_a_value_6075": "在函数中的所有代码路径并非都返回值时报告错误。",
  "Report_errors_for_fallthrough_cases_in_switch_statement_6076": "报告 switch 语句中遇到 fallthrough 情况的错误。",
  "Do_not_report_errors_on_unreachable_code_6077": "不报告有关不可访问的代码的错误。",
  "Disallow_inconsistently_cased_references_to_the_same_file_6078": "不允许对同一文件采用大小不一致的引用。",
  "Specify_library_files_to_be_included_in_the_compilation_Colon_6079": "指定要在编译中包括的库文件: ",
  "Specify_JSX_code_generation_Colon_preserve_or_react_6080": "指定 JSX 代码生成: \"preserve\" 或 \"react\"",
  "Only_amd_and_system_modules_are_supported_alongside_0_6082": "--{0} 旁仅支持 \"amd\" 和 \"system\" 模块。",
  "Base_directory_to_resolve_non_absolute_module_names_6083": "用于解析非绝对模块名的基目录。",
  "Specify_the_object_invoked_for_createElement_and_spread_when_targeting_react_JSX_emit_6084": "指定面向 \"react\" JSX EMIT 时为 createElement 和 __spread 调用的对象",
  "Enable_tracing_of_the_name_resolution_process_6085": "启用名称解析过程的跟踪。",
  "Resolving_module_0_from_1_6086": "======== 正在从“{1}”解析模块“{0}”。========",
  "Explicitly_specified_module_resolution_kind_Colon_0_6087": "显示指定了模块解析类型:“{0}”。",
  "Module_resolution_kind_is_not_specified_using_0_6088": "未指定模块解析类型，正在使用“{0}”。",
  "Module_name_0_was_successfully_resolved_to_1_6089": "======== 模块名“{0}”已成功解析为“{1}”。========",
  "Module_name_0_was_not_resolved_6090": "======== 未解析模块名“{0}”。========",
  "paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0_6091": "指定了 \"paths“ 选项，正在查找模式以匹配模块名“{0}”。",
  "Module_name_0_matched_pattern_1_6092": "模块名“{0}”，匹配的模式“{1}”。",
  "Trying_substitution_0_candidate_module_location_Colon_1_6093": "正在尝试替换“{0}”，候选模块位置:“{1}”。",
  "Resolving_module_name_0_relative_to_base_url_1_2_6094": "正在相对于基 URL“{1}”-“{2}”解析模块名“{0}”。",
  "Loading_module_as_file_Slash_folder_candidate_module_location_0_6095": "正在将模块加载为文件/文件夹，候选模块位置“{0}”。",
  "File_0_does_not_exist_6096": "文件“{0}”不存在。",
  "File_0_exist_use_it_as_a_name_resolution_result_6097": "文件“{0}”存在 - 将其用作名称解析结果。",
  "Loading_module_0_from_node_modules_folder_6098": "正在从 \"node_modules\" 文件夹加载模块“{0}”。",
  "Found_package_json_at_0_6099": "在“{0}”处找到了 \"package.json\"。",
  "package_json_does_not_have_a_types_or_main_field_6100": "\"package.json\" 没有 \"types\" 或 \"main\" 字段。",
  "package_json_has_0_field_1_that_references_2_6101": "\"package.json\" 具有引用“{2}”的“{0}”字段“{1}”。",
  "Allow_javascript_files_to_be_compiled_6102": "允许编译 JavaScript 文件。",
  "Option_0_should_have_array_of_strings_as_a_value_6103": "选项“{0}”应将字符串数组作为一个值。",
  "Checking_if_0_is_the_longest_matching_prefix_for_1_2_6104": "检查“{0}”是否是“{1}”-“{2}”的最长匹配前缀。",
  "Expected_type_of_0_field_in_package_json_to_be_string_got_1_6105": "\"package.json\" 中“{0}”字段的类型应为 \"string\"，但实际为“{1}”。",
  "baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1_6106": "\"baseUrl\" 选项设置为“{0}”，正在使用此值解析非相关模块名“{1}”",
  "rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0_6107": "设置了 \"rootDirs\" 选项，正在使用它解析相对模块名“{0}”",
  "Longest_matching_prefix_for_0_is_1_6108": "“{0}”的最长匹配前缀为“{1}”",
  "Loading_0_from_the_root_dir_1_candidate_location_2_6109": "正在从根目录“{1}”加载“{0}”，候选位置“{2}”",
  "Trying_other_entries_in_rootDirs_6110": "正在尝试 \"rootDirs\" 中的其他条目",
  "Module_resolution_using_rootDirs_has_failed_6111": "使用 \"rootDirs\" 的模块解析失败",
  "Do_not_emit_use_strict_directives_in_module_output_6112": "不要在模块输出中发出 \"use strict\" 指令。",
  "Enable_strict_null_checks_6113": "启用严格的 NULL 检查。",
  "Unknown_option_excludes_Did_you_mean_exclude_6114": "未知的 \"excludes\" 选项。你的意思是 \"exclude\"?",
  "Raise_error_on_this_expressions_with_an_implied_any_type_6115": "在带隐式“any\" 类型的 \"this\" 表达式上引发错误。",
  "Resolving_type_reference_directive_0_containing_file_1_root_directory_2_6116": "======== 正在解析类型引用指令“{0}”，包含文件“{1}”，根目录“{2}”。========",
  "Resolving_using_primary_search_paths_6117": "正在使用主搜索路径解析...",
  "Resolving_from_node_modules_folder_6118": "正在从 node_modules 文件夹解析...",
  "Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2_6119": "======== 类型引用指令“{0}”已成功解析为“{1}”，主要: {2}。========",
  "Type_reference_directive_0_was_not_resolved_6120": "======== 未解析类型引用指令“{0}”。========",
  "Resolving_with_primary_search_path_0_6121": "正在使用主搜索路径“{0}”解析",
  "Root_directory_cannot_be_determined_skipping_primary_search_paths_6122": "无法确定根目录，正在跳过主搜索路径。",
  "Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set_6123": "======== 正在解析类型引用指令“{0}”，包含文件“{1}”，未设置根目录。========",
  "Type_declaration_files_to_be_included_in_compilation_6124": "要包含在编译中类型声明文件。",
  "Looking_up_in_node_modules_folder_initial_location_0_6125": "正在在 \"node_modules\" 文件夹中查找，初始位置“{0}”",
  "Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_mod_6126": "未指定包含文件，并且无法确定根目录，正在跳过在 \"node_modules\" 文件夹中查找。",
  "Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1_6127": "======== 正在解析类型引用指令“{0}”，未设置包含文件，根目录“{1}”。========",
  "Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set_6128": "======== 正在解析类型引用指令“{0}”，未设置包含文件，未设置根目录。========",
  "The_config_file_0_found_doesn_t_contain_any_source_files_6129": "找到的配置文件 \"{0}\" 未包含任何源文件。",
  "Resolving_real_path_for_0_result_1_6130": "正在解析 \"{0}\" 的真实路径，结果为 \"{1}\"",
  "Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system_6131": "无法使用选项“{0}”来编译模块，除非 \"--module\" 标记为 \"amd\" 或 \"system\"。",
  "File_name_0_has_a_1_extension_stripping_it_6132": "文件名“{0}”的扩展名为“{1}”，请去除它",
  "_0_is_declared_but_never_used_6133": "“{0}”已声明，但从未使用过。",
  "Report_errors_on_unused_locals_6134": "报告未使用的局部变量上的错误。",
  "Report_errors_on_unused_parameters_6135": "报告未使用的参数上的错误。",
  "The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files_6136": "用于搜索 node_modules 和加载 JavaScript 文件的最大依赖项深度",
  "No_types_specified_in_package_json_so_returning_main_value_of_0_6137": "\"package.json\" 中未指定任何类型，因此返回“{0}”的 \"main\" 值",
  "Property_0_is_declared_but_never_used_6138": "声明了属性“{0}”，但从未使用过。",
  "Import_emit_helpers_from_tslib_6139": "从 \"tslib\" 导入发出帮助程序。",
  "Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using__6140": "项目“{0}”中启用了键入内容的自动发现。使用缓存位置“{2}”运行模块“{1}”的额外解析传递。",
  "Parse_in_strict_mode_and_emit_use_strict_for_each_source_file_6141": "以严格模式进行分析，并为每个源文件发出 \"use strict\" 指令",
  "Module_0_was_resolved_to_1_but_jsx_is_not_set_6142": "模块“{0}”已解析为“{1}”，但尚未设置 \"--jsx\"。",
  "Module_0_was_resolved_to_1_but_allowJs_is_not_set_6143": "模块“{0}”已解析为“{1}”，但尚未设置 \"--allowJs\"。",
  "Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1_6144": "模块“{0}”解析为文件“{1}”中本地声明的环境模块。",
  "Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified_6145": "模块“{0}”解析为“{1}”中声明的环境模块，因为未修改此文件。",
  "Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h_6146": "指定在设定 \"react\" JSX 发出目标时要使用的 JSX 工厂函数，例如 \"react.createElement\" 或 \"h\"。",
  "Variable_0_implicitly_has_an_1_type_7005": "变量“{0}”隐式具有“{1}”类型。",
  "Parameter_0_implicitly_has_an_1_type_7006": "参数“{0}”隐式具有“{1}”类型。",
  "Member_0_implicitly_has_an_1_type_7008": "成员“{0}”隐式包含类型“{1}”。",
  "new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type_7009": "其目标缺少构造签名的 \"new\" 表达式隐式具有 \"any\" 类型。",
  "_0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type_7010": "缺少返回类型批注的“{0}”隐式具有“{1}”返回类型。",
  "Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7011": "缺少返回类型批注的函数表达式隐式具有“{0}”返回类型。",
  "Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7013": "缺少返回类型批注的构造签名隐式具有返回类型 \"any\"。",
  "Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number_7015": "元素隐式具有 \"any\" 类型，因为索引表达式的类型不为 \"number\"。",
  "Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type_7016": "无法找到模块“{0}”的声明文件。“{1}”隐式拥有 \"any\" 类型。",
  "Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_7017": "元素隐式具有 \"any\" 类型，因为类型“{0}”没有索引签名。",
  "Object_literal_s_property_0_implicitly_has_an_1_type_7018": "对象文字的属性“{0}”隐式含有“{1}”类型。",
  "Rest_parameter_0_implicitly_has_an_any_type_7019": "Rest 参数“{0}”隐式具有 \"any[]\" 类型。",
  "Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7020": "缺少返回类型批注的调用签名隐式具有返回类型 \"any\"。",
  "_0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or__7022": "“{0}”隐式具有类型 \"any\"，因为它不具有类型批注，且在其自身的初始化表达式中得到直接或间接引用。",
  "_0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_reference_7023": "由于“{0}'”不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型 \"any\"。",
  "Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_ref_7024": "由于函数不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型 \"any\"。",
  "Generator_implicitly_has_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_typ_7025": "生成器隐式具有类型“{0}”，因为它不生成任何值。请考虑提供一个返回类型。",
  "JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists_7026": "JSX 元素隐式具有类型 \"any\"，因为不存在接口“JSX.{0}”",
  "Unreachable_code_detected_7027": "检测到无法访问的代码。",
  "Unused_label_7028": "未使用的标签。",
  "Fallthrough_case_in_switch_7029": "switch 语句中的 Fallthrough 情况。",
  "Not_all_code_paths_return_a_value_7030": "并非所有代码路径都返回值。",
  "Binding_element_0_implicitly_has_an_1_type_7031": "绑定元素“{0}”隐式具有“{1}”类型。",
  "Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation_7032": "属性“{0}”隐式具有类型 \"any\"，因为其 set 访问器缺少参数类型批注。",
  "Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation_7033": "属性“{0}”隐式具有类型 \"any\"，因为其 get 访问器缺少返回类型批注。",
  "Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined_7034": "变量“{0}”在某些无法确定其类型的位置处隐式具有类型“{1}”。",
  "You_cannot_rename_this_element_8000": "无法重命名此元素。",
  "You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library_8001": "不能重命名标准 TypeScript 库中定义的元素。",
  "import_can_only_be_used_in_a_ts_file_8002": "\"import ... =\" 只能在 .ts 文件中使用。",
  "export_can_only_be_used_in_a_ts_file_8003": "\"export=\" 只能在 .ts 文件中使用。",
  "type_parameter_declarations_can_only_be_used_in_a_ts_file_8004": "\"type parameter declarations\" 只能在 .ts 文件中使用。",
  "implements_clauses_can_only_be_used_in_a_ts_file_8005": "\"implements clauses\" 只能在 .ts 文件中使用。",
  "interface_declarations_can_only_be_used_in_a_ts_file_8006": "\"interface declarations\" 只能在 .ts 文件中使用。",
  "module_declarations_can_only_be_used_in_a_ts_file_8007": "\"module declarations\" 只能在 .ts 文件中使用。",
  "type_aliases_can_only_be_used_in_a_ts_file_8008": "\"type aliases\" 只能在 .ts 文件中使用。",
  "_0_can_only_be_used_in_a_ts_file_8009": "“{0}”只能在 .ts 文件中使用。",
  "types_can_only_be_used_in_a_ts_file_8010": "\"types\" 只能在 .ts 文件中使用。",
  "type_arguments_can_only_be_used_in_a_ts_file_8011": "\"type arguments\" 只能在 .ts 文件中使用。",
  "parameter_modifiers_can_only_be_used_in_a_ts_file_8012": "\"parameter modifiers\" 只能在 .ts 文件中使用。",
  "enum_declarations_can_only_be_used_in_a_ts_file_8015": "\"enum declarations\" 只能在 .ts 文件中使用。",
  "type_assertion_expressions_can_only_be_used_in_a_ts_file_8016": "\"type assertion expressions\" 只能在 .ts 文件中使用。",
  "Only_identifiers_Slashqualified_names_with_optional_type_arguments_are_currently_supported_in_a_clas_9002": "类 \"extends\" 子句当前只支持具有可选类型参数的标识符/限定名称。",
  "class_expressions_are_not_currently_supported_9003": "当前不支持 \"class\" 表达式。",
  "Language_service_is_disabled_9004": "语言服务已禁用。",
  "JSX_attributes_must_only_be_assigned_a_non_empty_expression_17000": "只能为 JSX 属性分配非空“表达式”。",
  "JSX_elements_cannot_have_multiple_attributes_with_the_same_name_17001": "JSX 元素不能具有多个名称相同的特性。",
  "Expected_corresponding_JSX_closing_tag_for_0_17002": "“{0}”预期的相应 JSX 结束标记。",
  "JSX_attribute_expected_17003": "需要 JSX 属性。",
  "Cannot_use_JSX_unless_the_jsx_flag_is_provided_17004": "无法使用 JSX，除非提供了 \"--jsx\" 标志。",
  "A_constructor_cannot_contain_a_super_call_when_its_class_extends_null_17005": "当构造函数的类扩展 \"null\" 时，它不能包含 \"super\" 调用。",
  "An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_ex_17006": "乘方表达式的左侧不允许存在具有“{0}”运算符的一元表达式。请考虑用括号将表达式括起。",
  "A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Con_17007": "乘方表达式的左侧不允许出现类型断言表达式。请考虑用括号将表达式括起。",
  "JSX_element_0_has_no_corresponding_closing_tag_17008": "JSX 元素“{0}”没有相应的结束标记。",
  "super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class_17009": "访问派生类的构造函数中的 \"this\" 前，必须调用 \"super\"。",
  "Unknown_type_acquisition_option_0_17010": "未知类型获取选项“{0}”。",
  "Circularity_detected_while_resolving_configuration_Colon_0_18000": "解析配置时检测到循环: {0}",
  "A_path_in_an_extends_option_must_be_relative_or_rooted_but_0_is_not_18001": "“扩展”选项中的路径必须是相对路径或根路径，但“{0}”不是。",
  "The_files_list_in_config_file_0_is_empty_18002": "配置文件“{0}”中的 \"files\" 列表为空。",
  "No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2_18003": "在配置文件“{0}”中找不到任何输入。指定的 \"include\" 路径为“{1}”，\"exclude\" 路径为“{2}”。",
  "Add_missing_super_call_90001": "添加缺失的 \"super()\" 调用。",
  "Make_super_call_the_first_statement_in_the_constructor_90002": "在构造函数中，使 \"super()\" 调用第一个语句。",
  "Change_extends_to_implements_90003": "将 \"extends\" 改为 \"implements\"",
  "Remove_unused_identifiers_90004": "删除未使用的标识符",
  "Implement_interface_on_reference_90005": "在引用上实现接口",
  "Implement_interface_on_class_90006": "在类上实现接口",
  "Implement_inherited_abstract_class_90007": "实现已继承的抽象类",
  "Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript__90009": "添加 tsconfig.json 文件有助于组织包含 TypeScript 和 JavaScript 文件的项目。有关详细信息，请访问 https://aka.ms/tsconfig",
  "Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated_90010": "类型“{0}”无法分配给类型“{1}”。存在具有此名称的两种不同类型，但它们是不相关的。",
  "Import_0_from_1_90013": "从 {1} 导入 {0}",
  "Change_0_to_1_90014": "将 {0} 更改为 {1}",
  "Add_0_to_existing_import_declaration_from_1_90015": "将 {0} 从 {1} 添加到现有导入声明"
}