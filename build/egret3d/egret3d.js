var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var Egret3DState = (function () {
        function Egret3DState() {
        }
        Egret3DState.initState = function () {
            Egret3DState.use = true;
            Egret3DState._info = document.createElement("div");
            Egret3DState._time = document.createElement("div");
            Egret3DState._dataInfo = document.createElement("div");
            Egret3DState._objectInfo = document.createElement("div");
            document.body.appendChild(Egret3DState._info);
            document.body.appendChild(Egret3DState._time);
            document.body.appendChild(Egret3DState._dataInfo);
            document.body.appendChild(Egret3DState._objectInfo);
            Egret3DState._info.style.color = "lightblue";
            Egret3DState._time.style.color = "lightblue";
            Egret3DState._dataInfo.style.color = "lightblue";
            Egret3DState._objectInfo.style.color = "lightblue";
            Egret3DState._info.innerText = "Egret3D Debug State";
        };
        Egret3DState.showTime = function (time, delay) {
            if (!Egret3DState.use)
                Egret3DState.initState();
            Egret3DState._time.innerText = time.toString() + "/" + delay.toString();
        };
        Egret3DState.showDataInfo = function () {
            var data = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                data[_i - 0] = arguments[_i];
            }
            if (!Egret3DState.use)
                Egret3DState.initState();
            Egret3DState._dataInfo.innerText = "";
            var d;
            for (d in data) {
                Egret3DState._dataInfo.innerText += data[d].toString() + "/r/t";
            }
        };
        Egret3DState.use = false;
        return Egret3DState;
    }());
    egret3d.Egret3DState = Egret3DState;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    (function (TextureMethodType) {
        TextureMethodType[TextureMethodType["diffuse"] = 0] = "diffuse";
        TextureMethodType[TextureMethodType["normal"] = 1] = "normal";
        TextureMethodType[TextureMethodType["specular"] = 2] = "specular";
        TextureMethodType[TextureMethodType["color"] = 3] = "color";
        TextureMethodType[TextureMethodType["shadow"] = 4] = "shadow";
    })(egret3d.TextureMethodType || (egret3d.TextureMethodType = {}));
    var TextureMethodType = egret3d.TextureMethodType;
    /**
    * @private
    */
    (function (ShaderPhaseType) {
        ShaderPhaseType[ShaderPhaseType["start_vertex"] = 0] = "start_vertex";
        ShaderPhaseType[ShaderPhaseType["local_vertex"] = 1] = "local_vertex";
        ShaderPhaseType[ShaderPhaseType["global_vertex"] = 2] = "global_vertex";
        ShaderPhaseType[ShaderPhaseType["end_vertex"] = 3] = "end_vertex";
        ShaderPhaseType[ShaderPhaseType["start_fragment"] = 4] = "start_fragment";
        ShaderPhaseType[ShaderPhaseType["materialsource_fragment"] = 5] = "materialsource_fragment";
        ShaderPhaseType[ShaderPhaseType["diffuse_fragment"] = 6] = "diffuse_fragment";
        ShaderPhaseType[ShaderPhaseType["normal_fragment"] = 7] = "normal_fragment";
        ShaderPhaseType[ShaderPhaseType["matCap_fragment"] = 8] = "matCap_fragment";
        ShaderPhaseType[ShaderPhaseType["specular_fragment"] = 9] = "specular_fragment";
        ShaderPhaseType[ShaderPhaseType["shadow_fragment"] = 10] = "shadow_fragment";
        ShaderPhaseType[ShaderPhaseType["lighting_fragment"] = 11] = "lighting_fragment";
        ShaderPhaseType[ShaderPhaseType["multi_end_fragment"] = 12] = "multi_end_fragment";
        ShaderPhaseType[ShaderPhaseType["end_fragment"] = 13] = "end_fragment";
    })(egret3d.ShaderPhaseType || (egret3d.ShaderPhaseType = {}));
    var ShaderPhaseType = egret3d.ShaderPhaseType;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.UV
     * @classdesc
     * UV类，用来存储模型顶点uv数据
     *
     * @see egret3d.GeometryData
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var UV = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function UV(u, v) {
            if (u === void 0) { u = 0; }
            if (v === void 0) { v = 0; }
            /**
            * @language zh_CN
            * u
            */
            this.u = 0;
            /**
            * @language zh_CN
            * v
            */
            this.v = 0;
            this.u = u;
            this.v = v;
        }
        return UV;
    }());
    egret3d.UV = UV;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Point
     * @classdesc
     * Point 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Point = (function () {
        /**
         * @language en_US
         * Creates a new point. If you pass no parameters to this method, a point is
         * created at(0,0).
         *
         * @param x The horizontal coordinate.
         * @param y The vertical coordinate.
         */
        /**
         * @language zh_CN
         * 创建一个Point实例
         * @param x x坐标 默认为0
         * @param y y坐标 默认为0
         * @version Egret 3.0
         * @platform Web,Native
         */
        function Point(x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            this.x = x;
            this.y = y;
        }
        Object.defineProperty(Point.prototype, "length", {
            /**
             * @language en_US
             * The length of the line segment from(0,0) to this point.
             * @returns length
                    * @version Egret 3.0
            * @platform Web,Native
             */
            /**
             * @language zh_CN
             * 返回从(0, 0)到(x, y)的距离
             * @returns number 当前2维向量的长度
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language en_US
         * Adds the coordinates of another point to the coordinates of this point to
         * create a new point.
         *
         * @param v The point to be added.
         * @returns The new point.
         */
        /**
         * @language zh_CN
         * 当前Point加上v Point，结果返回新的实例
         * @param v
         * @version Egret 3.0
         * @platform Web,Native
         */
        Point.prototype.add = function (v) {
            return new Point(this.x + v.x, this.y + v.y);
        };
        /**
         * @language en_US
         * Creates a copy of this Point object.
         *
         * @returns The new Point object.
         */
        /**
         * @language zh_CN
         * 克隆Point
         * @returns  Point 返回克隆后的Point
         * @version Egret 3.0
         * @platform Web,Native
         */
        Point.prototype.clone = function () {
            return new Point(this.x, this.y);
        };
        /**
         * @language zh_CN
         * 复制源Point的值
         * @param sourcePoint 数据源
         * @version Egret 3.0
         * @platform Web,Native
         */
        Point.prototype.copyFrom = function (sourcePoint) {
            this.x = sourcePoint.x;
            this.y = sourcePoint.y;
        };
        /**
         * @language en_US
         * Determines whether two points are equal. Two points are equal if they have
         * the same <i>x</i> and <i>y</i> values.
         *
         * @param toCompare The point to be compared.
         * @returns A value of <code>true</code> if the object is equal to this Point
         *         object; <code>false</code> if it is not equal.
         */
        /**
         * @language zh_CN
         * 比较两个Point是否全等
         * @param toCompare 被比较的Point
         * @returns boolean 全等返回true
         * @version Egret 3.0
         * @platform Web,Native
         */
        Point.prototype.equals = function (toCompare) {
            return (this.x == toCompare.x && this.y == toCompare.y);
        };
        /**
         * @language en_US
         * Scales the line segment between(0,0) and the current point to a set
         * length.
         *
         * @param thickness The scaling value. For example, if the current point is
         *                 (0,5), and you normalize it to 1, the point returned is
         *                  at(0,1).
         */
        /**
         * @language zh_CN
         * 当前Point标准化
         * @param thickness 默认参数为1，使当前Point的长度为thickness 原点(0, 0)到(x, y)的距离
         * @version Egret 3.0
         * @platform Web,Native
         */
        Point.prototype.normalize = function (thickness) {
            if (thickness === void 0) { thickness = 1; }
            if (this.length != 0) {
                var invLength = thickness / this.length;
                this.x *= invLength;
                this.y *= invLength;
                return;
            }
            throw "Cannot divide by zero length.";
        };
        /**
         * @language en_US
         * Offsets the Point object by the specified amount. The value of
         * <code>dx</code> is added to the original value of <i>x</i> to create the
         * new <i>x</i> value. The value of <code>dy</code> is added to the original
         * value of <i>y</i> to create the new <i>y</i> value.
         *
         * @param dx The amount by which to offset the horizontal coordinate,
         *           <i>x</i>.
         * @param dy The amount by which to offset the vertical coordinate, <i>y</i>.
         */
        /**
         * @language zh_CN
         * 当前Point偏移位置
         * @param dx 偏移的x坐标
         * @param dx 偏移的y坐标
         * @version Egret 3.0
         * @platform Web,Native
         */
        Point.prototype.offset = function (dx, dy) {
            this.x += dx;
            this.y += dy;
        };
        /**
         * @language en_US
         * Subtracts the coordinates of another point from the coordinates of this
         * point to create a new point.
         *
         * @param v The point to be subtracted.
         * @returns The new point.
         */
        /**
         * @language zh_CN
         * 当前Point减去v Point,结果返回一个新实例
         * @param v
         * @returns Point 结果返回
         * @version Egret 3.0
         * @platform Web,Native
         */
        Point.prototype.subtract = function (v) {
            return new Point(this.x - v.x, this.y - v.y);
        };
        /**
         * @language en_US
         * Returns a string that contains the values of the <i>x</i> and <i>y</i>
         * coordinates. The string has the form <code>"(x=<i>x</i>,
         * y=<i>y</i>)"</code>, so calling the <code>toString()</code> method for a
         * point at 23,17 would return <code>"(x=23, y=17)"</code>.
         *
         * @returns The string representation of the coordinates.
         */
        /**
        * @language zh_CN
        * 当前Point以字符串形式返回
        * @returns string
         * @version Egret 3.0
         * @platform Web,Native
        */
        Point.prototype.toString = function () {
            return "[Point] (x=" + this.x + ", y=" + this.y + ")";
        };
        /**
         * @language en_US
         * Returns the distance between <code>pt1</code> and <code>pt2</code>.
         *
         * @param pt1 The first point.
         * @param pt2 The second point.
         * @returns The distance between the first and second points.
         */
        /**
        * @language zh_CN
        * 计算两个Point之间的距离
        * @returns number 返回两个Point之间的距离
         * @version Egret 3.0
         * @platform Web,Native
        */
        Point.distance = function (pt1, pt2) {
            var dx = pt2.x - pt1.x;
            var dy = pt2.y - pt1.y;
            return Math.sqrt(dx * dx + dy * dy);
        };
        return Point;
    }());
    egret3d.Point = Point;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Vector3D
     * @classdesc
     * 用 Vector3D 表示三维空间中的位置,也可以做4维向量,当为3维向量时w始终为0。</p>
     * 定义了一个三元的浮点向量。</p>
     * 当使用一个向量表示一个表面法线时，向量应该是标准化的。</p>
     * 其他用途的定向矢量的大小不变。当用作一个点，元素的矢量表示在三维空间中的位置。</p>
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Vector3D = (function () {
        /**
        * @language en_US
        * Creates an instance of a Vector3D object. If you do not specify a。
        * parameter for the constructor, a Vector3D object is created with
        * the elements (0,0,0,0).
        *
        * @param x The first element, such as the x coordinate.
        * @param y The second element, such as the y coordinate.
        * @param z The third element, such as the z coordinate.
        * @param w An optional element for additional data such as the angle
        *          of rotation.
        */
        /**
        * @language zh_CN
        * 创建一个对象实例，默认为(0, 0, 0, 0)
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Vector3D(x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 0; }
            /**
            * @language en_US
            * The first element of a Vector3D object, such as the x coordinate of
            * a point in the three-dimensional space. The default value is 0.
            */
            /**
            * @language zh_CN
            * 在三维空间中x坐标，默认值是0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.x = 0;
            /**
            * @language en_US
            * The second element of a Vector3D object, such as the y coordinate of
            * a point in the three-dimensional space. The default value is 0.
            */
            /**
            * @language zh_CN
            * 在三维空间中y坐标，默认值是0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.y = 0;
            /**
            * @language en_US
            * The third element of a Vector3D object, such as the y coordinate of
            * a point in the three-dimensional space. The default value is 0.
            */
            /**
            * @language zh_CN
            * 在三维空间中z坐标，默认值是0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.z = 0;
            /**
            * @language zh_CN
            * 可作为一种透视投影的三维位置或投影
            * 也可以做四元数中的w
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.w = 0;
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        Object.defineProperty(Vector3D.prototype, "a", {
            /**
            * @language en_US
            *  得到w分量
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.w;
            },
            /**
            * @language en_US
            *  设置w分量
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.w = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "r", {
            /**
            * @language en_US
            *  得到x分量
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.x;
            },
            /**
            * @language en_US
            *  设置x分量
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "g", {
            /**
            * @language en_US
            *  得到y分量
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.y;
            },
            /**
            * @language en_US
            *  设置y分量
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "b", {
            /**
            * @language en_US
            *  得到z分量
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.z;
            },
            /**
            * @language en_US
            *  设置z分量
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.z = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "length", {
            /**
            * @language en_US
            * The length, magnitude, of the current Vector3D object from the
            * origin (0,0,0) to the object's x, y, and z coordinates. The w
            * property is ignored. A unit vector has a length or magnitude of
            * one.
            */
            /**
            * @language zh_CN
            * 向量的长度，原点(0, 0, 0)到(x, y, z)的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return Math.sqrt(this.lengthSquared);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "lengthSquared", {
            /**
            * @language en_US
            * The square of the length of the current Vector3D object, calculated。
            * using the x, y, and z properties. The w property is ignored. Use the
            * <code>lengthSquared()</code> method whenever possible instead of the
            * slower <code>Math.sqrt()</code> method call of the
            * <code>Vector3D.length()</code> method.
            */
            /**
            * @language zh_CN
            * 3维向量的坐标x的平方加 y的平方加 z的平方
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language en_US
        * Adds the value of the x, y, and z elements of the current Vector3D。
        * object to the values of the x, y, and z elements of another Vector3D
        * object. The <code>add()</code> method does not change the current
        * Vector3D object. Instead, it returns a new Vector3D object with
        * the new values.
        *
        * <p>The result of adding two vectors together is a resultant vector.
        * One way to visualize the result is by drawing a vector from the
        * origin or tail of the first vector to the end or head of the second
        * vector. The resultant vector is the distance between the origin
        * point of the first vector and the end point of the second vector.
        * </p>
        */
        /**
        * @language zh_CN
        * 向量相加，结果返回一个新实例
        * @returns Vector3D 结果返回
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.add = function (a) {
            return new Vector3D(this.x + a.x, this.y + a.y, this.z + a.z, this.w + a.w);
        };
        /**
        * @language en_US
        * Returns a new Vector3D object that is an exact copy of the current
        * Vector3D object.
        *
        * @returns A new Vector3D object that is a copy of the current
        * Vector3D object.
        */
        /**
        * @language zh_CN
        * 克隆一个Vector3D
        * @returns 返回克隆后的实例
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.clone = function () {
            return new Vector3D(this.x, this.y, this.z, this.w);
        };
        /**
        * @language en_US
        * Copies all of vector data from the source Vector3D object into the
        * calling Vector3D object.
        *
        * @param src The Vector3D object from which to copy the data.
        */
        /**
        * @language zh_CN
        * 复制Vector3D对象
        * @param src 数据源
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.copyFrom = function (src) {
            this.x = src.x;
            this.y = src.y;
            this.z = src.z;
            this.w = src.w;
        };
        /**
        * @language en_US
        * Returns a new Vector3D object that is perpendicular (at a right。
        * angle) to the current Vector3D and another Vector3D object. If the
        * returned Vector3D object's coordinates are (0,0,0), then the two
        * Vector3D objects are parallel to each other.
        *
        * <p>You can use the normalized cross product of two vertices of a
        * polygon surface with the normalized vector of the camera or eye
        * viewpoint to get a dot product. The value of the dot product can
        * identify whether a surface of a three-dimensional object is hidden
        * from the viewpoint.</p>
        *
        * @param a A second Vector3D object.
        * @returns A new Vector3D object that is perpendicular to the current
        *          Vector3D object and the Vector3D object specified as the
        *          parameter.
        */
        /**
        * @language zh_CN
        * 两个Vector3D进行叉乘 this 叉乘 a
        * 叉乘后的结果是这两条向量的垂直向量
        * @param a
        * @returns Vector3D 返回叉乘结果
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.crossProduct = function (a) {
            return new Vector3D(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x, 1);
        };
        /**
        * @language en_US
        * Decrements the value of the x, y, and z elements of the current。
        * Vector3D object by the values of the x, y, and z elements of
        * specified Vector3D object. Unlike the
        * <code>Vector3D.subtract()</code> method, the
        * <code>decrementBy()</code> method changes the current Vector3D
        * object and does not return a new Vector3D object.
        *
        * @param a The Vector3D object containing the values to subtract from
        *          the current Vector3D object.
        */
        /**
        * @language zh_CN
        * 当前向量减去a向量，结果赋值给自己
        * @param a 减去的向量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.decrementBy = function (a) {
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
        };
        /**
        * @language en_US
        * Returns the distance between two Vector3D objects. The。
        * <code>distance()</code> method is a static method. You can use it
        * directly as a method of the Vector3D class to get the Euclidean
        * distance between two three-dimensional points.
        *
        * @param pt1 A Vector3D object as the first three-dimensional point.
        * @param pt2 A Vector3D object as the second three-dimensional point.
        * @returns The distance between two Vector3D objects.
        */
        /**
        * @language zh_CN
        * 计算两个Vector3D之间的距离
        * @param pt1 坐标1
        * @param pt2 坐标2
        * @returns number 两个Vector3D之间的距离
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.distance = function (pt1, pt2) {
            var x = (pt1.x - pt2.x);
            var y = (pt1.y - pt2.y);
            var z = (pt1.z - pt2.z);
            return Math.sqrt(x * x + y * y + z * z);
        };
        /**
        * @language en_US
        * If the current Vector3D object and the one specified as the。
        * parameter are unit vertices, this method returns the cosine of the
        * angle between the two vertices. Unit vertices are vertices that
        * point to the same direction but their length is one. They remove the
        * length of the vector as a factor in the result. You can use the
        * <code>normalize()</code> method to convert a vector to a unit
        * vector.
        *
        * <p>The <code>dotProduct()</code> method finds the angle between two
        * vertices. It is also used in backface culling or lighting
        * calculations. Backface culling is a procedure for determining which
        * surfaces are hidden from the viewpoint. You can use the normalized
        * vertices from the camera, or eye, viewpoint and the cross product of
        * the vertices of a polygon surface to get the dot product. If the dot
        * product is less than zero, then the surface is facing the camera or
        * the viewer. If the two unit vertices are perpendicular to each
        * other, they are orthogonal and the dot product is zero. If the two
        * vertices are parallel to each other, the dot product is one.</p>
        *
        * @param a The second Vector3D object.
        * @returns A scalar which is the dot product of the current Vector3D
        *          object and the specified Vector3D object.
        *
        */
        /**
        * @language zh_CN
        * 计算两个Vector3D的点积,返回两个Vector3D之间的夹角关系
        * @param a 另一个Vector3D
        * @returns number 返回两个Vector3D之间的夹角关系
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.dotProduct = function (a) {
            return this.x * a.x + this.y * a.y + this.z * a.z;
        };
        /**
        * @language en_US
        * @param toCompare The Vector3D object to be compared with the current
        *                  Vector3D object.
        * @param allFour   An optional parameter that specifies whether the w
        *                  property of the Vector3D objects is used in the
        *                  comparison.
        * @returns A value of true if the specified Vector3D object is equal
        *          to the current Vector3D object; false if it is not equal.
        */
        /**
        * @language zh_CN
        * 求两个Vector3D的值是否全等
        * @param toCompare 与些Vector3D进行比较
        * @param allFour 默认参数为1，是否比较w分量
        * @returns boolean 全等返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.equals = function (toCompare, allFour) {
            if (allFour === void 0) { allFour = false; }
            return (this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z && (!allFour || this.w == toCompare.w));
        };
        /**
        * @language en_US

        * Increments the value of the x, y, and z elements of the current
        * Vector3D object by the values of the x, y, and z elements of a
        * specified Vector3D object. Unlike the <code>Vector3D.add()</code>
        * method, the <code>incrementBy()</code> method changes the current
        * Vector3D object and does not return a new Vector3D object.
        *
        * @param a The Vector3D object to be added to the current Vector3D
        *          object.
        */
        /**
        * @language zh_CN
        * 当前Vector3D加等于a Vector3D，只加x y z 3个分量
        * @param a 加等a
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.incrementBy = function (a) {
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
        };
        /**
        * @language zh_CN
        * 当前Vector3D除分量 或者 除Vector3D
        * @param v 如果是number就是除分量 如果为Vector3D 就是除Vector3D
        * @return Vector3D 返回自己，计算之后的结果
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.divide = function (v) {
            if (v instanceof Vector3D)
                return new Vector3D(this.x / v.x, this.y / v.y, this.z / v.z);
            else {
                this.x = this.x / v;
                this.y = this.y / v;
                this.z = this.z / v;
            }
            return this;
        };
        /**
        * @language en_US
        * Sets the current Vector3D object to its inverse. The inverse object
        * is also considered the opposite of the original object. The value of
        * the x, y, and z properties of the current Vector3D object is changed
        * to -x, -y, and -z.
        */
        /**
        * @language zh_CN
        * 当前Vector3D x y z 3个分量取反
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.negate = function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
        };
        /**
        * @language en_US
        * Scales the line segment between(0,0) and the current point to a set
        * length.
        *
        * @param thickness The scaling value. For example, if the current
        * Vector3D object is (0,3,4), and you normalize it to
        * 1, the point returned is at(0,0.6,0.8).
        */
        /**
        * @language zh_CN
        * 当前Vector3D标准化
        * @param thickness 默认参数为1，使当前Vector3D的长度为thickness 原点(0, 0, 0)到(x, y, z)的距离
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.normalize = function (thickness) {
            if (thickness === void 0) { thickness = 1; }
            if (this.length != 0) {
                var invLength = thickness / this.length;
                this.x *= invLength;
                this.y *= invLength;
                this.z *= invLength;
                return;
            }
        };
        /**
        * @language en_US
        * Scales the current Vector3D object by a scalar, a magnitude. The
        * Vector3D object's x, y, and z elements are multiplied by the scalar
        * number specified in the parameter. For example, if the vector is
        * scaled by ten, the result is a vector that is ten times longer. The
        * scalar can also change the direction of the vector. Multiplying the
        * vector by a negative number reverses its direction.
        *
        * @param s A multiplier (scalar) used to scale a Vector3D object.
        */
        /**
        * @language zh_CN
        * 当前Vector3D扩大s倍
        * @param s 扩大的倍数
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.scaleBy = function (s) {
            this.x *= s;
            this.y *= s;
            this.z *= s;
        };
        /**
        * @language en_US
        * Sets the members of Vector3D to the specified values
        *
        * @param xa The first element, such as the x coordinate.
        * @param ya The second element, such as the y coordinate.
        * @param za The third element, such as the z coordinate.
        */
        /**
        * @language zh_CN
        * 填充当前Vector3D的x, y, z
        * @param xa
        * @param yz
        * @param za
        * @param wz
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.setTo = function (xa, ya, za, wa) {
            if (wa === void 0) { wa = 1; }
            this.x = xa;
            this.y = ya;
            this.z = za;
            this.w = wa;
        };
        /**
        * @language en_US
        * Subtracts the value of the x, y, and z elements of the current
        * Vector3D object from the values of the x, y, and z elements of
        * another Vector3D object. The <code>subtract()</code> method does not
        * change the current Vector3D object. Instead, this method returns a
        * new Vector3D object with the new values.
        *
        * @param a The Vector3D object to be subtracted from the current
        *          Vector3D object.
        * @returns A new Vector3D object that is the difference between the
        *          current Vector3D and the specified Vector3D object.
        */
        /**
        * @language zh_CN
        * 当前Vector3D减去a Vector3D 结果返回新实例
        * @param a 减去的Vector3D
        * @param target 默认参数为null,如果当前参数为null那么就会new一个新的Vector3D返回
        * @returns Vector3D 结果返回
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.subtract = function (a, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Vector3D();
            }
            target.setTo(this.x - a.x, this.y - a.y, this.z - a.z);
            return target;
        };
        /**
        * @language zh_CN
        * 当前Vector3D乘other Vector3D 结果返回新实例
        * @param a 相乘的Vector3D
        * @param target 如果当前参数为null那么就会new一个新的Vector3D返回
        * @returns Vector3D 结果返回
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.multiply = function (other, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Vector3D();
            }
            var x0 = this.x;
            var y0 = this.y;
            var z0 = this.z;
            var x1 = other.x;
            var y1 = other.y;
            var z1 = other.z;
            target.setTo(x0 * x1, y0 * y1, z0 * z1);
            return target;
        };
        /**
        * @language zh_CN
        * 当前Vector3D除以other Vector3D 结果返回新实例
        * @param a 相除的Vector3D
        * @param target 如果当前参数为null那么就会new一个新的Vector3D返回
        * @returns Vector3D 结果返回
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.divided = function (other, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Vector3D();
            }
            var x0 = this.x;
            var y0 = this.y;
            var z0 = this.z;
            var x1 = other.x;
            var y1 = other.y;
            var z1 = other.z;
            target.setTo(x0 / x1, y0 / y1, z0 / z1);
            return target;
        };
        /**
        * @language zh_CN
        * 计算两个Vector3D之间的线性差值，结果为当前对象
        * @param v0 Vector3D 1
        * @param v1 Vector3D 2
        * @param t 时刻
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.lerp = function (v0, v1, t) {
            var v0x = v0.x, v0y = v0.y, v0z = v0.z, v0w = v0.w;
            var v1x = v1.x, v1y = v1.y, v1z = v1.z, v1w = v1.w;
            this.x = (v1x - v0x) * t + v0x;
            this.y = (v1y - v0y) * t + v0y;
            this.z = (v1z - v0z) * t + v0z;
            this.w = (v1w - v0w) * t + v0w;
        };
        /**
        * @language zh_CN
        * 当前Vector3D以字符串形式返回
        * @returns string
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.toString = function () {
            return "<" + this.x + ", " + this.y + ", " + this.z + ">";
        };
        /**
        * @language zh_CN
        * 解析字符串为Vector3D
        * @param str 格式用空格间隔开，只解析为x,y,z
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.parsing = function (str) {
            var strS = str.split(" ");
            if (strS.length < 3)
                return;
            this.x = parseFloat(strS[0]);
            this.y = parseFloat(strS[1]);
            this.z = parseFloat(strS[2]);
        };
        /**
        * @language en_US
        * The x axis defined as a Vector3D object with coordinates (1,0,0).
        */
        /**
        * @language zh_CN
        * X轴坐标 (1,0,0).
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.X_AXIS = new Vector3D(1, 0, 0);
        /**
        * @language en_US
        * The y axis defined as a Vector3D object with coordinates (0,1,0).
        */
        /**
        * @language zh_CN
        * Y轴坐标 (0,1,0).
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.Y_AXIS = new Vector3D(0, 1, 0);
        /**
        * @language en_US
        * The z axis defined as a Vector3D object with coordinates (0,0,1).
        */
        /**
        * @language zh_CN
        * Z轴坐标 (0,0,1).
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.Z_AXIS = new Vector3D(0, 0, 1);
        return Vector3D;
    }());
    egret3d.Vector3D = Vector3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Rectangle
     * @classdesc
     * Rectangle 类 表示矩形
     *
     * Rectangle 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。
     *
     * Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其它属性。
     *
     * 您可以使用 new Rectangle() 构造函数创建 Rectangle 对象。
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Rectangle = (function () {
        /**
         * @language zh_CN
         * 创建一个新 Rectangle 对象，其左上角由 x 和 y 参数指定，并具有指定的 width 和 height 参数。
         * @param x 矩形左上角的 x 坐标。
         * @param y 矩形左上角的 y 坐标。
         * @param width 矩形的宽度
         * @param height 矩形的高度
         * @version Egret 3.0
         * @platform Web,Native
         */
        function Rectangle(x, y, width, height) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (width === void 0) { width = 32; }
            if (height === void 0) { height = 32; }
            /**
            * @language zh_CN
            * 矩形左上角的 x 坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.x = 0;
            /**
            * @language zh_CN
            * 矩形左上角的 y 坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.y = 0;
            /**
            * @language zh_CN
            * 矩形的宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.width = 0;
            /**
            * @language zh_CN
            * 矩形的高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.height = 0;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        /**
        * @language zh_CN
        * 复制矩形数据
        * @param other 被复制的矩形
        * @version Egret 3.0
        * @platform Web,Native
        */
        Rectangle.prototype.copy = function (other) {
            this.x = other.x;
            this.y = other.y;
            this.width = other.width;
            this.height = other.height;
            return this;
        };
        /**
         * @language zh_CN
         * 检测x y 是否在当前矩形内
         * @param x  x 坐标。
         * @param y  y 坐标。
         * @returns boolean 是否在当前矩形内
         * @version Egret 3.0
         * @platform Web,Native
         */
        Rectangle.prototype.inner = function (x, y) {
            if (x < this.x || x > this.x + this.width ||
                y < this.y || y > this.y + this.height) {
                return false;
            }
            return true;
        };
        return Rectangle;
    }());
    egret3d.Rectangle = Rectangle;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Quaternion
     * @classdesc
     * Quaternion类
     *
     * 定义了一个四元数表示物体在空间的旋转。
     * 四元数通常用作替代欧拉角和旋转矩阵的方式来实现平滑插值和避免万向节锁
     * 注意，这四元数类不自动保持四元数标准化。因此，在必要的时候，必须采取单位化的四元数，通过调用单位化方法
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Quaternion = (function () {
        /**
        * @language en_US
        * Creates a new Quaternion object.
        * @param x The x value of the quaternion.
        * @param y The y value of the quaternion.
        * @param z The z value of the quaternion.
        * @param w The w value of the quaternion.
        */
        /**
        * @language zh_CN
        * 创建一个四元数.
        * @param x
        * @param y
        * @param z
        * @param w
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Quaternion(x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 1; }
            /**
            * @language en_US
            * The x value of the quaternion.
            */
            /**
            * @language zh_CN
            * 四元数的x值.
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.x = 0;
            /**
            * @language en_US
            * The y value of the quaternion.
            */
            /**
            * @language zh_CN
            * 四元数的y值.
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.y = 0;
            /**
            * @language en_US
            * The z value of the quaternion.
            */
            /**
            * @language zh_CN
            * 四元数的z值.
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.z = 0;
            /**
            * @language en_US
            * The w value of the quaternion.
            */
            /**
            * @language zh_CN
            * 四元数的w值.
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.w = 1;
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        Object.defineProperty(Quaternion.prototype, "magnitude", {
            /**
            * @language en_US
            *
            * @returns the magnitude of the quaternion object.
            */
            /**
            * @language zh_CN
            *
            * 返回四元数的大小.
            * @param w
            * @returns number 四元数的大小.
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language en_US
        * Fills the quaternion object with the result from a multiplication of two quaternion objects.
        *
        * @param    qa    The first quaternion in the multiplication.
        * @param    qb    The second quaternion in the multiplication.
        */
        /**
        * @language zh_CN
        * 两个四元数相乘,然后结果给当调用者.
        * @param qa 第一个四元数
        * @param qb 第二个四元数
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.multiply = function (qa, qb) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            this.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            this.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            this.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
        };
        /**
        * @language zh_CN
        * 四元数乘以一个3维向量，结果返回一个四元数
        * @param vector 相乘的向量
        * @param target 返回的结果，如果为null就会实例化一个四元数对象返回
        * @returns Quaternion 返回相乘后的结果
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.multiplyVector = function (vector, target) {
            if (target === void 0) { target = null; }
            if (target === null) {
                target = new Quaternion();
            }
            var x2 = vector.x;
            var y2 = vector.y;
            var z2 = vector.z;
            target.w = -this.x * x2 - this.y * y2 - this.z * z2;
            target.x = this.w * x2 + this.y * z2 - this.z * y2;
            target.y = this.w * y2 - this.x * z2 + this.z * x2;
            target.z = this.w * z2 + this.x * y2 - this.y * x2;
            return target;
        };
        /**
        * @language en_US
        * Fills the quaternion object with values representing the given rotation around a vector.
        *
        * @param    axis    The axis around which to rotate
        * @param    angle    The angle in radians of the rotation.
        */
        /**
        * @language zh_CN
        * 创建一个以axis轴为中心旋转angle角度的四元数
        *
        * @param axis   旋转轴
        * @param angle  旋转角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.fromAxisAngle = function (axis, angle) {
            angle *= Math.PI / 180.0;
            var halfAngle = angle * 0.5;
            var sin_a = Math.sin(halfAngle);
            this.w = Math.cos(halfAngle);
            this.x = axis.x * sin_a;
            this.y = axis.y * sin_a;
            this.z = axis.z * sin_a;
            this.normalize();
        };
        /**
        * @language zh_CN
        * 返回四元数绕轴心和角度
        *
        * @param axis 轴心
        * @returns 角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.toAxisAngle = function (axis) {
            var sqrLength = this.x * this.x + this.y * this.y + this.z * this.z;
            var angle = 0;
            if (sqrLength > 0.0) {
                angle = 2.0 * Math.acos(this.w);
                sqrLength = 1.0 / Math.sqrt(sqrLength);
                axis.x = this.x * sqrLength;
                axis.y = this.y * sqrLength;
                axis.z = this.z * sqrLength;
            }
            else {
                angle = 0;
                axis.x = 1.0;
                axis.y = 0;
                axis.z = 0;
            }
            angle /= Math.PI / 180.0;
            return angle;
        };
        /**
        * @language en_US
        * Spherically interpolates between two quaternions, providing an interpolation between rotations with constant angle change rate.
        * @param qa The first quaternion to interpolate.
        * @param qb The second quaternion to interpolate.
        * @param t The interpolation weight, a value between 0 and 1.
        */
        /**
        * @language zh_CN
        * 两个四元数之间球形插值，插值之间提供旋转恒定角变化率。
        *
        * @param qa 四元数1
        * @param qb 四元数2
        * @param t 差值时刻
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.slerp = function (qa, qb, t) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            var dot = w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2;
            // shortest direction
            if (dot < 0) {
                dot = -dot;
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            if (dot < 0.95) {
                // interpolate angle linearly
                var angle = Math.acos(dot);
                var s = 1 / Math.sin(angle);
                var s1 = Math.sin(angle * (1 - t)) * s;
                var s2 = Math.sin(angle * t) * s;
                this.w = w1 * s1 + w2 * s2;
                this.x = x1 * s1 + x2 * s2;
                this.y = y1 * s1 + y2 * s2;
                this.z = z1 * s1 + z2 * s2;
            }
            else {
                // nearly identical angle, interpolate linearly
                this.w = w1 + t * (w2 - w1);
                this.x = x1 + t * (x2 - x1);
                this.y = y1 + t * (y2 - y1);
                this.z = z1 + t * (z2 - z1);
                var len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
                this.w *= len;
                this.x *= len;
                this.y *= len;
                this.z *= len;
            }
        };
        /**
        * @language en_US
        * Linearly interpolates between two quaternions.
        * @param qa The first quaternion to interpolate.
        * @param qb The second quaternion to interpolate.
        * @param t The interpolation weight, a value between 0 and 1.
        */
        /**
        * @language zh_CN
        * 两个四元数之间的线性插值
        *
        * @param qa 四元数1
        * @param qb 四元数2
        * @param t 差值时刻
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.lerp = function (qa, qb, t) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            var len;
            // shortest direction
            if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            this.w = w1 + t * (w2 - w1);
            this.x = x1 + t * (x2 - x1);
            this.y = y1 + t * (y2 - y1);
            this.z = z1 + t * (z2 - z1);
            len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
            this.w *= len;
            this.x *= len;
            this.y *= len;
            this.z *= len;
        };
        /**
        * @language en_US
        * Fills the quaternion object with values representing the given euler rotation.
        *
        * @param    ax        The angle in radians of the rotation around the ax axis.
        * @param    ay        The angle in radians of the rotation around the ay axis.
        * @param    az        The angle in radians of the rotation around the az axis.
        */
        /**
        * @language zh_CN
        * 用数值表示给定的欧拉旋转填充四元数对象。
        *
        * @param ax x轴旋转角度
        * @param ay y轴旋转角度
        * @param az z轴旋转角度
        * @return Quaternion 四元数对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.fromEulerAngles = function (ax, ay, az) {
            ax *= egret3d.MathUtil.DEGREES_TO_RADIANS;
            ay *= egret3d.MathUtil.DEGREES_TO_RADIANS;
            az *= egret3d.MathUtil.DEGREES_TO_RADIANS;
            var halfX = ax * 0.5, halfY = ay * 0.5, halfZ = az * 0.5;
            var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
            var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
            var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
            this.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            this.x = sinX * cosY * cosZ - cosX * sinY * sinZ;
            this.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
            this.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
            return this;
        };
        /**
        * @language en_US
        * Fills a target Vector3D object with the Euler angles that form the rotation represented by this quaternion.
        * @param target An optional Vector3D object to contain the Euler angles. If not provided, a new object is created.
        * @returns The Vector3D containing the Euler angles.
        */
        /**
        * @language zh_CN
        * 把四元数转成欧拉角返回
        *
        * @param target 默认参数为null，转成的欧拉返回值，如果为null就新建一个对象返回
        * @retruns Vector3D 转成的欧拉返回值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.toEulerAngles = function (target) {
            if (target === void 0) { target = null; }
            if (target === null) {
                target = new egret3d.Vector3D();
            }
            target.x = Math.atan2(2.0 * (this.w * this.x + this.y * this.z), 1.0 - 2.0 * (this.x * this.x + this.y * this.y));
            var temp = 2.0 * (this.w * this.y - this.z * this.x);
            temp = egret3d.MathUtil.clampf(temp, -1.0, 1.0);
            target.y = Math.asin(temp);
            target.z = Math.atan2(2.0 * (this.w * this.z + this.x * this.y), 1.0 - 2.0 * (this.y * this.y + this.z * this.z));
            target.x /= egret3d.MathUtil.DEGREES_TO_RADIANS;
            target.y /= egret3d.MathUtil.DEGREES_TO_RADIANS;
            target.z /= egret3d.MathUtil.DEGREES_TO_RADIANS;
            return target;
        };
        /**
        * @language en_US
        * Normalises the quaternion object.
        */
        /**
        * @language zh_CN
        * 单位化四元数
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.normalize = function (val) {
            if (val === void 0) { val = 1; }
            var mag = val / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            this.x *= mag;
            this.y *= mag;
            this.z *= mag;
            this.w *= mag;
        };
        /**
        * @language en_US
        * Used to trace the values of a quaternion.
        *
        * @returns A string representation of the quaternion object.
        */
        /**
        * @language zh_CN
        * 以字符串形式返回四元数的值
        * @returns string
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.toString = function () {
            return "{x:" + this.x + " y:" + this.y + " z:" + this.z + " w:" + this.w + "}";
        };
        /**
        * @language en_US
        * Converts the quaternion to a Matrix3D object representing an equivalent rotation.
        * @param target An optional Matrix3D container to store the transformation in. If not provided, a new object is created.
        * @returns A Matrix3D object representing an equivalent rotation.
        */
        /**
        * @language zh_CN
        * 把一个四元数转换成矩阵
        * @param target 返回转换后的矩阵，如果为null就新建一个对象返回
        * @see egret3d.Matrix4_4
        * @returns  Matrix4_4 返回转换后的矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.toMatrix3D = function (target) {
            if (target === void 0) { target = null; }
            var rawData = egret3d.MathUtil.RAW_DATA_CONTAINER;
            var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
            var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
            var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;
            rawData[0] = xx - yy - zz + ww;
            rawData[4] = xy2 - zw2;
            rawData[8] = xz2 + yw2;
            rawData[12] = 0;
            rawData[1] = xy2 + zw2;
            rawData[5] = -xx + yy - zz + ww;
            rawData[9] = yz2 - xw2;
            rawData[13] = 0;
            rawData[2] = xz2 - yw2;
            rawData[6] = yz2 + xw2;
            rawData[10] = -xx - yy + zz + ww;
            rawData[14] = 0;
            rawData[3] = 0.0;
            rawData[7] = 0.0;
            rawData[11] = 0;
            rawData[15] = 1;
            if (!target)
                return new egret3d.Matrix4_4(new Float32Array(rawData));
            target.copyRawDataFrom(rawData);
            return target;
        };
        /**
        * @language en_US
        * Extracts a quaternion rotation matrix out of a given Matrix3D object.
        * @param matrix The Matrix3D out of which the rotation will be extracted.
        */
        /**
        * @language zh_CN
        * 用一个旋转矩阵生成四元数
        * @param matrix 旋转矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.fromMatrix = function (matrix) {
            var v = matrix.decompose(egret3d.Orientation3D.QUATERNION)[1];
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = v.w;
        };
        /**
        * @language zh_CN
        * 返回一个把当前四元数取逆后的四元数
        * @param target 默认参数为null,如果当前参数为null那么就会new一个新的四元数对象返回
        * @return Quaternion 四元数
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.inverse = function (target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Quaternion();
            }
            var norm = this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z;
            if (norm > 0.0) {
                var invNorm = 1.0 / norm;
                target.w = this.w * invNorm;
                target.x = -this.x * invNorm;
                target.y = -this.y * invNorm;
                target.z = -this.z * invNorm;
            }
            return target;
        };
        /**
        * @language en_US
        * Clones the quaternion.
        * @returns An exact duplicate of the current Quaternion.
        */
        /**
        * @language zh_CN
        * 克隆一个四元数
        * @returns Quaternion 当前四元数复制后返回.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.clone = function () {
            return new Quaternion(this.x, this.y, this.z, this.w);
        };
        /**
        * @language en_US
        * Rotates a point.
        * @param vector The Vector3D object to be rotated.
        * @param target An optional Vector3D object that will contain the rotated coordinates. If not provided, a new object will be created.
        * @returns A Vector3D object containing the rotated point.
        */
        /**
        * @language zh_CN
        * 旋转一个3量坐标点
        * @param vector 被旋转的对象
        * @param target 默认参数为null，旋转后的坐标对象。如果为null，将创建一个新的对象
        * @returns Vector3D 返回旋转后的坐标对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.transformVector = function (vector, target) {
            if (target === void 0) { target = null; }
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            if (target === null) {
                target = new egret3d.Vector3D();
            }
            // p*q'
            w1 = -this.x * x2 - this.y * y2 - this.z * z2;
            x1 = this.w * x2 + this.y * z2 - this.z * y2;
            y1 = this.w * y2 - this.x * z2 + this.z * x2;
            z1 = this.w * z2 + this.x * y2 - this.y * x2;
            target.x = -w1 * this.x + x1 * this.w - y1 * this.z + z1 * this.y;
            target.y = -w1 * this.y + x1 * this.z + y1 * this.w - z1 * this.x;
            target.z = -w1 * this.z - x1 * this.y + y1 * this.x + z1 * this.w;
            return target;
        };
        /**
        * @language en_US
        * Copies the data from a quaternion into this instance.
        * @param q The quaternion to copy from.
        */
        /**
        * @language zh_CN
        * 将数据从四元数复制到该实例
        * @param q 被复制的四元数对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.copyFrom = function (q) {
            this.x = q.x;
            this.y = q.y;
            this.z = q.z;
            this.w = q.w;
        };
        return Quaternion;
    }());
    egret3d.Quaternion = Quaternion;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Orientation3D
     * @classdesc
     * 定义 Orientation3D 常量。</p>
     * Matrix4_4.decompose 会分 axisAngle、eulerAngles、quaternion这3种类型进行分解。</p>
     * 比如:</p>
     <pre>
     matrix.decompose(Orientation3D.QUATERNION)
     </pre>
     *
     * @see egret3d.Matrix4_4
     * @see egret3d.Quaternion
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Orientation3D = (function () {
        function Orientation3D() {
        }
        /**
        * @language zh_CN
        * 按轴旋转角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Orientation3D.AXIS_ANGLE = "axisAngle";
        /**
        * @language zh_CN
        * 按欧拉角旋转角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Orientation3D.EULER_ANGLES = "eulerAngles";
        /**
        * @language zh_CN
        * 四元数旋转角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Orientation3D.QUATERNION = "quaternion";
        return Orientation3D;
    }());
    egret3d.Orientation3D = Orientation3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Plane3D
     * @classdesc
     * Plane3D 类 3D空间中的平面表示数据
     * 由a,b,c,d4个分量组成 在三维空间中定义了一个平面 Ax + By + Cz + D = 0
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Plane3D = (function () {
        /**
         * @language en_US
         * Create a Plane3D with ABCD coefficients
         */
        /**
        * @language zh_CN
        * 创建一个平面实例
        * @param a
        * @param b
        * @param c
        * @param d
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Plane3D(a, b, c, d) {
            if (a === void 0) { a = 0; }
            if (b === void 0) { b = 0; }
            if (c === void 0) { c = 0; }
            if (d === void 0) { d = 0; }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
        }
        /**
        * @language zh_CN
        * 填充平面的各分量的值
        * @param a
        * @param b
        * @param c
        * @param d
        * @version Egret 3.0
        * @platform Web,Native
        */
        Plane3D.prototype.setTo = function (a, b, c, d) {
            if (a === void 0) { a = 0; }
            if (b === void 0) { b = 0; }
            if (c === void 0) { c = 0; }
            if (d === void 0) { d = 0; }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
        };
        /**
         * @language en_US
         * Fills this Plane3D with the coefficients from 3 points in 3d space.
         * @param p0 Vector3D
         * @param p1 Vector3D
         * @param p2 Vector3D
         */
        /**
        * @language zh_CN
        * 由3个坐标来创建一个3d平面
        * @param p0 Vector3D
        * @param p1 Vector3D
        * @param p2 Vector3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Plane3D.prototype.fromPoints = function (p0, p1, p2) {
            var d1x = p1.x - p0.x;
            var d1y = p1.y - p0.y;
            var d1z = p1.z - p0.z;
            var d2x = p2.x - p0.x;
            var d2y = p2.y - p0.y;
            var d2z = p2.z - p0.z;
            this.a = d1y * d2z - d1z * d2y;
            this.b = d1z * d2x - d1x * d2z;
            this.c = d1x * d2y - d1y * d2x;
            this.d = -(this.a * p0.x + this.b * p0.y + this.c * p0.z);
        };
        /**
         * @language en_US
         * Fills this Plane3D with the coefficients from the plane's normal and a point in 3d space.
         * @param normal Vector3D
         * @param point  Vector3D
         */
        /**
        * @language zh_CN
        * 由一条normal向量和一个坐标创建一个3d平面
        * @param normal Vector3D
        * @param point  Vector3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Plane3D.prototype.fromNormalAndPoint = function (normal, point) {
            this.a = normal.x;
            this.b = normal.y;
            this.c = normal.z;
            this.d = -(this.a * point.x + this.b * point.y + this.c * point.z);
        };
        /**
         * @language en_US
         * Normalize this Plane3D
         * @returns Plane3D This Plane3D.
         */
        /**
        * @language zh_CN
        * 单位化3d平面
        * @returns number 返回平面长度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Plane3D.prototype.normalize = function () {
            var len = Math.sqrt(this.a * this.a + this.b * this.b + this.c * this.c);
            if (len > 0.0) {
                var invLength = 1.0 / len;
                this.a *= invLength;
                this.b *= invLength;
                this.c *= invLength;
                this.d *= invLength;
            }
            return len;
        };
        /**
         * @language en_US
         * Returns the signed distance between this Plane3D and the point p.
         * @param p Vector3D
         * @returns Number
         */
        /**
        * @language zh_CN
        * 计算3d平面到点p的距离
        * @param p Vector3D
        * @returns number 返回计算后的距离
        * @version Egret 3.0
        * @platform Web,Native
        */
        Plane3D.prototype.distance = function (p) {
            return this.a * p.x + this.b * p.y + this.c * p.z + this.d;
        };
        /**
         * @language en_US
         * Classify a point against this Plane3D. (in front, back or intersecting)
         * @param p Vector3D
         * @param epsilon
         * @returns PlaneClassification.FRONT在平面正面
         * PlaneClassification.BACK在平面背面面
         * PlaneClassification.INTERSECT在平面上
         */
        /**
        * @language zh_CN
        * 计算3d平面和点p的空间关系
        * @param p Vector3D
        * @param epsilon 相对偏移值
        * @returns number int Plane3.FRONT or Plane3D.BACK or Plane3D.INTERSECT
        * @version Egret 3.0
        * @platform Web,Native
        */
        Plane3D.prototype.classifyPoint = function (p, epsilon) {
            if (epsilon === void 0) { epsilon = 0.01; }
            var dis = this.distance(p);
            if (dis < -epsilon) {
                return egret3d.PlaneClassification.BACK;
            }
            else if (dis > epsilon) {
                return egret3d.PlaneClassification.FRONT;
            }
            return egret3d.PlaneClassification.INTERSECT;
        };
        /**
        * @language zh_CN
        * 当前Plane3D以字符串形式返回
        * @returns string
        * @version Egret 3.0
        * @platform Web,Native
        */
        Plane3D.prototype.toString = function () {
            return "Plane3D [a:" + this.a + ", b:" + this.b + ", c:" + this.c + ", d:" + this.d + "]";
        };
        // indicates the alignment of the plane
        /**
         * @private
         */
        Plane3D.ALIGN_ANY = 0;
        /**
         * @private
         */
        Plane3D.ALIGN_XY_AXIS = 1;
        /**
         * @private
         */
        Plane3D.ALIGN_YZ_AXIS = 2;
        /**
         * @private
         */
        Plane3D.ALIGN_XZ_AXIS = 3;
        return Plane3D;
    }());
    egret3d.Plane3D = Plane3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Matrix4_4
     * @classdesc
     *
     * Matrix4_4 类表示一个转换矩阵，该矩阵确定三维 (3D) 显示对象的位置和方向。
     * 该矩阵可以执行转换功能，包括平移（沿 x、y 和 z 轴重新定位）、旋转和缩放（调整大小）.
     * Matrix4_4 类还可以执行透视投影，这会将 3D 坐标空间中的点映射到二维 (2D) 视图.
     * 单一矩阵可以将多个转换组合在一起，并一次性对 3D 显示对象应用这些转换.
     * 例如，可以将一个矩阵应用于 3D 坐标，以便依次执行旋转和平移.
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Matrix4_4 = (function () {
        /**
        * @language zh_CN
        * 构造
        * @param datas {number[16]}
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Matrix4_4(datas) {
            if (datas === void 0) { datas = null; }
            this.result = new Float32Array(16);
            this.m = new Float32Array(16);
            this.oRawData = new Float32Array(16);
            if (datas) {
                this.rawData = datas;
            }
            else
                this.rawData = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        }
        /**
        * @language zh_CN
        * 生成一个注视目标的矩阵.
        * @param eye 眼睛的位置.
        * @param at 目标的位置.
        * @param up 向上的方向.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.lookAt = function (eye, at, up) {
            var zaxis = at.subtract(eye);
            zaxis.normalize();
            var xaxis = up.crossProduct(zaxis);
            xaxis.normalize();
            var yaxis = zaxis.crossProduct(xaxis);
            this.rawData[0] = xaxis.x;
            this.rawData[1] = yaxis.x;
            this.rawData[2] = zaxis.x;
            this.rawData[3] = 0;
            this.rawData[4] = xaxis.y;
            this.rawData[5] = yaxis.y;
            this.rawData[6] = zaxis.y;
            this.rawData[7] = 0;
            this.rawData[8] = xaxis.z;
            this.rawData[9] = yaxis.z;
            this.rawData[10] = zaxis.z;
            this.rawData[11] = 0;
            this.rawData[12] = -xaxis.dotProduct(eye);
            this.rawData[13] = -yaxis.dotProduct(eye);
            this.rawData[14] = -zaxis.dotProduct(eye);
            this.rawData[15] = 1;
        };
        /**
        * @language zh_CN
        * 矩阵相乘.
        * @param mat4 相乘的矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.multiply = function (mat4) {
            var a = this.rawData, b = mat4.rawData, r = this.result;
            r[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
            r[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
            r[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
            r[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];
            r[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
            r[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
            r[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
            r[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];
            r[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
            r[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
            r[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
            r[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];
            r[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
            r[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
            r[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
            r[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
            for (var i = 0; i < 16; i++)
                this.rawData[i] = r[i];
        };
        /**
        * @private
        * @language zh_CN
        */
        Matrix4_4.prototype.perspectiveB = function (fov, aspect, near, far) {
            var y = Math.tan(fov * Math.PI / 360) * near;
            var x = y * aspect;
            return this.frustum(-x, x, -y, y, near, far);
        };
        /**
        * @private
        * @language zh_CN
        */
        Matrix4_4.prototype.frustum = function (l, r, b, t, n, f) {
            var m = this.rawData;
            m[0] = 2 * n / (r - l);
            m[1] = 0;
            m[2] = (r + l) / (r - l);
            m[3] = 0;
            m[4] = 0;
            m[5] = 2 * n / (t - b);
            m[6] = (t + b) / (t - b);
            m[7] = 0;
            m[8] = 0;
            m[9] = 0;
            m[10] = -(f + n) / (f - n);
            m[11] = -2 * f * n / (f - n);
            m[12] = 0;
            m[13] = 0;
            m[14] = -1;
            m[15] = 0;
            return this;
        };
        //public ortho(l: number, r: number, b: number, t: number, n: number, f: number): Matrix4_4 {
        //    var m = this.rawData;
        //    m[0] = 2 / (r - l);
        //    m[1] = 0;
        //    m[2] = 0;
        //    m[3] = -(r + l) / (r - l);
        //    m[4] = 0;
        //    m[5] = 2 / (t - b);
        //    m[6] = 0;
        //    m[7] = -(t + b) / (t - b);
        //    m[8] = 0;
        //    m[9] = 0;
        //    m[10] = -2 / (f - n);
        //    m[11] = -(f + n) / (f - n);
        //    m[12] = 0;
        //    m[13] = 0;
        //    m[14] = 0;
        //    m[15] = 1;
        //    return this;
        //}
        /**
        * @language zh_CN
        * 生成一个透视投影矩阵.
        * @param fovy 观察时y 轴方向的角度，就是观察范围夹角。
        * @param aspect 横纵比，在视空间宽度除以高度.
        * @param zn 近裁剪面位置Z值.
        * @param zf 远裁剪面位置Z值.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.perspective = function (fovy, aspect, zn, zf) {
            var angle = fovy * (Math.PI / 180.0);
            var yScale = Math.tan((Math.PI - angle) / 2.0);
            var xScale = yScale / aspect;
            this.rawData[0] = xScale;
            this.rawData[1] = 0;
            this.rawData[2] = 0;
            this.rawData[3] = 0;
            this.rawData[4] = 0;
            this.rawData[5] = yScale;
            this.rawData[6] = 0;
            this.rawData[7] = 0;
            this.rawData[8] = 0;
            this.rawData[9] = 0;
            this.rawData[10] = zf / (zf - zn);
            this.rawData[11] = 1;
            this.rawData[12] = 0;
            this.rawData[13] = 0;
            this.rawData[14] = -zn * zf / (zf - zn);
            this.rawData[15] = 0;
        };
        /**
        * @language zh_CN
        * 生成一个透视投影矩阵.
        * @param w 屏幕的宽度。
        * @param h 屏幕的高度.
        * @param zn 近裁剪面位置Z值.
        * @param zf 远裁剪面位置Z值.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.ortho = function (w, h, zn, zf) {
            this.rawData[0] = 2 / w;
            this.rawData[1] = 0;
            this.rawData[2] = 0;
            this.rawData[3] = 0;
            this.rawData[4] = 0;
            this.rawData[5] = 2 / h;
            this.rawData[6] = 0;
            this.rawData[7] = 0;
            this.rawData[8] = 0;
            this.rawData[9] = 0;
            this.rawData[10] = 1 / (zf - zn);
            this.rawData[11] = 0;
            this.rawData[12] = 0;
            this.rawData[13] = 0;
            this.rawData[14] = zn / (zn - zf);
            this.rawData[15] = 1;
        };
        /**
        * @language zh_CN
        * 生成一个透视投影矩阵.
        * @param l 观察时X轴最小值.
        * @param r 观察时X轴最大值.
        * @param b 观察时Y轴最小值。
        * @param t 观察时Y轴最大值.
        * @param zn 近裁剪面位置Z值.
        * @param zf 远裁剪面位置Z值.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.orthoOffCenter = function (l, r, b, t, zn, zf) {
            this.rawData[0] = 2 / (r - 1);
            this.rawData[1] = 0;
            this.rawData[2] = 0;
            this.rawData[3] = 0;
            this.rawData[4] = 0;
            this.rawData[5] = 2 / (t - b);
            this.rawData[6] = 0;
            this.rawData[7] = 0;
            this.rawData[8] = 0;
            this.rawData[9] = 0;
            this.rawData[10] = 1 / (zf - zn);
            this.rawData[11] = 0;
            this.rawData[12] = (1 + r) / (1 - r);
            this.rawData[13] = (t + b) / (b - t);
            this.rawData[14] = zn / (zn - zf);
            this.rawData[15] = 1;
        };
        /**
        * @language zh_CN
        * 通过将当前 Matrix4_4 对象与另一个 Matrix4_4 对象相乘来前置一个矩阵
        * @param lhs 目标矩阵.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.append = function (lhs) {
            var m111 = this.rawData[0], m121 = this.rawData[4], m131 = this.rawData[8], m141 = this.rawData[12], m112 = this.rawData[1], m122 = this.rawData[5], m132 = this.rawData[9], m142 = this.rawData[13], m113 = this.rawData[2], m123 = this.rawData[6], m133 = this.rawData[10], m143 = this.rawData[14], m114 = this.rawData[3], m124 = this.rawData[7], m134 = this.rawData[11], m144 = this.rawData[15], m211 = lhs.rawData[0], m221 = lhs.rawData[4], m231 = lhs.rawData[8], m241 = lhs.rawData[12], m212 = lhs.rawData[1], m222 = lhs.rawData[5], m232 = lhs.rawData[9], m242 = lhs.rawData[13], m213 = lhs.rawData[2], m223 = lhs.rawData[6], m233 = lhs.rawData[10], m243 = lhs.rawData[14], m214 = lhs.rawData[3], m224 = lhs.rawData[7], m234 = lhs.rawData[11], m244 = lhs.rawData[15];
            this.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
            this.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
            this.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
            this.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
            this.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
            this.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
            this.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
            this.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
            this.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
            this.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
            this.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
            this.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
            this.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
            this.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
            this.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
            this.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
        };
        /**
        * @language zh_CN
        * 矩阵相加.
        * @param lhs 目标矩阵.
        * @returns 相加后的结果.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.add = function (lhs) {
            var m111 = this.rawData[0], m121 = this.rawData[4], m131 = this.rawData[8], m141 = this.rawData[12], m112 = this.rawData[1], m122 = this.rawData[5], m132 = this.rawData[9], m142 = this.rawData[13], m113 = this.rawData[2], m123 = this.rawData[6], m133 = this.rawData[10], m143 = this.rawData[14], m114 = this.rawData[3], m124 = this.rawData[7], m134 = this.rawData[11], m144 = this.rawData[15], m211 = lhs.rawData[0], m221 = lhs.rawData[4], m231 = lhs.rawData[8], m241 = lhs.rawData[12], m212 = lhs.rawData[1], m222 = lhs.rawData[5], m232 = lhs.rawData[9], m242 = lhs.rawData[13], m213 = lhs.rawData[2], m223 = lhs.rawData[6], m233 = lhs.rawData[10], m243 = lhs.rawData[14], m214 = lhs.rawData[3], m224 = lhs.rawData[7], m234 = lhs.rawData[11], m244 = lhs.rawData[15];
            this.rawData[0] = m111 + m211;
            this.rawData[1] = m112 + m212;
            this.rawData[2] = m113 + m213;
            this.rawData[3] = m114 + m214;
            this.rawData[4] = m121 + m221;
            this.rawData[5] = m122 + m222;
            this.rawData[6] = m123 + m223;
            this.rawData[7] = m124 + m224;
            this.rawData[8] = m131 + m231;
            this.rawData[9] = m132 + m232;
            this.rawData[10] = m133 + m233;
            this.rawData[11] = m134 + m234;
            this.rawData[12] = m141 + m241;
            this.rawData[13] = m142 + m242;
            this.rawData[14] = m143 + m243;
            this.rawData[15] = m144 + m244;
            return this;
        };
        /**
        * @language zh_CN
        * 矩阵相减.
        * @param lhs 目标矩阵.
        * @returns Matrix4_4 相加减的结果.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.sub = function (lhs) {
            var m111 = this.rawData[0], m121 = this.rawData[4], m131 = this.rawData[8], m141 = this.rawData[12], m112 = this.rawData[1], m122 = this.rawData[5], m132 = this.rawData[9], m142 = this.rawData[13], m113 = this.rawData[2], m123 = this.rawData[6], m133 = this.rawData[10], m143 = this.rawData[14], m114 = this.rawData[3], m124 = this.rawData[7], m134 = this.rawData[11], m144 = this.rawData[15], m211 = lhs.rawData[0], m221 = lhs.rawData[4], m231 = lhs.rawData[8], m241 = lhs.rawData[12], m212 = lhs.rawData[1], m222 = lhs.rawData[5], m232 = lhs.rawData[9], m242 = lhs.rawData[13], m213 = lhs.rawData[2], m223 = lhs.rawData[6], m233 = lhs.rawData[10], m243 = lhs.rawData[14], m214 = lhs.rawData[3], m224 = lhs.rawData[7], m234 = lhs.rawData[11], m244 = lhs.rawData[15];
            this.rawData[0] = m111 - m211;
            this.rawData[1] = m112 - m212;
            this.rawData[2] = m113 - m213;
            this.rawData[3] = m114 - m214;
            this.rawData[4] = m121 - m221;
            this.rawData[5] = m122 - m222;
            this.rawData[6] = m123 - m223;
            this.rawData[7] = m124 - m224;
            this.rawData[8] = m131 - m231;
            this.rawData[9] = m132 - m232;
            this.rawData[10] = m133 - m233;
            this.rawData[11] = m134 - m234;
            this.rawData[12] = m141 - m241;
            this.rawData[13] = m142 - m242;
            this.rawData[14] = m143 - m243;
            this.rawData[15] = m144 - m244;
            return this;
        };
        /**
        * @language zh_CN
        * 矩阵乘分量.
        * @param v .
        * @returns Matrix4_4 返回一个相乘后的结果 矩阵.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.mult = function (v) {
            this.rawData[0] *= v;
            this.rawData[1] *= v;
            this.rawData[2] *= v;
            this.rawData[3] *= v;
            this.rawData[4] *= v;
            this.rawData[5] *= v;
            this.rawData[6] *= v;
            this.rawData[7] *= v;
            this.rawData[8] *= v;
            this.rawData[9] *= v;
            this.rawData[10] *= v;
            this.rawData[11] *= v;
            this.rawData[12] *= v;
            this.rawData[13] *= v;
            this.rawData[14] *= v;
            this.rawData[15] *= v;
            return this;
        };
        /**
        * @language zh_CN
        * 创建一个欧拉旋转矩阵.
        * @param x 绕x轴旋转角度.
        * @param y 绕y轴旋转角度.
        * @param z 绕z轴旋转角度.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.rotation = function (x, y, z) {
            this.appendRotation(x, egret3d.Vector3D.X_AXIS);
            this.appendRotation(y, egret3d.Vector3D.Y_AXIS);
            this.appendRotation(z, egret3d.Vector3D.Z_AXIS);
        };
        /**
        * @language zh_CN
        * 当前矩阵乘 (按axis轴旋转degrees角度创建出来的矩阵)
        * @param degrees 旋转角度.
        * @param axis 绕axis轴旋转角度.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.appendRotation = function (degrees, axis) {
            var m = Matrix4_4.getAxisRotation(axis.x, axis.y, axis.z, degrees);
            ///this.append(m);
            var tmp = egret3d.MathUtil.CALCULATION_MATRIX;
            var s, c;
            var angle = degrees * egret3d.MathUtil.DEGREES_TO_RADIANS;
            s = Math.sin(angle);
            c = Math.cos(angle);
            if (axis.x == 1) {
                tmp.rawData[0] = 1.0;
                tmp.rawData[1] = 0.0;
                tmp.rawData[2] = 0.0;
                tmp.rawData[3] = 0.0;
                tmp.rawData[4] = 0.0;
                tmp.rawData[5] = c;
                tmp.rawData[6] = s;
                tmp.rawData[7] = 0.0;
                tmp.rawData[8] = 0.0;
                tmp.rawData[9] = -s;
                tmp.rawData[10] = c;
                tmp.rawData[7] = 0.0;
                tmp.rawData[12] = 0.0;
                tmp.rawData[13] = 0.0;
                tmp.rawData[14] = 0.0;
                tmp.rawData[15] = 1.0;
            }
            if (axis.y == 1) {
                tmp.rawData[0] = c;
                tmp.rawData[1] = 0.0;
                tmp.rawData[2] = -s;
                tmp.rawData[3] = 0.0;
                tmp.rawData[4] = 0.0;
                tmp.rawData[5] = 1.0;
                tmp.rawData[6] = 0.0;
                tmp.rawData[7] = 0.0;
                tmp.rawData[8] = s;
                tmp.rawData[9] = 0.0;
                tmp.rawData[10] = c;
                tmp.rawData[11] = 0.0;
                tmp.rawData[12] = 0.0;
                tmp.rawData[13] = 0.0;
                tmp.rawData[14] = 0.0;
                tmp.rawData[15] = 1.0;
            }
            if (axis.z == 1) {
                tmp.rawData[0] = c;
                tmp.rawData[1] = s;
                tmp.rawData[2] = 0.0;
                tmp.rawData[3] = 0.0;
                tmp.rawData[4] = -s;
                tmp.rawData[5] = c;
                tmp.rawData[6] = 0.0;
                tmp.rawData[7] = 0.0;
                tmp.rawData[8] = 0.0;
                tmp.rawData[9] = 0.0;
                tmp.rawData[10] = 1.0;
                tmp.rawData[11] = 0.0;
                tmp.rawData[12] = 0.0;
                tmp.rawData[13] = 0.0;
                tmp.rawData[14] = 0.0;
                tmp.rawData[15] = 1.0;
            }
            this.append(tmp);
        };
        /**
        * @language zh_CN
        * 生成一个缩放矩阵
        * @param xScale x轴缩放
        * @param yScale y轴缩放
        * @param zScale z轴缩放
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.appendScale = function (xScale, yScale, zScale) {
            this.rawData[0] = xScale;
            this.rawData[1] = 0.0;
            this.rawData[2] = 0.0;
            this.rawData[4] = 0.0;
            this.rawData[5] = yScale;
            this.rawData[6] = 0.0;
            this.rawData[8] = 0.0;
            this.rawData[9] = 0.0;
            this.rawData[10] = zScale;
        };
        /**
        * @language zh_CN
        * 加上一个平移矩阵
        * @param x x轴坐标
        * @param y y轴坐标
        * @param z z轴坐标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.appendTranslation = function (x, y, z) {
            this.rawData[12] += x;
            this.rawData[13] += y;
            this.rawData[14] += z;
        };
        /**
        * @language zh_CN
        * 返回一个当前矩阵的克隆矩阵
        * @returns Matrix4_4 克隆后的矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.clone = function () {
            var ret = new Matrix4_4();
            ret.copyFrom(this);
            return ret;
        };
        /**
        * @language zh_CN
        * 给当前矩阵其中一行赋值
        * @param column 拷贝的行
        * @param vector3D 拷贝的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyColumnFrom = function (column, vector3D) {
            switch (column) {
                case 0:
                    this.rawData[0] = vector3D.x;
                    this.rawData[1] = vector3D.y;
                    this.rawData[2] = vector3D.z;
                    this.rawData[3] = vector3D.w;
                    break;
                case 1:
                    this.rawData[4] = vector3D.x;
                    this.rawData[5] = vector3D.y;
                    this.rawData[6] = vector3D.z;
                    this.rawData[7] = vector3D.w;
                    break;
                case 2:
                    this.rawData[8] = vector3D.x;
                    this.rawData[9] = vector3D.y;
                    this.rawData[10] = vector3D.z;
                    this.rawData[11] = vector3D.w;
                    break;
                case 3:
                    this.rawData[12] = vector3D.x;
                    this.rawData[13] = vector3D.y;
                    this.rawData[14] = vector3D.z;
                    this.rawData[15] = vector3D.w;
                    break;
                default:
            }
        };
        /**
        * @language zh_CN
        * 拷贝矩阵中的其中一行 把值存在vector3D.
        * @param column 拷贝的行
        * @param vector3D 拷贝存值目标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyRowTo = function (column, vector3D) {
            switch (column) {
                case 0:
                    vector3D.x = this.rawData[0];
                    vector3D.y = this.rawData[1];
                    vector3D.z = this.rawData[2];
                    vector3D.w = this.rawData[3];
                    break;
                case 1:
                    vector3D.x = this.rawData[4];
                    vector3D.y = this.rawData[5];
                    vector3D.z = this.rawData[6];
                    vector3D.w = this.rawData[7];
                    break;
                case 2:
                    vector3D.x = this.rawData[8];
                    vector3D.y = this.rawData[9];
                    vector3D.z = this.rawData[10];
                    vector3D.w = this.rawData[11];
                    break;
                case 3:
                    vector3D.x = this.rawData[12];
                    vector3D.y = this.rawData[13];
                    vector3D.z = this.rawData[14];
                    vector3D.w = this.rawData[15];
                    break;
                default:
            }
        };
        /**
        * @language zh_CN
        * 把一个矩阵的值赋给当前矩阵.
        * @param sourceMatrix3D 源矩阵.
        * @returns 返回当前矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyFrom = function (sourceMatrix3D) {
            var len = sourceMatrix3D.rawData.length;
            for (var c = 0; c < len; c++)
                this.rawData[c] = sourceMatrix3D.rawData[c];
            return this;
        };
        /**
        * @language zh_CN
        * 把一个 float 数组赋值给当前矩阵.
        * @param vector 源数组.
        * @param index 从数组的index 开始copy.
        * @param transpose 是否转置当前矩阵.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyRawDataFrom = function (vector, index, transpose) {
            if (index === void 0) { index = 0; }
            if (transpose === void 0) { transpose = false; }
            if (transpose)
                this.transpose();
            var len = vector.length - index;
            for (var c = 0; c < len; c++)
                this.rawData[c] = vector[c + index];
            if (transpose)
                this.transpose();
        };
        /**
        * @language zh_CN
        * 把当前矩阵的值拷贝给一个 float 数组.
        * @param vector 目标数组.
        * @param index 从数组的index 开始copy.
        * @param transpose 是否转置当前矩阵.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyRawDataTo = function (vector, index, transpose) {
            if (index === void 0) { index = 0; }
            if (transpose === void 0) { transpose = false; }
            if (transpose)
                this.transpose();
            var len = this.rawData.length;
            for (var c = 0; c < len; c++)
                vector[c + index] = this.rawData[c];
            if (transpose)
                this.transpose();
        };
        /**
        * @language zh_CN
        * 给当前矩阵的某一列 赋值
        * @param col 列
        * @param vector3D 值来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyColFrom = function (col, vector3D) {
            switch (col) {
                case 0:
                    this.rawData[0] = vector3D.x;
                    this.rawData[4] = vector3D.y;
                    this.rawData[8] = vector3D.z;
                    this.rawData[12] = vector3D.w;
                    break;
                case 1:
                    this.rawData[1] = vector3D.x;
                    this.rawData[5] = vector3D.y;
                    this.rawData[9] = vector3D.z;
                    this.rawData[13] = vector3D.w;
                    break;
                case 2:
                    this.rawData[2] = vector3D.x;
                    this.rawData[6] = vector3D.y;
                    this.rawData[10] = vector3D.z;
                    this.rawData[14] = vector3D.w;
                    break;
                case 3:
                    this.rawData[3] = vector3D.x;
                    this.rawData[7] = vector3D.y;
                    this.rawData[11] = vector3D.z;
                    this.rawData[15] = vector3D.w;
                    break;
                default:
                    new Error("no more raw!");
            }
        };
        /**
        * @language zh_CN
        * 拷贝当前矩阵的某一列
        * @param col 列
        * @param vector3D 拷贝目标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyColTo = function (col, vector3D) {
            switch (col) {
                case 0:
                    vector3D.x = this.rawData[0];
                    vector3D.y = this.rawData[4];
                    vector3D.z = this.rawData[8];
                    vector3D.w = this.rawData[12];
                    break;
                case 1:
                    vector3D.x = this.rawData[1];
                    vector3D.y = this.rawData[5];
                    vector3D.z = this.rawData[9];
                    vector3D.w = this.rawData[13];
                    break;
                case 2:
                    vector3D.x = this.rawData[2];
                    vector3D.y = this.rawData[6];
                    vector3D.z = this.rawData[10];
                    vector3D.w = this.rawData[14];
                    break;
                case 3:
                    vector3D.x = this.rawData[3];
                    vector3D.y = this.rawData[7];
                    vector3D.z = this.rawData[11];
                    vector3D.w = this.rawData[15];
                    break;
                default:
                    new Error("no more raw!");
            }
        };
        /**
        * @language zh_CN
        * 拷贝当前矩阵
        * @param dest 拷贝目标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyToMatrix3D = function (dest) {
            dest.rawData = this.rawData.slice(0);
        };
        /**
        * @language zh_CN
        * 分解当前矩阵
        * @param orientationStyle 分解类型
        * @returns Vector3D[3] pos rot scale
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.decompose = function (orientationStyle) {
            if (orientationStyle === void 0) { orientationStyle = "eulerAngles"; }
            var q = egret3d.MathUtil.CALCULATION_QUATERNION;
            var vec = [];
            var m = this.clone();
            var mr = m.rawData;
            var pos = new egret3d.Vector3D(mr[12], mr[13], mr[14]);
            mr[12] = 0;
            mr[13] = 0;
            mr[14] = 0;
            var scale = new egret3d.Vector3D();
            scale.x = Math.sqrt(mr[0] * mr[0] + mr[1] * mr[1] + mr[2] * mr[2]);
            scale.y = Math.sqrt(mr[4] * mr[4] + mr[5] * mr[5] + mr[6] * mr[6]);
            scale.z = Math.sqrt(mr[8] * mr[8] + mr[9] * mr[9] + mr[10] * mr[10]);
            if (mr[0] * (mr[5] * mr[10] - mr[6] * mr[9]) - mr[1] * (mr[4] * mr[10] - mr[6] * mr[8]) + mr[2] * (mr[4] * mr[9] - mr[5] * mr[8]) < 0)
                scale.z = -scale.z;
            mr[0] /= scale.x;
            mr[1] /= scale.x;
            mr[2] /= scale.x;
            mr[4] /= scale.y;
            mr[5] /= scale.y;
            mr[6] /= scale.y;
            mr[8] /= scale.z;
            mr[9] /= scale.z;
            mr[10] /= scale.z;
            var rot = new egret3d.Vector3D();
            switch (orientationStyle) {
                case egret3d.Orientation3D.AXIS_ANGLE:
                    rot.w = Math.acos((mr[0] + mr[5] + mr[10] - 1) / 2);
                    var len = Math.sqrt((mr[6] - mr[9]) * (mr[6] - mr[9]) + (mr[8] - mr[2]) * (mr[8] - mr[2]) + (mr[1] - mr[4]) * (mr[1] - mr[4]));
                    rot.x = (mr[6] - mr[9]) / len;
                    rot.y = (mr[8] - mr[2]) / len;
                    rot.z = (mr[1] - mr[4]) / len;
                    break;
                case egret3d.Orientation3D.QUATERNION:
                    var tr = mr[0] + mr[5] + mr[10];
                    if (tr > 0) {
                        rot.w = Math.sqrt(1 + tr) / 2;
                        rot.x = (mr[6] - mr[9]) / (4 * rot.w);
                        rot.y = (mr[8] - mr[2]) / (4 * rot.w);
                        rot.z = (mr[1] - mr[4]) / (4 * rot.w);
                    }
                    else if ((mr[0] > mr[5]) && (mr[0] > mr[10])) {
                        rot.x = Math.sqrt(1 + mr[0] - mr[5] - mr[10]) / 2;
                        rot.w = (mr[6] - mr[9]) / (4 * rot.x);
                        rot.y = (mr[1] + mr[4]) / (4 * rot.x);
                        rot.z = (mr[8] + mr[2]) / (4 * rot.x);
                    }
                    else if (mr[5] > mr[10]) {
                        rot.y = Math.sqrt(1 + mr[5] - mr[0] - mr[10]) / 2;
                        rot.x = (mr[1] + mr[4]) / (4 * rot.y);
                        rot.w = (mr[8] - mr[2]) / (4 * rot.y);
                        rot.z = (mr[6] + mr[9]) / (4 * rot.y);
                    }
                    else {
                        rot.z = Math.sqrt(1 + mr[10] - mr[0] - mr[5]) / 2;
                        rot.x = (mr[8] + mr[2]) / (4 * rot.z);
                        rot.y = (mr[6] + mr[9]) / (4 * rot.z);
                        rot.w = (mr[1] - mr[4]) / (4 * rot.z);
                    }
                    break;
                case egret3d.Orientation3D.EULER_ANGLES:
                    var tr = mr[0] + mr[5] + mr[10];
                    if (tr > 0) {
                        q.w = Math.sqrt(1 + tr) / 2;
                        q.x = (mr[6] - mr[9]) / (4 * q.w);
                        q.y = (mr[8] - mr[2]) / (4 * q.w);
                        q.z = (mr[1] - mr[4]) / (4 * q.w);
                    }
                    else if ((mr[0] > mr[5]) && (mr[0] > mr[10])) {
                        q.x = Math.sqrt(1 + mr[0] - mr[5] - mr[10]) / 2;
                        q.w = (mr[6] - mr[9]) / (4 * q.x);
                        q.y = (mr[1] + mr[4]) / (4 * q.x);
                        q.z = (mr[8] + mr[2]) / (4 * q.x);
                    }
                    else if (mr[5] > mr[10]) {
                        rot.y = Math.sqrt(1 + mr[5] - mr[0] - mr[10]) / 2;
                        q.x = (mr[1] + mr[4]) / (4 * q.y);
                        q.w = (mr[8] - mr[2]) / (4 * q.y);
                        q.z = (mr[6] + mr[9]) / (4 * q.y);
                    }
                    else {
                        q.z = Math.sqrt(1 + mr[10] - mr[0] - mr[5]) / 2;
                        q.x = (mr[8] + mr[2]) / (4 * q.z);
                        q.y = (mr[6] + mr[9]) / (4 * q.z);
                        q.w = (mr[1] - mr[4]) / (4 * q.z);
                    }
                    q.toEulerAngles(rot);
                    break;
            }
            vec.push(pos);
            vec.push(rot);
            vec.push(scale);
            return vec;
        };
        /**
        * @language zh_CN
        * 当前矩阵变换一个向量
        * @param v 要变换的向量
        * @param target 默认为 null 如果当前参数为null那么就会new一个新的Vector3D返回
        * @returns Vector3D 变换后的向量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.deltaTransformVector = function (v, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new egret3d.Vector3D();
            }
            var x = v.x;
            var y = v.y;
            var z = v.z;
            target.x = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8];
            target.y = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9];
            target.z = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10];
            target.w = x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11];
            return target;
        };
        /**
        * @language zh_CN
        * 单位化当前矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.identity = function () {
            this.rawData[1] = 0;
            this.rawData[2] = 0;
            this.rawData[3] = 0;
            this.rawData[4] = 0;
            this.rawData[6] = 0;
            this.rawData[7] = 0;
            this.rawData[8] = 0;
            this.rawData[9] = 0;
            this.rawData[11] = 0;
            this.rawData[12] = 0;
            this.rawData[13] = 0;
            this.rawData[14] = 0;
            this.rawData[0] = 1;
            this.rawData[5] = 1;
            this.rawData[10] = 1;
            this.rawData[15] = 1;
        };
        /**
        * @language zh_CN
        * 填充当前矩阵
        * @param value 填充的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.fill = function (value) {
            this.rawData[1] = value;
            this.rawData[2] = value;
            this.rawData[3] = value;
            this.rawData[4] = value;
            this.rawData[6] = value;
            this.rawData[7] = value;
            this.rawData[8] = value;
            this.rawData[9] = value;
            this.rawData[11] = value;
            this.rawData[12] = value;
            this.rawData[13] = value;
            this.rawData[14] = value;
            this.rawData[0] = value;
            this.rawData[5] = value;
            this.rawData[10] = value;
            this.rawData[15] = value;
        };
        /**
        * @language zh_CN
        * 当前矩阵求逆
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.invers33 = function () {
            /// Invert a 3x3 using cofactors.  This is about 8 times faster than
            /// the Numerical Recipes code which uses Gaussian elimination.
            var rkInverse_00 = this.rawData[5] * this.rawData[10] - this.rawData[9] * this.rawData[6];
            var rkInverse_01 = this.rawData[8] * this.rawData[6] - this.rawData[4] * this.rawData[10];
            var rkInverse_02 = this.rawData[4] * this.rawData[9] - this.rawData[8] * this.rawData[5];
            var rkInverse_10 = this.rawData[9] * this.rawData[2] - this.rawData[1] * this.rawData[10];
            var rkInverse_11 = this.rawData[0] * this.rawData[10] - this.rawData[8] * this.rawData[2];
            var rkInverse_12 = this.rawData[8] * this.rawData[1] - this.rawData[0] * this.rawData[9];
            var rkInverse_20 = this.rawData[1] * this.rawData[6] - this.rawData[5] * this.rawData[2];
            var rkInverse_21 = this.rawData[4] * this.rawData[2] - this.rawData[0] * this.rawData[6];
            var rkInverse_22 = this.rawData[0] * this.rawData[5] - this.rawData[4] * this.rawData[1];
            var fDet = this.rawData[0] * rkInverse_00 +
                this.rawData[4] * rkInverse_10 +
                this.rawData[8] * rkInverse_20;
            if (Math.abs(fDet) > 0.00000000001) {
                var fInvDet = 1.0 / fDet;
                this.rawData[0] = fInvDet * rkInverse_00;
                this.rawData[4] = fInvDet * rkInverse_01;
                this.rawData[8] = fInvDet * rkInverse_02;
                this.rawData[1] = fInvDet * rkInverse_10;
                this.rawData[5] = fInvDet * rkInverse_11;
                this.rawData[9] = fInvDet * rkInverse_12;
                this.rawData[2] = fInvDet * rkInverse_20;
                this.rawData[6] = fInvDet * rkInverse_21;
                this.rawData[10] = fInvDet * rkInverse_22;
            }
        };
        /**
        * @language zh_CN
        * 当前矩阵求逆
        * @returns boolean 是否能求逆
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.invert = function () {
            var d = this.determinant;
            var invertable = Math.abs(d) > 0.00000000001;
            if (invertable) {
                d = 1 / d;
                var m11 = this.rawData[0];
                var m21 = this.rawData[4];
                var m31 = this.rawData[8];
                var m41 = this.rawData[12];
                var m12 = this.rawData[1];
                var m22 = this.rawData[5];
                var m32 = this.rawData[9];
                var m42 = this.rawData[13];
                var m13 = this.rawData[2];
                var m23 = this.rawData[6];
                var m33 = this.rawData[10];
                var m43 = this.rawData[14];
                var m14 = this.rawData[3];
                var m24 = this.rawData[7];
                var m34 = this.rawData[11];
                var m44 = this.rawData[15];
                this.rawData[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
                this.rawData[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
                this.rawData[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
                this.rawData[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
                this.rawData[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
                this.rawData[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
                this.rawData[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
                this.rawData[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
                this.rawData[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
                this.rawData[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
                this.rawData[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
                this.rawData[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
                this.rawData[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
                this.rawData[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
                this.rawData[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
                this.rawData[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
            }
            return invertable;
        };
        /**
        * @language zh_CN
        * 生成一个变换矩阵
        * @param pos  位移
        * @param scale 缩放
        * @param rot 旋转
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.makeTransform = function (pos, scale, rot) {
            rot.toMatrix3D(egret3d.MathUtil.CALCULATION_MATRIX);
            this.rawData[0] = egret3d.MathUtil.CALCULATION_MATRIX.rawData[0] * scale.x;
            this.rawData[1] = egret3d.MathUtil.CALCULATION_MATRIX.rawData[1] * scale.y;
            this.rawData[2] = egret3d.MathUtil.CALCULATION_MATRIX.rawData[2] * scale.z;
            this.rawData[3] = 0;
            this.rawData[4] = egret3d.MathUtil.CALCULATION_MATRIX.rawData[4] * scale.x;
            this.rawData[5] = egret3d.MathUtil.CALCULATION_MATRIX.rawData[5] * scale.y;
            this.rawData[6] = egret3d.MathUtil.CALCULATION_MATRIX.rawData[6] * scale.z;
            this.rawData[7] = 0;
            this.rawData[8] = egret3d.MathUtil.CALCULATION_MATRIX.rawData[8] * scale.x;
            this.rawData[9] = egret3d.MathUtil.CALCULATION_MATRIX.rawData[9] * scale.y;
            this.rawData[10] = egret3d.MathUtil.CALCULATION_MATRIX.rawData[10] * scale.z;
            this.rawData[11] = 0;
            this.rawData[12] = pos.x;
            this.rawData[13] = pos.y;
            this.rawData[14] = pos.z;
            this.rawData[15] = 1;
        };
        /**
        * @language zh_CN
        * 生成一个变换矩阵
        * @param components Vector3D[3] 位移 旋转 缩放
        * @returns boolean 生成是否成功
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.recompose = function (components) {
            egret3d.MathUtil.CALCULATION_QUATERNION.fromEulerAngles(components[1].x, components[1].y, components[1].z);
            this.makeTransform(components[0], components[2], egret3d.MathUtil.CALCULATION_QUATERNION);
            return true;
        };
        /**
        * @language zh_CN
        * 用当前矩阵变换一个3D向量
        * @param v 变换的向量
        * @param target 如果当前参数为null那么就会new一个新的Vector3D返回
        * @returns Vector3D 变换后的向量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.transformVector = function (v, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new egret3d.Vector3D();
            }
            var x = v.x;
            var y = v.y;
            var z = v.z;
            target.x = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12];
            target.y = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13];
            target.z = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14];
            target.w = x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11] + this.rawData[15];
            return target;
        };
        /**
        * @language zh_CN
        * 用当前矩阵变换一个3D向量
        * @param v 变换的向量
        * @param target 如果当前参数为null那么就会new一个新的Vector3D返回
        * @returns Vector3D 变换后的向量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.transformVector4 = function (v, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new egret3d.Vector3D();
            }
            var x = v.x;
            var y = v.y;
            var z = v.z;
            var w = v.w;
            target.x = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + w * this.rawData[12];
            target.y = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + w * this.rawData[13];
            target.z = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + w * this.rawData[14];
            target.w = x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11] + w * this.rawData[15];
            return target;
        };
        /**
        * @language zh_CN
        * 用当前矩阵变换一个3D向量
        * @param v 变换的向量
        * @param target 如果当前参数为null那么就会new一个新的Vector3D返回
        * @returns Vector3D 变换后的向量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.mat3TransformVector = function (v, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new egret3d.Vector3D();
            }
            var x = v.x;
            var y = v.y;
            var z = v.z;
            target.x = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8];
            target.y = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9];
            target.z = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10];
            return target;
        };
        /**
        * @language zh_CN
        * 用当前矩阵变换一个3D平面
        * @param plane 变换的平面
        * @returns Plane3D 变换后的平面
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.transformPlane = function (plane) {
            var mat = new Matrix4_4();
            mat.copyFrom(this);
            mat.invert();
            mat.transpose();
            var v = new egret3d.Vector3D(plane.a, plane.b, plane.c, plane.d);
            v.copyFrom(mat.transformVector(v));
            var p = new egret3d.Plane3D();
            p.a = v.x;
            p.b = v.y;
            p.c = v.z;
            p.d = v.w / Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
            return p;
        };
        /**
        * @language zh_CN
        * 当前矩阵转置
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.transpose = function () {
            for (var i = 0; i < this.oRawData.length; i++) {
                this.oRawData[i] = this.rawData[i];
            }
            this.rawData[1] = this.oRawData[4];
            this.rawData[2] = this.oRawData[8];
            this.rawData[3] = this.oRawData[12];
            this.rawData[4] = this.oRawData[1];
            this.rawData[6] = this.oRawData[9];
            this.rawData[7] = this.oRawData[13];
            this.rawData[8] = this.oRawData[2];
            this.rawData[9] = this.oRawData[6];
            this.rawData[11] = this.oRawData[14];
            this.rawData[12] = this.oRawData[3];
            this.rawData[13] = this.oRawData[7];
            this.rawData[14] = this.oRawData[11];
        };
        /**
        * @language zh_CN
        * 生成一个(以x,y,z为中心轴旋转degrees角度)的矩阵
        * @param x 中心轴的x
        * @param y 中心轴的y
        * @param z 中心轴的z
        * @param degrees 旋转角度
        * @returns Matrix4_4 矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.getAxisRotation = function (x, y, z, degrees) {
            var m = new Matrix4_4();
            var rad = degrees * (Math.PI / 180);
            var c = Math.cos(rad);
            var s = Math.sin(rad);
            var t = 1 - c;
            var tmp1, tmp2;
            m.rawData[0] = c + x * x * t;
            m.rawData[5] = c + y * y * t;
            m.rawData[10] = c + z * z * t;
            tmp1 = x * y * t;
            tmp2 = z * s;
            m.rawData[1] = tmp1 + tmp2;
            m.rawData[4] = tmp1 - tmp2;
            tmp1 = x * z * t;
            tmp2 = y * s;
            m.rawData[8] = tmp1 + tmp2;
            m.rawData[2] = tmp1 - tmp2;
            tmp1 = y * z * t;
            tmp2 = x * s;
            m.rawData[9] = tmp1 - tmp2;
            m.rawData[6] = tmp1 + tmp2;
            return m;
        };
        Object.defineProperty(Matrix4_4.prototype, "determinant", {
            /**
            * @language zh_CN
            * 返回矩阵行列式
            *
            * @returns number 行列式值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return ((this.rawData[0] * this.rawData[5] - this.rawData[4] * this.rawData[1]) * (this.rawData[10] * this.rawData[15] - this.rawData[14] * this.rawData[11]) - (this.rawData[0] * this.rawData[9] - this.rawData[8] * this.rawData[1]) * (this.rawData[6] * this.rawData[15] - this.rawData[14] * this.rawData[7]) + (this.rawData[0] * this.rawData[13] - this.rawData[12] * this.rawData[1]) * (this.rawData[6] * this.rawData[11] - this.rawData[10] * this.rawData[7]) + (this.rawData[4] * this.rawData[9] - this.rawData[8] * this.rawData[5]) * (this.rawData[2] * this.rawData[15] - this.rawData[14] * this.rawData[3]) - (this.rawData[4] * this.rawData[13] - this.rawData[12] * this.rawData[5]) * (this.rawData[2] * this.rawData[11] - this.rawData[10] * this.rawData[3]) + (this.rawData[8] * this.rawData[13] - this.rawData[12] * this.rawData[9]) * (this.rawData[2] * this.rawData[7] - this.rawData[6] * this.rawData[3]));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4_4.prototype, "position", {
            /**
            * @language zh_CN
            * 返回矩阵位移
            *
            * @returns Vector3D 位移
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return new egret3d.Vector3D(this.rawData[12], this.rawData[13], this.rawData[14]);
            },
            /**
            * @language zh_CN
            * 设置矩阵位移
            *
            * @param value 位移
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.rawData[12] = value.x;
                this.rawData[13] = value.y;
                this.rawData[14] = value.z;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4_4.prototype, "scale", {
            /**
            * @language zh_CN
            * 返回矩阵缩放
            *
            * @returns Vector3D 缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return new egret3d.Vector3D(this.rawData[0], this.rawData[5], this.rawData[10]);
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 以字符串返回矩阵的值
        *
        * @returns string 字符
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.toString = function () {
            return "matrix3d(" + Math.round(this.rawData[0] * 1000) / 1000 + "," + Math.round(this.rawData[1] * 1000) / 1000 + "," + Math.round(this.rawData[2] * 1000) / 1000 + "," + Math.round(this.rawData[3] * 1000) / 1000 + "," + Math.round(this.rawData[4] * 1000) / 1000 + "," + Math.round(this.rawData[5] * 1000) / 1000 + "," + Math.round(this.rawData[6] * 1000) / 1000 + "," + Math.round(this.rawData[7] * 1000) / 1000 + "," + Math.round(this.rawData[8] * 1000) / 1000 + "," + Math.round(this.rawData[9] * 1000) / 1000 + "," + Math.round(this.rawData[10] * 1000) / 1000 + "," + Math.round(this.rawData[11] * 1000) / 1000 + "," + Math.round(this.rawData[12] * 1000) / 1000 + "," + Math.round(this.rawData[13] * 1000) / 1000 + "," + Math.round(this.rawData[14] * 1000) / 1000 + "," + Math.round(this.rawData[15] * 1000) / 1000 + ")";
        };
        /**
        * @language zh_CN
        * 求两个矩阵之间的差值
        * @param m0 矩阵0
        * @param m1 矩阵1
        * @param t 时间差 0.0 - 1.0
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.lerp = function (m0, m1, t) {
            ///t(m1 - m0) + m0
            this.copyFrom(m1).sub(m0).mult(t).add(m0);
        };
        return Matrix4_4;
    }());
    egret3d.Matrix4_4 = Matrix4_4;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.EyesMatrix
     * @classdesc
     * 可使用 EyesMatrix 类 对左，右眼睛矩阵的操作
     * 它会在摄像机的位置做一个左 右偏移 模拟出眼睛的矩阵
     * @version Egret 3.0
     * @platform Web,Native
     */
    var EyesMatrix = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function EyesMatrix() {
            /**
            * @language zh_CN
            * @private
            */
            this.eyeSpace = 1;
            this.eyePosition = new egret3d.Vector3D();
            this.eyeRotation = new egret3d.Vector3D(0, 1, 0);
            this.eyeFocalLength = 180;
            this.leftPos = new egret3d.Vector3D();
            this.rightPos = new egret3d.Vector3D();
            this.targetPos = new egret3d.Vector3D(0.0, 0.0, this.eyeFocalLength);
            this.lookAtPos = new egret3d.Vector3D();
            this.quaternion = new egret3d.Quaternion();
            this.dir = new egret3d.Vector3D();
            this.leftEyeMatrix = new egret3d.Matrix4_4();
            this.rightEyeMatrix = new egret3d.Matrix4_4();
        }
        /**
        * @private
        * @language zh_CN
        * 数据更新
        * @param matrix 当前相机矩阵
        */
        EyesMatrix.prototype.update = function (camera) {
            camera.globalOrientation.transformVector(egret3d.Vector3D.X_AXIS, this.dir);
            this.dir.normalize();
            this.leftEyeMatrix.copyFrom(camera.modelMatrix);
            this.rightEyeMatrix.copyFrom(camera.modelMatrix);
            var space = this.eyeSpace * 0.5;
            this.leftEyeMatrix.appendTranslation(-this.dir.x * space, -this.dir.y * space, -this.dir.z * space);
            this.rightEyeMatrix.appendTranslation(this.dir.x * space, this.dir.y * space, this.dir.z * space);
        };
        return EyesMatrix;
    }());
    egret3d.EyesMatrix = EyesMatrix;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.PlaneClassification
     * @classdesc
     * 定义 PlaneClassification 常量
     * @version Egret 3.0
     * @platform Web,Native
     */
    var PlaneClassification = (function () {
        function PlaneClassification() {
        }
        /**
        * @language zh_CN
        * 背面
        * @version Egret 3.0
        * @platform Web,Native
        */
        PlaneClassification.BACK = 0;
        /**
        * @language zh_CN
        * 正面
        * @version Egret 3.0
        * @platform Web,Native
        */
        PlaneClassification.FRONT = 1;
        /**
        * @language zh_CN
        * 在法线朝上的一面
        * @version Egret 3.0
        * @platform Web,Native
        */
        PlaneClassification.IN = 0;
        /**
        * @language zh_CN
        * 在法线朝下的一面
        * @version Egret 3.0
        * @platform Web,Native
        */
        PlaneClassification.OUT = 1;
        /**
        * @language zh_CN
        * 相交
        * @version Egret 3.0
        * @platform Web,Native
        */
        PlaneClassification.INTERSECT = 2;
        return PlaneClassification;
    }());
    egret3d.PlaneClassification = PlaneClassification;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.MathUtil
    * @classdesc
    * 可使用 MathUtil 类 进行3d矩阵的计算
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MathUtil = (function () {
        function MathUtil() {
        }
        /**
        * @language zh_CN
        * 四元数转矩阵
        * @param quarternion 源四元数
        * @param m 目标矩阵 默认为null 如果为null将会new 一个Matrix4_4
        * @returns 返回转出矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.quaternion2matrix = function (quarternion, m) {
            if (m === void 0) { m = null; }
            var x = quarternion.x;
            var y = quarternion.y;
            var z = quarternion.z;
            var w = quarternion.w;
            var xx = x * x;
            var xy = x * y;
            var xz = x * z;
            var xw = x * w;
            var yy = y * y;
            var yz = y * z;
            var yw = y * w;
            var zz = z * z;
            var zw = z * w;
            var raw = MathUtil.RAW_DATA_CONTAINER;
            raw[0] = 1 - 2 * (yy + zz);
            raw[1] = 2 * (xy + zw);
            raw[2] = 2 * (xz - yw);
            raw[4] = 2 * (xy - zw);
            raw[5] = 1 - 2 * (xx + zz);
            raw[6] = 2 * (yz + xw);
            raw[8] = 2 * (xz + yw);
            raw[9] = 2 * (yz - xw);
            raw[10] = 1 - 2 * (xx + yy);
            raw[3] = raw[7] = raw[11] = raw[12] = raw[13] = raw[14] = 0;
            raw[15] = 1;
            if (m) {
                m.copyRawDataFrom(raw);
                return m;
            }
            else
                return new egret3d.Matrix4_4(new Float32Array(raw));
        };
        /**
        * @language zh_CN
        * 得到矩阵朝前的方向
        * @param m 源矩阵
        * @param v 返回的方向 可为null 如果为null将会new 一个Vector3D
        * @returns Vector3D 返回方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.getForward = function (m, v) {
            if (v === void 0) { v = null; }
            if (v === null) {
                v = new egret3d.Vector3D(0.0, 0.0, 0.0);
            }
            m.copyRowTo(2, v);
            v.normalize();
            return v;
        };
        /**
        * @language zh_CN
        * 得到矩阵朝上的方向
        * @param m 源矩阵
        * @param v 返回的方向 可为null 如果为null将会new 一个Vector3D
        * @returns Vector3D 返回方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.getUp = function (m, v) {
            //v ||= new Vector3D(0.0, 0.0, 0.0);
            if (v === void 0) { v = null; }
            if (v === null) {
                v = new egret3d.Vector3D(0.0, 0.0, 0.0);
            }
            m.copyRowTo(1, v);
            v.normalize();
            return v;
        };
        /**
        * @language zh_CN
        * 得到矩阵朝右的方向
        * @param m 源矩阵
        * @param v 返回的方向 可为null 如果为null将会new 一个Vector3D
        * @returns Vector3D 返回方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.getRight = function (m, v) {
            if (v === void 0) { v = null; }
            //v ||= new Vector3D(0.0, 0.0, 0.0);
            if (v === null) {
                v = new egret3d.Vector3D(0.0, 0.0, 0.0);
            }
            m.copyRowTo(0, v);
            v.normalize();
            return v;
        };
        /**
        * @language zh_CN
        * 比较两个矩阵是否相同
        * @param m1 矩阵1
        * @param m2 矩阵2
        * @returns boolean 相同返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.compare = function (m1, m2) {
            var r1 = MathUtil.RAW_DATA_CONTAINER;
            var r2 = m2.rawData;
            m1.copyRawDataTo(r1);
            for (var i = 0; i < 16; ++i) {
                if (r1[i] != r2[i])
                    return false;
            }
            return true;
        };
        /**
        * @language zh_CN
        * 得到平面的反射矩阵
        * @param plane 反射的面
        * @param target 计算返回的矩阵 可为null 如果为null将会new 一个Matrix4_4
        * @returns Matrix4_4 返回计算的结果
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.reflection = function (plane, target) {
            if (target === void 0) { target = null; }
            if (target === null)
                target = new egret3d.Matrix4_4();
            var a = plane.a, b = plane.b, c = plane.c, d = plane.d;
            var rawData = MathUtil.RAW_DATA_CONTAINER;
            var ab2 = -2 * a * b;
            var ac2 = -2 * a * c;
            var bc2 = -2 * b * c;
            // reflection matrix
            rawData[0] = 1 - 2 * a * a;
            rawData[4] = ab2;
            rawData[8] = ac2;
            rawData[12] = -2 * a * d;
            rawData[1] = ab2;
            rawData[5] = 1 - 2 * b * b;
            rawData[9] = bc2;
            rawData[13] = -2 * b * d;
            rawData[2] = ac2;
            rawData[6] = bc2;
            rawData[10] = 1 - 2 * c * c;
            rawData[14] = -2 * c * d;
            rawData[3] = 0;
            rawData[7] = 0;
            rawData[11] = 0;
            rawData[15] = 1;
            target.copyRawDataFrom(rawData);
            return target;
        };
        /**
        * @language zh_CN
        * 得到矩阵的平移
        * @param transform 计算的矩阵
        * @param result 计算返回平移坐标 可为null 如果为null将会new 一个Vector3D
        * @returns Vector3D 返回平移坐标
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.getTranslation = function (transform, result) {
            if (result === void 0) { result = null; }
            if (!result)
                result = new egret3d.Vector3D();
            transform.copyRowTo(3, result);
            return result;
        };
        /**
        * @language zh_CN
        * 把一个值固定在一个范围之内
        * @param value 当前判定的值
        * @param min_inclusive 最小取值
        * @param max_inclusive 最大取值
        * @returns number 计算后的结果
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.clampf = function (value, min_inclusive, max_inclusive) {
            if (min_inclusive > max_inclusive) {
                var temp = min_inclusive;
                min_inclusive = max_inclusive;
                max_inclusive = temp;
            }
            return value < min_inclusive ? min_inclusive : (value < max_inclusive ? value : max_inclusive);
        };
        /**
        * @private
        */
        MathUtil.ScreenToPosition = function (value, offset, max) {
            return (value + offset * 0.5) / max * 2 - 1;
        };
        /**
        * @private
        */
        MathUtil.PositionToScreen = function (value, offset, max) {
            return (value + 1) * 0.5 * max - offset * 0.5;
        };
        /**
        * @language zh_CN
        * 1弧度为多少角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.RADIANS_TO_DEGREES = 180 / Math.PI;
        /**
        * @language zh_CN
        * 1角度为多少弧度
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.DEGREES_TO_RADIANS = Math.PI / 180;
        /**
        * @private
        * 1角度为多少弧度
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.RAW_DATA_CONTAINER = new Float32Array(16);
        /**
        * @private
        */
        MathUtil.CALCULATION_MATRIX = new egret3d.Matrix4_4();
        /**
        * @private
        */
        MathUtil.CALCULATION_QUATERNION = new egret3d.Quaternion();
        /**
        * @private
        */
        MathUtil.CALCULATION_VECTOR3D = new egret3d.Vector3D();
        return MathUtil;
    }());
    egret3d.MathUtil = MathUtil;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Ray
     * @classdesc
     * 射线是指直线上的一点和它一旁的部分所组成的直线，射线有且仅有一个端点，无法测量，由一个原点,和一个方向构成
     * 用于检测射线,也可用于鼠标拣选场景中的模型
     *
     * @see egret3d.Picker
     * @see egret3d.Vector3D
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Ray = (function () {
        /**
        * @language zh_CN
        * constructor
        * @origin 射线原点
        * @direction 射线方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Ray(origin, direction) {
            if (origin === void 0) { origin = new egret3d.Vector3D(); }
            if (direction === void 0) { direction = new egret3d.Vector3D(); }
            /**
            * @language zh_CN
            * 射线原点
            */
            this.origin = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 射线方向
            */
            this.dir = new egret3d.Vector3D();
            this.invViewMat = new egret3d.Matrix4_4();
            this.origin.copyFrom(origin);
            this.dir.copyFrom(direction);
        }
        /**
        * @language zh_CN
        * 计算一个三角形和一个射线的交点
        * @param v0 三角形的第一个顶点
        * @param v1 三角形的第二个顶点
        * @param v2 三角形的第三个顶点
        * @param ret t(交点到射线起始点的距离) u(交点在v1-v0上的投影的位置) v(交点在v1-v2上的投影的位置, 交点为ret=v0+pU*(v1-v0)+pV*(v2-v0))
        * @returns boolean 相交返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.IntersectTriangle = function (v0, v1, v2, ret) {
            if (ret === void 0) { ret = null; }
            var edge1 = v1.subtract(v0);
            var edge2 = v2.subtract(v0);
            var pvec = this.dir.crossProduct(edge2);
            var det = edge1.dotProduct(pvec);
            var tvec;
            if (det > 0) {
                tvec = this.origin.subtract(v0);
            }
            else {
                tvec = v0.subtract(this.origin);
                det = -det;
            }
            if (det < 0.0001) {
                return false;
            }
            // Calculate U parameter and test bounds
            var u = tvec.dotProduct(pvec);
            if (ret != null) {
                ret[1] = u;
            }
            if (u < 0.0 || u > det) {
                return false;
            }
            // Prepare to test V parameter
            var qvec = tvec.crossProduct(edge1);
            // Calculate V parameter and test bounds
            var v = this.dir.dotProduct(qvec);
            if (ret != null) {
                ret[2] = v;
            }
            if (v < 0.0 || u + v > det) {
                return false;
            }
            // Calculate T, scale parameters, ray intersects triangle
            var t = edge2.dotProduct(qvec);
            var invDet = 1.0 / det;
            t *= invDet;
            u *= invDet;
            v *= invDet;
            if (ret != null) {
                ret[0] = t;
                ret[1] = u;
                ret[2] = v;
            }
            if (t < 0) {
                return false;
            }
            return true;
        };
        /**
        * @language zh_CN
        * 检测射线相交模型
        * @param renderItem 检测的模型
        * @param uv_offset 顶点uv数据偏移 可以为-1
        * @param result 数据返回
        * @returns boolean 相交返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.IntersectMeshEx = function (renderItem, uv_offset, result) {
            return this.IntersectMesh(renderItem.geometry.verticesData, renderItem.geometry.indexData, renderItem.geometry.vertexAttLength, renderItem.geometry.indexData.length / 3, uv_offset, renderItem.modelMatrix, result);
        };
        /**
        * @language zh_CN
        * 检测射线相交模型
        * @param verticesData 检测的模型的顶点数据
        * @param indexData 检测的模型的索引数据
        * @param offset 每个顶点的大小
        * @param faces 模型面数
        * @param uv_offset 顶点uv数据偏移 可以为-1
        * @param mMat 顶点的世界变换矩阵
        * @param result 数据返回
        * @returns boolean 相交返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.IntersectMesh = function (verticesData, indexData, offset, faces, uv_offset, mMat, result) {
            var modletriangle = new Array();
            modletriangle.push(new egret3d.Vector3D());
            modletriangle.push(new egret3d.Vector3D());
            modletriangle.push(new egret3d.Vector3D());
            var uvarray = new Array();
            uvarray.push(new egret3d.Vector3D());
            uvarray.push(new egret3d.Vector3D());
            uvarray.push(new egret3d.Vector3D());
            var triangle = new Array();
            var v0 = new egret3d.Vector3D();
            var v1 = new egret3d.Vector3D();
            var v2 = new egret3d.Vector3D();
            triangle.push(v0);
            triangle.push(v1);
            triangle.push(v2);
            var pos = new egret3d.Vector3D();
            var uv = new egret3d.Point();
            var ret = new Array();
            ret.push(0.0);
            ret.push(0.0);
            ret.push(0.0);
            var face = -1;
            var t = Number.MAX_VALUE;
            var u = 0;
            var v = 0;
            for (var i = 0; i < faces; ++i) {
                for (var j = 0; j < 3; ++j) {
                    var index = indexData[3 * i + j];
                    pos.setTo(verticesData[offset * index + 0], verticesData[offset * index + 1], verticesData[offset * index + 2]);
                    pos.copyFrom(mMat.transformVector(pos));
                    triangle[j].x = pos.x;
                    triangle[j].y = pos.y;
                    triangle[j].z = pos.z;
                }
                if (this.IntersectTriangle(v0, v1, v2, ret)) {
                    if (ret[0] < t) {
                        face = i;
                        t = ret[0];
                        u = ret[1];
                        v = ret[2];
                    }
                }
            }
            if (face < faces && face >= 0) {
                for (var i = 0; i < 3; ++i) {
                    var index = indexData[3 * face + i];
                    pos.setTo(verticesData[offset * index + 0], verticesData[offset * index + 1], verticesData[offset * index + 2]);
                    modletriangle[i].copyFrom(pos);
                    if (uv_offset > 0) {
                        uv.x = verticesData[offset * index + 0 + uv_offset];
                        uv.y = verticesData[offset * index + 1 + uv_offset];
                        uvarray[i].x = uv.x;
                        uvarray[i].y = uv.y;
                    }
                    pos.copyFrom(mMat.transformVector(pos));
                    triangle[i].x = pos.x;
                    triangle[i].y = pos.y;
                    triangle[i].z = pos.z;
                }
                var tmp0 = v1.subtract(v0);
                tmp0.scaleBy(u);
                var tmp1 = v2.subtract(v0);
                tmp1.scaleBy(v);
                result.globalPosition.copyFrom(v0.add(tmp0.add(tmp1)));
                tmp0 = modletriangle[1].subtract(modletriangle[0]);
                tmp0.scaleBy(u);
                tmp1 = modletriangle[2].subtract(modletriangle[0]);
                tmp1.scaleBy(v);
                result.localPosition.copyFrom(modletriangle[0].add(tmp0.add(tmp1)));
                if (uv_offset > 0) {
                    tmp0 = uvarray[1].subtract(uvarray[0]);
                    tmp0.scaleBy(u);
                    tmp1 = uvarray[2].subtract(uvarray[0]);
                    tmp1.scaleBy(v);
                    result.uv.copyFrom(uvarray[0].add(tmp0.add(tmp1)));
                }
                return true;
            }
            return false;
        };
        /**
        * @language zh_CN
        * 计算摄像机的射线
        * @param width 视口宽
        * @param height 视口高
        * @param viewMat 相机视图矩阵
        * @param projMat 相机投影矩阵
        * @param x 鼠标x
        * @param y 鼠标y
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.CalculateAndTransformRay = function (width, height, viewMat, projMat, x, y) {
            this.reset();
            this.dir.x = (2.0 * x / width - 1.0) / projMat.rawData[0];
            this.dir.y = (-2.0 * y / height + 1.0) / projMat.rawData[5];
            this.dir.z = 1.0;
            this.invViewMat.copyFrom(viewMat);
            this.origin.copyFrom(this.invViewMat.transformVector(this.origin));
            this.dir.copyFrom(this.invViewMat.deltaTransformVector(this.dir));
            this.dir.normalize();
        };
        /**
        * @language zh_CN
        * 射线重置
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.reset = function () {
            this.origin.setTo(0, 0, 0);
            this.dir.setTo(0, 0, 0);
        };
        return Ray;
    }());
    egret3d.Ray = Ray;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
     * @language zh_CN
     * @class egret3d.Color
     * @classdesc
     * 可使用 Color 类调整显示对象的颜色值
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Color = (function () {
        /**
        * @language zh_CN
        * 创建一个Color对象
        * @param r red
        * @param g green
        * @param b blue
        * @param a alpha
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Color(r, g, b, a) {
            if (r === void 0) { r = 0; }
            if (g === void 0) { g = 0; }
            if (b === void 0) { b = 0; }
            if (a === void 0) { a = 255; }
            /**
            * @language zh_CN
            * alpha
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.a = 255;
            /**
            * @language zh_CN
            * red
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.r = 255;
            /**
            * @language zh_CN
            * green
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.g = 255;
            /**
            * @language zh_CN
            * blue
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.b = 255;
            this.a = a;
            this.r = r;
            this.g = g;
            this.b = b;
        }
        /**
        * @language zh_CN
        * 返回白色 new Color(255, 255, 255, 255)
        * @retruns Color 白色
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.white = function () {
            return new Color(255, 255, 255, 255);
        };
        /**
        * @language zh_CN
        * 返回黑色 new Color(0, 0, 0, 255)
        * @retrun Color 黑色
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.black = function () {
            return new Color(0, 0, 0, 255);
        };
        /**
        * @language zh_CN
        * 返回白色 new Color(255, 0, 0, 255)
        * @retrun 白色
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.red = function () {
            return new Color(255, 0, 0, 255);
        };
        /**
        * @language zh_CN
        * 返回绿色 new Color(0, 255, 0, 255)
        * @retrun 绿色
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.green = function () {
            return new Color(0, 255, 0, 255);
        };
        /**
        * @language zh_CN
        * 返回蓝色 new Color(0, 0, 255, 255)
        * @retrun 蓝色
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.blue = function () {
            return new Color(0, 0, 255, 255);
        };
        /**
        * @language zh_CN
        * 以number值返加颜色
        * @param colorFormat 格式
        * @returns number 颜色
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.prototype.getColor = function (colorFormat) {
            if (colorFormat === void 0) { colorFormat = egret3d.ContextConfig.ColorFormat_RGBA8888; }
            if (colorFormat == egret3d.ContextConfig.ColorFormat_RGB565)
                return 0;
            if (colorFormat == egret3d.ContextConfig.ColorFormat_RGBA5551)
                return 0;
            if (colorFormat == egret3d.ContextConfig.ColorFormat_RGBA4444)
                return 0;
            return this.r << 24 | this.g << 16 | this.b << 8 | this.a;
        };
        /**
        * @language zh_CN
        * 颜色取插值
        * @param c0 颜色1
        * @param c1 颜色2
        * @param t (0.0-1.0)
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.prototype.lerp = function (c0, c1, t) {
            ///t(c1 - c0) + c0
            this.a = t * (c1.a - c0.a) + c0.a;
            this.r = t * (c1.r - c0.r) + c0.r;
            this.g = t * (c1.g - c0.g) + c0.g;
            this.b = t * (c1.b - c0.b) + c0.b;
            this.a = Math.floor(this.a);
            this.r = Math.floor(this.r);
            this.g = Math.floor(this.g);
            this.b = Math.floor(this.b);
        };
        /**
         * @language zh_CN
         * 拷贝颜色值
         * @param src Color 被拷贝对象颜色
         * @version Egret 3.0
         * @platform Web,Native
         */
        Color.prototype.copyFrom = function (src) {
            this.a = src.a;
            this.r = src.r;
            this.g = src.g;
            this.b = src.b;
        };
        /**
         * @language zh_CN
         * 设置颜色值
         * @param a Alpha
         * @param r Red
         * @param g Green
         * @param b Blue
         * @version Egret 3.0
         * @platform Web,Native
         */
        Color.prototype.setTo = function (a, r, g, b) {
            if (a === void 0) { a = 255; }
            if (r === void 0) { r = 255; }
            if (g === void 0) { g = 255; }
            if (b === void 0) { b = 255; }
            this.a = a;
            this.r = r;
            this.g = g;
            this.b = b;
        };
        /**
         * @language zh_CN
         * 创建颜色值
         * @param argb 0xff00ff00格式
         * @return color
         * @version Egret 3.0
         * @platform Web,Native
         */
        Color.createColor = function (argb) {
            var color = new Color();
            color.setColorARGB(argb);
            return color;
        };
        /**
         * @language zh_CN
         * 设置颜色值
         * @param argb 0xff00ff00格式
         * @version Egret 3.0
         * @platform Web,Native
         */
        Color.prototype.setColorARGB = function (argb) {
            this.a = argb / 0x1000000;
            this.a >>= 0;
            this.r = argb & 0xff0000;
            this.r >>= 16;
            this.g = argb & 0xff00;
            this.g >>= 8;
            this.b = argb & 0xff;
        };
        /**
         * @language zh_CN
         * 在2个颜色之间取随机颜色
         * @param c1 第一个颜色
         * @param c2 第二个颜色
         * @param sameRandom 是否argb的随机种子使用同一个
         * @version Egret 3.0
         * @platform Web,Native
         */
        Color.prototype.randomColor = function (c1, c2, sameRandom) {
            if (sameRandom === void 0) { sameRandom = false; }
            if (sameRandom) {
                var random = Math.random();
                this.a = c1.a + (c2.a - c1.a) * random;
                this.r = c1.r + (c2.r - c1.r) * random;
                this.g = c1.g + (c2.g - c1.g) * random;
                this.b = c1.b + (c2.b - c1.b) * random;
            }
            else {
                this.a = c1.a + (c2.a - c1.a) * Math.random();
                this.r = c1.r + (c2.r - c1.r) * Math.random();
                this.g = c1.g + (c2.g - c1.g) * Math.random();
                this.b = c1.b + (c2.b - c1.b) * Math.random();
            }
            this.a = Math.floor(this.a);
            this.r = Math.floor(this.r);
            this.g = Math.floor(this.g);
            this.b = Math.floor(this.b);
        };
        return Color;
    }());
    egret3d.Color = Color;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.ColorGradients
     * @classdesc
     * 使用 ColorGradients记录一个颜色渐变信息
     * @version Egret 3.0
     * @platform Web,Native
     */
    var ColorGradients = (function () {
        function ColorGradients() {
            this.colors = [];
            this.times = [];
        }
        /**
        * @language zh_CN
        * 渐变颜色取插值
        * @param c0 颜色1
        * @param c1 颜色2
        * @param t (0.0-1.0)
        * @version Egret 3.0
        * @platform Web,Native
        */
        ColorGradients.prototype.lerpColor = function (t, dst) {
            if (dst === void 0) { dst = null; }
            if (t < 0) {
                t = 0;
            }
            else if (t > 1) {
                t = 1;
            }
            if (dst == null)
                dst = new egret3d.Color();
            var clr;
            var nextClr;
            for (var i = 0, count = this.times.length - 1; i < count; i++) {
                if (t >= this.times[i] && t < this.times[i + 1]) {
                    t = (t - this.times[i]) / (this.times[i + 1] - this.times[i]);
                    dst.lerp(this.colors[i], this.colors[i + 1], t);
                    break;
                }
            }
            return dst;
        };
        return ColorGradients;
    }());
    egret3d.ColorGradients = ColorGradients;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Bound
     * @classdesc
     * 可使用 Bound 类 取得包围盒的数据。</p>
     * 包含包围盒的各顶点信息，当包围盒要进行世界变换时，应当变换各顶点信息。</p>
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Bound = (function () {
        /**
        * @language zh_CN
        * 创建一个包围对象
        * @prame owner 绑定的Object3D对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Bound(owner) {
            /**
            * @language zh_CN
            * 顶点数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.vexData = new Array();
            /**
            * @language zh_CN
            * 索引数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.indexData = new Array();
            /**
            * @language zh_CN
            * 顶点长度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.vexLength = 3;
            this.matrix = new egret3d.Matrix4_4();
            this.temp = new egret3d.Vector3D();
            this.owner = owner;
        }
        Object.defineProperty(Bound.prototype, "transform", {
            /**
            * @language zh_CN
            * 得到变换矩阵 如果没有绑定Object3D对象
            * @returns 变换矩阵
            */
            get: function () {
                if (!this.owner) {
                    return this.matrix;
                }
                return this.owner.modelMatrix;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 检测一个点是否包围盒内
        * @param pos 检测的点
        * @returns 成功返回true
        */
        Bound.prototype.pointIntersect = function (pos) {
            return false;
        };
        /**
        * @language zh_CN
        * 检测两个包围对象是否相交
        * @param target 检测的目标
        * @param intersect 默认参数为null 相交的结果 可以为null
        * @returns  成功返回true
        */
        Bound.prototype.intersect = function (target, intersect) {
            if (intersect === void 0) { intersect = null; }
            return true;
        };
        /**
        * @language zh_CN
        * 克隆一個包圍對象
        * @returns Bound 包圍對象
        */
        Bound.prototype.clone = function () {
            var bound = new Bound(this.owner);
            bound.copyVertex(this);
            return bound;
        };
        /**
        * @private
        */
        Bound.prototype.calculateTransform = function () {
            for (var j = 0; j < this.vexData.length; j += 3) {
                this.temp.setTo(this.vexData[j], this.vexData[j + 1], this.vexData[j + 2]);
                this.transform.transformVector(this.temp, this.temp);
                this.vexData[j + 0] = this.temp.x;
                this.vexData[j + 1] = this.temp.y;
                this.vexData[j + 2] = this.temp.z;
            }
        };
        /**
        * @private
        */
        Bound.prototype.copyVertex = function (bound) {
            for (var i = 0; i < bound.vexData.length; ++i) {
                this.vexData[i] = bound.vexData[i];
            }
            for (var i = 0; i < bound.indexData.length; ++i) {
                this.indexData[i] = bound.indexData[i];
            }
            this.vexLength = bound.vexLength;
        };
        /**
        * @private
        */
        Bound.prototype.createChild = function () {
            this.childBound = new Bound(this.owner);
        };
        /**
        * @private
        * @language zh_CN
        */
        Bound.prototype.inBound = function (frustum) {
            return true;
        };
        Bound.prototype.updateAABB = function () {
        };
        return Bound;
    }());
    egret3d.Bound = Bound;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    * @class egret3d.HashMap
    * @classdesc
    * 用来做数据存储使用 hash map 映射表
    * <p> 通用的hash map 映射表  key为键 value为任意类型的值
    * <p> 还可以通过开启开关使用双线列表能正常使用list带有顺序的存储方式
    *
    */
    var HashMap = (function () {
        function HashMap(useOrderList) {
            if (useOrderList === void 0) { useOrderList = false; }
            this.data = [];
            this.list = new Array();
            if (useOrderList) {
                this.list = new Array();
            }
        }
        HashMap.prototype.isHas = function (key) {
            if (this.data[key])
                return true;
            return false;
        };
        HashMap.prototype.getValue = function (key) {
            return this.data[key];
        };
        HashMap.prototype.getList = function () {
            return this.list;
        };
        HashMap.prototype.add = function (key, value) {
            this.data[key] = value;
            if (this.list) {
                this.list.push(value);
            }
        };
        HashMap.prototype.remove = function (key) {
            if (this.list) {
                var index = this.list.indexOf(this.data[key]);
                if (index != -1) {
                    this.list.splice(index);
                }
            }
            delete this.data[key];
        };
        HashMap.prototype.dispose = function () {
            delete this.data;
            delete this.list;
        };
        return HashMap;
    }());
    egret3d.HashMap = HashMap;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Bound
     * @classdesc
     * 可使用 Bound 类 取得包围盒的数据。</p>
     * 包含包围盒的各顶点信息，当包围盒要进行世界变换时，应当变换各顶点信息。</p>
     * @see egret3d.Bound
     * @version Egret 3.0
     * @platform Web,Native
     */
    var BoundBox = (function (_super) {
        __extends(BoundBox, _super);
        /**
        * @language zh_CN
        * 创建一个包围
        * @param owner 绑定的Object3D对象
        * @param min 最小点
        * @param max 最大点
        * @version Egret 3.0
        * @platform Web,Native
        */
        function BoundBox(owner, min, max) {
            if (owner === void 0) { owner = null; }
            if (min === void 0) { min = new egret3d.Vector3D(); }
            if (max === void 0) { max = new egret3d.Vector3D(); }
            _super.call(this, owner);
            /**
            * @language zh_CN
            * 盒子最小点
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.min = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 盒子最大点
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.max = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 盒子宽
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.width = 0;
            /**
            * @language zh_CN
            * 盒子高
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.heigth = 0;
            /**
            * @language zh_CN
            * 盒子长
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.depth = 0;
            /**
            * @language zh_CN
            * 盒子体积
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.volume = 0;
            /**
            * @language zh_CN
            * 盒子包围球中心点
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.center = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 盒子包围球半径
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.radius = 0;
            this.min.copyFrom(min);
            this.max.copyFrom(max);
            this.calculateBox();
        }
        /**
        * @language zh_CN
        * 拷贝一个包围盒
        * @param box 数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.copyFrom = function (box) {
            this.min.copyFrom(box.min);
            this.max.copyFrom(box.max);
            this.calculateBox();
        };
        /**
        * @language zh_CN
        * 填充当前包围盒
        * @param min 最小点
        * @param max 最大点
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.fillBox = function (min, max) {
            this.min.copyFrom(min);
            this.max.copyFrom(max);
            this.calculateBox();
        };
        /**
        * @language zh_CN
        * 检测一个点是否包围盒内
        * @param pos 检测的点
        * @returns boolean 成功返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.pointIntersect = function (pos) {
            if (pos.x <= this.max.x && pos.x >= this.min.x &&
                pos.y <= this.max.y && pos.y >= this.min.y &&
                pos.z <= this.max.z && pos.z >= this.min.z) {
                return true;
            }
            return false;
        };
        /**
        * @language zh_CN
        * 检测两个包围盒是否相交
        * 功能和 intersect 一样 为版本兼容没有删除此API
        * @param box2 其中一个包围盒
        * @param boxIntersect  默认参数为null 相交的包围盒 可以为null
        * @returns boolean 成功返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.intersectAABBs = function (box2, boxIntersect) {
            if (boxIntersect === void 0) { boxIntersect = null; }
            if (this.min.x > box2.max.x) {
                return false;
            }
            if (this.max.x < box2.min.x) {
                return false;
            }
            if (this.min.y > box2.max.y) {
                return false;
            }
            if (this.max.y < box2.min.y) {
                return false;
            }
            if (this.min.z > box2.max.z) {
                return false;
            }
            if (this.max.z < box2.min.z) {
                return false;
            }
            if (boxIntersect != null) {
                boxIntersect.min.x = Math.max(this.min.x, box2.min.x);
                boxIntersect.max.x = Math.min(this.max.x, box2.max.x);
                boxIntersect.min.y = Math.max(this.min.y, box2.min.y);
                boxIntersect.max.y = Math.min(this.max.y, box2.max.y);
                boxIntersect.min.z = Math.max(this.min.z, box2.min.z);
                boxIntersect.max.z = Math.min(this.max.z, box2.max.z);
                boxIntersect.calculateBox();
            }
            return true;
        };
        /**
        * @language zh_CN
        * 检测两个包围对象是否相交
        * 注意：target 和 intersect 必须为BoundBox对象
        * @param target 检测的目标
        * @param intersect 默认参数为null 相交的结果 可以为null
        * @returns boolean 成功返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.intersect = function (target, intersect) {
            if (intersect === void 0) { intersect = null; }
            if (!this._box0) {
                this._box0 = this.clone();
            }
            else {
                this._box0.copyVertex(this);
            }
            this._box0.calculateTransform();
            this._box0.updateAABB();
            if (!this._box1) {
                this._box1 = target.clone();
            }
            else {
                this._box1.copyVertex(this);
            }
            this._box1.calculateTransform();
            this._box1.updateAABB();
            return this._box0.intersectAABBs(this._box1, intersect);
        };
        /**
        * @language zh_CN
        * 以字符串形式返回box的值
        * @returns string 字符串
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.toString = function () {
            return "BoundBox [min:(" + this.min.x + ", " + this.min.y + ", " + this.min.z + ") max:(" + this.max.x + ", " + this.max.y + ", " + this.max.z + ")]";
        };
        /**
        * @language zh_CN
        * 计算包围盒数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.calculateBox = function () {
            this.vexData.length = 0;
            this.indexData.length = 0;
            var sub = this.max.subtract(this.min);
            this.vexData.push(this.min.x);
            this.vexData.push(this.min.y);
            this.vexData.push(this.min.z);
            this.vexData.push(this.min.x);
            this.vexData.push(this.min.y);
            this.vexData.push(this.min.z + sub.z);
            this.vexData.push(this.min.x + sub.x);
            this.vexData.push(this.min.y);
            this.vexData.push(this.min.z + sub.z);
            this.vexData.push(this.min.x + sub.x);
            this.vexData.push(this.min.y);
            this.vexData.push(this.min.z);
            this.vexData.push(this.max.x - sub.x);
            this.vexData.push(this.max.y);
            this.vexData.push(this.max.z - sub.z);
            this.vexData.push(this.max.x - sub.x);
            this.vexData.push(this.max.y);
            this.vexData.push(this.max.z);
            this.vexData.push(this.max.x);
            this.vexData.push(this.max.y);
            this.vexData.push(this.max.z);
            this.vexData.push(this.max.x);
            this.vexData.push(this.max.y);
            this.vexData.push(this.max.z - sub.z);
            this.indexData.push(0, 4, 7, 0, 7, 3, 2, 6, 5, 2, 5, 1, 4, 5, 6, 4, 6, 7, 0, 3, 2, 0, 2, 1, 0, 1, 5, 0, 5, 4, 3, 7, 6, 3, 6, 2);
            this.width = this.max.x - this.min.x;
            this.heigth = this.max.y - this.min.y;
            this.depth = this.max.z - this.min.z;
            this.volume = this.width * this.heigth * this.depth;
            var c = this.max.subtract(this.min);
            c.scaleBy(0.5);
            this.radius = c.length;
            this.center.copyFrom(this.min);
            var tmp = this.center.add(c);
            this.center.copyFrom(tmp);
        };
        /**
        * @language zh_CN
        * 检测一个盒子是否在视椎体内
        * @param frustum 视椎体
        * @returns boolean 在视椎内返回ture
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.inBound = function (frustum) {
            return frustum.inBox(this);
        };
        BoundBox.prototype.updateAABB = function () {
            this.min.copyFrom(new egret3d.Vector3D(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE));
            this.max.copyFrom(new egret3d.Vector3D(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE));
            for (var i = 0; i < this.vexData.length; i += this.vexLength) {
                if (this.max.x < this.vexData[i]) {
                    this.max.x = this.vexData[i];
                }
                if (this.max.y < this.vexData[i + 1]) {
                    this.max.y = this.vexData[i + 1];
                }
                if (this.max.z < this.vexData[i + 2]) {
                    this.max.z = this.vexData[i + 2];
                }
                if (this.min.x > this.vexData[i]) {
                    this.min.x = this.vexData[i];
                }
                if (this.min.y > this.vexData[i + 1]) {
                    this.min.y = this.vexData[i + 1];
                }
                if (this.min.z > this.vexData[i + 2]) {
                    this.min.z = this.vexData[i + 2];
                }
            }
        };
        /**
        * @private
        */
        BoundBox.prototype.createChild = function () {
            this.childBound = new BoundBox(this.owner);
            var max = new egret3d.Vector3D();
            var min = new egret3d.Vector3D();
            max.x = this.center.x + this.width / 4;
            max.y = this.center.y + this.heigth / 4;
            max.z = this.center.z + this.depth / 4;
            min.x = this.center.x - this.width / 4;
            min.y = this.center.y - this.heigth / 4;
            min.z = this.center.z - this.depth / 4;
            this.childBound.fillBox(min, max);
        };
        /**
        * @language zh_CN
        * 克隆一個包圍對象
        * @returns Bound 包圍對象
        */
        BoundBox.prototype.clone = function () {
            var bound = new BoundBox(this.owner);
            bound.copyVertex(this);
            bound.width = this.width;
            bound.heigth = this.heigth;
            bound.depth = this.depth;
            bound.min.copyFrom(this.min);
            bound.max.copyFrom(this.max);
            bound.volume = this.volume;
            bound.center.copyFrom(this.center);
            bound.radius = this.radius;
            return bound;
        };
        return BoundBox;
    }(egret3d.Bound));
    egret3d.BoundBox = BoundBox;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
     * @language zh_CN
     * @class egret3d.BezierCurve
     * @classdesc
     * 贝塞尔曲线
     * @version Egret 3.0
     * @platform Web,Native
     */
    var BezierCurve = (function () {
        function BezierCurve() {
        }
        BezierCurve.prototype.calcBezierY = function (pos, ctrl, t) {
            var A0;
            var B0;
            var A1;
            var B1;
            for (var i = 0; i < 3; i++) {
                if (t >= pos[i].x && t <= pos[i + 1].x) {
                    A0 = pos[i];
                    B0 = ctrl[i];
                    A1 = pos[i + 1];
                    B1 = ctrl[i + 1];
                    break;
                }
            }
            t = (t - A0.x) / (A1.x - A0.x);
            return this.cubic_bezier(A0.y, B0.y, B1.y, A1.y, t);
        };
        BezierCurve.prototype.calcBezierX = function (pos, ctrl, t) {
            var A0;
            var B0;
            var A1;
            var B1;
            for (var i = 0; i < 3; i++) {
                if (t >= pos[i].x && t <= pos[i + 1].x) {
                    A0 = pos[i];
                    B0 = ctrl[i];
                    A1 = pos[i + 1];
                    B1 = ctrl[i + 1];
                    break;
                }
            }
            t = (t - A0.x) / (A1.x - A0.x);
            return this.cubic_bezier(A0.x, B0.x, B1.x, A1.x, t);
        };
        BezierCurve.prototype.cubic_bezier = function (p0, p1, p2, p3, t) {
            //第一次混合
            p0 = this.mix(p0, p1, t);
            p1 = this.mix(p1, p2, t);
            p2 = this.mix(p2, p3, t);
            //第二次混合
            p0 = this.mix(p0, p1, t);
            p1 = this.mix(p1, p2, t);
            //第三次混合
            p0 = this.mix(p0, p1, t);
            return p0;
            //var progress: number = 1.0 - t;
            //var progress2: number = progress * progress;
            //var progress3: number = progress2 * progress;
            //var t2: number = t * t;
            //var t3: number = t2 * t;
            //var res: number = p0 * progress3 + 3.0 * p1 * t * progress2 + 3.0 * p2 * t2 * progress + p3 * t3;
            //return res;
        };
        BezierCurve.prototype.cubic_bezier2 = function (p0, p1, p2, p3, t) {
            var progress = 1.0 - t;
            var progress2 = progress * progress;
            var progress3 = progress2 * progress;
            var t2 = t * t;
            var t3 = t2 * t;
            var res = p0 * progress3 + 3.0 * p1 * t * progress2 + 3.0 * p2 * t2 * progress + p3 * t3;
            return res;
        };
        BezierCurve.prototype.mix = function (num0, num1, t) {
            return num0 * (1 - t) + num1 * t;
        };
        return BezierCurve;
    }());
    egret3d.BezierCurve = BezierCurve;
    var BezierData = (function () {
        function BezierData() {
            this.posPoints = [];
            this.ctrlPoints = [];
        }
        BezierData.prototype.calc = function (t) {
            var value = BezierData.calc.calcBezierY(this.posPoints, this.ctrlPoints, t);
            return value;
        };
        BezierData.prototype.merge = function () {
            var res = new Float32Array(BezierData.SegCount * 4 * 2);
            for (var i = 0, count = BezierData.SegCount * 2; i < count; i++) {
                res[i * 4 + 0] = this.posPoints[i].x;
                res[i * 4 + 1] = this.posPoints[i].y;
                res[i * 4 + 2] = this.ctrlPoints[i].x;
                res[i * 4 + 3] = this.ctrlPoints[i].y;
            }
            return res;
        };
        BezierData.prototype.scaleBy = function (value) {
            if (this.posPoints.length == 0)
                return;
            for (var i = 0, count = BezierData.SegCount * 2; i < count; i++) {
                this.posPoints[i].y *= value;
                this.ctrlPoints[i].y *= value;
            }
        };
        //public compress(): Float32Array {
        //    var floats: Array<number> = [];
        //    for (var i: number = 0, count: number = this.posPoints.length; i < count; i++) {
        //        floats.push(this.posPoints[i].x, this.posPoints[i].y);
        //        floats.push(this.ctrlPoints[i].x, this.ctrlPoints[i].y);
        //    }
        //    var res: Float32Array = BezierData.compressFloats(floats);
        //    return res;
        //}
        BezierData.prototype.trySampler = function () {
            for (var i = 0, count = this.posPoints.length; i < count; i++) {
                if (this.posPoints[i].y != 0 || this.ctrlPoints[i].y != 0) {
                    return this.doSampler();
                }
            }
            return null;
        };
        BezierData.prototype.sampler = function () {
            //if (ignore0) {
            //    var value: number = this.posPoints[0].y;
            //    for (var i: number = 0, count: number = this.posPoints.length; i < count; i++) {
            //        if (this.posPoints[i].y != value || this.ctrlPoints[i].y != value) {
            //            return this.doSampler();
            //        }
            //    }
            //    return null;
            //}
            return this.doSampler();
        };
        BezierData.prototype.pushSameValue = function (value) {
            var SegmentCount = 9 + 1;
            var res = new Float32Array(SegmentCount * BezierData.SegCount + 2 + 1); //10 + 10 + 2 + 1
            for (var i = 0, count = BezierData.SegCount * BezierData.SegCount + 2; i < count; i++) {
                res[i] = value;
            }
            //true
            res[count + 2] = 1;
            return res;
        };
        BezierData.prototype.doSampler = function () {
            var floats = [];
            var times = [];
            var segmentTime;
            var segmentStartTime = 0;
            var segmentEndTime = 0;
            //每段有10个数据，将该段曲线分为9小段
            var SegmentCount = 9;
            var i;
            var count;
            for (i = 0, count = BezierData.SegCount; i < count; i++) {
                floats.push(this.posPoints[i * 2].y); //第一个数字
                segmentStartTime = this.posPoints[i * 2].x;
                segmentEndTime = this.posPoints[i * 2 + 1].x;
                segmentTime = (segmentEndTime - segmentStartTime) / SegmentCount; //该贝塞尔的每小段
                times.push(segmentTime);
                for (var j = 1; j < SegmentCount; j++) {
                    floats.push(this.calc(segmentStartTime + segmentTime * j));
                }
                floats.push(this.posPoints[i * 2 + 1].y); //第10个数字
            }
            var res = new Float32Array(floats.length + times.length);
            for (i = 0, count = floats.length; i < count; i++) {
                res[i] = floats[i];
            }
            for (var j = 0, count = times.length; j < count; i++, j++) {
                res[i] = times[j];
            }
            //false
            //res[i] = 0;
            return res;
        };
        //public compress(): Float32Array {
        //    var floats: Array<number> = [];
        //    var times: Array<number> = [];
        //    var segmentTime: number;
        //    var segmentStartTime: number = 0;
        //    var segmentEndTime: number = 0;
        //    //每段有10个数据，将该段曲线分为9小段
        //    const SegmentCount: number = 9;
        //    for (var i: number = 0, count: number = BezierData.SegCount; i < count; i++) {
        //        floats.push(this.posPoints[i * 2].y);//第一个数字
        //        segmentStartTime = this.posPoints[i * 2].x;
        //        segmentEndTime = this.posPoints[i * 2 + 1].x;
        //        segmentTime = segmentEndTime - segmentStartTime;//该段的时间
        //        times.push(segmentTime);
        //        for (var j: number = 1; j < SegmentCount; j++) {
        //            floats.push(this.calc(segmentStartTime + segmentTime * j / SegmentCount));
        //        }
        //        floats.push(this.posPoints[i * 2 + 1].y);//第10个数字
        //    }
        //    var res: Float32Array = BezierData.compressFloats(floats, times);
        //    return res;
        //}
        BezierData.prototype.validate = function () {
            if (this.posPoints == null) {
                this.posPoints = [];
            }
            if (this.ctrlPoints == null) {
                this.ctrlPoints = [];
            }
            var i = 0, count = 0;
            for (i = this.posPoints.length / 2, count = BezierData.SegCount; i < count; i++) {
                this.posPoints.push(new egret3d.Point(0, 0));
                this.posPoints.push(new egret3d.Point(1, 0));
            }
            for (i = this.ctrlPoints.length / 2, count = BezierData.SegCount; i < count; i++) {
                this.ctrlPoints.push(new egret3d.Point(0, 0));
                this.ctrlPoints.push(new egret3d.Point(1, 0));
            }
        };
        //___________压缩数据
        BezierData.compressFloats = function (floats, times) {
            if (floats.length % 2 == 1) {
                floats.push(0);
            }
            var floatCount = 0;
            floatCount += BezierData.SegCount * 5; //每段有10个float高度数据，压缩后变成5个
            floatCount += 2; //2个float是用于放入min和range
            floatCount += 1; //记录是否表示所有的数据都相等
            floatCount += BezierData.SegCount; //每段有一个float记录该段的总时间
            var res = new Float32Array(floatCount);
            var maxInt = 4096; //最大的数，在这个范围进行压缩
            var maxInt_1 = maxInt - 1;
            var i;
            var count;
            //获得最小和最大值
            var ints = [];
            ints.length = floats.length;
            var floatValue;
            var max = -Number.MAX_VALUE;
            var min = Number.MAX_VALUE;
            for (i = 0, count = floats.length; i < count; i++) {
                floatValue = ints[i] = floats[i];
                max = Math.max(floatValue, max);
                min = Math.min(floatValue, min);
            }
            var range = max - min;
            //表示所有的数据都相等
            if (range > 0) {
                //转化每个float，于0 - maxInt之间
                var intValue = 0;
                for (i = 0, count = ints.length; i < count; i++) {
                    intValue = ints[i];
                    intValue -= min;
                    intValue /= range; //0-1之间
                    intValue *= maxInt_1; //0 - (maxInt - 1)之间
                    ints[i] = Math.floor(intValue);
                }
                //2合1
                var int1;
                var int2;
                for (i = 0, count = ints.length / 2; i < count; i++) {
                    int1 = ints[i * 2];
                    int2 = ints[i * 2 + 1];
                    res[i] = int1 + int2 / maxInt;
                }
                res[i] = min;
                i++;
                res[i] = range;
                i++;
                res[i] = 0;
                i++;
            }
            else {
                for (i = 0, count = ints.length / 2; i < count; i++) {
                    res[i] = min;
                }
                res[i] = min;
                i++;
                res[i] = range;
                i++;
                res[i] = 1;
                i++;
            }
            for (var j = 0, count = BezierData.SegCount; j < count; i++, j++) {
                res[i] = times[j];
            }
            //输出结果
            return res;
        };
        BezierData.SegCount = 2; //四段贝塞尔曲线
        BezierData.calc = new BezierCurve();
        return BezierData;
    }());
    egret3d.BezierData = BezierData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.ColorTransform
     * @classdesc
     * 可使用 ColorTransform 类调整显示对象的颜色值
     * @version Egret 3.0
     * @platform Web,Native
     */
    var ColorTransform = (function () {
        /**
         * @language zh_CN
         * @class egret3d.ColorTransform
         * @classdesc
         * ColorTransform 用到的数据，用于偏色某个材质球
         * @version Egret 3.0
         * @platform Web,Native
         */
        function ColorTransform() {
            /**
            * @language zh_CN
            * 颜色变化矩阵。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.m44 = new egret3d.Matrix4_4();
            /**
            * @language zh_CN
            * 颜色偏移数组
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.vec4 = new Float32Array(4);
        }
        /**
        * @language zh_CN
        * 重置数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        ColorTransform.prototype.reset = function () {
            this.m44.identity();
            this.vec4.fill(0);
        };
        return ColorTransform;
    }());
    egret3d.ColorTransform = ColorTransform;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.PickResult
    * @classdesc
    * 鼠标拾取返回数据。</p>
    * 鼠标拾取模型上的交点 (本地坐标、世界坐标)。</p>
    * 鼠标拾取模型的uv。</p>
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PickResult = (function () {
        function PickResult() {
            /**
            * @language zh_CN
            * 鼠标拾取模型上的交点 (本地坐标)。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.localPosition = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 鼠标拾取模型上的交点 (世界坐标)。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.globalPosition = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 鼠标拾取模型的uv。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.uv = new egret3d.Vector3D();
        }
        return PickResult;
    }());
    egret3d.PickResult = PickResult;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @language zh_CN
   * @class egret3d.Event3D
   * @classdesc
   * Event3D 类作为创建 Event3D 对象的基类，当发生事件时，Event3D 对象将作为参数传递给事件侦听器。Event3D 类的属性包含有关事件的基本信息，例如事件的类型。对于许多事件（如由 Event3D 类常量表示的事件），此基本信息就足够了。但其他事件可能需要更详细的信息。例如，与鼠标单击关联的事件需要包括有关单击事件的位置以及在单击事件期间是否按下了任何键的其他信息。您可以通过扩展 Event3D 类（MouseEvent 类执行的操作）将此类其他信息传递给事件侦听器。
   * @version Egret 3.0
   * @platform Web,Native
   */
    var Event3D = (function () {
        /**
        * @language zh_CN
        * 创建一个作为参数传递给事件侦听器的 Event3D 对象。
        * @param typeName string 事件类型
        * @param data {any}附加数据(可选)
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Event3D(eventType, data) {
            if (eventType === void 0) { eventType = null; }
            if (data === void 0) { data = null; }
            /**
            * @language zh_CN
            * 当前时间。
            * @returns {number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.time = 0;
            /**
            * @language zh_CN
            * 每帧延时。
            * @returns {number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.delay = 0;
            this.eventType = eventType;
            this.data = data;
        }
        ///**
        //* @language zh_CN
        //* COMPLETE 常量定义 相关完成事件。
        //* @version Egret 3.0
        //* @platform Web,Native
        //*/
        //static COMPLETE: string = "complete";
        ///**
        //* @language zh_CN
        //* CHANGE_PROPERTY 常量定义 changeProperty 事件对象的 type 属性的值。
        //* @version Egret 3.0
        //* @platform Web,Native
        //*/
        //static CHANGE: string = "change";
        /**
        * @language zh_CN
        * ENTER_FRAME 定义 时实 更新tick。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.ENTER_FRAME = "enter_frame";
        /**
        * @language zh_CN
        * RESIZE 定义 修改大小时发生。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.RESIZE = "resize";
        return Event3D;
    }());
    egret3d.Event3D = Event3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var PropertyAnimEvent3D = (function (_super) {
        __extends(PropertyAnimEvent3D, _super);
        function PropertyAnimEvent3D(eventType, data) {
            if (eventType === void 0) { eventType = null; }
            if (data === void 0) { data = null; }
            _super.call(this, eventType, data);
        }
        /**
        * @language zh_CN
        * 动画播放完一个周期的事件
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnimEvent3D.EVENT_PLAY_COMPLETE = "event_play_complete";
        return PropertyAnimEvent3D;
    }(egret3d.Event3D));
    egret3d.PropertyAnimEvent3D = PropertyAnimEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var SkeletonAnimationEvent3D = (function (_super) {
        __extends(SkeletonAnimationEvent3D, _super);
        function SkeletonAnimationEvent3D(eventType, data) {
            if (eventType === void 0) { eventType = null; }
            if (data === void 0) { data = null; }
            _super.call(this, eventType, data);
        }
        /**
        * @language zh_CN
        * 动画播放完一个周期的事件
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimationEvent3D.EVENT_PLAY_COMPLETE = "event_play_complete";
        /**
        * @language zh_CN
        * 动画帧更改的事件
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimationEvent3D.EVENT_FRAME_CHANGE = "event_frame_change";
        return SkeletonAnimationEvent3D;
    }(egret3d.Event3D));
    egret3d.SkeletonAnimationEvent3D = SkeletonAnimationEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * 鼠标键码
     * @version Egret 3.0
     * @platform Web,Native
     */
    (function (MouseCode) {
        /**
        * @language zh_CN
        * 鼠标左键
        * @version Egret 3.0
        * @platform Web,Native
        */
        MouseCode[MouseCode["Mouse_Left"] = 0] = "Mouse_Left";
        /**
        * @language zh_CN
        * 鼠标中键
        * @version Egret 3.0
        * @platform Web,Native
        */
        MouseCode[MouseCode["Mouse_Mid"] = 1] = "Mouse_Mid";
        /**
        * @language zh_CN
        * 鼠标右键
        * @version Egret 3.0
        * @platform Web,Native
        */
        MouseCode[MouseCode["Mouse_Right"] = 2] = "Mouse_Right";
    })(egret3d.MouseCode || (egret3d.MouseCode = {}));
    var MouseCode = egret3d.MouseCode;
    /**
    * @language zh_CN
    * @class egret3d.MouseEvent3D
    * @classdesc
    * MouseEvent3D 是所有引擎中可操作鼠标事件节点 的事件类型标记。
    * 只有Input.addEventListener 才会产生下类事件
    * @includeExample events/MouseEvent3D.ts
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    * @see egret3d.Input
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MouseEvent3D = (function (_super) {
        __extends(MouseEvent3D, _super);
        function MouseEvent3D() {
            _super.apply(this, arguments);
            /**
             * @language zh_CN
             * 鼠标code值
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.mouseCode = 0;
        }
        /**
         * @language zh_CN
         * MOUSE_CLICK 常量定义 onClick 事件对象的 type 属性的值。
         * @version Egret 3.0
         * @platform Web,Native
         */
        MouseEvent3D.MOUSE_CLICK = "onMouseClick";
        /**
         * @language zh_CN
         * MOUSE_DOWN 常量定义 onMouseDown 事件对象的 type 属性的值。
         * @version Egret 3.0
         * @platform Web,Native
         */
        MouseEvent3D.MOUSE_DOWN = "onMouseDown";
        /**
         * @language zh_CN
         * MOUSE_UP 常量定义 onMouseUp 事件对象的 type 属性的值。
         * @version Egret 3.0
         * @platform Web,Native
         */
        MouseEvent3D.MOUSE_UP = "onMouseUp";
        /**
         * @language zh_CN
         * MOUSE_MOVE 常量定义 onMouseMove 事件对象的 type 属性的值。
         * @version Egret 3.0
         * @platform Web,Native
         */
        MouseEvent3D.MOUSE_MOVE = "onMouseMove";
        /**
         * @language zh_CN
         * MOUSE_OVER 常量定义 onMouseMove 事件对象的 type 属性的值。
         * @version Egret 3.0
         * @platform Web,Native
         */
        MouseEvent3D.MOUSE_OVER = "onMouseOver";
        /**
         * @language zh_CN
         * MOUSE_WHEEL 常量定义 onMouseWheel 事件对象的 type 属性的值。
         * @version Egret 3.0
         * @platform Web,Native
         */
        MouseEvent3D.MOUSE_WHEEL = "onMouseWheel";
        return MouseEvent3D;
    }(egret3d.Event3D));
    egret3d.MouseEvent3D = MouseEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.TouchEvent3D
    * @classdesc
    * TouchEvent3D 是所有引擎中可操作触摸事件节点 的事件类型标记。
    * 只有Input.addEventListener 才会产生下类事件
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    * @see egret3d.Input
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TouchEvent3D = (function (_super) {
        __extends(TouchEvent3D, _super);
        function TouchEvent3D() {
            _super.apply(this, arguments);
        }
        /**
         * @language zh_CN
         * TOUCH_MOVE 常量定义 onTouchMove 事件对象的 type 属性的值。
         * @version Egret 3.0
         * @platform Web,Native
         */
        TouchEvent3D.TOUCH_MOVE = "onTouchMove";
        /**
        * @language zh_CN
        * TOUCH_END 常量定义 onTouchEnd 事件对象的 type 属性的值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        TouchEvent3D.TOUCH_START = "onTouchStart";
        /**
        * @language zh_CN
        * TOUCH_START 常量定义 onTouchStart 事件对象的 type 属性的值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        TouchEvent3D.TOUCH_END = "onTouchEnd";
        return TouchEvent3D;
    }(egret3d.Event3D));
    egret3d.TouchEvent3D = TouchEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.PickEvent3D
    * @classdesc
    * PickEvent3D 是所有引擎中可操作物体拣选事件的事件类型标记。
    * 当IRender对象开启了 enablePick ，并且监听了PickEvent3D事件后，
    * 鼠标或触摸对IRender对象进行操作后会产生一些对应的事件进行影响。
    * 只有Object3D对象调用addEventListener 才会产生下类事件
    * @includeExample events/PickEvent3D.ts
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    * @see egret3d.Object3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PickEvent3D = (function (_super) {
        __extends(PickEvent3D, _super);
        function PickEvent3D() {
            _super.apply(this, arguments);
        }
        /**
         * @language zh_CN
         * PICK_CLICK 点击拣选事件
         * 手机上没有此事件
         * @version Egret 3.0
         * @platform Web,Native
         */
        PickEvent3D.PICK_CLICK = "onPickClick";
        /**
         * @language zh_CN
         * PICK_DOWN  按下拣选事件
         * @version Egret 3.0
         * @platform Web,Native
         */
        PickEvent3D.PICK_DOWN = "onPickDown";
        /**
         * @language zh_CN
         * PICK_UP 弹起拣选事件
         * @version Egret 3.0
         * @platform Web,Native
         */
        PickEvent3D.PICK_UP = "onPickUp";
        /**
         * @language zh_CN
         * PICK_MOVE 光标移动拣选
         * @version Egret 3.0
         * @platform Web,Native
         */
        PickEvent3D.PICK_MOVE = "onPickMove";
        /**
         * @language zh_CN
         * PICK_WHEEL 滚轮滚动拣选事件
         * @version Egret 3.0
         * @platform Web,Native
         */
        PickEvent3D.PICK_WHEEL = "onPickWheel";
        return PickEvent3D;
    }(egret3d.Event3D));
    egret3d.PickEvent3D = PickEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * 按键码
     * @version Egret 3.0
     * @platform Web,Native
     */
    (function (KeyCode) {
        KeyCode[KeyCode["Key_BackSpace"] = 8] = "Key_BackSpace";
        KeyCode[KeyCode["Key_Tab"] = 9] = "Key_Tab";
        KeyCode[KeyCode["Key_Clear"] = 12] = "Key_Clear";
        KeyCode[KeyCode["Key_Enter"] = 13] = "Key_Enter";
        KeyCode[KeyCode["Key_Shift_L"] = 16] = "Key_Shift_L";
        KeyCode[KeyCode["Key_Control_L"] = 17] = "Key_Control_L";
        KeyCode[KeyCode["Key_Alt_L"] = 18] = "Key_Alt_L";
        KeyCode[KeyCode["Key_Pause"] = 19] = "Key_Pause";
        KeyCode[KeyCode["Key_CapsLock"] = 20] = "Key_CapsLock";
        KeyCode[KeyCode["Key_Escape"] = 21] = "Key_Escape";
        KeyCode[KeyCode["Key_Space"] = 32] = "Key_Space";
        KeyCode[KeyCode["Key_Prior"] = 33] = "Key_Prior";
        KeyCode[KeyCode["Key_Next"] = 34] = "Key_Next";
        KeyCode[KeyCode["Key_End"] = 35] = "Key_End";
        KeyCode[KeyCode["Key_Home"] = 36] = "Key_Home";
        KeyCode[KeyCode["Key_Left"] = 37] = "Key_Left";
        KeyCode[KeyCode["Key_Up"] = 38] = "Key_Up";
        KeyCode[KeyCode["Key_Right"] = 39] = "Key_Right";
        KeyCode[KeyCode["Key_Down"] = 40] = "Key_Down";
        KeyCode[KeyCode["Key_Select"] = 41] = "Key_Select";
        KeyCode[KeyCode["Key_Print"] = 42] = "Key_Print";
        KeyCode[KeyCode["Key_Execute"] = 43] = "Key_Execute";
        KeyCode[KeyCode["Key_Insert"] = 45] = "Key_Insert";
        KeyCode[KeyCode["Key_Delete"] = 46] = "Key_Delete";
        KeyCode[KeyCode["Key_Help"] = 47] = "Key_Help";
        KeyCode[KeyCode["Key_0"] = 48] = "Key_0";
        KeyCode[KeyCode["Key_1"] = 49] = "Key_1";
        KeyCode[KeyCode["Key_2"] = 50] = "Key_2";
        KeyCode[KeyCode["Key_3"] = 51] = "Key_3";
        KeyCode[KeyCode["Key_4"] = 52] = "Key_4";
        KeyCode[KeyCode["Key_5"] = 53] = "Key_5";
        KeyCode[KeyCode["Key_6"] = 54] = "Key_6";
        KeyCode[KeyCode["Key_7"] = 55] = "Key_7";
        KeyCode[KeyCode["Key_8"] = 56] = "Key_8";
        KeyCode[KeyCode["Key_9"] = 57] = "Key_9";
        KeyCode[KeyCode["Key_A"] = 65] = "Key_A";
        KeyCode[KeyCode["Key_B"] = 66] = "Key_B";
        KeyCode[KeyCode["Key_C"] = 67] = "Key_C";
        KeyCode[KeyCode["Key_D"] = 68] = "Key_D";
        KeyCode[KeyCode["Key_E"] = 69] = "Key_E";
        KeyCode[KeyCode["Key_F"] = 70] = "Key_F";
        KeyCode[KeyCode["Key_G"] = 71] = "Key_G";
        KeyCode[KeyCode["Key_H"] = 72] = "Key_H";
        KeyCode[KeyCode["Key_I"] = 73] = "Key_I";
        KeyCode[KeyCode["Key_J"] = 74] = "Key_J";
        KeyCode[KeyCode["Key_K"] = 75] = "Key_K";
        KeyCode[KeyCode["Key_L"] = 76] = "Key_L";
        KeyCode[KeyCode["Key_M"] = 77] = "Key_M";
        KeyCode[KeyCode["Key_N"] = 78] = "Key_N";
        KeyCode[KeyCode["Key_O"] = 79] = "Key_O";
        KeyCode[KeyCode["Key_P"] = 80] = "Key_P";
        KeyCode[KeyCode["Key_Q"] = 81] = "Key_Q";
        KeyCode[KeyCode["Key_R"] = 82] = "Key_R";
        KeyCode[KeyCode["Key_S"] = 83] = "Key_S";
        KeyCode[KeyCode["Key_T"] = 84] = "Key_T";
        KeyCode[KeyCode["Key_U"] = 85] = "Key_U";
        KeyCode[KeyCode["Key_V"] = 86] = "Key_V";
        KeyCode[KeyCode["Key_W"] = 87] = "Key_W";
        KeyCode[KeyCode["Key_X"] = 88] = "Key_X";
        KeyCode[KeyCode["Key_Y"] = 89] = "Key_Y";
        KeyCode[KeyCode["Key_Z"] = 90] = "Key_Z";
        KeyCode[KeyCode["Key_KP_0"] = 96] = "Key_KP_0";
        KeyCode[KeyCode["Key_KP_1"] = 97] = "Key_KP_1";
        KeyCode[KeyCode["Key_KP_2"] = 98] = "Key_KP_2";
        KeyCode[KeyCode["Key_KP_3"] = 99] = "Key_KP_3";
        KeyCode[KeyCode["Key_KP_4"] = 100] = "Key_KP_4";
        KeyCode[KeyCode["Key_KP_5"] = 101] = "Key_KP_5";
        KeyCode[KeyCode["Key_KP_6"] = 102] = "Key_KP_6";
        KeyCode[KeyCode["Key_KP_7"] = 103] = "Key_KP_7";
        KeyCode[KeyCode["Key_KP_8"] = 104] = "Key_KP_8";
        KeyCode[KeyCode["Key_KP_9"] = 105] = "Key_KP_9";
        KeyCode[KeyCode["Key_Multiply"] = 106] = "Key_Multiply";
        KeyCode[KeyCode["Key_Add"] = 107] = "Key_Add";
        KeyCode[KeyCode["Key_Separator"] = 108] = "Key_Separator";
        KeyCode[KeyCode["Key_Subtract"] = 109] = "Key_Subtract";
        KeyCode[KeyCode["Key_Decimal"] = 110] = "Key_Decimal";
        KeyCode[KeyCode["Key_Divide"] = 111] = "Key_Divide";
        KeyCode[KeyCode["Key_F1"] = 112] = "Key_F1";
        KeyCode[KeyCode["Key_F2"] = 113] = "Key_F2";
        KeyCode[KeyCode["Key_F3"] = 114] = "Key_F3";
        KeyCode[KeyCode["Key_F4"] = 115] = "Key_F4";
        KeyCode[KeyCode["Key_F5"] = 116] = "Key_F5";
        KeyCode[KeyCode["Key_F6"] = 117] = "Key_F6";
        KeyCode[KeyCode["Key_F7"] = 118] = "Key_F7";
        KeyCode[KeyCode["Key_F8"] = 119] = "Key_F8";
        KeyCode[KeyCode["Key_F9"] = 120] = "Key_F9";
        KeyCode[KeyCode["Key_F10"] = 121] = "Key_F10";
        KeyCode[KeyCode["Key_F11"] = 122] = "Key_F11";
        KeyCode[KeyCode["Key_F12"] = 123] = "Key_F12";
        KeyCode[KeyCode["Key_F13"] = 124] = "Key_F13";
        KeyCode[KeyCode["Key_F14"] = 125] = "Key_F14";
        KeyCode[KeyCode["Key_F15"] = 126] = "Key_F15";
        KeyCode[KeyCode["Key_F16"] = 127] = "Key_F16";
        KeyCode[KeyCode["Key_F17"] = 128] = "Key_F17";
        KeyCode[KeyCode["Key_F18"] = 129] = "Key_F18";
        KeyCode[KeyCode["Key_F19"] = 130] = "Key_F19";
        KeyCode[KeyCode["Key_F20"] = 131] = "Key_F20";
        KeyCode[KeyCode["Key_F21"] = 132] = "Key_F21";
        KeyCode[KeyCode["Key_F22"] = 133] = "Key_F22";
        KeyCode[KeyCode["Key_F23"] = 134] = "Key_F23";
        KeyCode[KeyCode["Key_F24"] = 135] = "Key_F24";
        KeyCode[KeyCode["Key_Num_Lock"] = 136] = "Key_Num_Lock";
        KeyCode[KeyCode["Key_Scroll_Lock"] = 137] = "Key_Scroll_Lock";
    })(egret3d.KeyCode || (egret3d.KeyCode = {}));
    var KeyCode = egret3d.KeyCode;
    /**
    * @language zh_CN
    * @class egret3d.MouseEvent3D
    * @classdesc
    * KeyEvent3D 按键事件，
    * 只有Input.addEventListener 才会产生下类事件
    * @includeExample events/KeyEvent3D.ts
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    * @see egret3d.Input
    * @version Egret 3.0
    * @platform Web,Native
    */
    var KeyEvent3D = (function (_super) {
        __extends(KeyEvent3D, _super);
        function KeyEvent3D() {
            _super.apply(this, arguments);
            /**
             * @language zh_CN
             * 按键code值
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.keyCode = 0;
        }
        /**
         * @language zh_CN
         * KEY_CLICK 常量定义 onKeyClick 事件对象的 type 属性的值。
         * @version Egret 3.0
         * @platform Web,Native
         */
        KeyEvent3D.KEY_CLICK = "onKeyClick";
        /**
         * @language zh_CN
         * KEY_DOWN 常量定义 onKeyDown 事件对象的 type 属性的值。
         * @version Egret 3.0
         * @platform Web,Native
         */
        KeyEvent3D.KEY_DOWN = "onKeyDown";
        /**
         * @language zh_CN
         * KEY_UP 常量定义 onKeyUp 事件对象的 type 属性的值。
         * @version Egret 3.0
         * @platform Web,Native
         */
        KeyEvent3D.KEY_UP = "onKeyUp";
        return KeyEvent3D;
    }(egret3d.Event3D));
    egret3d.KeyEvent3D = KeyEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * 设备的方向(设备横向持有或纵向持有)。
     * @version Egret 3.0
     * @platform Web,Native
     */
    (function (Orientation) {
        /**
         * 设备纵向持有0°,即纵向主方向。
         * @version Egret 3.0
         * @platform Web,Native
         */
        Orientation[Orientation["Portrait_Primary"] = 0] = "Portrait_Primary";
        /**
         * 设备纵向持有180°，即纵向次方向
         * @version Egret 3.0
         * @platform Web,Native
         */
        Orientation[Orientation["Portrait_Secondary"] = 180] = "Portrait_Secondary";
        /**
         * 设备横向持有-90°,即横向主方向。
         * @version Egret 3.0
         * @platform Web,Native
         */
        Orientation[Orientation["Landscape_Primary"] = -90] = "Landscape_Primary";
        /**
        * 设备横向持有90°,即横向次方向。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Orientation[Orientation["Landscape_Secondary"] = 90] = "Landscape_Secondary";
    })(egret3d.Orientation || (egret3d.Orientation = {}));
    var Orientation = egret3d.Orientation;
    /**
    * @language zh_CN
    * @class egret3d.MouseEvent3D
    * @classdesc
    * OrientationEvent3D 是所有引擎中可重力感应事件节点的事件类型标记。
    * 只有Input.addEventListener 才会产生下类事件
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    * @see egret3d.Input
    * @version Egret 3.0
    * @platform Web,Native
    */
    var OrientationEvent3D = (function (_super) {
        __extends(OrientationEvent3D, _super);
        function OrientationEvent3D() {
            _super.apply(this, arguments);
        }
        Object.defineProperty(OrientationEvent3D.prototype, "orientation", {
            /**
             * @language zh_CN
             * 获取设备的方向枚举值,枚举值为其对应角度
             * @return {Orientation} 设备的方向枚举值
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                var value = window.orientation;
                return value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrientationEvent3D.prototype, "acceleration", {
            /**
             * @language zh_CN
             * 获取排除重力影响的加速度
             * @return {DeviceAcceleration} 加速度,单位是m/s2
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._acceleration;
            },
            /**
             * @language zh_CN
             * 设置排除重力影响的加速度
             * @param deviceAcceleration {DeviceAcceleration} 加速度,单位是m/s2。
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (deviceAcceleration) {
                this._acceleration = deviceAcceleration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrientationEvent3D.prototype, "accelerationIncludingGravity", {
            /**
            * @language zh_CN
            * 获取受到重力影响的加速度
            * @return {DeviceAcceleration} 加速度,单位是m/s2
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._accelerationIncludingGravity;
            },
            /**
            * @language zh_CN
            * 设置受到重力影响的加速度
            * @param deviceAcceleration {DeviceAcceleration} 加速度,单位是m/s2。
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (deviceAcceleration) {
                this._accelerationIncludingGravity = deviceAcceleration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrientationEvent3D.prototype, "rotationRate", {
            /**
             * @language zh_CN
             * 获取旋转角度的变化速率
             * @return {DeviceAcceleration} 旋转速率,单位是deg/s。
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._rotationRate;
            },
            /**
             * @language zh_CN
             * 设置旋转速率
             * @param deviceRotationRate {DeviceRotationRate} 旋转速率,单位是deg/s。
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (deviceRotationRate) {
                this._rotationRate = deviceRotationRate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrientationEvent3D.prototype, "absolute", {
            /**
             * @language zh_CN
             * 获取是否是绝对旋转重力方向
             * @return {boolean}。
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._absolute;
            },
            /**
             * @language zh_CN
             * 设置是否是绝对旋转重力方向
             * @param value {boolean}。
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this._absolute = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrientationEvent3D.prototype, "alpha", {
            /**
             * @language zh_CN
             * 获取Alpha旋转，围绕Z轴旋转，即水平方向旋转
             * @return {number} 旋转角度。
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._alpha;
            },
            /**
             * @language zh_CN
             * 设置Alpha旋转，围绕Z轴旋转，即水平方向旋转
             * @param value {number} 旋转角度。
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this._alpha = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrientationEvent3D.prototype, "beta", {
            /**
             * @language zh_CN
             * 获取Beta旋转，围绕X轴旋转，即前后方向旋转
             * @return {number} 旋转角度。
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._beta;
            },
            /**
             * @language zh_CN
             * 设置Beta旋转，围绕X轴旋转，即前后方向旋转
             * @param value {number} 旋转角度。
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this._beta = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrientationEvent3D.prototype, "gamma", {
            /**
             * @language zh_CN
             * 获取Gamma旋转，围绕Y轴旋转，即左右方向旋转
             * @return {number} 旋转角度。
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._gamma;
            },
            /**
             * @language zh_CN
             * 设置Gamma旋转，围绕Y轴旋转，即左右方向旋转
             * @param value {number} 旋转角度。
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this._gamma = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         * ORIENTATION_CHANGE 常量定义 onOrientationChange 事件对象的 type 属性的值。
         * @version Egret 3.0
         * @platform Web,Native
         */
        OrientationEvent3D.ORIENTATION_CHANGE = "onOrientationChange";
        /**
         * @language zh_CN
         * DEVICE_MOTION 常量定义 onDeviceMotion 事件对象的 type 属性的值。
         * @version Egret 3.0
         * @platform Web,Native
         */
        OrientationEvent3D.DEVICE_MOTION = "onDeviceMotion";
        /**
         * @language zh_CN
         * DEVICE_ORIENTATION 常量定义 onDeviceOrientation 事件对象的 type 属性的值。
         * @version Egret 3.0
         * @platform Web,Native
         */
        OrientationEvent3D.DEVICE_ORIENTATION = "onDeviceOrientation";
        return OrientationEvent3D;
    }(egret3d.Event3D));
    egret3d.OrientationEvent3D = OrientationEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.LoaderEvent3D
    * @classdesc
    * LoaderEvent3D 使用URLLoader加载资源的事件返回对象
    * 只有URLLoader对象调用addEventListener 才会产生下类事件
    * @includeExample events/LoaderEvent3D.ts
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    @ @see egret3d.URLLoader
    * @version Egret 3.0
    * @platform Web,Native
    */
    var LoaderEvent3D = (function (_super) {
        __extends(LoaderEvent3D, _super);
        function LoaderEvent3D() {
            _super.apply(this, arguments);
        }
        /**
        * @language zh_CN
        * LOADER_COMPLETE 常量定义 onLoadComplete 事件对象的 type 属性的值。
        * 加载完成后事件响应
        * @version Egret 3.0
        * @platform Web,Native
        */
        LoaderEvent3D.LOADER_COMPLETE = "onLoadComplete";
        /**
        * @language zh_CN
        * LOADER_PROGRESS 常量定义 onLoadProgress 事件对象的 type 属性的值。
        * 加载过程中事件响应
        * @version Egret 3.0
        * @platform Web,Native
        */
        LoaderEvent3D.LOADER_PROGRESS = "onLoadProgress";
        /**
        * @language zh_CN
        * LOADER_ERROR 常量定义 onLoadError 事件对象的 type 属性的值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        LoaderEvent3D.LOADER_ERROR = "onLoadError";
        return LoaderEvent3D;
    }(egret3d.Event3D));
    egret3d.LoaderEvent3D = LoaderEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParserEvent3D
    * @classdesc
    * ParserEvent3D 使用ParserUtils加载资源的事件返回对象
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParserEvent3D = (function (_super) {
        __extends(ParserEvent3D, _super);
        function ParserEvent3D() {
            _super.apply(this, arguments);
        }
        /**
         * @language zh_CN
         * PARSER_COMPLETE 常量定义 onParserComplete 事件对象的 type 属性的值。
         * @version Egret 3.0
         * @platform Web,Native
         */
        ParserEvent3D.PARSER_COMPLETE = "onParserComplete";
        return ParserEvent3D;
    }(egret3d.Event3D));
    egret3d.ParserEvent3D = ParserEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.ParticleEvent3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleEvent3D = (function (_super) {
        __extends(ParticleEvent3D, _super);
        function ParticleEvent3D() {
            _super.apply(this, arguments);
        }
        /**
         * @language zh_CN
         * EMIT_PARTICLE_BIRTH 常量定义 一个子粒子出生
         * @version Egret 3.0
         * @platform Web,Native
         */
        ParticleEvent3D.EMIT_PARTICLE_BIRTH = "EMIT_PARTICLE_BIRTH";
        /**
         * @language zh_CN
         * EMIT_PARTICLE_DEATH 常量定义 一个子粒子死亡
         * @version Egret 3.0
         * @platform Web,Native
         */
        ParticleEvent3D.EMIT_PARTICLE_DEATH = "EMIT_PARTICLE_DEATH";
        return ParticleEvent3D;
    }(egret3d.Event3D));
    egret3d.ParticleEvent3D = ParticleEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.EventDispatcher
    * @classdesc
    * EventDispatcher 类是可调度事件的所有类的基类。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EventDispatcher = (function () {
        function EventDispatcher() {
            /**
             * @language zh_CN
             * @private
             */
            this.listeners = {};
        }
        /**
         * @language zh_CN
         * 派发一个 Event3D 事件到所有注册了特定类型侦听器的对象中。
         * @param event {any} 事件类型。
         * @version Egret 3.0
         * @platform Web,Native
         */
        EventDispatcher.prototype.dispatchEvent = function (event3D) {
            var list = this.listeners[event3D.eventType];
            if (list != null) {
                list = list.slice();
                for (var i = 0; i < list.length; i++) {
                    var listener = list[i];
                    try {
                        listener.handler.call(listener.thisObject, event3D);
                    }
                    catch (error) {
                        if (window.console) {
                            console.error(error.stack);
                        }
                    }
                }
            }
        };
        /**
        * @language zh_CN
        * 使用 EventDispatcher 对象注册事件侦听器对象，以使侦听器能够接收事件通知。可以为特定类型的事件和优先级注册事件侦听器。成功注册一个事件侦听器后，无法通过额外调用 addEventListener() 来更改其优先级。要更改侦听器的优先级，必须首先调用 removeEventListener()。然后，可以使用新的优先级再次注册该侦听器。
        * @param type {string} 事件的类型。
        * @param callback {Function} 处理事件的侦听器函数。此函数必须接受 Event3D 对象作为其唯一的参数，并且不能返回任何结果，
        * 如下面的示例所示： function(evt:Event3D):void 函数可以有任何名称。
        * @param  priority {number} 事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在
        * 优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
         * @version Egret 3.0
         * @platform Web,Native
        */
        EventDispatcher.prototype.addEventListener = function (type, callback, thisObject, priolity) {
            if (priolity === void 0) { priolity = 0; }
            if (this.listeners[type] == null) {
                this.listeners[type] = [];
            }
            var listener = new EventListener(type, thisObject, callback, priolity);
            listener.id = ++EventListener.event_id_count;
            this.listeners[type].push(listener);
            this.listeners[type].sort(function (listener1, listener2) {
                return listener2.priolity - listener1.priolity;
            });
            return listener.id;
        };
        /**
         * @language zh_CN
         * 移除事件侦听器。
         * @param type {string} 事件名。
         * @param callback {Function} 侦听函数。
         * @version Egret 3.0
         * @platform Web,Native
         */
        EventDispatcher.prototype.removeEventListener = function (type, callback, thisObject) {
            if (this.hasEventListener(type, thisObject, callback)) {
                for (var i = 0; i < this.listeners[type].length; i++) {
                    var listener = this.listeners[type][i];
                    if (listener.equalCurrentListener(type, thisObject, callback)) {
                        listener.handler = null;
                        listener.thisObject = null;
                        this.listeners[type].splice(i, 1);
                        return;
                    }
                }
            }
        };
        /**
         * @language zh_CN
         * 移除事件侦听器。
         * @param id  事件id, addEventListener 的返回值.
         * @version Egret 3.0
         * @platform Web,Native
         */
        EventDispatcher.prototype.removeEventListenerAt = function (id) {
            for (var key in this.listeners) {
                for (var i = 0; i < this.listeners[key].length; i++) {
                    var listener = this.listeners[key][i];
                    if (listener.id == id) {
                        listener.handler = null;
                        listener.thisObject = null;
                        this.listeners[key].splice(i, 1);
                        return;
                    }
                }
            }
        };
        /**
         * @language zh_CN
         * 移除所有事件侦听器。
         * @version Egret 3.0
         * @platform Web,Native
         */
        EventDispatcher.prototype.clearEventListener = function () {
            this.listeners = {};
        };
        /**
        * @language zh_CN
        * 检测是否存在监听器。
        * @param type {string}
        * @returns {boolean}
         * @version Egret 3.0
         * @platform Web,Native
        */
        EventDispatcher.prototype.containEventListener = function (type) {
            if (this.listeners[type] == null)
                return false;
            return this.listeners[type].length > 0;
        };
        /**
        * @language zh_CN
        * 检测是否存在监听器。
        * @param type {string} 事件名
        * @param callback {Function} 处理事件的侦听器函数
        * @returns {boolean}
        * @version Egret 3.0
        * @platform Web,Native
        */
        EventDispatcher.prototype.hasEventListener = function (type, thisObject, callback) {
            if (this.listeners[type] == null)
                return false;
            for (var i = 0; i < this.listeners[type].length; i++) {
                var listener = this.listeners[type][i];
                if (listener.equalCurrentListener(type, thisObject, callback)) {
                    return true;
                }
            }
            return false;
        };
        return EventDispatcher;
    }());
    egret3d.EventDispatcher = EventDispatcher;
    /**
    *
    * @language zh_CN
    * @class egret3d.EventListener
    * @classdesc
    * EventListener 类 用于添加或删除事件侦听器。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EventListener = (function () {
        /**
        * @language zh_CN
        * @param type 事件的类型。
        * @param handler 处理事件的侦听器函数
        * @param  priority 事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在
        * 优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function EventListener(type, thisObject, handler, priolity) {
            if (type === void 0) { type = null; }
            if (thisObject === void 0) { thisObject = null; }
            if (handler === void 0) { handler = null; }
            if (priolity === void 0) { priolity = 0; }
            this.type = type;
            this.thisObject = thisObject;
            this.handler = handler;
            this.priolity = priolity;
        }
        /**
        * @language zh_CN
        * 比较两个事件是否相等。
        * @param type {string} 事件的类型。
        * @param handler {Function} 处理事件的侦听器函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        EventListener.prototype.equalCurrentListener = function (type, thisObject, handler) {
            if (this.type == type && this.thisObject == thisObject && this.handler == handler) {
                return true;
            }
            return false;
        };
        /**
        * @private
        */
        EventListener.event_id_count = 0;
        return EventListener;
    }());
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.EventManager
    * @classdesc
    * 事件管理。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EventManager = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @param canvas 画布
        * @version Egret 3.0
        * @platform Web,Native
        */
        function EventManager(canvas) {
            this._retRenderList = new Array();
            this._canvas = canvas;
            this._pickEvent3d = new egret3d.PickEvent3D();
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_CLICK, this.onMouseClick, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_DOWN, this.onMouseDown, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.onMouseUp, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_MOVE, this.onMouseMove, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_START, this.onTouchDown, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_END, this.onTouchUp, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_MOVE, this.onTouchMove, this);
        }
        Object.defineProperty(EventManager.prototype, "_view3ds", {
            get: function () {
                return this._canvas.view3Ds;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 清理EventManager
        * @version Egret 3.0
        * @platform Web,Native
        */
        EventManager.prototype.onClear = function () {
            this._canvas = null;
        };
        /**
        * @language zh_CN
        * 清除绑定关系。
        * @version Egret 3.0
        * @platform Web,Native
        */
        EventManager.prototype.onClearListeners = function () {
        };
        /**
         * @language zh_CN
         * 分发事件。
         * @param e {any} 事件参数
         * @param typeStr {string} 事件类型
         * @version Egret 3.0
         * @platform Web,Native
         */
        EventManager.prototype.sendEvent = function (e, typeStr, func) {
            var canvas = this._canvas;
            if (!canvas) {
                return;
            }
            for (var i = 0; i < this._view3ds.length; i++) {
                var view = this._view3ds[i];
                if (!view.entityCollect || !view.entityCollect.mousePickList) {
                    continue;
                }
                var collect = view.entityCollect.mousePickList;
                var ret = egret3d.Picker.pickObject3DList(canvas, view, collect, false, this._retRenderList);
                var len = ret.length;
                if (len <= 0) {
                    continue;
                }
                var render = null;
                var dis = Number.MAX_VALUE;
                var temp_dis = 0;
                var object3d = null;
                var mouseChilder = false;
                for (var j = 0; j < len; j++) {
                    object3d = ret[j];
                    temp_dis = egret3d.Vector3D.distance(object3d.globalPosition, view.camera3D.globalPosition);
                    if (temp_dis < dis) {
                        dis = temp_dis;
                        render = ret[j];
                    }
                    if (object3d.mouseChilder) {
                        mouseChilder = object3d.mouseChilder;
                    }
                }
                if (ret.length > 0) {
                    if (ret.length == 1 && render) {
                        render.dispatchEvent(func.call(this, typeStr, e, render));
                    }
                    else {
                        if (mouseChilder) {
                            ret = egret3d.Picker.pickObject3DList(canvas, view, ret, true, this._retRenderList);
                            dis = Number.MAX_VALUE;
                            len = ret.length;
                            if (len <= 0) {
                                if (render) {
                                    render.dispatchEvent(func.call(this, typeStr, e, render));
                                }
                            }
                            else {
                                render = null;
                                for (var j = 0; j < len; j++) {
                                    object3d = ret[j];
                                    temp_dis = egret3d.Vector3D.distance(object3d.globalPosition, view.camera3D.globalPosition);
                                    if (temp_dis < dis) {
                                        dis = temp_dis;
                                        render = ret[j];
                                    }
                                }
                                if (render) {
                                    render.dispatchEvent(func.call(this, typeStr, e, render));
                                }
                            }
                        }
                        else {
                            if (render) {
                                render.dispatchEvent(func.call(this, typeStr, e, render));
                            }
                        }
                    }
                }
            }
        };
        EventManager.prototype.initPickEvent3D = function (typeStr, e, render) {
            this._pickEvent3d.eventType = typeStr;
            this._pickEvent3d.target = render;
            this._pickEvent3d.data = e;
            this._pickEvent3d.pickResult = render.pickResult;
            return this._pickEvent3d;
        };
        EventManager.prototype.onTouchMove = function (e) {
            this.sendEvent(e, egret3d.PickEvent3D.PICK_MOVE, this.initPickEvent3D);
        };
        EventManager.prototype.onTouchUp = function (e) {
            this.sendEvent(e, egret3d.PickEvent3D.PICK_UP, this.initPickEvent3D);
        };
        EventManager.prototype.onTouchDown = function (e) {
            this.sendEvent(e, egret3d.PickEvent3D.PICK_DOWN, this.initPickEvent3D);
        };
        EventManager.prototype.onMouseClick = function (e) {
            this.sendEvent(e, egret3d.PickEvent3D.PICK_CLICK, this.initPickEvent3D);
        };
        EventManager.prototype.onMouseDown = function (e) {
            this.sendEvent(e, egret3d.PickEvent3D.PICK_DOWN, this.initPickEvent3D);
        };
        EventManager.prototype.onMouseUp = function (e) {
            this.sendEvent(e, egret3d.PickEvent3D.PICK_UP, this.initPickEvent3D);
        };
        EventManager.prototype.onMouseMove = function (e) {
            this.sendEvent(e, egret3d.PickEvent3D.PICK_MOVE, this.initPickEvent3D);
        };
        return EventManager;
    }());
    egret3d.EventManager = EventManager;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @private
    * @class egret3d.ShaderBase
    * @classdesc
    * shader 基类
    */
    var ShaderBase = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param materialData
        * @param usage
        */
        function ShaderBase(type) {
            this.index = 0;
            this.shadersName = new Array();
            this.endShadername = "";
            this.stateChange = false;
            /**
            * @language zh_CN
            *
            */
            this.maxBone = 0;
            this.shaderType = -1;
            this.shaderType = type;
        }
        /**
        * @language zh_CN
        *
        * @param shaderName xxx
        */
        ShaderBase.prototype.addUseShaderName = function (shaderName) {
            this.shadersName.push(shaderName);
        };
        /**
        * @language zh_CN
        *
        * @param shaderName xxx
        */
        ShaderBase.prototype.addEndShaderName = function (shaderName) {
            this.endShadername = shaderName;
        };
        /**
        * @language zh_CN
        *
        * @returns string
        */
        ShaderBase.prototype.getShader = function (passUsage) {
            if (this.endShadername != "") {
                var index = this.shadersName.indexOf(this.endShadername);
                if (index == -1) {
                    this.shadersName.push(this.endShadername);
                }
            }
            return egret3d.ShaderUtil.instance.fillShaderContent(this, this.shadersName, passUsage);
        };
        return ShaderBase;
    }());
    egret3d.ShaderBase = ShaderBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.VarRegister
        * @classdesc
        * shader 变量 基类
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var VarRegister = (function () {
            function VarRegister() {
                /**
                * @language zh_CN
                * 值名字
                */
                this.varName = ""; /// a
                /**
                * @language zh_CN
                * 变量名
                */
                this.name = ""; /// a[0]
                /**
                * @language zh_CN
                * 变量属性类型
                */
                this.key = ""; /// att varying uniform
                /**
                * @language zh_CN
                * 变量类型
                */
                this.valueType = ""; /// float vec2 vec3 vec4 int int2 int3 int4
                /**
                * @language zh_CN
                * 变量值
                */
                this.value = ""; /// var value
                /**
                * @language zh_CN
                * active Texture Index
                */
                this.activeTextureIndex = -1;
                /**
                * @language zh_CN
                * index
                */
                this.index = -1;
                /**
                * @language zh_CN
                * level
                */
                this.level = "";
                this.size = 0;
                this.dataType = 0;
                this.normalized = false;
                this.stride = 0;
                this.offset = 0;
                this.offsetIndex = 0;
                this.offsetBytes = 0;
            }
            /**
            * @language zh_CN
            * 得到组合后的字符串
            * @param compoments
            */
            VarRegister.prototype.var = function (compoments) {
                return this.level + " " + this.valueType + " " + name + "." + compoments;
            };
            /**
            * @language zh_CN
            *
            * @param compoments
            */
            VarRegister.prototype.use = function (compoments) {
                if (compoments === void 0) { compoments = ""; }
                if (compoments != "")
                    return this.name + "." + compoments;
                return this.name;
            };
            /**
            * @language zh_CN
            *
            * @returns VarRegister
            */
            VarRegister.prototype.clone = function () {
                var temp = new VarRegister();
                temp.name = this.name;
                temp.valueType = this.valueType;
                temp.level = this.level;
                temp.varName = this.varName;
                temp.value = this.value;
                return temp;
            };
            VarRegister.prototype.computeVarName = function () {
                var index = this.name.indexOf("[");
                if (index >= 0) {
                    this.varName = this.name.substr(0, index);
                }
                else {
                    this.varName = this.name;
                }
            };
            return VarRegister;
        }());
        GLSL.VarRegister = VarRegister;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.Attribute
        * @classdesc
        * 变量属性
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Attribute = (function (_super) {
            __extends(Attribute, _super);
            /**
            * @language zh_CN
            * constructor
            * @param name
            * @param valueType
            */
            function Attribute(name, valueType) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "attribute";
                this.valueType = valueType;
            }
            return Attribute;
        }(GLSL.VarRegister));
        GLSL.Attribute = Attribute;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.AttributeType
        * @classdesc
        *
        * shader中的变量属性类型
        * @version Egret 3.0
        * @platform Web,Native
        */
        var AttributeType = (function () {
            function AttributeType() {
            }
            /**
            * shader int类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.int = "int";
            /**
            * shader float类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.float = "float";
            /**
            * shader vec2类型 两个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.vec2 = "vec2";
            /**
            * shader vec3类型 三个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.vec3 = "vec3";
            /**
            * shader vec4类型 四个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.vec4 = "vec4";
            /**
            * shader 2x2 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.mat2 = "mat2";
            /**
            * shader 3x3 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.mat3 = "mat3";
            /**
            * shader 4x4 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.mat4 = "mat4";
            return AttributeType;
        }());
        GLSL.AttributeType = AttributeType;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.ConstVar
        * @classdesc
        * shader中常量类型变量的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var ConstVar = (function (_super) {
            __extends(ConstVar, _super);
            /**
            * @language zh_CN
            * 构造
            * @param name 常量名
            * @param valueType 常量类型
            * @param value 常量的值
            */
            function ConstVar(name, valueType, value) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "const";
                this.valueType = valueType;
                this.value = value;
            }
            return ConstVar;
        }(GLSL.VarRegister));
        GLSL.ConstVar = ConstVar;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.Sampler2D
        * @classdesc
        *
        * shader中sampler2D类型变量的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Sampler2D = (function (_super) {
            __extends(Sampler2D, _super);
            /**
            * @language zh_CN
            * 构造
            * @param name 变量名
            */
            function Sampler2D(name) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "sampler2D";
                ///this.valueType = valueType;
            }
            return Sampler2D;
        }(GLSL.VarRegister));
        GLSL.Sampler2D = Sampler2D;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @private
        * @class egret3d.Sampler3D
        * @classdesc
        *
        * shader中samplerCube类型变量的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Sampler3D = (function (_super) {
            __extends(Sampler3D, _super);
            /**
            * @language zh_CN
            * 构造
            * @param name 变量名
            */
            function Sampler3D(name) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "samplerCube";
            }
            return Sampler3D;
        }(GLSL.VarRegister));
        GLSL.Sampler3D = Sampler3D;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.TmpVar
        * @classdesc
        *
        * shader中临时变量类型的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var TmpVar = (function (_super) {
            __extends(TmpVar, _super);
            /**
            * @language zh_CN
            * 构造
            * @param name 变量名
            * @param valueType 变量类型
            */
            function TmpVar(name, valueType) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "";
                this.valueType = valueType;
            }
            return TmpVar;
        }(GLSL.VarRegister));
        GLSL.TmpVar = TmpVar;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.Uniform
        * @classdesc
        *
        * shader中uniform类型的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Uniform = (function (_super) {
            __extends(Uniform, _super);
            /**
            * @language zh_CN
            * 创建一个Uniform对象
            * @param name 变量名
            * @param valueType 变量类型
            */
            function Uniform(name, valueType) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "uniform";
                this.valueType = valueType;
            }
            return Uniform;
        }(GLSL.VarRegister));
        GLSL.Uniform = Uniform;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.UniformType
        * @classdesc
        * shader Uniform 变量的类型
        */
        var UniformType = (function () {
            function UniformType() {
            }
            /**
            * shader bool类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.bool = "bool";
            /**
            * shader int类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.int = "int";
            /**
            * shader float类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.float = "float";
            /**
            * shader vec2类型 两个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.vec2 = "vec2";
            /**
            * shader vec3类型 三个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.vec3 = "vec3";
            /**
            * shader vec4类型 四个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.vec4 = "vec4";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.bvec2 = "bvec2";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.bvec3 = "bvec3";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.bvec4 = "bvec4";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.ivec2 = "ivec2";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.ivec3 = "ivec3";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.ivec4 = "ivec4";
            /**
            * shader 2x2 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.mat2 = "mat2";
            /**
            * shader 3x3 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.mat3 = "mat3";
            /**
            * shader 4x4 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.mat4 = "mat4";
            /**
            * shader 贴图对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.sampler2D = "sampler2D";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.sampleCube = "sampleCube";
            return UniformType;
        }());
        GLSL.UniformType = UniformType;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.VarConstName
        * @classdesc
        * shader 变量 名字定义
        * 用户在写自定义shader时，按照引擎中已经列取出来的变量名进行命名
        */
        var VarConstName = (function () {
            function VarConstName() {
            }
            VarConstName.attribute_position = "attribute_position";
            VarConstName.attribute_normal = "attribute_normal";
            VarConstName.attribute_tangent = "attribute_tangent";
            VarConstName.attribute_vertexColor = "attribute_vertexColor";
            VarConstName.attribute_uv0 = "attribute_uv0";
            VarConstName.attribute_uv1 = "attribute_uv1";
            VarConstName.varying_pos = "varying_pos";
            VarConstName.varying_normal = "varying_normal";
            VarConstName.varying_tangent = "varying_tangent";
            VarConstName.varying_color = "varying_color";
            VarConstName.varying_uv0 = "varying_uv0";
            VarConstName.varying_uv1 = "varying_uv1";
            VarConstName.varying_globalPos = "varying_globalPos";
            VarConstName.varying_lightDir = "varying_lightDir";
            VarConstName.varying_eye = "varying_eye";
            VarConstName.uniform_floatv_0 = "uniform_floatv_0";
            VarConstName.uniform_floatv_1 = "uniform_floatv_1";
            VarConstName.uniform_floatv_2 = "uniform_floatv_2";
            VarConstName.uniform_iv_0 = "uniform_iv_0";
            VarConstName.uniform_iv_1 = "uniform_iv_1";
            VarConstName.uniform_iv_2 = "uniform_iv_2";
            VarConstName.uniform_bv_0 = "uniform_bv_0";
            VarConstName.uniform_bv_1 = "uniform_bv_1";
            VarConstName.uniform_bv_2 = "uniform_bv_2";
            VarConstName.uniform_vec2fv_0 = "uniform_vec2fv_0";
            VarConstName.uniform_vec2fv_1 = "uniform_vec2fv_1";
            VarConstName.uniform_vec2fv_2 = "uniform_vec2fv_2";
            VarConstName.uniform_vec3fv_0 = "uniform_vec3fv_0";
            VarConstName.uniform_vec3fv_1 = "uniform_vec3fv_1";
            VarConstName.uniform_vec3fv_2 = "uniform_vec3fv_2";
            VarConstName.uniform_vec4fv_0 = "uniform_vec4fv_0";
            VarConstName.uniform_vec4fv_1 = "uniform_vec4fv_1";
            VarConstName.uniform_vec4fv_2 = "uniform_vec4fv_2";
            VarConstName.uniform_vec2iv_0 = "uniform_vec2iv_0";
            VarConstName.uniform_vec2iv_1 = "uniform_vec2iv_1";
            VarConstName.uniform_vec2iv_2 = "uniform_vec2iv_2";
            VarConstName.uniform_vec3iv_0 = "uniform_vec3iv_0";
            VarConstName.uniform_vec3iv_1 = "uniform_vec3iv_1";
            VarConstName.uniform_vec3iv_2 = "uniform_vec3iv_2";
            VarConstName.uniform_vec4iv_0 = "uniform_vec4iv_0";
            VarConstName.uniform_vec4iv_1 = "uniform_vec4iv_1";
            VarConstName.uniform_vec4iv_2 = "uniform_vec4iv_2";
            VarConstName.uniform_vec2bv_0 = "uniform_vec2bv_0";
            VarConstName.uniform_vec2bv_1 = "uniform_vec2bv_1";
            VarConstName.uniform_vec2bv_2 = "uniform_vec2bv_2";
            VarConstName.uniform_vec3bv_0 = "uniform_vec3bv_0";
            VarConstName.uniform_vec3bv_1 = "uniform_vec3bv_1";
            VarConstName.uniform_vec3bv_2 = "uniform_vec3bv_2";
            VarConstName.uniform_vec4bv_0 = "uniform_vec4bv_0";
            VarConstName.uniform_vec4bv_1 = "uniform_vec4bv_1";
            VarConstName.uniform_vec4bv_2 = "uniform_vec4bv_2";
            VarConstName.uniform_modelMatrix = "uniform_modelMatrix";
            VarConstName.uniform_projectionMatrix = "uniform_projectionMatrix";
            VarConstName.uniform_normalMatrix = "uniform_normalMatrix";
            VarConstName.uniform_eye = "uniform_eye";
            VarConstName.uniform_lightDir = "uniform_lightDir";
            VarConstName.texture2D_0 = "texture2D_0";
            VarConstName.texture2D_1 = "texture2D_1";
            VarConstName.texture2D_2 = "texture2D_2";
            VarConstName.texture2D_3 = "texture2D_3";
            VarConstName.texture2D_4 = "texture2D_4";
            return VarConstName;
        }());
        GLSL.VarConstName = VarConstName;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.Varying
        * @classdesc
        *
        * shader中varying类型的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Varying = (function (_super) {
            __extends(Varying, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @param name 变量名
            * @param valueType 变量类型
            */
            function Varying(name, valueType) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "varying";
                this.valueType = valueType;
            }
            return Varying;
        }(GLSL.VarRegister));
        GLSL.Varying = Varying;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.Extension
        * @classdesc
        * 变量属性
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Extension = (function (_super) {
            __extends(Extension, _super);
            /**
            * @language zh_CN
            * constructor
            * @param name
            * @param valueType
            */
            function Extension(name) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "#extension";
            }
            return Extension;
        }(GLSL.VarRegister));
        GLSL.Extension = Extension;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.VaryingType
        * @classdesc
        * shader中varying 变量 类型
        * @version Egret 3.0
        * @platform Web,Native
        */
        var VaryingType = (function () {
            function VaryingType() {
            }
            /**
            * shader bool类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.bool = "bool";
            /**
            * shader int类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.int = "int";
            /**
            * shader float类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.float = "float";
            /**
            * shader vec2类型 两个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.vec2 = "vec2";
            /**
            * shader vec3类型 三个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.vec3 = "vec3";
            /**
            * shader vec4类型 四个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.vec4 = "vec4";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.bvec2 = "bvec2";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.bvec3 = "bvec3";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.bvec4 = "bvec4";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.ivec2 = "ivec2";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.ivec3 = "ivec3";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.ivec4 = "ivec4";
            /**
            * shader 2x2 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.mat2 = "mat2";
            /**
            * shader 3x3 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.mat3 = "mat3";
            /**
            * shader 4x4 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.mat4 = "mat4";
            /**
            * shader 贴图对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.sampler2D = "sampler2D";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.sampleCube = "sampleCube";
            return VaryingType;
        }());
        GLSL.VaryingType = VaryingType;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ShaderLib = (function () {
        function ShaderLib() {
        }
        ShaderLib.lib = {
            "alphaMask_fs": "uniform sampler2D maskTexture ; \n" +
                "void main(void){ \n" +
                "float maskAlpha = texture2D( maskTexture , uv_0 ).x; \n" +
                "if(maskAlpha * diffuseColor.w < 0.001){ \n" +
                "discard; \n" +
                "} \n" +
                "materialSource.alpha *= maskAlpha; \n" +
                "} \n",
            "AOMap_fs": "uniform sampler2D aoTexture ; \n" +
                "uniform float aoPower ; \n" +
                "void main(void){ \n" +
                "float ao = texture2D( aoTexture , varying_uv1 ).x ; \n" +
                "diffuseColor.xyz *= (ao * aoPower) ; \n" +
                "} \n",
            "baseShadowPass_fs": "varying vec2 varying_uv0; \n" +
                "varying vec4 varying_ViewPose; \n" +
                "varying vec4 varying_color; \n" +
                "vec4 outColor ; \n" +
                "vec2 uv_0; \n" +
                "void main() { \n" +
                "uv_0 = varying_uv0; \n" +
                "} \n",
            "baseShadowPass_vs": "attribute vec3 attribute_position; \n" +
                "attribute vec2 attribute_uv0; \n" +
                "attribute vec4 attribute_color; \n" +
                "uniform mat4 uniform_ModelViewMatrix ; \n" +
                "uniform mat4 uniform_ProjectionMatrix ; \n" +
                "varying vec4 varying_ViewPose; \n" +
                "varying vec2 varying_uv0; \n" +
                "varying vec4 varying_color; \n" +
                "vec3 e_position = vec3(0.0, 0.0, 0.0); \n" +
                "vec4 outPosition ; \n" +
                "void main(void){ \n" +
                "e_position = attribute_position; \n" +
                "varying_color = attribute_color; \n" +
                "varying_uv0 = attribute_uv0; \n" +
                "} \n",
            "base_fs": "#extension GL_OES_standard_derivatives : enable \n" +
                "varying vec3 varying_eyeNormal  ; \n" +
                "varying vec2 varying_uv0; \n" +
                "varying vec4 varying_ViewPose; \n" +
                "varying vec4 varying_color; \n" +
                "varying vec3 varying_ViewDir ; \n" +
                "uniform mat4 uniform_ViewMatrix ; \n" +
                "vec4 outColor ; \n" +
                "vec4 diffuseColor ; \n" +
                "vec4 specularColor ; \n" +
                "vec4 ambientColor; \n" +
                "vec4 light ; \n" +
                "vec3 normal; \n" +
                "vec2 uv_0; \n" +
                "vec3 flatNormals(vec3 pos) { \n" +
                "vec3 fdx = dFdx(pos); \n" +
                "vec3 fdy = dFdy(pos); \n" +
                "return normalize(cross(fdx, fdy)); \n" +
                "} \n" +
                "void main() { \n" +
                "diffuseColor  = vec4(1.0,1.0,1.0,1.0); \n" +
                "specularColor = vec4(0.0,0.0,0.0,0.0); \n" +
                "ambientColor  = vec4(0.0,0.0,0.0,0.0); \n" +
                "light         = vec4(1.0,1.0,1.0,1.0); \n" +
                "normal = normalize(varying_eyeNormal) ; \n" +
                "uv_0 = varying_uv0; \n" +
                "} \n",
            "base_vs": "attribute vec3 attribute_position; \n" +
                "attribute vec3 attribute_normal; \n" +
                "attribute vec4 attribute_color; \n" +
                "attribute vec2 attribute_uv0; \n" +
                "vec3 e_position = vec3(0.0, 0.0, 0.0); \n" +
                "uniform mat4 uniform_ModelViewMatrix ; \n" +
                "uniform mat4 uniform_ProjectionMatrix ; \n" +
                "uniform vec3 uniform_eyepos ; \n" +
                "varying vec4 varying_ViewPose; \n" +
                "varying vec3 varying_eyeNormal  ; \n" +
                "varying vec2 varying_uv0; \n" +
                "varying vec4 varying_color; \n" +
                "varying vec3 varying_ViewDir ; \n" +
                "vec4 outPosition ; \n" +
                "void main(void){ \n" +
                "e_position = attribute_position; \n" +
                "varying_color = attribute_color; \n" +
                "varying_uv0 = attribute_uv0; \n" +
                "} \n",
            "bezier": "vec2 quadratic_bezier(vec2 A, vec2 B, vec2 C, float t) \n" +
                "{ \n" +
                "vec2 D = mix(A, B, t); \n" +
                "vec2 E = mix(B, C, t); \n" +
                "return mix(D, E, t); \n" +
                "} \n" +
                "vec2 cubic_bezier(vec2 A, vec2 B, vec2 C, vec2 D, float t) \n" +
                "{ \n" +
                "vec2 E = mix(A, B, t); \n" +
                "vec2 F = mix(B, C, t); \n" +
                "vec2 G = mix(C, D, t); \n" +
                "return quadratic_bezier(E, F, G, t); \n" +
                "} \n",
            "bloom_fs": "varying vec2 varying_uv0; \n" +
                "uniform sampler2D diffuseTexture; \n" +
                "void main() \n" +
                "{ \n" +
                "vec2 uv = vec2(varying_uv0.x,1.0-varying_uv0.y); \n" +
                "float dx = 1.0/float(1024.0); \n" +
                "float dy = 1.0/float(1024.0); \n" +
                "vec4 outColor ; \n" +
                "vec4 color = outColor = texture2D(diffuseTexture,uv.xy); \n" +
                "color += texture2D(diffuseTexture,uv.xy+vec2(dx*3.0,0.0)); \n" +
                "color += texture2D(diffuseTexture,uv.xy+vec2(0.0,dy)); \n" +
                "color += texture2D(diffuseTexture,uv.xy+vec2(dx*3.0,dy)); \n" +
                "color += texture2D(diffuseTexture,uv.xy+vec2(0.0,dy*2.0)); \n" +
                "color += texture2D(diffuseTexture,uv.xy+vec2(dx*3.0,dy*2.0)); \n" +
                "color += texture2D(diffuseTexture,uv.xy+vec2(0.0,dy*3.0)); \n" +
                "color += texture2D(diffuseTexture,uv.xy+vec2(dx*3.0,dy*3.0)); \n" +
                "color /= 8.0; \n" +
                "vec4 cout = vec4(0.0,0.0,0.0,0.0); \n" +
                "float lum = color.x * 0.3 + color.y *0.59 + color.z * 0.11; \n" +
                "vec4 p = color*(lum/0.1); \n" +
                "p /= vec4(vec4(1.0,1.0,1.0,0.0)+p); \n" +
                "float luml = (p.x+p.y+p.z)/3.0; \n" +
                "if (luml > 0.8) \n" +
                "{ \n" +
                "cout = color ; \n" +
                "} \n" +
                "gl_FragColor = cout ; \n" +
                "} \n",
            "colorGradients_fs": "varying vec4 varying_pos; \n" +
                "uniform float uniform_colorGradientsSource[10] ; \n" +
                "void main(void){ \n" +
                "vec3 posStart = vec3(uniform_colorGradientsSource[0], uniform_colorGradientsSource[1], uniform_colorGradientsSource[2]); \n" +
                "vec3 posEnd = vec3(uniform_colorGradientsSource[3], uniform_colorGradientsSource[4], uniform_colorGradientsSource[5]); \n" +
                "vec4 color = vec4(uniform_colorGradientsSource[6], uniform_colorGradientsSource[7], uniform_colorGradientsSource[8], uniform_colorGradientsSource[9]); \n" +
                "color.w = color.w * clamp((varying_pos.y - posStart.y) / (posEnd.y - posStart.y), 0.0, 1.0); \n" +
                "diffuseColor.xyz = clamp(diffuseColor.xyz / diffuseColor.w,0.0,1.0); \n" +
                "diffuseColor.xyz = diffuseColor.xyz * (1.0 - color.w) + color.xyz * color.w; \n" +
                "} \n" +
                "  \n",
            "colorTransform_fs": "uniform vec4 uniform_colorTransformVec4 ; \n" +
                "uniform mat4 uniform_colorTransformM44 ; \n" +
                "void main(){ \n" +
                "diffuseColor = uniform_colorTransformM44 * diffuseColor; \n" +
                "diffuseColor = diffuseColor + uniform_colorTransformVec4; \n" +
                "} \n",
            "color_fragment": "vec4 diffuseColor ; \n" +
                "void main() { \n" +
                "if( diffuseColor.w == 0.0 ){ \n" +
                "discard; \n" +
                "} \n" +
                "diffuseColor = vec4(1.0, 1.0, 1.0, 1.0); \n" +
                "if( diffuseColor.w <= materialSource.cutAlpha ){ \n" +
                "discard; \n" +
                "}else \n" +
                "diffuseColor.xyz *= diffuseColor.w ; \n" +
                "} \n",
            "combin_fs": "uniform sampler2D colorTexture; \n" +
                "void main(void){ \n" +
                "} \n",
            "cube_fragment": "uniform samplerCube diffuseTexture ; \n" +
                "varying vec3 varying_pos; \n" +
                "vec4 diffuseColor ; \n" +
                "void main() { \n" +
                "if( diffuseColor.w == 0.0 ){ \n" +
                "discard; \n" +
                "} \n" +
                "vec3 uvw = normalize(varying_pos.xyz); \n" +
                "diffuseColor = vec4(textureCube(diffuseTexture, uvw.xyz)); \n" +
                "if( diffuseColor.w <= materialSource.cutAlpha ){ \n" +
                "discard; \n" +
                "}else \n" +
                "diffuseColor.xyz *= diffuseColor.w ; \n" +
                "} \n",
            "cube_vertex": "varying vec3 varying_pos; \n" +
                "void main(void){ \n" +
                "varying_pos =  e_position; \n" +
                "}  \n",
            "detail_Bending_vs": "uniform float uniformTime[4] ; \n" +
                "void main(void){ \n" +
                "e_position = attribute_position; \n" +
                "varying_uv0 = attribute_uv0; \n" +
                "varying_color = attribute_color; \n" +
                "vec4 curve = SmoothTriangleWave(vec4(sin(uniformTime[0]*0.001),1.0,1.0,1.0)); \n" +
                "e_position.xyz += curve.x * vec3(1.0,0.5,0.0) * ( attribute_color.xyz) ; \n" +
                "} \n",
            "diffuseShadowPass_fs": "uniform sampler2D diffuseTexture; \n" +
                "vec4 diffuseColor ; \n" +
                "void main() { \n" +
                "diffuseColor = varying_color ; \n" +
                "if( diffuseColor.w == 0.0 ){ \n" +
                "discard; \n" +
                "} \n" +
                "diffuseColor = texture2D(diffuseTexture , uv_0 ); \n" +
                "if( diffuseColor.w <= 0.3 ){ \n" +
                "discard; \n" +
                "} \n" +
                "} \n",
            "diffuse_fragment": "uniform sampler2D diffuseTexture; \n" +
                "vec4 diffuseColor ; \n" +
                "void main() { \n" +
                "if( diffuseColor.w == 0.0 ){ \n" +
                "discard; \n" +
                "} \n" +
                "diffuseColor = texture2D(diffuseTexture , uv_0 ); \n" +
                "if( diffuseColor.w <= materialSource.cutAlpha ){ \n" +
                "discard; \n" +
                "}else \n" +
                "diffuseColor.xyz *= diffuseColor.w ; \n" +
                "} \n",
            "diffuse_vertex": "attribute vec3 attribute_normal; \n" +
                "attribute vec4 attribute_color; \n" +
                "varying vec3 varying_ViewDir ; \n" +
                "uniform mat4 uniform_NormalMatrix; \n" +
                "void main(void){ \n" +
                "mat3 normalMatrix = mat3(uniform_NormalMatrix); \n" +
                "varying_eyeNormal = normalize(normalMatrix * -attribute_normal); \n" +
                "varying_ViewPose = vec4(normalMatrix*e_position, 1.0) ; \n" +
                "varying_ViewDir = normalize(normalMatrix * (uniform_eyepos.xyz - e_position)) ; \n" +
                "outPosition = uniform_ModelViewMatrix * vec4(e_position, 1.0) ; \n" +
                "varying_color = attribute_color; \n" +
                "} \n",
            "directLight_fragment": "const int max_directLight = 0 ; \n" +
                "uniform float uniform_directLightSource[6*max_directLight] ; \n" +
                "varying vec3 varying_ViewDir; \n" +
                "uniform mat4 uniform_NormalMatrix; \n" +
                "struct DirectLight{ \n" +
                "vec3 direction; \n" +
                "vec3 diffuse; \n" +
                "}; \n" +
                "void calculateDirectLight( MaterialSource materialSource ){ \n" +
                "float lambertTerm , specular ; \n" +
                "vec3 N = normal; \n" +
                "for(int i = 0 ; i < max_directLight ; i++){ \n" +
                "DirectLight directLight ; \n" +
                "directLight.direction = vec3(uniform_directLightSource[i*6+0],uniform_directLightSource[i*6+1],uniform_directLightSource[i*6+2]); \n" +
                "directLight.diffuse = vec3(uniform_directLightSource[i*6+3],uniform_directLightSource[i*6+4],uniform_directLightSource[i*6+5]); \n" +
                "vec3 lightDir = -normalize(directLight.direction); \n" +
                "light += LightingBlinnPhong(normalize(lightDir),vec3(1.0,1.0,1.0),normal,-varying_ViewDir,0.5); \n" +
                "} \n" +
                "} \n" +
                "void main() { \n" +
                "calculateDirectLight( materialSource ); \n" +
                "} \n",
            "endShadowPass_fs": "void main() { \n" +
                "if(varying_color.w<=0.0){ \n" +
                "discard; \n" +
                "} \n" +
                "outColor.x =  outColor.y = outColor.z = varying_ViewPose.z/varying_ViewPose.w  ; \n" +
                "outColor.w = 1.0 ; \n" +
                "gl_FragColor = outColor ; \n" +
                "} \n",
            "endShadowPass_vs": "void main() { \n" +
                "outPosition = uniform_ProjectionMatrix * outPosition ; \n" +
                "varying_ViewPose = outPosition ; \n" +
                "gl_Position = outPosition ; \n" +
                "} \n" +
                "                       \n",
            "end_fs": "vec4 diffuseColor ; \n" +
                "vec4 specularColor ; \n" +
                "vec4 ambientColor; \n" +
                "vec4 light ; \n" +
                "void main() { \n" +
                "diffuseColor.xyz = materialSource.diffuse.xyz * diffuseColor.xyz ; \n" +
                "outColor.xyz = light.xyz * diffuseColor.xyz * materialSource.diffuse ; \n" +
                "outColor.w = materialSource.alpha * diffuseColor.w ; \n" +
                "gl_FragColor = outColor * varying_color; \n" +
                "} \n",
            "end_vs": "vec4 endPosition ; \n" +
                "uniform float uniform_materialSource[20]; \n" +
                "void main() { \n" +
                "gl_PointSize = 50.0; \n" +
                "gl_PointSize = uniform_materialSource[18]; \n" +
                "gl_Position = uniform_ProjectionMatrix * outPosition ; \n" +
                "} \n" +
                "                       \n",
            "environmentDiffuse_vertex": "void main(){ \n" +
                "} \n",
            "environmentMapping_fragment": "uniform samplerCube environmentMapTex ; \n" +
                "uniform float reflectValue; \n" +
                "void main(){ \n" +
                "vec3 r = reflect(-normalize(varying_ViewDir),  normal  ); \n" +
                "vec4 reflectiveColor = textureCube(environmentMapTex,r.xyz); \n" +
                "diffuseColor.xyz = mix( diffuseColor.xyz,reflectiveColor.xyz, specularColor.y + reflectValue ); \n" +
                "} \n" +
                "          \n",
            "expFog_fs": "struct Fog{ \n" +
                "vec3 fogColor  ; \n" +
                "float globalDensity ; \n" +
                "vec3 distance ; \n" +
                "}; \n" +
                "varying vec4 varying_pos; \n" +
                "uniform float uniform_globalFog[7]; \n" +
                "void main(void){ \n" +
                "Fog fog; \n" +
                "fog.fogColor = vec3(uniform_globalFog[0],uniform_globalFog[1],uniform_globalFog[2]); \n" +
                "fog.globalDensity = uniform_globalFog[3]; \n" +
                "fog.distance = vec2(uniform_globalFog[4], uniform_globalFog[5]); \n" +
                "float d = distance(uniform_eyepos,varying_pos.xyz); \n" +
                "float distFog = max( 0.0 , d - fog.distance.x )* fog.distance.y; \n" +
                "float fogFactor = (1.0-exp( -distFog * 0.000001 * fog.globalDensity )) ; \n" +
                "diffuseColor.xyz = mix( diffuseColor.xyz  , fog.fogColor , min(fogFactor,1.0) ); \n" +
                "} \n" +
                "  \n",
            "expHeightFog_fs": "struct Fog{ \n" +
                "vec3 fogColor  ; \n" +
                "float globalDensity ; \n" +
                "float fogStartDistance ; \n" +
                "float fogHeightStart ; \n" +
                "float fogAlpha ; \n" +
                "}; \n" +
                "varying vec4 varying_pos; \n" +
                "uniform float uniform_globalFog[7]; \n" +
                "vec3 applyFog( float yDistance, vec3  vpos , Fog fog ) \n" +
                "{ \n" +
                "float d = distance(uniform_eyepos,varying_pos.xyz); \n" +
                "float distFog = max( 0.0 , d - fog.fogStartDistance ) ; \n" +
                "float yFog = max(0.0, (vpos.y - fog.fogHeightStart - yDistance) )  ; \n" +
                "float fogAmount =  1.0-(exp(-distFog * fog.globalDensity )) + (exp(-yFog * fog.globalDensity )); \n" +
                "return mix( diffuseColor.xyz,fog.fogColor, clamp(fogAmount,0.0,fog.fogAlpha) ); \n" +
                "} \n" +
                "void main(void){ \n" +
                "Fog fog; \n" +
                "fog.fogColor = vec3(uniform_globalFog[0],uniform_globalFog[1],uniform_globalFog[2]); \n" +
                "fog.globalDensity = uniform_globalFog[3]; \n" +
                "fog.fogStartDistance = uniform_globalFog[4] ; \n" +
                "fog.fogHeightStart = uniform_globalFog[5] ; \n" +
                "fog.fogAlpha = uniform_globalFog[6] ; \n" +
                "float yd = uniform_eyepos.y - varying_pos.y ; \n" +
                "diffuseColor.xyz = applyFog( yd , varying_pos.xyz , fog ); \n" +
                "} \n" +
                "  \n",
            "flatNormal_fs": "#extension GL_OES_standard_derivatives : enable \n" +
                "vec3 flatNormal(vec3 pos){ \n" +
                "vec3 fdx = dFdx(pos); \n" +
                "vec3 fdy = dFdy(pos); \n" +
                "return normalize(cross(fdx, fdy)); \n" +
                "} \n",
            "gamma_fs": "const float gamma = 2.2; \n" +
                "float toLinear_float_v1(float v) { \n" +
                "return pow(v, gamma); \n" +
                "} \n" +
                "vec2 toLinear_vec2_v1(vec2 v) { \n" +
                "return pow(v, vec2(gamma)); \n" +
                "} \n" +
                "vec3 toLinear_vec3_v1(vec3 v) { \n" +
                "return pow(v, vec3(gamma)); \n" +
                "} \n" +
                "vec4 toLinear_vec4_v1(vec4 v) { \n" +
                "return vec4(toLinear_vec3_v1(v.rgb), v.a); \n" +
                "} \n" +
                "float toGamma_float_v2(float v) { \n" +
                "return pow(v, 1.0 / gamma); \n" +
                "} \n" +
                "vec2 toGamma_vec2_v2(vec2 v) { \n" +
                "return pow(v, vec2(1.0 / gamma)); \n" +
                "} \n" +
                "vec3 toGamma_vec3_v2(vec3 v) { \n" +
                "return pow(v, vec3(1.0 / gamma)); \n" +
                "} \n" +
                "vec4 toGamma_vec4_v2(vec4 v) { \n" +
                "return vec4(toGamma_vec3_v2(v.rgb), v.a); \n" +
                "} \n" +
                "vec4 textureLinear(sampler2D uTex, vec2 uv) { \n" +
                "return toLinear_vec4_v1(texture2D(uTex, uv)); \n" +
                "} \n",
            "gaussian_H_fs": "varying vec2 varying_uv0; \n" +
                "uniform sampler2D diffuseTexture; \n" +
                "void main() \n" +
                "{ \n" +
                "vec2 uv = vec2(varying_uv0.x,1.0-varying_uv0.y); \n" +
                "float d = 1.0/float(1024.0); \n" +
                "vec4 color = vec4(0.0,0.0,0.0,0.0); \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(-8.0*d,0.0))* 0.001; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(-7.0*d,0.0))* 0.105; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(-6.0*d,0.0))* 0.217; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(-5.0*d,0.0))* 0.344; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(-4.0*d,0.0))* 0.492; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(-3.0*d,0.0))* 0.55; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(-2.0*d,0.0))* 0.69; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(-1.0*d,0.0))* 0.70; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy) * 1.0; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(1.0*d,0.0)) * 0.70; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(2.0*d,0.0)) * 0.69; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(3.0*d,0.0)) * 0.55; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(4.0*d,0.0)) * 0.492; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(5.0*d,0.0)) * 0.344; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(6.0*d,0.0)) * 0.217; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(7.0*d,0.0)) * 0.105; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(8.0*d,0.0)) * 0.001; \n" +
                "color /= 8.0; \n" +
                "gl_FragColor = color ; \n" +
                "} \n",
            "gaussian_V_fs": "varying vec2 varying_uv0; \n" +
                "uniform sampler2D diffuseTexture; \n" +
                "uniform sampler2D colorTexture; \n" +
                "void main() \n" +
                "{ \n" +
                "vec2 uv = vec2(varying_uv0.x,1.0-varying_uv0.y); \n" +
                "float d = 1.0/float(1024.0); \n" +
                "vec4 color = vec4(0.0,0.0,0.0,0.0); \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0,-8.0*d)) * 0.001; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0,-7.0*d)) * 0.105; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0,-6.0*d)) * 0.217; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0,-5.0*d)) * 0.344; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0,-4.0*d)) * 0.492; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0,-3.0*d)) * 0.55; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0,-2.0*d)) * 0.69; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0,-1.0*d)) * 0.70; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy) * 1.0; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0, 1.0*d)) * 0.70; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0, 2.0*d)) * 0.69; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0, 3.0*d)) * 0.55; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0, 4.0*d)) * 0.492; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0, 5.0*d)) * 0.344; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0, 6.0*d)) * 0.217; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0, 7.0*d)) * 0.105; \n" +
                "color +=     texture2D(diffuseTexture,uv.xy+vec2(0.0, 8.0*d)) * 0.001; \n" +
                "color /= 8.0; \n" +
                "gl_FragColor = color + texture2D(colorTexture,uv.xy); \n" +
                "} \n",
            "hud_cull_fs": "varying vec2 varying_uv0; \n" +
                "uniform sampler2D diffuseTexture; \n" +
                "uniform vec2 uv_scale; \n" +
                "void main(void) { \n" +
                "vec2 uv_0 = varying_uv0; \n" +
                "uv_0 *= uv_scale; \n" +
                "vec4 color = texture2D(diffuseTexture, varying_uv0); \n" +
                "float mask = 1.0; \n" +
                "float f = uv_scale.y - varying_uv0.y; \n" +
                "if (varying_uv0.y < uv_scale.y){ \n" +
                "if(f < 0.03 && f > 0.0){ \n" +
                "mask =1.0 - (f / 0.03 * 0.9 + 0.1); \n" +
                "} \n" +
                "else{ \n" +
                "mask = 0.1; \n" +
                "} \n" +
                "} \n" +
                "color.xyz *= mask; \n" +
                "gl_FragColor  = color; \n" +
                "} \n",
            "hud_H_fs": "varying vec2 varying_uv0; \n" +
                "uniform sampler2D diffuseTexture; \n" +
                "void main(void) { \n" +
                "vec2 uv = vec2(varying_uv0.x ,1.0-varying_uv0.y); \n" +
                "vec4 color = texture2D(diffuseTexture, uv); \n" +
                "gl_FragColor  = color; \n" +
                "} \n",
            "hud_vs": "attribute vec3 attribute_position; \n" +
                "attribute vec2 attribute_uv0; \n" +
                "varying  vec2 varying_uv0; \n" +
                "uniform  mat4 uniform_ViewProjectionMatrix; \n" +
                "void main(void) { \n" +
                "vec4 pos = vec4(attribute_position, 1.0); \n" +
                "gl_Position = uniform_ViewProjectionMatrix * pos; \n" +
                "varying_uv0 = attribute_uv0; \n" +
                "} \n",
            "hud_V_fs": "varying vec2 varying_uv0; \n" +
                "uniform sampler2D diffuseTexture; \n" +
                "void main(void) { \n" +
                "vec4 color = texture2D(diffuseTexture, varying_uv0); \n" +
                "gl_FragColor  = color; \n" +
                "} \n",
            "lightingBase_fs": "vec4 LightingBlinnPhong(vec3 lightDir, vec3 lightColor , vec3 normal , vec3 viewDir, float atten){ \n" +
                "vec3 ambient = materialSource.ambient ; \n" +
                "float NdotL = clamp(dot (normal, lightDir),0.0,1.0); \n" +
                "vec3 diffuse = lightColor.xyz * NdotL ; \n" +
                "vec3 h = normalize (lightDir + normalize(viewDir)); \n" +
                "float nh = clamp(dot (normal, h),0.0,1.0); \n" +
                "float specPower = pow (nh, materialSource.shininess ) * materialSource.specularScale ; \n" +
                "vec3 specular = lightColor.xyz * specPower * materialSource.specular ; \n" +
                "specularColor.xyz += specular; \n" +
                "vec4 c; \n" +
                "c.rgb = (diffuse+specular+ambient) * (atten * 2.0 ); \n" +
                "c.a = materialSource.alpha + (specPower * atten); \n" +
                "return c; \n" +
                "} \n" +
                "void main(void) { \n" +
                "light.xyzw = vec4(0.0,0.0,0.0,1.0) ; \n" +
                "} \n",
            "lightMapSpecularPower_fs": "uniform sampler2D lightTexture ; \n" +
                "varying vec2 varying_uv1 ; \n" +
                "void main(void){ \n" +
                "vec3 lightmap = texture2D( lightTexture , varying_uv1 ).xyz * 1.5; \n" +
                "diffuseColor.xyz *= lightmap ; \n" +
                "specularColor.xyz *= lightmap; \n" +
                "} \n",
            "lightMap_fs": "uniform sampler2D lightTexture ; \n" +
                "varying vec2 varying_uv1 ; \n" +
                "void main(void){ \n" +
                "vec3 lightmap = texture2D( lightTexture , varying_uv1 ).xyz * 1.5; \n" +
                "diffuseColor.xyz *= lightmap ; \n" +
                "} \n",
            "lineFog": "struct Fog{ \n" +
                "vec3 fogColor  ; \n" +
                "float globalDensity ; \n" +
                "vec3 distance ; \n" +
                "}; \n" +
                "varying vec4 varying_pos; \n" +
                "uniform float uniform_globalFog[7]; \n" +
                "void main(void){ \n" +
                "Fog fog; \n" +
                "fog.fogColor = vec3(uniform_globalFog[0],uniform_globalFog[1],uniform_globalFog[2]); \n" +
                "fog.globalDensity = uniform_globalFog[3]; \n" +
                "fog.distance = vec2(uniform_globalFog[4], uniform_globalFog[5]); \n" +
                "float dist = abs( varying_ViewPose.z ); \n" +
                "float fogFactor = ( fog.distance.y - dist) / (fog.distance.y - fog.distance.x); \n" +
                "fogFactor = clamp( fogFactor, 0.0, 1.0 ); \n" +
                "diffuseColor.xyz = mix( fog.fogColor, diffuseColor.xyz, fogFactor ); \n" +
                "} \n",
            "matCapPass_vs": "varying vec2 capCoord ; \n" +
                "void main(void){ \n" +
                "capCoord.x = dot(normalMatrix[0].xyz,normal); \n" +
                "capCoord.y = dot(normalMatrix[1].xyz,normal); \n" +
                "capCoord = capCoord * 0.5 + 0.5; \n" +
                "ambientColor.xyz +=  + capCoord.xyz * 2.0 - 1.0 ; \n" +
                "} \n",
            "matCap_TextureAdd_fs": "uniform sampler2D matcapTexture; \n" +
                "uniform mat4 uniform_NormalMatrix; \n" +
                "void main() { \n" +
                "vec4 capCoord ; \n" +
                "capCoord.x = -normal.x; \n" +
                "capCoord.y = normal.y; \n" +
                "capCoord.xy = capCoord.xy * 0.5 + 0.5; \n" +
                "capCoord = texture2D(matcapTexture , capCoord.xy ) * 2.0 - 1.0 ; \n" +
                "ambientColor.xyz += capCoord.xyz ; \n" +
                "} \n",
            "matCap_TextureMult_fs": "uniform sampler2D matcapTexture; \n" +
                "uniform mat4 uniform_NormalMatrix; \n" +
                "void main() { \n" +
                "vec4 capCoord ; \n" +
                "capCoord.x = -normal.x; \n" +
                "capCoord.y = normal.y; \n" +
                "capCoord.xy = capCoord.xy * 0.5 + 0.5; \n" +
                "capCoord = texture2D(matcapTexture , capCoord.xy ) ; \n" +
                "diffuseColor.xyz *= capCoord.xyz * 2.0 ; \n" +
                "} \n",
            "materialSource_fs": "struct MaterialSource{ \n" +
                "vec3 diffuse; \n" +
                "vec3 ambient; \n" +
                "vec3 specular; \n" +
                "float alpha; \n" +
                "float cutAlpha; \n" +
                "float shininess; \n" +
                "float roughness; \n" +
                "float albedo; \n" +
                "vec4 uvRectangle; \n" +
                "float specularScale; \n" +
                "float normalScale; \n" +
                "}; \n" +
                "uniform float uniform_materialSource[20] ; \n" +
                "MaterialSource materialSource ; \n" +
                "void main(){ \n" +
                "materialSource.diffuse.x = uniform_materialSource[0]; \n" +
                "materialSource.diffuse.y = uniform_materialSource[1]; \n" +
                "materialSource.diffuse.z = uniform_materialSource[2]; \n" +
                "materialSource.ambient.x = uniform_materialSource[3]; \n" +
                "materialSource.ambient.y = uniform_materialSource[4]; \n" +
                "materialSource.ambient.z = uniform_materialSource[5]; \n" +
                "materialSource.specular.x = uniform_materialSource[6]; \n" +
                "materialSource.specular.y = uniform_materialSource[7]; \n" +
                "materialSource.specular.z = uniform_materialSource[8]; \n" +
                "materialSource.alpha = uniform_materialSource[9]; \n" +
                "materialSource.cutAlpha = uniform_materialSource[10]; \n" +
                "materialSource.shininess = uniform_materialSource[11]; \n" +
                "materialSource.specularScale = uniform_materialSource[12]; \n" +
                "materialSource.albedo = uniform_materialSource[13]; \n" +
                "materialSource.uvRectangle.x = uniform_materialSource[14]; \n" +
                "materialSource.uvRectangle.y = uniform_materialSource[15]; \n" +
                "materialSource.uvRectangle.z = uniform_materialSource[16]; \n" +
                "materialSource.uvRectangle.w = uniform_materialSource[17]; \n" +
                "materialSource.normalScale = uniform_materialSource[19]; \n" +
                "uv_0 = varying_uv0.xy * materialSource.uvRectangle.zw + materialSource.uvRectangle.xy ; \n" +
                "} \n",
            "mulUvRoll_fs": "uniform float mulUvRoll[4] ; \n" +
                "uniform sampler2D diffuseTexture; \n" +
                "uniform sampler2D diffuseTexture1; \n" +
                "vec4 diffuseColor ; \n" +
                "vec2 uv_1; \n" +
                "void main() { \n" +
                "uv_1 = varying_uv0; \n" +
                "uv_0.xy += vec2(mulUvRoll[0],mulUvRoll[1]); \n" +
                "uv_1.xy += vec2(mulUvRoll[2],mulUvRoll[3]); \n" +
                "diffuseColor = texture2D(diffuseTexture , uv_0 ) * texture2D(diffuseTexture1 , uv_1 ); \n" +
                "diffuseColor.xyz = clamp(diffuseColor.xyz / diffuseColor.w,0.0,1.0); \n" +
                "} \n",
            "normalMap_fragment": "uniform sampler2D normalTexture; \n" +
                "varying vec2 varying_uv0        ; \n" +
                "mat3 TBN ; \n" +
                "mat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) { \n" +
                "vec3 dp1 = dFdx(p); \n" +
                "vec3 dp2 = dFdy(p); \n" +
                "vec2 duv1 = dFdx(uv); \n" +
                "vec2 duv2 = dFdy(uv); \n" +
                "vec3 dp2perp = cross(dp2, N); \n" +
                "vec3 dp1perp = cross(N, dp1); \n" +
                "vec3 T = dp2perp * duv1.x + dp1perp * duv2.x; \n" +
                "vec3 B = dp2perp * duv1.y + dp1perp * duv2.y; \n" +
                "float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B))); \n" +
                "return mat3(T * invmax, B * invmax, N); \n" +
                "} \n" +
                "vec3 tbn(vec3 map, vec3 N, vec3 V, vec2 texcoord) { \n" +
                "mat3 TBN = cotangentFrame(N, -V, texcoord); \n" +
                "return normalize(TBN * map); \n" +
                "} \n" +
                "void main(){ \n" +
                "vec3 normalTex = texture2D(normalTexture,uv_0).xyz *2.0 - 1.0; \n" +
                "normalTex.y *= -1.0; \n" +
                "normal.xyz = tbn( normalTex.xyz , normal.xyz , normalize(varying_ViewPose.xyz) , uv_0 ) ; \n" +
                "} \n",
            "particle_bezier": "vec2 bzData[20]; \n" +
                "void dcpBezier(float bezierData[22], float tTotal) \n" +
                "{ \n" +
                "float timeNow = 0.0; \n" +
                "float time1 = bezierData[20] * tTotal; \n" +
                "float time2 = bezierData[21] * tTotal; \n" +
                "for(int i = 0; i < 20; i ++){ \n" +
                "bzData[i].x = timeNow; \n" +
                "bzData[i].y = bezierData[i]; \n" +
                "if(i <= 9){ \n" +
                "timeNow += time1; \n" +
                "}else if(i >= 11){ \n" +
                "timeNow += time2; \n" +
                "} \n" +
                "} \n" +
                "bzData[10].x = bzData[9].x; \n" +
                "} \n" +
                "float calcBezierArea(float tCurrent){ \n" +
                "float res = 0.0; \n" +
                "float v0; \n" +
                "float v1; \n" +
                "float t0; \n" +
                "float t1; \n" +
                "float deltaTime = 0.0; \n" +
                "float a_deltaTime; \n" +
                "for(int i = 0; i < 19; i ++){ \n" +
                "v0 = bzData[i].y; \n" +
                "v1 = bzData[i + 1].y; \n" +
                "t0 = bzData[i].x; \n" +
                "t1 = bzData[i + 1].x; \n" +
                "deltaTime = t1 - t0; \n" +
                "if(deltaTime > 0.0001) \n" +
                "{ \n" +
                "a_deltaTime = 0.5 * (v1 - v0); \n" +
                "if(tCurrent >= t1){ \n" +
                "res += deltaTime * (v0 + a_deltaTime); \n" +
                "}else{ \n" +
                "deltaTime = tCurrent - t0; \n" +
                "res += deltaTime * (v0 + a_deltaTime); \n" +
                "break; \n" +
                "} \n" +
                "} \n" +
                "} \n" +
                "return res; \n" +
                "} \n" +
                "float calcOneBezierArea(float bezierData[22], float tCurrent, float tTotal){ \n" +
                "dcpBezier(bezierData, tTotal); \n" +
                "return calcBezierArea(tCurrent); \n" +
                "} \n" +
                "float calcBezierSize(float tCurrent){ \n" +
                "float res = 0.0; \n" +
                "float y0; \n" +
                "float y1; \n" +
                "float t0; \n" +
                "float t1; \n" +
                "float deltaTime = 0.0; \n" +
                "float v; \n" +
                "for(int i = 0; i < 19; i ++){ \n" +
                "y0 = bzData[i].y; \n" +
                "y1 = bzData[i + 1].y; \n" +
                "t0 = bzData[i].x; \n" +
                "t1 = bzData[i + 1].x; \n" +
                "deltaTime = t1 - t0; \n" +
                "if(deltaTime > 0.0001) \n" +
                "{ \n" +
                "if(tCurrent <= t1){ \n" +
                "v = (y1 - y0) / deltaTime; \n" +
                "deltaTime = tCurrent - t0; \n" +
                "res = y0 + v * deltaTime; \n" +
                "break; \n" +
                "} \n" +
                "} \n" +
                "} \n" +
                "return res; \n" +
                "} \n" +
                "float calcOneBezierSize(float bezierData[22], float tCurrent, float tTotal){ \n" +
                "dcpBezier(bezierData, tTotal); \n" +
                "return calcBezierSize(tCurrent); \n" +
                "} \n",
            "particle_color_fs": "uniform float uniform_colorTransform[40]; \n" +
                "vec3 unpack_color(float rgb_data) \n" +
                "{ \n" +
                "vec3 res; \n" +
                "res.z = fract( rgb_data ); \n" +
                "rgb_data -= res.z; \n" +
                "rgb_data = rgb_data/256.0; \n" +
                "res.y = fract( rgb_data ); \n" +
                "rgb_data -= res.y; \n" +
                "res.x = rgb_data/256.0; \n" +
                "return res; \n" +
                "} \n" +
                "void main() { \n" +
                "float startColor ; \n" +
                "float startSegment ; \n" +
                "float nextColor ; \n" +
                "float nextSegment ; \n" +
                "float startAlpha; \n" +
                "float nextAlpha; \n" +
                "float progress = varying_particleData.x/varying_particleData.y; \n" +
                "const int maxColorCount = 20; \n" +
                "for( int i = 1 ; i < maxColorCount ; i++ ){ \n" +
                "if( progress >= fract(uniform_colorTransform[i+maxColorCount-1]) ){ \n" +
                "startColor = uniform_colorTransform[i-1] ; \n" +
                "startSegment = fract(uniform_colorTransform[i+maxColorCount-1]) ; \n" +
                "nextColor = uniform_colorTransform[i]; \n" +
                "nextSegment = fract(uniform_colorTransform[i+maxColorCount]) ; \n" +
                "startAlpha = uniform_colorTransform[i+maxColorCount-1] - startSegment; \n" +
                "nextAlpha = uniform_colorTransform[i+maxColorCount] - nextSegment; \n" +
                "}else{ \n" +
                "break; \n" +
                "} \n" +
                "} \n" +
                "float len = nextSegment - startSegment ; \n" +
                "float ws = ( progress - startSegment ) / len ; \n" +
                "vec4 color = mix(vec4(unpack_color(startColor).xyz,startAlpha / 256.0),vec4(unpack_color(nextColor).xyz, nextAlpha / 256.0),ws) ; \n" +
                "diffuseColor *= color; \n" +
                "} \n",
            "particle_color_vs": "float particle(  ParticleData curParticle ){ \n" +
                "} \n",
            "particle_diffuse_fragment": "uniform sampler2D diffuseTexture; \n" +
                "vec4 diffuseColor ; \n" +
                "void calcUVCoord(){ \n" +
                "} \n" +
                "void main() { \n" +
                "if( diffuseColor.w == 0.0 ){ \n" +
                "discard; \n" +
                "} \n" +
                "calcUVCoord(); \n" +
                "diffuseColor = texture2D(diffuseTexture , uv_0 ); \n" +
                "if( diffuseColor.w <= materialSource.cutAlpha ){ \n" +
                "discard; \n" +
                "}else \n" +
                "diffuseColor.xyz *= diffuseColor.w ; \n" +
                "} \n",
            "particle_end": "float particle( ParticleData curParticle ){ \n" +
                "return 1.0 ; \n" +
                "} \n" +
                "mat4 buildModelMatrix(vec4 quat, vec3 scale, vec3 position) \n" +
                "{ \n" +
                "mat4 ret = mat4( \n" +
                "vec4(scale.x, 0.0, 0.0, 0.0), \n" +
                "vec4(0.0, scale.y, 0.0, 0.0), \n" +
                "vec4(0.0, 0.0, scale.z, 0.0), \n" +
                "vec4(0.0, 0.0, 0.0, 1.0) \n" +
                "); \n" +
                "ret = buildMat4Quat(quat) * ret; \n" +
                "ret[3][0] = position.x; \n" +
                "ret[3][1] = position.y; \n" +
                "ret[3][2] = position.z; \n" +
                "return ret; \n" +
                "} \n" +
                "vec3 calcParticleMove(vec3 distanceXYZ){ \n" +
                "if(velocityLimitVec2.y > TrueOrFalse){ \n" +
                "vec3 temp = distanceXYZ * distanceXYZ; \n" +
                "float distanceCurrent = sqrt(temp.x + temp.y + temp.z); \n" +
                "float distanceLimit = velocityLimitVec2.x; \n" +
                "if(distanceLimit < 0.0001){ \n" +
                "return vec3(0.0); \n" +
                "} \n" +
                "if(distanceCurrent > distanceLimit){ \n" +
                "distanceXYZ *= distanceLimit / distanceCurrent; \n" +
                "} \n" +
                "} \n" +
                "return distanceXYZ; \n" +
                "} \n" +
                "mat4 getRenderModeMatrix(mat4 cameraMatrix, mat4 modelMatrix){ \n" +
                "return cameraMatrix; \n" +
                "} \n" +
                "void updateStretchedBillBoard(vec4 startPos, vec4 newPos){ \n" +
                "} \n" +
                "void main(void) { \n" +
                "if(discard_particle > TrueOrFalse){ \n" +
                "outPosition = vec4(0.0,0.0,0.0,0.0); \n" +
                "}else{ \n" +
                "vec3 position_emitter = attribute_offsetPosition; \n" +
                "vec3 velocityLocalVec3 = velocityBaseVec3 * currentTime; \n" +
                "vec3 velocityWorldVec3 = vec3(0.0,0.0,0.0); \n" +
                "vec3 velocityMultiVec3 = vec3(0.0,0.0,0.0); \n" +
                "if(particleStateData.velocityOverWorldSpace < TrueOrFalse){ \n" +
                "velocityLocalVec3 += velocityOverVec3; \n" +
                "}else{ \n" +
                "velocityWorldVec3 += velocityOverVec3; \n" +
                "} \n" +
                "if(particleStateData.velocityForceWorldSpace < TrueOrFalse){ \n" +
                "velocityLocalVec3 += velocityForceVec3; \n" +
                "}else{ \n" +
                "velocityWorldVec3 += velocityForceVec3; \n" +
                "} \n" +
                "if(particleStateData.worldSpace > TrueOrFalse){ \n" +
                "}else{ \n" +
                "followTargetPosition.x = particleStateData.positionX; \n" +
                "followTargetPosition.y = particleStateData.positionY; \n" +
                "followTargetPosition.z = particleStateData.positionZ; \n" +
                "followTargetRotation.x = particleStateData.rotationX; \n" +
                "followTargetRotation.y = particleStateData.rotationY; \n" +
                "followTargetRotation.z = particleStateData.rotationZ; \n" +
                "followTargetRotation.w = particleStateData.rotationW; \n" +
                "} \n" +
                "mat4 followRotQuat = buildMat4Quat(followTargetRotation); \n" +
                "velocityLocalVec3 = (followRotQuat * vec4(velocityLocalVec3, 1.0)).xyz; \n" +
                "mat4 modelMatrix = buildModelMatrix(followTargetRotation, followTargetScale, followTargetPosition); \n" +
                "position_emitter = (modelMatrix * vec4(position_emitter, 1.0)).xyz; \n" +
                "velocityMultiVec3 = velocityLocalVec3 + velocityWorldVec3; \n" +
                "velocityMultiVec3 = calcParticleMove(velocityMultiVec3); \n" +
                "velocityMultiVec3.y -= 4.9 * currentTime * currentTime * particleStateData.gravity; \n" +
                "vec3 origPosition = position_emitter; \n" +
                "position_emitter += velocityMultiVec3; \n" +
                "updateStretchedBillBoard(vec4(origPosition, 1.0), vec4(position_emitter, 1.0)); \n" +
                "mat4 billboardMatrix = getRenderModeMatrix(uniform_cameraMatrix, modelMatrix); \n" +
                "outPosition = billboardMatrix * localPosition; \n" +
                "outPosition.xyz += position_emitter.xyz; \n" +
                "outPosition = uniform_ViewMatrix * outPosition; \n" +
                "} \n" +
                "varying_posZ = outPosition.z; \n" +
                "gl_Position = uniform_ProjectionMatrix * outPosition ; \n" +
                "} \n" +
                "	 \n",
            "particle_end_fs": "vec4 diffuseColor ; \n" +
                "uniform float uniform_particleFsData[3]; \n" +
                "varying float varying_posZ; \n" +
                "void fadeOutParticleByZ(float scaleFrom, float scaleTo){ \n" +
                "float threshold = uniform_particleFsData[0] * scaleFrom; \n" +
                "if(varying_posZ < threshold) \n" +
                "return; \n" +
                "threshold = uniform_particleFsData[0] * scaleTo; \n" +
                "if(varying_posZ > threshold){ \n" +
                "discard; \n" +
                "} \n" +
                "float fadeAlpha = (threshold - varying_posZ) / threshold; \n" +
                "fadeAlpha = clamp(fadeAlpha, 0.0, 1.0); \n" +
                "outColor.w *= fadeAlpha; \n" +
                "if( diffuseColor.w <= materialSource.cutAlpha ){ \n" +
                "discard; \n" +
                "} \n" +
                "} \n" +
                "void main() { \n" +
                "outColor.xyz = diffuseColor.xyz * materialSource.diffuse ; \n" +
                "outColor.w = materialSource.alpha * diffuseColor.w ; \n" +
                "if(uniform_particleFsData[2] > TrueOrFalse){ \n" +
                "outColor.xyz *= outColor.w * varying_color.w; \n" +
                "} \n" +
                "gl_FragColor = outColor * varying_color; \n" +
                "} \n",
            "particle_end_vs": "float particle( ParticleData curParticle ){ \n" +
                "return 1.0 ; \n" +
                "} \n" +
                "mat4 buildModelMatrix(vec4 quat, vec3 scale, vec3 position) \n" +
                "{ \n" +
                "mat4 ret = mat4( \n" +
                "vec4(scale.x, 0.0, 0.0, 0.0), \n" +
                "vec4(0.0, scale.y, 0.0, 0.0), \n" +
                "vec4(0.0, 0.0, scale.z, 0.0), \n" +
                "vec4(0.0, 0.0, 0.0, 1.0) \n" +
                "); \n" +
                "ret = buildMat4Quat(quat) * ret; \n" +
                "ret[3][0] = position.x; \n" +
                "ret[3][1] = position.y; \n" +
                "ret[3][2] = position.z; \n" +
                "return ret; \n" +
                "} \n" +
                "vec3 calcParticleMove(vec3 distanceXYZ){ \n" +
                "if(velocityLimitVec2.y > TrueOrFalse){ \n" +
                "vec3 temp = distanceXYZ * distanceXYZ; \n" +
                "float distanceCurrent = sqrt(temp.x + temp.y + temp.z); \n" +
                "float distanceLimit = velocityLimitVec2.x; \n" +
                "if(distanceLimit < 0.0001){ \n" +
                "return vec3(0.0); \n" +
                "} \n" +
                "if(distanceCurrent > distanceLimit){ \n" +
                "distanceXYZ *= distanceLimit / distanceCurrent; \n" +
                "} \n" +
                "} \n" +
                "return distanceXYZ; \n" +
                "} \n" +
                "mat4 getRenderModeMatrix(mat4 cameraMatrix, mat4 modelMatrix){ \n" +
                "return cameraMatrix; \n" +
                "} \n" +
                "void updateStretchedBillBoard(vec4 startPos, vec4 newPos){ \n" +
                "} \n" +
                "void main(void) { \n" +
                "vec4 emitterBirthPos; \n" +
                "if(discard_particle > TrueOrFalse){ \n" +
                "outPosition = vec4(0.0,0.0,0.0,0.0); \n" +
                "}else{ \n" +
                "vec3 position_emitter = attribute_offsetPosition; \n" +
                "vec3 velocityLocalVec3 = velocityBaseVec3 * currentTime; \n" +
                "vec3 velocityWorldVec3 = vec3(0.0,0.0,0.0); \n" +
                "vec3 velocityMultiVec3 = vec3(0.0,0.0,0.0); \n" +
                "if(particleStateData.velocityOverWorldSpace < TrueOrFalse){ \n" +
                "velocityLocalVec3 += velocityOverVec3; \n" +
                "}else{ \n" +
                "velocityWorldVec3 += velocityOverVec3; \n" +
                "} \n" +
                "if(particleStateData.velocityForceWorldSpace < TrueOrFalse){ \n" +
                "velocityLocalVec3 += velocityForceVec3; \n" +
                "}else{ \n" +
                "velocityWorldVec3 += velocityForceVec3; \n" +
                "} \n" +
                "if(particleStateData.worldSpace > TrueOrFalse){ \n" +
                "}else{ \n" +
                "followTargetPosition.x = particleStateData.positionX; \n" +
                "followTargetPosition.y = particleStateData.positionY; \n" +
                "followTargetPosition.z = particleStateData.positionZ; \n" +
                "followTargetRotation.x = particleStateData.rotationX; \n" +
                "followTargetRotation.y = particleStateData.rotationY; \n" +
                "followTargetRotation.z = particleStateData.rotationZ; \n" +
                "followTargetRotation.w = particleStateData.rotationW; \n" +
                "} \n" +
                "mat4 followRotQuat = buildMat4Quat(followTargetRotation); \n" +
                "velocityLocalVec3 = (followRotQuat * vec4(velocityLocalVec3, 1.0)).xyz; \n" +
                "mat4 modelMatrix = buildModelMatrix(followTargetRotation, followTargetScale, followTargetPosition); \n" +
                "position_emitter = (modelMatrix * vec4(position_emitter, 1.0)).xyz; \n" +
                "velocityMultiVec3 = velocityLocalVec3 + velocityWorldVec3; \n" +
                "velocityMultiVec3 = calcParticleMove(velocityMultiVec3); \n" +
                "velocityMultiVec3.y -= 4.9 * currentTime * currentTime * particleStateData.gravity; \n" +
                "vec3 origPosition = position_emitter; \n" +
                "position_emitter += velocityMultiVec3; \n" +
                "updateStretchedBillBoard(vec4(origPosition, 1.0), vec4(position_emitter, 1.0)); \n" +
                "mat4 billboardMatrix = getRenderModeMatrix(uniform_cameraMatrix, modelMatrix); \n" +
                "outPosition = billboardMatrix * localPosition; \n" +
                "outPosition.xyz += position_emitter.xyz; \n" +
                "outPosition = uniform_ViewMatrix * outPosition; \n" +
                "emitterBirthPos = uniform_ViewMatrix * vec4(position_emitter, 1.0); \n" +
                "} \n" +
                "varying_posZ = emitterBirthPos.z; \n" +
                "gl_Position = uniform_ProjectionMatrix * outPosition ; \n" +
                "} \n" +
                "	 \n",
            "particle_follow_vs": "attribute vec3 attribute_followPosition ; \n" +
                "attribute vec4 attribute_followRotation ; \n" +
                "attribute vec3 attribute_followScale; \n" +
                "float particle(  ParticleData curParticle ){ \n" +
                "followTargetPosition = attribute_followPosition; \n" +
                "followTargetRotation = attribute_followRotation; \n" +
                "} \n" +
                "	 \n",
            "particle_fs": "uniform vec2 uniform_fadeOutParticleData; \n" +
                "varying float varying_posZ; \n" +
                "void fadeOutParticleByZ(){ \n" +
                "if(varying_posZ > uniform_fadeOutParticleData.x){ \n" +
                "discard; \n" +
                "} \n" +
                "float fadeAlpha = (uniform_fadeOutParticleData.x - varying_posZ) / uniform_fadeOutParticleData.x; \n" +
                "fadeAlpha = clamp(fadeAlpha, 0.0, 1.0); \n" +
                "fadeAlpha *= fadeAlpha; \n" +
                "outColor.w *= fadeAlpha; \n" +
                "if( diffuseColor.w <= materialSource.cutAlpha ){ \n" +
                "discard; \n" +
                "} \n" +
                "} \n",
            "particle_rm_billboard": "mat4 getRenderModeMatrix(mat4 cameraMatrix, mat4 modelMatrix) { \n" +
                "mat4 matrix = mat4( \n" +
                "cameraMatrix[0], \n" +
                "cameraMatrix[1], \n" +
                "cameraMatrix[2], \n" +
                "vec4(0.0, 0.0, 1.0, 1.0)); \n" +
                "return matrix; \n" +
                "} \n",
            "particle_rm_mesh": "mat4 getRenderModeMatrix(mat4 cameraMatrix, mat4 modelMatrix) { \n" +
                "return mat4( \n" +
                "vec4(1.0, 0.0, 0.0, 0.0), \n" +
                "vec4(0.0, 1.0, 0.0, 0.0), \n" +
                "vec4(0.0, 0.0, 1.0, 0.0), \n" +
                "vec4(0.0, 0.0, 0.0, 1.0) \n" +
                "); \n" +
                "} \n",
            "particle_rm_stretched": "mat4 getRenderModeMatrix(mat4 cameraMatrix, mat4 modelMatrix) { \n" +
                "mat4 matrix = mat4( \n" +
                "cameraMatrix[0], \n" +
                "cameraMatrix[1], \n" +
                "cameraMatrix[2], \n" +
                "vec4(0.0, 0.0, 1.0, 1.0)); \n" +
                "return matrix; \n" +
                "} \n" +
                "void updateStretchedBillBoard(vec4 startPos, vec4 newPos){ \n" +
                "localPosition.x *= particleStateData.lengthScale; \n" +
                "mat4 temp = uniform_ProjectionMatrix * uniform_ViewMatrix; \n" +
                "startPos = temp * startPos; \n" +
                "newPos = temp * newPos; \n" +
                "vec3 dirVector = newPos.xyz - startPos.xyz; \n" +
                "if(dirVector.x == 0.0 && dirVector.y == 0.0 && dirVector.z == 0.0){ \n" +
                "dirVector = attribute_offsetPosition; \n" +
                "} \n" +
                "if(dirVector.x == 0.0 && dirVector.y == 0.0 && dirVector.z == 0.0){ \n" +
                "return; \n" +
                "} \n" +
                "float scaleBefore = dirVector.x * dirVector.x + dirVector.y * dirVector.y + dirVector.z * dirVector.z; \n" +
                "scaleBefore = sqrt(scaleBefore); \n" +
                "float scaleAfter = dirVector.x * dirVector.x + dirVector.y * dirVector.y; \n" +
                "scaleAfter = sqrt(scaleAfter); \n" +
                "scaleAfter = scaleAfter / scaleBefore; \n" +
                "localPosition.x *= scaleAfter; \n" +
                "startPos.xyz /= startPos.z; \n" +
                "newPos.xyz /= newPos.z; \n" +
                "dirVector = newPos.xyz - startPos.xyz; \n" +
                "dirVector = normalize(dirVector); \n" +
                "vec3 dirStartVector = vec3(0.0, 1.0, 0.0); \n" +
                "float added = -0.5 * PI; \n" +
                "if(dirVector.x > 0.0){ \n" +
                "dirVector.xy *= -1.0; \n" +
                "added += PI; \n" +
                "} \n" +
                "float acosValue = dot(dirStartVector, dirVector); \n" +
                "float angle = acos(acosValue) + added; \n" +
                "temp = buildRotMat4(vec3(0.0, 0.0, angle)); \n" +
                "localPosition = temp * localPosition; \n" +
                "} \n",
            "particle_rotationConst": "attribute float attribute_rotationZ ; \n" +
                "float particle(  ParticleData curParticle ){ \n" +
                "float rot = currentTime * attribute_rotationZ * (PI / 180.0); \n" +
                "localPosition = buildRotMat4(vec3(0.0,0.0,rot)) * localPosition; \n" +
                "} \n",
            "particle_rotationOneBezier": "uniform float uniform_rotationBezier[22]; \n" +
                "float particle(  ParticleData curParticle ){ \n" +
                "if(discard_particle < TrueOrFalse){ \n" +
                "float rot = calcOneBezierSize(uniform_rotationBezier, currentTime, curParticle.life); \n" +
                "rot = currentTime * rot * (PI / 180.0); \n" +
                "localPosition = buildRotMat4(vec3(0.0,0.0,rot)) * localPosition; \n" +
                "} \n" +
                "} \n",
            "particle_rotationTwoBezier": "attribute float attribute_rotationRandomSeed; \n" +
                "uniform float uniform_rotationBezier[22]; \n" +
                "uniform float uniform_rotationBezier2[22]; \n" +
                "float particle(  ParticleData curParticle ){ \n" +
                "if(discard_particle < TrueOrFalse){ \n" +
                "vec2 rotationTwoBezier = vec2(0.0); \n" +
                "rotationTwoBezier.x = calcOneBezierArea(uniform_rotationBezier, currentTime, curParticle.life); \n" +
                "rotationTwoBezier.y = calcOneBezierArea(uniform_rotationBezier2, currentTime, curParticle.life); \n" +
                "float rot = mix(rotationTwoBezier.x, rotationTwoBezier.y, attribute_rotationRandomSeed); \n" +
                "rot = currentTime * rot * (PI / 180.0); \n" +
                "localPosition = buildRotMat4(vec3(0.0,0.0,rot)) * localPosition; \n" +
                "} \n" +
                "} \n",
            "particle_size_vs": "uniform float uniform_bezierSize[22]; \n" +
                "void main() { \n" +
                "float bezierSize = calcOneBezierSize(uniform_bezierSize, currentTime, curParticle.life); \n" +
                "localPosition.xyz *= bezierSize; \n" +
                "} \n",
            "particle_textureSheetConst": "varying vec3 varying_textureSheetData; \n" +
                "uniform float uniform_textureSheet[5]; \n" +
                "vec2 getSheetOffset(float frame, float tileX, float tileY) \n" +
                "{ \n" +
                "frame = floor(frame); \n" +
                "vec2 ret = vec2(0.0); \n" +
                "ret.x = (1.0 / tileX) * mod(frame, tileX); \n" +
                "ret.y = frame / tileY; \n" +
                "ret.y = floor(ret.y); \n" +
                "ret.y = (1.0 / tileY) * ret.y; \n" +
                "return ret; \n" +
                "} \n" +
                "void calcUVCoord() { \n" +
                "vec2 rectUV = vec2(1.0 / uniform_textureSheet[1], 1.0 / uniform_textureSheet[0]); \n" +
                "uv_0.xy *= rectUV; \n" +
                "float frame = varying_textureSheetData.x + varying_textureSheetData.y; \n" +
                "frame = clamp(frame, uniform_textureSheet[3], uniform_textureSheet[4]); \n" +
                "uv_0.xy += getSheetOffset(frame, uniform_textureSheet[0], uniform_textureSheet[1]); \n" +
                "} \n",
            "particle_textureSheetOneBezier": "varying vec3 varying_textureSheetData; \n" +
                "uniform float uniform_textureSheet[5]; \n" +
                "uniform float uniform_frameBezier[22]; \n" +
                "vec2 getSheetOffset(float frame, float tileX, float tileY) \n" +
                "{ \n" +
                "frame = floor(frame); \n" +
                "vec2 ret = vec2(0.0); \n" +
                "ret.x = (1.0 / tileX) * mod(frame, tileX); \n" +
                "ret.y = frame / tileY; \n" +
                "ret.y = floor(ret.y); \n" +
                "ret.y = (1.0 / tileY) * ret.y; \n" +
                "return ret; \n" +
                "} \n" +
                "void calcUVCoord() { \n" +
                "vec2 rectUV = vec2(1.0 / uniform_textureSheet[1], 1.0 / uniform_textureSheet[0]); \n" +
                "uv_0.xy *= rectUV; \n" +
                "float frame = varying_textureSheetData.x + varying_textureSheetData.y; \n" +
                "float currentTime = varying_particleData.x * uniform_textureSheet[2]; \n" +
                "currentTime = mod(currentTime, varying_particleData.y); \n" +
                "float bezierFrame = calcOneBezierSize(uniform_frameBezier, currentTime, varying_particleData.y); \n" +
                "bezierFrame = clamp(bezierFrame, uniform_textureSheet[3], uniform_textureSheet[4]); \n" +
                "frame += bezierFrame; \n" +
                "uv_0.xy += getSheetOffset(frame, uniform_textureSheet[0], uniform_textureSheet[1]); \n" +
                "} \n",
            "particle_textureSheetTwoBezier": "varying vec3 varying_textureSheetData; \n" +
                "uniform float uniform_textureSheet[5]; \n" +
                "uniform float uniform_frameBezier1[22]; \n" +
                "uniform float uniform_frameBezier2[22]; \n" +
                "vec2 getSheetOffset(float frame, float tileX, float tileY) \n" +
                "{ \n" +
                "frame = floor(frame); \n" +
                "vec2 ret = vec2(0.0); \n" +
                "ret.x = (1.0 / tileX) * mod(frame, tileX); \n" +
                "ret.y = frame / tileY; \n" +
                "ret.y = floor(ret.y); \n" +
                "ret.y = (1.0 / tileY) * ret.y; \n" +
                "return ret; \n" +
                "} \n" +
                "void calcUVCoord() { \n" +
                "vec2 rectUV = vec2(1.0 / uniform_textureSheet[1], 1.0 / uniform_textureSheet[0]); \n" +
                "uv_0.xy *= rectUV; \n" +
                "float frame = varying_textureSheetData.x + varying_textureSheetData.y; \n" +
                "float currentTime = varying_particleData.x * uniform_textureSheet[2]; \n" +
                "currentTime = mod(currentTime, varying_particleData.y); \n" +
                "float b1 = calcOneBezierSize(uniform_frameBezier1, currentTime2, varying_particleData.y); \n" +
                "float b2 = calcOneBezierSize(uniform_frameBezier2, currentTime2, varying_particleData.y); \n" +
                "float bezierFrame = mix(b1, b2, varying_particleData.z); \n" +
                "bezierFrame = clamp(bezierFrame, uniform_textureSheet[3], uniform_textureSheet[4]); \n" +
                "frame += bezierFrame; \n" +
                "uv_0.xy += getSheetOffset(frame, uniform_textureSheet[0], uniform_textureSheet[1]); \n" +
                "} \n",
            "particle_textureSheet_vs": "attribute vec3 attribute_textureSheetData; \n" +
                "varying vec3 varying_textureSheetData; \n" +
                "float particle(  ParticleData curParticle ){ \n" +
                "varying_textureSheetData = attribute_textureSheetData; \n" +
                "} \n" +
                "	 \n",
            "particle_time_fs": "const float TrueOrFalse = 0.55555; \n" +
                "varying vec3 varying_particleData; \n" +
                "void main(void) { \n" +
                "light = vec4(1.0,1.0,1.0,1.0); \n" +
                "} \n",
            "particle_time_vs": "attribute vec3 attribute_time ; \n" +
                "float currentTime = 0.0; \n" +
                "varying vec3 varying_particleData; \n" +
                "struct ParticleData{ \n" +
                "float bornTime; \n" +
                "float life; \n" +
                "float index; \n" +
                "}; \n" +
                "float particle( ParticleData curParticle ){ \n" +
                "float time = particleStateData.time - particleStateData.delay; \n" +
                "if(time <= curParticle.bornTime){ \n" +
                "return currentTime = 0.0; \n" +
                "} \n" +
                "if(particleStateData.loop < TrueOrFalse){ \n" +
                "float emitterDuring = particleStateData.duration - particleStateData.delay; \n" +
                "if(curParticle.bornTime >= emitterDuring) \n" +
                "{ \n" +
                "return currentTime = 0.0; \n" +
                "} \n" +
                "if(time >= curParticle.life + curParticle.bornTime) \n" +
                "{ \n" +
                "return currentTime = 0.0; \n" +
                "} \n" +
                "} \n" +
                "currentTime = time - curParticle.bornTime; \n" +
                "currentTime = mod(currentTime, particleStateData.loopTime); \n" +
                "if(currentTime >= curParticle.life){ \n" +
                "return currentTime = 0.0; \n" +
                "} \n" +
                "if( currentTime <= 0.0 ) \n" +
                "return currentTime = 0.0; \n" +
                "} \n" +
                "void main(void) { \n" +
                "ParticleData curParticle ; \n" +
                "curParticle.bornTime = attribute_time.x ; \n" +
                "curParticle.life = attribute_time.y ; \n" +
                "curParticle.index = attribute_time.z ; \n" +
                "float active = particle( curParticle ) ; \n" +
                "varying_particleData.x = currentTime; \n" +
                "varying_particleData.y = curParticle.life ; \n" +
                "varying_particleData.z = curParticle.index; \n" +
                "if( active < TrueOrFalse ){ \n" +
                "e_discard(); \n" +
                "}else{ \n" +
                "} \n" +
                "} \n",
            "particle_uv_roll_fs": "uniform float uniform_particleUVRoll[2]; \n" +
                "void calcUVCoord() { \n" +
                "uv_0.xy += vec2(varying_particleData.x * uniform_particleUVRoll[0], varying_particleData.x * uniform_particleUVRoll[1]); \n" +
                "} \n",
            "particle_velocity": "attribute vec3 attribute_velocity; \n" +
                "float particle(  ParticleData curParticle ){ \n" +
                "velocityBaseVec3 = attribute_velocity; \n" +
                "} \n",
            "particle_velocityForceConst": "attribute vec3 attribute_velocityForceConst ; \n" +
                "float particle(   ParticleData curParticle ){ \n" +
                "velocityForceVec3 = 0.5 * attribute_velocityForceConst * currentTime * currentTime; \n" +
                "} \n",
            "particle_velocityForceOneBezier": "vec3 velocityForceOneBezier = vec3(0.0); \n" +
                "void calcVelocityForceBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "} \n" +
                "void main() { \n" +
                "if(discard_particle < TrueOrFalse){ \n" +
                "velocityForceVec3.xyz = velocityForceOneBezier.xyz; \n" +
                "calcVelocityForceBezier(currentTime, curParticle.life); \n" +
                "} \n" +
                "} \n",
            "particle_velocityForceOneBezierX": "uniform float uniform_velocityForceX[22]; \n" +
                "void calcVelocityForceBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityForceOneBezier.x = calcOneBezierArea(uniform_velocityForceX, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityForceOneBezierY": "uniform float uniform_velocityForceY[22]; \n" +
                "void calcVelocityForceBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityForceOneBezier.y = calcOneBezierArea(uniform_velocityForceY, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityForceOneBezierZ": "uniform float uniform_velocityForceZ[22]; \n" +
                "void calcVelocityForceBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityForceOneBezier.z = calcOneBezierArea(uniform_velocityForceZ, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityForceTwoBezier": "attribute float attribute_velocityForceRandomSeed; \n" +
                "vec3 velocityForceTwoBezier1 = vec3(0.0); \n" +
                "vec3 velocityForceTwoBezier2 = vec3(0.0); \n" +
                "void calcVelocityForceBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "} \n" +
                "void main() { \n" +
                "if(discard_particle < TrueOrFalse){ \n" +
                "calcVelocityForceBezier(currentTime, curParticle.life); \n" +
                "velocityForceVec3.x = mix(velocityForceTwoBezier1.x, velocityForceTwoBezier2.x, attribute_velocityForceRandomSeed); \n" +
                "velocityForceVec3.y = mix(velocityForceTwoBezier1.y, velocityForceTwoBezier2.y, attribute_velocityForceRandomSeed); \n" +
                "velocityForceVec3.z = mix(velocityForceTwoBezier1.z, velocityForceTwoBezier2.z, attribute_velocityForceRandomSeed); \n" +
                "} \n" +
                "} \n",
            "particle_velocityForceTwoBezierX1": "uniform float uniform_velocityForceX1[22]; \n" +
                "void calcVelocityForceBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityForceTwoBezier1.x = calcOneBezierArea(uniform_velocityForceX1, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityForceTwoBezierX2": "uniform float uniform_velocityForceX2[22]; \n" +
                "void calcVelocityForceBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityForceTwoBezier2.x = calcOneBezierArea(uniform_velocityForceX2, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityForceTwoBezierY1": "uniform float uniform_velocityForceY1[22]; \n" +
                "void calcVelocityForceBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityForceTwoBezier1.y = calcOneBezierArea(uniform_velocityForceY1, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityForceTwoBezierY2": "uniform float uniform_velocityForceY2[22]; \n" +
                "void calcVelocityForceBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityForceTwoBezier2.y = calcOneBezierArea(uniform_velocityForceY2, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityForceTwoBezierZ1": "uniform float uniform_velocityForceZ1[22]; \n" +
                "void calcVelocityForceBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityForceTwoBezier1.z = calcOneBezierArea(uniform_velocityForceZ1, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityForceTwoBezierZ2": "uniform float uniform_velocityForceZ2[22]; \n" +
                "void calcVelocityForceBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityForceTwoBezier2.z = calcOneBezierArea(uniform_velocityForceZ2, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityLimitConst": "attribute float attribute_velocityLimit; \n" +
                "float particle(  ParticleData curParticle ){ \n" +
                "velocityLimitVec2.x = attribute_velocityLimit * currentTime; \n" +
                "if(velocityLimitVec2.x < 0.0){ \n" +
                "velocityLimitVec2.x = 0.0; \n" +
                "} \n" +
                "velocityLimitVec2.y = 1.0; \n" +
                "} \n",
            "particle_velocityLimitOneBezier": "uniform float uniform_velocityLimit[22]; \n" +
                "void main() { \n" +
                "if(discard_particle < TrueOrFalse){ \n" +
                "velocityLimitVec2.x = calcOneBezierArea(uniform_velocityLimit, currentTime, curParticle.life); \n" +
                "velocityLimitVec2.y = 1.0; \n" +
                "} \n" +
                "} \n",
            "particle_velocityLimitTwoBezier": "uniform float uniform_velocityLimit[22]; \n" +
                "uniform float uniform_velocityLimit2[22]; \n" +
                "attribute float attribute_velocityLimitRandomSeed; \n" +
                "void main() { \n" +
                "if(discard_particle < TrueOrFalse){ \n" +
                "float velocity2Limit1 = calcOneBezierArea(uniform_velocityLimit, currentTime, curParticle.life); \n" +
                "float velocity2Limit2 = calcOneBezierArea(uniform_velocityLimit2, currentTime, curParticle.life); \n" +
                "velocityLimitVec2.x = mix(velocity2Limit1, velocity2Limit1, attribute_velocityLimitRandomSeed); \n" +
                "if(velocityLimitVec2.x < 0.0){ \n" +
                "velocityLimitVec2.x = 0.0; \n" +
                "} \n" +
                "velocityLimitVec2.y = 1.0; \n" +
                "} \n" +
                "} \n",
            "particle_velocityOverConst": "attribute vec3 attribute_velocityOverConst; \n" +
                "float particle(  ParticleData curParticle ){ \n" +
                "velocityOverVec3 = attribute_velocityOverConst * currentTime; \n" +
                "} \n",
            "particle_velocityOverOneBezier": "vec3 velocityTwoBezier = vec3(0.0); \n" +
                "void calcVelocityOverBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "} \n" +
                "void main() { \n" +
                "if(discard_particle < TrueOrFalse){ \n" +
                "calcVelocityOverBezier(currentTime, curParticle.life); \n" +
                "velocityOverVec3.xyz = velocityTwoBezier.xyz; \n" +
                "} \n" +
                "} \n",
            "particle_velocityOverOneBezierX": "uniform float uniform_velocityOverX[22]; \n" +
                "void calcVelocityOverBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityTwoBezier.x = calcOneBezierArea(uniform_velocityOverX, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityOverOneBezierY": "uniform float uniform_velocityOverY[22]; \n" +
                "void calcVelocityOverBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityTwoBezier.y = calcOneBezierArea(uniform_velocityOverY, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityOverOneBezierZ": "uniform float uniform_velocityOverZ[22]; \n" +
                "void calcVelocityOverBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityTwoBezier.z = calcOneBezierArea(uniform_velocityOverZ, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityOverTwoBezier": "attribute float attribute_velocityOverRandomSeed; \n" +
                "vec3 velocityOverTwoBezier1 = vec3(0.0); \n" +
                "vec3 velocityOverTwoBezier2 = vec3(0.0); \n" +
                "void calcVelocityOverBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "} \n" +
                "void main() { \n" +
                "if(discard_particle < TrueOrFalse){ \n" +
                "calcVelocityOverBezier(currentTime, curParticle.life); \n" +
                "velocityOverVec3.x = mix(velocityOverTwoBezier1.x, velocityOverTwoBezier2.x, attribute_velocityOverRandomSeed); \n" +
                "velocityOverVec3.y = mix(velocityOverTwoBezier1.y, velocityOverTwoBezier2.y, attribute_velocityOverRandomSeed); \n" +
                "velocityOverVec3.z = mix(velocityOverTwoBezier1.z, velocityOverTwoBezier2.z, attribute_velocityOverRandomSeed); \n" +
                "} \n" +
                "} \n",
            "particle_velocityOverTwoBezierX1": "uniform float uniform_velocityOverX1[22]; \n" +
                "void calcVelocityOverBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityOverTwoBezier1.x = calcOneBezierArea(uniform_velocityOverX1, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityOverTwoBezierX2": "uniform float uniform_velocityOverX2[22]; \n" +
                "void calcVelocityOverBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityOverTwoBezier2.x = calcOneBezierArea(uniform_velocityOverX2, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityOverTwoBezierY1": "uniform float uniform_velocityOverY1[22]; \n" +
                "void calcVelocityOverBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityOverTwoBezier1.y = calcOneBezierArea(uniform_velocityOverY1, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityOverTwoBezierY2": "uniform float uniform_velocityOverY2[22]; \n" +
                "void calcVelocityOverBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityOverTwoBezier2.y = calcOneBezierArea(uniform_velocityOverY2, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityOverTwoBezierZ1": "uniform float uniform_velocityOverZ1[22]; \n" +
                "void calcVelocityOverBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityOverTwoBezier1.z = calcOneBezierArea(uniform_velocityOverZ1, curTime, totalTime); \n" +
                "} \n",
            "particle_velocityOverTwoBezierZ2": "uniform float uniform_velocityOverZ2[22]; \n" +
                "void calcVelocityOverBezier(float curTime, float totalTime) \n" +
                "{ \n" +
                "velocityOverTwoBezier2.z = calcOneBezierArea(uniform_velocityOverZ2, curTime, totalTime); \n" +
                "} \n",
            "particle_vs": "attribute vec4 attribute_color; \n" +
                "attribute vec3 attribute_offsetPosition; \n" +
                "uniform mat4 uniform_cameraMatrix; \n" +
                "uniform float uniform_particleState[22]; \n" +
                "uniform mat4 uniform_ViewMatrix; \n" +
                "const float PI = 3.1415926 ; \n" +
                "float currentTime = 0.0; \n" +
                "float totalTime = 0.0; \n" +
                "const float TrueOrFalse = 0.55555; \n" +
                "vec4 localPosition = vec4(0.0,0.0,0.0,1.0); \n" +
                "vec3 velocityBaseVec3 = vec3(0.0,0.0,0.0); \n" +
                "vec3 velocityOverVec3 = vec3(0.0,0.0,0.0); \n" +
                "vec3 velocityForceVec3 = vec3(0.0,0.0,0.0); \n" +
                "vec2 velocityBezierWeightVec2 = vec2(1.0, 1.0); \n" +
                "vec2 velocityLimitVec2 = vec2(0.0,0.0); \n" +
                "vec3 followTargetPosition = vec3(0.0,0.0,0.0); \n" +
                "vec3 followTargetScale = vec3(1.0,1.0,1.0); \n" +
                "vec4 followTargetRotation = vec4(0.0,0.0,0.0,0.0); \n" +
                "varying vec3 varyingViewDir ; \n" +
                "varying float varying_posZ; \n" +
                "float discard_particle = 0.0; \n" +
                "ParticleStateData particleStateData; \n" +
                "void e_discard(){ \n" +
                "discard_particle = 1.0; \n" +
                "} \n" +
                "struct ParticleStateData{ \n" +
                "float time; \n" +
                "float loop; \n" +
                "float worldSpace; \n" +
                "float scaleX; \n" +
                "float scaleY; \n" +
                "float scaleZ; \n" +
                "float rotationX; \n" +
                "float rotationY; \n" +
                "float rotationZ; \n" +
                "float rotationW; \n" +
                "float positionX; \n" +
                "float positionY; \n" +
                "float positionZ; \n" +
                "float loopTime; \n" +
                "float delay; \n" +
                "float duration; \n" +
                "float gravity; \n" +
                "float velocityOverWorldSpace; \n" +
                "float velocityForceWorldSpace; \n" +
                "float cameraScale; \n" +
                "float speedScale; \n" +
                "float lengthScale; \n" +
                "}; \n" +
                "mat4 buildRotMat4(vec3 rot) \n" +
                "{ \n" +
                "float s; \n" +
                "float c; \n" +
                "s = sin(rot.x); \n" +
                "c = cos(rot.x); \n" +
                "mat4 ret = mat4( \n" +
                "vec4(1.0, 0.0, 0.0, 0.0), \n" +
                "vec4(0.0, c, s, 0.0), \n" +
                "vec4(0.0, -s, c, 0.0), \n" +
                "vec4(0.0, 0.0, 0.0, 1.0) \n" +
                "); \n" +
                "s = sin(rot.y); \n" +
                "c = cos(rot.y); \n" +
                "ret = mat4( \n" +
                "vec4(c, 0.0, -s, 0.0), \n" +
                "vec4(0.0, 1.0, 0.0, 0.0), \n" +
                "vec4(s, 0.0, c, 0.0), \n" +
                "vec4(0.0, 0.0, 0.0, 1.0) \n" +
                ") * ret; \n" +
                "s = sin(rot.z); \n" +
                "c = cos(rot.z); \n" +
                "ret = mat4( \n" +
                "vec4(c, s, 0.0, 0.0), \n" +
                "vec4(-s, c, 0.0, 0.0), \n" +
                "vec4(0.0, 0.0, 1.0, 0.0), \n" +
                "vec4(0.0, 0.0, 0.0, 1.0) \n" +
                ") * ret; \n" +
                "return ret; \n" +
                "} \n" +
                "mat4 buildMat4Quat(vec4 quat){ \n" +
                "float xx = quat.x * quat.x; \n" +
                "float xy = quat.x * quat.y; \n" +
                "float xz = quat.x * quat.z; \n" +
                "float xw = quat.x * quat.w; \n" +
                "float yy = quat.y * quat.y; \n" +
                "float yz = quat.y * quat.z; \n" +
                "float yw = quat.y * quat.w; \n" +
                "float zz = quat.z * quat.z; \n" +
                "float zw = quat.z * quat.w; \n" +
                "return mat4( \n" +
                "1.0 - 2.0 * (yy + zz),		2.0 * (xy + zw),		2.0 * (xz - yw),		0, \n" +
                "2.0 * (xy - zw),				1.0 - 2.0 * (xx + zz),	2.0 * (yz + xw),		0, \n" +
                "2.0 * (xz + yw),				2.0 * (yz - xw),		1.0 - 2.0 * (xx + yy),	0, \n" +
                "0.0,							0.0,					0.0,					1 \n" +
                "); \n" +
                "} \n" +
                "void main(void) { \n" +
                "particleStateData.time							= uniform_particleState[0]; \n" +
                "particleStateData.loop							= uniform_particleState[1]; \n" +
                "particleStateData.worldSpace					= uniform_particleState[2]; \n" +
                "particleStateData.scaleX						= uniform_particleState[3]; \n" +
                "particleStateData.scaleY						= uniform_particleState[4]; \n" +
                "particleStateData.scaleZ						= uniform_particleState[5]; \n" +
                "particleStateData.rotationX						= uniform_particleState[6]; \n" +
                "particleStateData.rotationY						= uniform_particleState[7]; \n" +
                "particleStateData.rotationZ						= uniform_particleState[8]; \n" +
                "particleStateData.rotationW						= uniform_particleState[9]; \n" +
                "particleStateData.positionX						= uniform_particleState[10]; \n" +
                "particleStateData.positionY						= uniform_particleState[11]; \n" +
                "particleStateData.positionZ						= uniform_particleState[12]; \n" +
                "particleStateData.loopTime						= uniform_particleState[13]; \n" +
                "particleStateData.delay							= uniform_particleState[14]; \n" +
                "particleStateData.duration						= uniform_particleState[15]; \n" +
                "particleStateData.gravity						= uniform_particleState[16]; \n" +
                "particleStateData.velocityOverWorldSpace		= uniform_particleState[17]; \n" +
                "particleStateData.velocityForceWorldSpace		= uniform_particleState[18]; \n" +
                "particleStateData.cameraScale					= uniform_particleState[19]; \n" +
                "particleStateData.speedScale					= uniform_particleState[20]; \n" +
                "particleStateData.lengthScale					= uniform_particleState[21]; \n" +
                "mat4 modeViewMatrix = uniform_ModelViewMatrix ; \n" +
                "outPosition = localPosition = vec4(e_position, 1.0); \n" +
                "} \n",
            "pointLight_fragment": "const int max_pointLight = 0 ; \n" +
                "uniform float uniform_pointLightSource[6*max_pointLight] ; \n" +
                "uniform mat4 uniform_NormalMatrix; \n" +
                "struct PointLight{ \n" +
                "vec3 position ; \n" +
                "vec3 diffuse ; \n" +
                "}; \n" +
                "void calculatePointLight(MaterialSource materialSource){ \n" +
                "vec3 N = normal; \n" +
                "for(int i = 0 ; i < max_pointLight ; i++){ \n" +
                "PointLight pointLight; \n" +
                "pointLight.position = vec3(uniform_pointLightSource[i*6],uniform_pointLightSource[i*6+1],uniform_pointLightSource[i*6+2]); \n" +
                "pointLight.diffuse = vec3(uniform_pointLightSource[i*6+3],uniform_pointLightSource[i*6+4],uniform_pointLightSource[i*6+5]); \n" +
                "vec3 viewDir = normalize(varying_ViewPose.xyz/varying_ViewPose.w); \n" +
                "vec4 lightVirePos = uniform_NormalMatrix * vec4(pointLight.position.xyz,1.0) ; \n" +
                "vec3 lightDir = varying_ViewPose.xyz - lightVirePos.xyz ; \n" +
                "float lightDist = length( lightDir ); \n" +
                "float attenuation = 1.0 / (3.0 + 0.001 * lightDist +  0.00009 * lightDist * lightDist); \n" +
                "light += LightingBlinnPhong(normalize(lightDir),vec3(1.0,1.0,1.0),normal,-varying_ViewDir,attenuation); \n" +
                "}; \n" +
                "} \n" +
                "void main() { \n" +
                "calculatePointLight(materialSource); \n" +
                "} \n",
            "secondaryUV_vs": "attribute vec2 attribute_uv1; \n" +
                "varying vec2 varying_uv1 ; \n" +
                "void main(void){ \n" +
                "varying_uv1 = attribute_uv1 ; \n" +
                "} \n",
            "shadowMapping_fs": "uniform sampler2D shadowMapTexture; \n" +
                "uniform vec3 uniform_ShadowColor; \n" +
                "varying vec4 varying_ShadowCoord; \n" +
                "float unpackDepth(vec4 rgbaDepth){ \n" +
                "vec4 bitShift = vec4( 1.0 , 1.0/256.0 , 1.0/(256.0*256.0) , 1.0/(256.0*256.0*256.0) ); \n" +
                "float depth = dot(rgbaDepth,bitShift); \n" +
                "return depth ; \n" +
                "} \n" +
                "void main() { \n" +
                "vec3 shadowColor = vec3(1.0,1.0,1.0); \n" +
                "float shadow = 0.0; \n" +
                "if (varying_ShadowCoord.w > 0.0) { \n" +
                "vec3 shadowDepth = varying_ShadowCoord.xyz / varying_ShadowCoord.w * 0.5 + 0.5; \n" +
                "vec2 sample = clamp(shadowDepth.xy,0.0,1.0); \n" +
                "float sampleDepth = texture2D(shadowMapTexture, sample).z; \n" +
                "if(sampleDepth > shadowDepth.z) \n" +
                "shadowColor = uniform_ShadowColor; \n" +
                "} \n" +
                "diffuseColor.xyz = diffuseColor.xyz * shadowColor; \n" +
                "} \n",
            "shadowMapping_vs": "uniform mat4 uniform_ShadowMatrix; \n" +
                "uniform mat4 uniform_ModelMatrix; \n" +
                "varying vec4 varying_ShadowCoord; \n" +
                "void main() { \n" +
                "varying_ShadowCoord = uniform_ShadowMatrix * uniform_ModelMatrix * vec4(e_position, 1.0); \n" +
                "} \n",
            "skeletonShadowPass_vs": "attribute vec4 attribute_boneIndex; \n" +
                "attribute vec4 attribute_boneWeight; \n" +
                "attribute vec4 attribute_color; \n" +
                "vec4 e_boneIndex = vec4(0.0, 0.0, 0.0, 0.0); \n" +
                "vec4 e_boneWeight = vec4(0.0, 0.0, 0.0, 0.0); \n" +
                "const int bonesNumber = 0; \n" +
                "uniform vec4 uniform_PoseMatrix[bonesNumber]; \n" +
                "mat4 buildMat4(int index){ \n" +
                "vec4 quat = uniform_PoseMatrix[index * 2 + 0]; \n" +
                "vec4 translation = uniform_PoseMatrix[index * 2 + 1]; \n" +
                "float xx = quat.x * quat.x; \n" +
                "float xy = quat.x * quat.y; \n" +
                "float xz = quat.x * quat.z; \n" +
                "float xw = quat.x * quat.w; \n" +
                "float yy = quat.y * quat.y; \n" +
                "float yz = quat.y * quat.z; \n" +
                "float yw = quat.y * quat.w; \n" +
                "float zz = quat.z * quat.z; \n" +
                "float zw = quat.z * quat.w; \n" +
                "return mat4( \n" +
                "1.0 - 2.0 * (yy + zz),		2.0 * (xy + zw),		2.0 * (xz - yw),		0, \n" +
                "2.0 * (xy - zw),				1.0 - 2.0 * (xx + zz),	2.0 * (yz + xw),		0, \n" +
                "2.0 * (xz + yw),				2.0 * (yz - xw),		1.0 - 2.0 * (xx + yy),	0, \n" +
                "translation.x,				translation.y,			translation.z,			1 \n" +
                "); \n" +
                "} \n" +
                "void main(void){ \n" +
                "varying_color = attribute_color; \n" +
                "e_boneIndex = attribute_boneIndex; \n" +
                "e_boneWeight = attribute_boneWeight; \n" +
                "vec4 temp_position = vec4(attribute_position, 1.0) ; \n" +
                "mat4 m0 = buildMat4(int(e_boneIndex.x)); \n" +
                "mat4 m1 = buildMat4(int(e_boneIndex.y)); \n" +
                "mat4 m2 = buildMat4(int(e_boneIndex.z)); \n" +
                "mat4 m3 = buildMat4(int(e_boneIndex.w)); \n" +
                "outPosition = m0 * temp_position * e_boneWeight.x; \n" +
                "outPosition += m1 * temp_position * e_boneWeight.y; \n" +
                "outPosition += m2 * temp_position * e_boneWeight.z; \n" +
                "outPosition += m3 * temp_position * e_boneWeight.w; \n" +
                "e_position = outPosition.xyz; \n" +
                "outPosition = uniform_ModelViewMatrix * outPosition; \n" +
                "} \n",
            "skeleton_vs": "attribute vec4 attribute_boneIndex; \n" +
                "attribute vec4 attribute_boneWeight; \n" +
                "attribute vec3 attribute_normal; \n" +
                "attribute vec4 attribute_color; \n" +
                "vec4 e_boneIndex = vec4(0.0, 0.0, 0.0, 0.0); \n" +
                "vec4 e_boneWeight = vec4(0.0, 0.0, 0.0, 0.0); \n" +
                "const int bonesNumber = 0; \n" +
                "uniform vec4 uniform_PoseMatrix[bonesNumber]; \n" +
                "uniform mat4 uniform_NormalMatrix ; \n" +
                "mat4 buildMat4(int index){ \n" +
                "vec4 quat = uniform_PoseMatrix[index * 2 + 0]; \n" +
                "vec4 translation = uniform_PoseMatrix[index * 2 + 1]; \n" +
                "float xy2 = 2.0 * quat.x * quat.y; \n" +
                "float xz2 = 2.0 * quat.x * quat.z; \n" +
                "float xw2 = 2.0 * quat.x * quat.w; \n" +
                "float yz2 = 2.0 * quat.y * quat.z; \n" +
                "float yw2 = 2.0 * quat.y * quat.w; \n" +
                "float zw2 = 2.0 * quat.z * quat.w; \n" +
                "float xx = quat.x * quat.x; \n" +
                "float yy = quat.y * quat.y; \n" +
                "float zz = quat.z * quat.z; \n" +
                "float ww = quat.w * quat.w; \n" +
                "mat4 matrix = mat4( \n" +
                "xx - yy - zz + ww, xy2 + zw2, xz2 - yw2, 0, \n" +
                "xy2 - zw2, -xx + yy - zz + ww, yz2 + xw2, 0, \n" +
                "xz2 + yw2, yz2 - xw2, -xx - yy + zz + ww, 0, \n" +
                "translation.x, translation.y, translation.z, 1 \n" +
                "); \n" +
                "return matrix; \n" +
                "} \n" +
                "void main(void){ \n" +
                "e_boneIndex = attribute_boneIndex; \n" +
                "e_boneWeight = attribute_boneWeight; \n" +
                "vec4 temp_position = vec4(attribute_position, 1.0) ; \n" +
                "vec4 temp_normal = vec4(attribute_normal, 0.0) ; \n" +
                "mat4 m0 = buildMat4(int(e_boneIndex.x)); \n" +
                "mat4 m1 = buildMat4(int(e_boneIndex.y)); \n" +
                "mat4 m2 = buildMat4(int(e_boneIndex.z)); \n" +
                "mat4 m3 = buildMat4(int(e_boneIndex.w)); \n" +
                "outPosition = m0 * temp_position * e_boneWeight.x; \n" +
                "outPosition += m1 * temp_position * e_boneWeight.y; \n" +
                "outPosition += m2 * temp_position * e_boneWeight.z; \n" +
                "outPosition += m3 * temp_position * e_boneWeight.w; \n" +
                "e_position = outPosition.xyz; \n" +
                "vec4 temp_n ; \n" +
                "temp_n = m0 * temp_normal * e_boneWeight.x; \n" +
                "temp_n += m1 * temp_normal * e_boneWeight.y; \n" +
                "temp_n += m2 * temp_normal * e_boneWeight.z; \n" +
                "temp_n += m3 * temp_normal * e_boneWeight.w; \n" +
                "mat3 normalMatrix = mat3(uniform_NormalMatrix); \n" +
                "varying_eyeNormal = normalize(normalMatrix * -temp_n.xyz); \n" +
                "varying_ViewPose = vec4(normalMatrix*outPosition.xyz, 1.0) ; \n" +
                "outPosition = uniform_ModelViewMatrix * outPosition; \n" +
                "} \n",
            "specularMap_fragment": "uniform sampler2D specularTexture; \n" +
                "void main(void){ \n" +
                "specularColor.xyz *= texture2D( specularTexture , uv_0 ).xyz ; \n" +
                "} \n",
            "staticShadowPass_vs": "attribute vec4 attribute_color; \n" +
                "vec4 e_boneIndex = vec4(0.0, 0.0, 0.0, 0.0); \n" +
                "vec4 e_boneWeight = vec4(0.0, 0.0, 0.0, 0.0); \n" +
                "void main(void){ \n" +
                "varying_color = attribute_color; \n" +
                "outPosition = vec4(attribute_position, 1.0) ; \n" +
                "e_position = outPosition.xyz; \n" +
                "outPosition = uniform_ModelViewMatrix * outPosition; \n" +
                "} \n",
            "tangent_vs": "attribute vec3 attribute_tangent; \n" +
                "void main(void){ \n" +
                "}  \n",
            "terrainRGBA_fragment": "uniform sampler2D blendMaskTexture ; \n" +
                "uniform sampler2D splat_0Tex ; \n" +
                "uniform sampler2D splat_1Tex ; \n" +
                "uniform sampler2D splat_2Tex ; \n" +
                "uniform sampler2D splat_3Tex ; \n" +
                "uniform float uvs[8]; \n" +
                "void main() { \n" +
                "vec4 splat_control = texture2D ( blendMaskTexture , varying_uv0 ); \n" +
                "vec4 cc = vec4(0.0,0.0,0.0,1.0); \n" +
                "vec2 uv = varying_uv0 ; \n" +
                "cc.xyz = splat_control.x * texture2D (splat_0Tex, uv * vec2(uvs[0],uvs[1])).xyz ; \n" +
                "cc.xyz += splat_control.y * texture2D (splat_1Tex, uv * vec2(uvs[2],uvs[3]) ).xyz; \n" +
                "cc.xyz += splat_control.z * vec4(texture2D (splat_2Tex, uv* vec2(uvs[4],uvs[5]))).xyz; \n" +
                "cc.xyz += (1.0-length(splat_control.xyz)) * vec4(texture2D (splat_3Tex, uv* vec2(uvs[6],uvs[7]))).xyz; \n" +
                "diffuseColor.xyz = cc.xyz ; \n" +
                "} \n",
            "uvRoll_fs": "uniform float uvRoll[2] ; \n" +
                "uniform sampler2D diffuseTexture; \n" +
                "vec4 diffuseColor ; \n" +
                "void main() { \n" +
                "uv_0.xy += vec2(uvRoll[0],uvRoll[1]); \n" +
                "diffuseColor = texture2D(diffuseTexture , uv_0 ); \n" +
                "diffuseColor.xyz = clamp(diffuseColor.xyz / diffuseColor.w,0.0,1.0); \n" +
                "} \n",
            "uvSpriteSheet_fs": "uniform float uvSpriteSheet[4] ; \n" +
                "uniform sampler2D diffuseTexture; \n" +
                "vec4 diffuseColor ; \n" +
                "void main() { \n" +
                "uv_0.xy *= vec2(uvSpriteSheet[2],uvSpriteSheet[3]); \n" +
                "uv_0.xy += vec2(uvSpriteSheet[0],uvSpriteSheet[1]); \n" +
                "diffuseColor = texture2D(diffuseTexture , uv_0 ); \n" +
                "} \n",
            "uvStreamerRoll_fs": "uniform float uvRoll[3] ; \n" +
                "uniform sampler2D diffuseTexture; \n" +
                "uniform sampler2D streamerTexture; \n" +
                "vec4 diffuseColor ; \n" +
                "void main() { \n" +
                "diffuseColor = texture2D(diffuseTexture , varying_uv0 ); \n" +
                "vec2 rollUV = varying_uv0 + vec2(uvRoll[0],uvRoll[1]) + vec2(normal.xz) * 0.5 ; \n" +
                "diffuseColor.xyz += texture2D(streamerTexture , rollUV ).xyz * uvRoll[2] ; \n" +
                "} \n",
            "varyingViewDir_vs": "varying vec3 varying_ViewDir; \n" +
                "uniform vec3 uniform_eyepos; \n" +
                "uniform mat4 uniform_NormalMatrix; \n" +
                "void main(void){ \n" +
                "varying_ViewDir = (uniform_eyepos.xyz - e_position) ; \n" +
                "} \n",
            "vertexPos_vs": "varying vec4 varying_pos; \n" +
                "void main() { \n" +
                "varying_pos = uniform_ModelViewMatrix * vec4(e_position, 1.0) ; \n" +
                "} \n" +
                "                       \n",
            "waterDiffuse_fs": "uniform sampler2D diffuseTexture; \n" +
                "vec4 diffuseColor ; \n" +
                "void main() { \n" +
                "diffuseColor.xyz *= diffuseColor.w ; \n" +
                "} \n",
            "waterNormal_fs": "uniform vec2 waterNormalData[4]; \n" +
                "uniform float time ; \n" +
                "uniform sampler2D normalTextureA; \n" +
                "uniform sampler2D normalTextureB; \n" +
                "varying vec2 varying_uv0        ; \n" +
                "mat3 TBN ; \n" +
                "mat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) { \n" +
                "vec3 dp1 = dFdx(p); \n" +
                "vec3 dp2 = dFdy(p); \n" +
                "vec2 duv1 = dFdx(uv); \n" +
                "vec2 duv2 = dFdy(uv); \n" +
                "vec3 dp2perp = cross(dp2, N); \n" +
                "vec3 dp1perp = cross(N, dp1); \n" +
                "vec3 T = dp2perp * duv1.x + dp1perp * duv2.x; \n" +
                "vec3 B = dp2perp * duv1.y + dp1perp * duv2.y; \n" +
                "float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B))); \n" +
                "return mat3(T * invmax, B * invmax, N); \n" +
                "} \n" +
                "vec3 tbn(vec3 map, vec3 N, vec3 V, vec2 texcoord) { \n" +
                "mat3 TBN = cotangentFrame(N, -V, texcoord); \n" +
                "return normalize(TBN * map); \n" +
                "} \n" +
                "void main(void){ \n" +
                "float tempTime = mod(time,100000.0); \n" +
                "vec2 uvA = uv_0 * waterNormalData[3].x + waterNormalData[0] * tempTime ; \n" +
                "vec2 uvB = uv_0 * waterNormalData[3].y + waterNormalData[1] * tempTime  ; \n" +
                "vec3 normalTex_0 = texture2D(normalTextureA,uvA * 2.0 + normal.x*waterNormalData[2].x ).xyz *2.0 - 1.0; \n" +
                "vec3 normalTex_1 = texture2D(normalTextureB,uvB * 2.0 + normal.z*waterNormalData[2].y ).xyz *2.0 - 1.0; \n" +
                "normalTex_0.y *= -1.0; \n" +
                "normalTex_1.y *= -1.0; \n" +
                "vec3 normalTex_A = tbn( normalTex_0 , normal , -(varying_ViewDir) , uv_0 ); \n" +
                "vec3 normalTex_B = tbn( normalTex_1 , normal , -(varying_ViewDir) , uv_0 ); \n" +
                "normal.xyz = normalize( normalTex_A + normalTex_B ) ; \n" +
                "}  \n",
            "wave_fs": "uniform sampler2D diffuseTexture; \n" +
                "uniform vec3 uniform_eyepos; \n" +
                "uniform vec4 waveFSData[2]; \n" +
                "vec4 diffuseColor ; \n" +
                "void main(void){ \n" +
                "vec3 ViewDir = (mat3(uniform_NormalMatrix)*(uniform_eyepos.xyz - varying_ViewPose.xyz)) ; \n" +
                "diffuseColor.xyz = vec3(1.0,1.0,1.0) ; \n" +
                "vec3 shallowWaterColor = waveFSData[0].xyz * waveFSData[0].w ; \n" +
                "vec3 deepWaterColor = waveFSData[1].xyz * waveFSData[1].w; \n" +
                "float facing = clamp(dot( -normalize(ViewDir),normal),0.0,1.0); \n" +
                "vec3 waterColor = mix(shallowWaterColor,deepWaterColor,facing); \n" +
                "diffuseColor.xyz *= waterColor ; \n" +
                "}  \n",
            "wave_vs": "#define VERTEX_TEXTURES \n" +
                "attribute vec3 attribute_normal; \n" +
                "attribute vec4 attribute_color; \n" +
                "varying vec3 varying_ViewDir ; \n" +
                "uniform mat4 uniform_NormalMatrix; \n" +
                "uniform vec3 waveVSData[4]; \n" +
                "uniform float time ; \n" +
                "struct wave{ \n" +
                "vec3 wave_xyz_intensity_0 ; \n" +
                "vec3 wave_xyz_intensity_1 ; \n" +
                "vec3 wave_xyz_speed_0 ; \n" +
                "vec3 wave_xyz_speed_1 ; \n" +
                "}; \n" +
                "const float pi = 3.14 ; \n" +
                "vec3 calcWave2( float t , vec3 x, float amplitude, float waveLength ,float angularVelocity ,  vec3 waveDir ){ \n" +
                "angularVelocity = angularVelocity * 0.1; \n" +
                "vec3 waveVector = waveDir ; \n" +
                "float waveNumber = pi / waveLength; \n" +
                "waveVector *= waveNumber ; \n" +
                "vec3 temp ; \n" +
                "float kDotX0SubWt = dot(waveVector , x ) - angularVelocity * t  * 0.001; \n" +
                "float A = amplitude * sin(kDotX0SubWt) ; \n" +
                "temp.xz = waveDir.xz * A ; \n" +
                "temp.y += amplitude * cos(kDotX0SubWt); \n" +
                "temp = x - temp ; \n" +
                "return temp ; \n" +
                "} \n" +
                "void main(void){ \n" +
                "wave wa ; \n" +
                "wa.wave_xyz_intensity_0 = vec3(waveVSData[0]) ; \n" +
                "wa.wave_xyz_intensity_1 = vec3(waveVSData[1]) ; \n" +
                "wa.wave_xyz_speed_0 = vec3(waveVSData[2]) ; \n" +
                "wa.wave_xyz_speed_1 = vec3(waveVSData[3]) ; \n" +
                "float tempTime = mod( time , 1000000.0 ); \n" +
                "vec3 newPose1 = calcWave2(tempTime,e_position,40.0, 500.0, 20.0,vec3(1.0,0.0,1.0)); \n" +
                "newPose1 += calcWave2(tempTime,e_position,15.0, 50.0, 20.0,vec3(1.0,0.0,-0.5)); \n" +
                "newPose1 += calcWave2(tempTime,e_position,15.0, 50.0, 20.0,vec3(1.0,0.0,-0.5)); \n" +
                "e_position = newPose1 ; \n" +
                "mat3 normalMatrix = mat3(uniform_NormalMatrix); \n" +
                "varying_eyeNormal = normalize(-attribute_normal); \n" +
                "varying_ViewPose = vec4(e_position, 1.0) ; \n" +
                "varying_ViewDir = ((uniform_eyepos.xyz - e_position)) ; \n" +
                "outPosition = uniform_ModelViewMatrix * vec4(e_position, 1.0) ; \n" +
                "varying_color = attribute_color ; \n" +
                "}  \n",
        };
        return ShaderLib;
    }());
    egret3d.ShaderLib = ShaderLib;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ShaderPool = (function () {
        function ShaderPool() {
        }
        ShaderPool.register = function (context) {
            this.context = context;
        };
        ShaderPool.getGPUShader = function (shaderType, shaderID, source) {
            var shader = this.vsShaderHashMap.getValue(shaderID);
            if (!shader) {
                shader = this.fsShaderHashMap.getValue(shaderID);
            }
            if (!shader) {
                if (shaderType == egret3d.Shader.vertex) {
                    shader = this.context.creatVertexShader(source);
                    shader.id = shaderID;
                    this.vsShaderHashMap.add(shaderID, shader);
                }
                else if (shaderType == egret3d.Shader.fragment) {
                    shader = this.context.creatFragmentShader(source);
                    shader.id = shaderID;
                    this.fsShaderHashMap.add(shaderID, shader);
                }
            }
            return shader;
        };
        ShaderPool.getProgram = function (vs_shaderID, fs_shaderID) {
            var vsShader = this.vsShaderHashMap.getValue(vs_shaderID);
            var fsShader = this.fsShaderHashMap.getValue(fs_shaderID);
            var name = vsShader.id + "_" + fsShader.id;
            var program3D;
            if (this.programlib.isHas(name)) {
                program3D = this.programlib.getValue(name);
            }
            else {
                program3D = this.registerProgram(vsShader, fsShader);
                this.programlib.add(name, program3D);
            }
            return this.programlib.getValue(name);
        };
        ShaderPool.unRegisterShader = function (list) {
            //to delet shader
        };
        ShaderPool.registerProgram = function (vsShader, fsShader) {
            var program3D = this.context.creatProgram(vsShader, fsShader);
            return program3D;
        };
        ShaderPool.unRegisterProgram = function (vsKey, fsKey) {
            //to delet program
        };
        //总shader的map容器
        ShaderPool.programlib = new egret3d.HashMap();
        ShaderPool.vsShaderHashMap = new egret3d.HashMap();
        ShaderPool.fsShaderHashMap = new egret3d.HashMap();
        return ShaderPool;
    }());
    egret3d.ShaderPool = ShaderPool;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.ShaderContent
        * @classdesc
        * shader文件解析后的数据内容
        * 每种变量类型都进行了规类
        * 用相应的列表进行存储，这样可以便于shader文件进行合并
        * @version Egret 3.0
        * @platform Web,Native
        */
        var ShaderContent = (function () {
            function ShaderContent() {
                /**
                * @private
                * shader文件名
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.name = "";
                this.source = "";
                this.funcNames = new Array();
                this.funcDict = {};
                /**
                * @private
                * 结构体列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.structDict = {};
                this.structNames = new Array();
                /**
                * @private
                * attribute列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.attributeList = new Array();
                /**
                * @private
                * varying列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.varyingList = new Array();
                /**
                * @private
                * uniform列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.uniformList = new Array();
                /**
                * @private
                * const列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.constList = new Array();
                /**
                * @private
                * 临时变量列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.tempList = new Array();
                /**
                * @private
                * sampler2D列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.sampler2DList = new Array();
                /**
                * @private
                * sampler3D列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.sampler3DList = new Array();
                this.extensionList = new Array();
            }
            /**
            * @private
            * 增加一个变量对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            ShaderContent.prototype.addVar = function (sVar) {
                if (sVar.key == "attribute") {
                    this.attributeList.push(sVar);
                }
                else if (sVar.key == "varying") {
                    this.varyingList.push(sVar);
                }
                else if (sVar.key == "uniform") {
                    this.uniformList.push(sVar);
                }
                else if (sVar.key == "const") {
                    this.constList.push(sVar);
                }
                else if (sVar.key == "sampler2D") {
                    this.sampler2DList.push(sVar);
                }
                else if (sVar.key == "samplerCube") {
                    this.sampler3DList.push(sVar);
                }
                else if (sVar.key == "#extension") {
                    this.extensionList.push(sVar);
                }
                else {
                    this.tempList.push(sVar);
                }
            };
            /**
            * @private
            * 增加一个函数
            * @version Egret 3.0
            * @platform Web,Native
            */
            ShaderContent.prototype.addFunc = function (name, func) {
                if (!this.funcDict[name]) {
                    this.funcDict[name] = func;
                    this.funcNames.push(name);
                }
                else {
                    // if (name == "main") {
                    var newfunc = this.mergeMainFunc(this.funcDict[name], func);
                    this.funcDict[name] = newfunc;
                }
                if (this.funcDict["main"]) {
                    var index = this.funcNames.indexOf("main");
                    this.funcNames.splice(index, 1);
                    this.funcNames.push("main");
                }
            };
            /**
            * @private
            * 增加一个结构体
            * @version Egret 3.0
            * @platform Web,Native
            */
            ShaderContent.prototype.addStruct = function (name, structStr) {
                if (!this.structDict[name]) {
                    this.structDict[name] = structStr;
                    this.structNames.push(name);
                }
                else {
                    console.log("<" + name + ">" + "struct重复");
                }
            };
            /**
            * @private
            * 合并一个shader内容
            * @version Egret 3.0
            * @platform Web,Native
            */
            ShaderContent.prototype.addContent = function (otherContent) {
                for (var i = 0; i < otherContent.structNames.length; ++i) {
                    this.addStruct(otherContent.structNames[i], otherContent.structDict[otherContent.structNames[i]]);
                }
                for (var i = 0; i < otherContent.funcNames.length; ++i) {
                    this.addFunc(otherContent.funcNames[i], otherContent.funcDict[otherContent.funcNames[i]]);
                }
                for (var i = 0; i < otherContent.attributeList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.attributeList.length; ++j) {
                        if (otherContent.attributeList[i].name == this.attributeList[j].name) {
                            if (otherContent.attributeList[i].valueType != this.attributeList[j].valueType ||
                                otherContent.attributeList[i].key != this.attributeList[j].key) {
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.attributeList.push(otherContent.attributeList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.varyingList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.varyingList.length; ++j) {
                        if (otherContent.varyingList[i].name == this.varyingList[j].name) {
                            if (otherContent.varyingList[i].valueType != this.varyingList[j].valueType ||
                                otherContent.varyingList[i].key != this.varyingList[j].key) {
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.varyingList.push(otherContent.varyingList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.uniformList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.uniformList.length; ++j) {
                        if (otherContent.uniformList[i].name == this.uniformList[j].name) {
                            if (otherContent.uniformList[i].valueType != this.uniformList[j].valueType ||
                                otherContent.uniformList[i].key != this.uniformList[j].key) {
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.uniformList.push(otherContent.uniformList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.constList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.constList.length; ++j) {
                        if (otherContent.constList[i].name == this.constList[j].name) {
                            if (otherContent.constList[i].valueType != this.constList[j].valueType ||
                                otherContent.constList[i].key != this.constList[j].key) {
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.constList.push(otherContent.constList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.tempList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.tempList.length; ++j) {
                        if (otherContent.tempList[i].name == this.tempList[j].name) {
                            if (otherContent.tempList[i].valueType != this.tempList[j].valueType ||
                                otherContent.tempList[i].key != this.tempList[j].key) {
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.tempList.push(otherContent.tempList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.sampler2DList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.sampler2DList.length; ++j) {
                        if (otherContent.sampler2DList[i].name == this.sampler2DList[j].name) {
                            if (otherContent.sampler2DList[i].valueType != this.sampler2DList[j].valueType ||
                                otherContent.sampler2DList[i].key != this.sampler2DList[j].key) {
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.sampler2DList.push(otherContent.sampler2DList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.sampler3DList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.sampler3DList.length; ++j) {
                        if (otherContent.sampler3DList[i].name == this.sampler3DList[j].name) {
                            if (otherContent.sampler2DList[i].valueType != this.sampler3DList[j].valueType ||
                                otherContent.sampler3DList[i].key != this.sampler3DList[j].key) {
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.sampler3DList.push(otherContent.sampler3DList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.extensionList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.extensionList.length; ++j) {
                        if (otherContent.extensionList[i].name == this.extensionList[j].name) {
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.extensionList.push(otherContent.extensionList[i].clone());
                    }
                }
            };
            ShaderContent.prototype.mergeMainFunc = function (func1, func2) {
                var ret = func1;
                var func = "";
                var s_pos = func2.indexOf("{");
                var e_pos = func2.lastIndexOf("}");
                s_pos++;
                func = func2.slice(s_pos, e_pos);
                s_pos = ret.lastIndexOf("}");
                var f_func = ret.substr(0, s_pos);
                var s_func = ret.substr(s_pos, ret.length - s_pos);
                ret = f_func;
                ret += func;
                var temp = "";
                var line = "";
                var old = ret;
                ret += line;
                ret += s_func;
                return ret;
            };
            ShaderContent.prototype.clone = function () {
                var content = new ShaderContent();
                content.name = this.name;
                content.source = this.source;
                for (var i = 0; i < this.funcNames.length; ++i) {
                    content.funcNames.push(this.funcNames[i]);
                }
                for (var key in this.funcDict) {
                    content.funcDict[key] = this.funcDict[key];
                }
                for (var i = 0; i < this.structNames.length; ++i) {
                    content.structNames.push(this.structNames[i]);
                }
                for (var key in this.structDict) {
                    content.structDict[key] = this.structDict[key];
                }
                for (var i = 0; i < this.attributeList.length; ++i) {
                    content.attributeList.push(this.attributeList[i].clone());
                }
                for (var i = 0; i < this.varyingList.length; ++i) {
                    content.varyingList.push(this.varyingList[i].clone());
                }
                for (var i = 0; i < this.uniformList.length; ++i) {
                    content.uniformList.push(this.uniformList[i].clone());
                }
                for (var i = 0; i < this.constList.length; ++i) {
                    content.constList.push(this.constList[i].clone());
                }
                for (var i = 0; i < this.tempList.length; ++i) {
                    content.tempList.push(this.tempList[i].clone());
                }
                for (var i = 0; i < this.sampler2DList.length; ++i) {
                    content.sampler2DList.push(this.sampler2DList[i].clone());
                }
                for (var i = 0; i < this.sampler3DList.length; ++i) {
                    content.sampler3DList.push(this.sampler3DList[i].clone());
                }
                for (var i = 0; i < this.attributeList.length; ++i) {
                    content.attributeList.push(this.attributeList[i].clone());
                }
                for (var i = 0; i < this.extensionList.length; ++i) {
                    content.extensionList.push(this.extensionList[i].clone());
                }
                return content;
            };
            return ShaderContent;
        }());
        GLSL.ShaderContent = ShaderContent;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.FuncData
    * @classdesc
    * shader系统工具类，管理所有要用到的shader文件
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ShaderUtil = (function () {
        function ShaderUtil() {
            this._shaderContentDict = [];
            this.vs_begin = "##define vs begin##";
            this.vs_end = "##define vs end##";
            this.fs_begin = "##define fs begin##";
            this.fs_end = "##define fs end##";
        }
        Object.defineProperty(ShaderUtil, "instance", {
            /**
            * @language zh_CN
            *
            * 单例
            */
            get: function () {
                if (!this._instance) {
                    this._instance = new ShaderUtil();
                }
                return this._instance;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * @private
        * 加载shader文件
        */
        ShaderUtil.prototype.load = function () {
            var del = [];
            var add = [];
            for (var key in egret3d.ShaderLib.lib) {
                var s_pos = egret3d.ShaderLib.lib[key].indexOf(this.vs_begin);
                var e_pos = egret3d.ShaderLib.lib[key].indexOf(this.vs_end);
                var isDel = false;
                if (s_pos != -1) {
                    isDel = true;
                    s_pos += this.vs_begin.length;
                    del.push(key);
                    add[key + "vs"] = egret3d.ShaderLib.lib[key].substr(s_pos, e_pos - s_pos);
                }
                s_pos = egret3d.ShaderLib.lib[key].indexOf(this.fs_begin);
                e_pos = egret3d.ShaderLib.lib[key].indexOf(this.fs_end);
                if (s_pos != -1) {
                    s_pos += this.fs_begin.length;
                    if (isDel) {
                        del.push(key);
                    }
                    add[key + "fs"] = egret3d.ShaderLib.lib[key].substr(s_pos, e_pos - s_pos);
                }
            }
            for (var key in del) {
                delete egret3d.ShaderLib.lib[del[key]];
            }
            for (var key in add) {
                egret3d.ShaderLib.lib[key] = add[key];
            }
            for (var key in egret3d.ShaderLib.lib) {
                var content = this.readShader(egret3d.ShaderLib.lib[key]);
                this._shaderContentDict[key] = content;
                content.name = key;
            }
        };
        ShaderUtil.prototype.readShader = function (str) {
            var content = new egret3d.GLSL.ShaderContent();
            var shaderStr = egret3d.StringUtil.processShaderFile(str);
            var source = egret3d.StringUtil.parseContent(shaderStr);
            var shaderLine = source.concat();
            while (shaderLine.length > 0) {
                var line = shaderLine[0];
                shaderLine.shift();
                var ret = egret3d.StringUtil.getLineType(line);
                var index = -1;
                index = ret.indexOf("struct");
                if (index != -1) {
                    var tempArray = ret.split(" ");
                    var structStr = line;
                    content.addStruct(tempArray[1], structStr);
                    egret3d.StringUtil.processStruct(tempArray[1], structStr, content);
                    continue;
                }
                index = ret.indexOf("function");
                if (index != -1) {
                    var tempArray = ret.split(" ");
                    var func = line;
                    content.addFunc(tempArray[1], func);
                    continue;
                }
                index = ret.indexOf("unknown");
                if (index != -1) {
                    var tempArray = egret3d.StringUtil.parseLines(line);
                    var key = egret3d.StringUtil.getVarKey(tempArray);
                    var valueType = egret3d.StringUtil.getVarType(tempArray);
                    if (valueType == "sampler2D") {
                        var sampler2D = egret3d.StringUtil.getSampler2D(line);
                        if (sampler2D)
                            content.addVar(sampler2D);
                    }
                    else if (valueType == "samplerCube") {
                        var sampler3D = egret3d.StringUtil.getSampler3D(line);
                        if (sampler3D)
                            content.addVar(sampler3D);
                    }
                    else {
                        if (key == "attribute") {
                            var att = egret3d.StringUtil.getAttribute(line);
                            if (att)
                                content.addVar(att);
                        }
                        else if (key == "varying") {
                            var varying = egret3d.StringUtil.getVarying(line);
                            if (varying)
                                content.addVar(varying);
                        }
                        else if (key == "uniform") {
                            var uniform = egret3d.StringUtil.getUniform(line);
                            if (uniform)
                                content.addVar(uniform);
                        }
                        else if (key == "const") {
                            var ConstVar = egret3d.StringUtil.getConst(line);
                            if (ConstVar)
                                content.addVar(ConstVar);
                        }
                        else if (key == "#extension") {
                            var extension = egret3d.StringUtil.getExtension(line);
                            if (extension)
                                content.addVar(extension);
                        }
                        else {
                            content.addVar(egret3d.StringUtil.getTemper(line));
                        }
                    }
                    continue;
                }
            }
            return content;
        };
        /**
        * @language zh_CN
        * 返回组合shader后的内容
        * @param shaderNameList 要组合的shader名字列表
        * @param usage
        * @returns shader 内容
        */
        ShaderUtil.prototype.fillShaderContent = function (shaderBase, shaderNameList, usage) {
            var shaderContent;
            var i = 0;
            var varName = "";
            for (i = 0; i < shaderNameList.length; ++i) {
                if (varName != "") {
                    varName += "/";
                }
                varName += shaderNameList[i];
            }
            varName += "/d" + usage.maxDirectLight;
            varName += "/s" + usage.maxSpotLight;
            varName += "/p" + usage.maxPointLight;
            varName += "/b" + usage.maxBone;
            if (!this._shaderContentDict[varName]) {
                shaderContent = new egret3d.GLSL.ShaderContent();
                shaderContent.name = varName;
                for (i = 0; i < shaderNameList.length; ++i) {
                    var tempContent = this._shaderContentDict[shaderNameList[i]];
                    shaderContent.addContent(tempContent);
                }
            }
            else {
                shaderContent = this._shaderContentDict[varName].clone();
            }
            for (i = 0; i < shaderContent.attributeList.length; i++) {
                varName = shaderContent.attributeList[i].varName;
                usage[varName] = shaderContent.attributeList[i];
            }
            for (i = 0; i < shaderContent.varyingList.length; i++) {
                varName = shaderContent.varyingList[i].varName;
                if (!usage[varName]) {
                    usage[varName] = shaderContent.varyingList[i];
                }
            }
            for (i = 0; i < shaderContent.tempList.length; i++) {
                varName = shaderContent.tempList[i].varName;
                usage[varName] = shaderContent.tempList[i];
            }
            for (i = 0; i < shaderContent.uniformList.length; i++) {
                varName = shaderContent.uniformList[i].varName;
                usage[varName] = shaderContent.uniformList[i];
            }
            var constR;
            for (i = 0; i < shaderContent.constList.length; i++) {
                varName = shaderContent.constList[i].varName;
                constR = shaderContent.constList[i];
                usage[varName] = constR;
                switch (varName) {
                    case "max_directLight":
                        constR.value = usage.maxDirectLight;
                        break;
                    case "max_spotLight":
                        constR.value = usage.maxSpotLight;
                        break;
                    case "max_pointLight":
                        constR.value = usage.maxPointLight;
                        break;
                    case "bonesNumber":
                        shaderBase.maxBone = usage.maxBone;
                        constR.value = usage.maxBone;
                        break;
                }
            }
            ///sampler
            for (i = 0; i < shaderContent.sampler2DList.length; i++) {
                var sampler2D = shaderContent.sampler2DList[i];
                sampler2D.index = i;
                usage.sampler2DList.push(sampler2D);
                sampler2D.activeTextureIndex = ShaderUtil.getTexture2DIndex(i);
            }
            //for (i = 0; i < usage.sampler2DList.length; i++) {
            //    var sampler2D: GLSL.Sampler2D = usage.sampler2DList[i];
            //    sampler2D.index = i;
            //}
            ///sampler
            for (i = 0; i < shaderContent.sampler3DList.length; i++) {
                var sampler3D = shaderContent.sampler3DList[i];
                sampler3D.activeTextureIndex = ShaderUtil.getTexture2DIndex(shaderContent.sampler2DList.length + i);
                sampler3D.index = shaderContent.sampler2DList.length + i;
                usage.sampler3DList.push(sampler3D);
            }
            //usage.sampler3DList = shaderContent.sampler3DList;
            this.synthesisShader(shaderContent, shaderBase);
            return egret3d.ShaderPool.getGPUShader(shaderBase.shaderType, shaderContent.name, shaderContent.source);
        };
        ShaderUtil.prototype.synthesisShader = function (content, shaderBase) {
            var i;
            var source = "";
            for (i = 0; i < content.extensionList.length; i++) {
                source += ShaderUtil.connectExtension(content.extensionList[i]);
            }
            source += "precision highp float;            \t\n";
            ///var attribute
            for (i = 0; i < content.attributeList.length; i++) {
                source += ShaderUtil.connectAtt(content.attributeList[i]);
            }
            ///var struct
            for (i = 0; i < content.structNames.length; i++) {
                source += ShaderUtil.connectStruct(content.structDict[content.structNames[i]]);
            }
            ///var varying
            for (i = 0; i < content.varyingList.length; i++) {
                source += ShaderUtil.connectVarying(content.varyingList[i]);
            }
            ///temp
            for (i = 0; i < content.tempList.length; i++) {
                source += ShaderUtil.connectTemp(content.tempList[i]);
            }
            ///const
            for (i = 0; i < content.constList.length; i++) {
                source += ShaderUtil.connectConst(content.constList[i]);
            }
            ///uniform
            for (i = 0; i < content.uniformList.length; i++) {
                source += ShaderUtil.connectUniform(content.uniformList[i]);
            }
            ///sampler
            for (i = 0; i < content.sampler2DList.length; i++) {
                var sampler2D = content.sampler2DList[i];
                source += ShaderUtil.connectSampler(sampler2D);
            }
            ///sampler
            for (i = 0; i < content.sampler3DList.length; i++) {
                var sampler3D = content.sampler3DList[i];
                source += ShaderUtil.connectSampler3D(sampler3D);
            }
            ///---------------------------------------------------------------------------------
            ///---------------------------------------------------------------------------------
            for (i = 0; i < content.funcNames.length; i++) {
                source += content.funcDict[content.funcNames[i]];
            }
            content.source = source;
        };
        //----------------------------------------------------------------------------------------------------------------
        //----------------------------------------------------------------------------------------------------------------
        //----------------------------------------------------------------------------------------------------------------
        //----------------------------------------------------------------------------------------------------------------
        //----------------------------------------------------------------------------------------------------------------
        /**
        * @language zh_CN
        *
        * @param att
        */
        ShaderUtil.connectAtt = function (att) {
            return "attribute " + att.valueType + " " + att.name + "; \r\n";
        };
        /**
        * @language zh_CN
        *
        * @param tempVar
        */
        ShaderUtil.connectTemp = function (tempVar) {
            if (tempVar.value != "") {
                return tempVar.valueType + " " + tempVar.name + " = " + tempVar.value + "; \r\n";
            }
            return tempVar.valueType + " " + tempVar.name + "; \r\n";
        };
        /**
        * @language zh_CN
        *
        * @param struct
        */
        ShaderUtil.connectStruct = function (struct) {
            return struct + " \r\n";
        };
        /**
        * @language zh_CN
        *
        * @param constVar
        */
        ShaderUtil.connectConst = function (constVar) {
            return "const " + constVar.valueType + " " + constVar.name + " = " + constVar.value + "; \r\n";
        };
        /**
        * @language zh_CN
        *
        * @param varying
        */
        ShaderUtil.connectVarying = function (varying) {
            return "varying " + varying.valueType + " " + varying.name + "; \r\n";
        };
        /**
        * @language zh_CN
        *
        * @param unifrom
        */
        ShaderUtil.connectUniform = function (unifrom) {
            return "uniform " + unifrom.valueType + " " + unifrom.name + "; \r\n";
        };
        /**
        * @language zh_CN
        *
        * @param sampler
        */
        ShaderUtil.connectSampler = function (sampler) {
            return "uniform sampler2D " + sampler.name + "; \r\n";
        };
        ShaderUtil.connectSampler3D = function (sampler) {
            return "uniform samplerCube " + sampler.name + "; \r\n";
        };
        ShaderUtil.connectExtension = function (extension) {
            return "#extension " + extension.name + ":" + extension.value + "\r\n";
        };
        ShaderUtil.getTexture2DIndex = function (i) {
            switch (i) {
                case 0:
                    return egret3d.ContextSamplerType.TEXTURE_0;
                case 1:
                    return egret3d.ContextSamplerType.TEXTURE_1;
                case 2:
                    return egret3d.ContextSamplerType.TEXTURE_2;
                case 3:
                    return egret3d.ContextSamplerType.TEXTURE_3;
                case 4:
                    return egret3d.ContextSamplerType.TEXTURE_4;
                case 5:
                    return egret3d.ContextSamplerType.TEXTURE_5;
                case 6:
                    return egret3d.ContextSamplerType.TEXTURE_6;
                case 7:
                    return egret3d.ContextSamplerType.TEXTURE_7;
                case 8:
                    return egret3d.ContextSamplerType.TEXTURE_8;
            }
            throw new Error("texture not big then 8");
        };
        ShaderUtil._shaderLibs = {};
        ShaderUtil._methodLibs = {};
        return ShaderUtil;
    }());
    egret3d.ShaderUtil = ShaderUtil;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ShadowCast = (function () {
        function ShadowCast() {
            this.distance = 2000;
            this.dir = new egret3d.Vector3D(0, -1, -1);
            this.init();
        }
        Object.defineProperty(ShadowCast, "instance", {
            get: function () {
                if (!ShadowCast._instance) {
                    ShadowCast._instance = new ShadowCast();
                }
                return ShadowCast._instance;
            },
            enumerable: true,
            configurable: true
        });
        //使用阴影
        ShadowCast.enableShadow = function (flag) {
            this._enable = flag;
        };
        ShadowCast.prototype.init = function () {
            this.shadowRender = [];
        };
        ShadowCast.prototype.castShadowLight = function () {
            this.shadowRender.push(new egret3d.MultiRender(egret3d.PassType.shadowPass));
            this.shadowCamera = new egret3d.Camera3D();
            //this.shadowCamera.cameraType = CameraType.orthogonal;
            //this.shadowCamera.updateViewport(0, 0, 1024, 768);
            //this.shadowCamera.near = 500;
            //this.shadowCamera.far = 1500;
            this.shadowCamera.lookAt(new egret3d.Vector3D(0, 1000, -1000), new egret3d.Vector3D(0, 0, 0));
            this.shadowRender[this.shadowRender.length - 1].setRenderToTexture(512, 512);
        };
        ShadowCast.prototype.calculateCamera = function (object3d, camera) {
            egret3d.MathUtil.CALCULATION_VECTOR3D.copyFrom(this.dir);
            egret3d.MathUtil.CALCULATION_VECTOR3D.normalize();
            egret3d.MathUtil.CALCULATION_VECTOR3D.negate();
            egret3d.MathUtil.CALCULATION_VECTOR3D.scaleBy(this.distance);
            camera.lookAt(egret3d.MathUtil.CALCULATION_VECTOR3D, object3d.position);
        };
        ShadowCast._enable = false;
        return ShadowCast;
    }());
    egret3d.ShadowCast = ShadowCast;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.AnimationNode
     * @classdesc
     * 动画效果节点
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var AnimationNode = (function (_super) {
        __extends(AnimationNode, _super);
        function AnimationNode() {
            _super.apply(this, arguments);
            /**
            * @language zh_CN
            * 顶点着色器文件名
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.vertex_ShaderName = {};
            /**
            * @language zh_CN
            * 片断着色器文件名
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.fragment_ShaderName = {};
            /**
            * @language zh_CN
            * shader attribute 变量列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.attributes = new Array();
        }
        /**
        * @private
        */
        AnimationNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        */
        AnimationNode.prototype.initNode = function (data, arg) {
        };
        /**
        * @private
        */
        AnimationNode.prototype.update = function (animTime, delay, geometry) {
        };
        /**
        * @private
        */
        AnimationNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
        };
        /**
        * @private
        */
        AnimationNode.prototype.upload = function () {
        };
        return AnimationNode;
    }(egret3d.EventDispatcher));
    egret3d.AnimationNode = AnimationNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.AnimationCurve
    * @classdesc
    * 具有单一属性的 关键帧动画
    * 通过预计算后，动画信息将会缓存
    * @version Egret 3.0
    * @platform Web,Native
    */
    var AnimationCurve = (function () {
        function AnimationCurve() {
        }
        return AnimationCurve;
    }());
    egret3d.AnimationCurve = AnimationCurve;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var TimerAxis = (function (_super) {
        __extends(TimerAxis, _super);
        function TimerAxis() {
            _super.call(this);
            this._timeEvent = new egret3d.Event3D();
            this._times = new Array();
            this._processTimes = new Array();
            this._timer = 0;
            this._start = false;
        }
        TimerAxis.prototype.start = function () {
            this._timer = 0;
            this._start = true;
            this._processTimes.length = 0;
            for (var i = 0; i < this._times.length; ++i) {
                this._processTimes[i] = this._times[i];
            }
        };
        TimerAxis.prototype.addTimerAxis = function (time) {
            this._times.push(time);
        };
        TimerAxis.prototype.clearTimerAxis = function () {
            this._times.length = 0;
            this._processTimes.length = 0;
        };
        TimerAxis.prototype.reset = function () {
            this._processTimes.length = 0;
            this._timer = 0;
            this._start = false;
            for (var i = 0; i < this._times.length; ++i) {
                this._processTimes[i] = this._times[i];
            }
        };
        TimerAxis.prototype.update = function (delay, time) {
            if (!this._start) {
                return;
            }
            this._timer += delay;
            console.log(this._timer + "update");
            for (var i = 0; i < this._processTimes.length; ++i) {
                if (this._timer >= this._processTimes[i]) {
                    this._timeEvent.eventType = TimerAxis.TIME_EVENT;
                    this._timeEvent.data = this._processTimes[i];
                    this.dispatchEvent(this._timeEvent);
                    this._processTimes.splice(i, 1);
                    break;
                }
            }
        };
        TimerAxis.TIME_EVENT = "TimeEvent";
        return TimerAxis;
    }(egret3d.EventDispatcher));
    egret3d.TimerAxis = TimerAxis;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    (function (CurveType) {
        CurveType[CurveType["Line"] = 0] = "Line";
        CurveType[CurveType["BesselCurve"] = 1] = "BesselCurve";
    })(egret3d.CurveType || (egret3d.CurveType = {}));
    var CurveType = egret3d.CurveType;
    ;
    /**
    * @language zh_CN
    * @class egret3d.AnimCurve
    * @classdesc
    * AnimCurve 类为动画曲线，其中包含该曲线的类型，起始结束时刻以及参数�?
    *
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample animation/PropertyAnimation/AnimCurve.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var AnimCurve = (function () {
        function AnimCurve() {
            /**
            * @private
            */
            this.type = CurveType.Line;
            /**
            * @private
            */
            this.start = new egret3d.Point();
            /**
            * @private
            */
            this.end = new egret3d.Point();
            /**
            * @private
            */
            this.c1 = new egret3d.Point();
            /**
            * @private
            */
            this.c2 = new egret3d.Point();
            /**
            * @private
            */
            this.cache = null;
            /**
            * @private
            */
            this.useCache = false;
        }
        /**
        * @language zh_CN
        * 计算数�?
        * @param time 某个时刻
        * @returns number 该时刻对应的数�?
        * @version Egret 3.0
        * @platform Web,Native
        */
        AnimCurve.prototype.calculateValue = function (time) {
            if (time < this.start.x || time > this.end.x) {
                return 0;
            }
            if (this.useCache) {
                return this.cache[Math.floor(time - this.start.x)];
            }
            switch (this.type) {
                case CurveType.Line:
                    return this.valueFromLine(time);
                case CurveType.BesselCurve:
                    return this.valueFromBesselCurve(time);
            }
            return 0;
        };
        AnimCurve.prototype.valueFromLine = function (time) {
            var t = (time - this.start.x) / (this.end.x - this.start.x);
            return this.start.y + t * (this.end.y - this.start.y);
        };
        AnimCurve.prototype.valueFromBesselCurve = function (time) {
            var t = (time - this.start.x) / (this.end.x - this.start.x);
            var _1t = 1 - t;
            var _1t2 = _1t * _1t;
            var _1t3 = _1t2 * _1t;
            return this.start.y * _1t3 + 3 * this.c1.y * t * _1t2 + 3 * this.c2.x * t * t * _1t + this.end.y * t * t * t;
        };
        /**
        * @private
        */
        AnimCurve.prototype.cacheCurveData = function () {
            this.cache = [];
            for (var time = this.start.x; time < this.end.x; time++) {
                this.cache.push(this.calculateValue(time));
            }
            this.useCache = true;
        };
        return AnimCurve;
    }());
    egret3d.AnimCurve = AnimCurve;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.PropertyAnim
    * @classdesc
    * PropertyAnim 类为曲线动画驱动器，类中保存了各个属性对应的数值曲线数据，通过时间计算某个属性在某时刻的属性数值
    *
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample animation/PropertyAnimation/PropertyAnim.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PropertyAnim = (function (_super) {
        __extends(PropertyAnim, _super);
        function PropertyAnim() {
            _super.call(this);
            /**
            * @language zh_CN
            * 播放速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.speed = 1;
            this.isLoop = true;
            this._propertyArray = [];
            this._play = false;
            this._timePosition = 0;
            this._totalTime = 0;
            this._changeFrameTime = 0;
            this._oldFrameIndex = 0;
            this._event3D = new egret3d.Event3D();
        }
        /**
        * @language zh_CN
        * 是否存在某个属性的曲线动画
        * @returns boolean 是否存在
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.IsExist = function (property) {
            for (var i = 0; i < this._propertyArray.length; i++) {
                if (this._propertyArray[i].property == property) {
                    return true;
                }
            }
            return false;
        };
        /**
        * @language zh_CN
        * 添加曲线动画数据
        * @prame property 属性名
        * @prame keyFrames 曲线动画帧
        * @returns boolean 是否成功
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.addAnimCurve = function (property, keyFrames) {
            if (this.IsExist(property)) {
                return false;
            }
            if (null == keyFrames || keyFrames.length <= 0) {
                return false;
            }
            var propertyData = new PropertyData();
            propertyData.keyFrames = keyFrames;
            propertyData.property = property;
            propertyData.target = this._target;
            propertyData.isLoop = true;
            propertyData.timePosition = 0;
            this._propertyArray.push(propertyData);
            for (var i = 0; i < keyFrames.length - 1; i++) {
                if (keyFrames[i].end.x > this._totalTime) {
                    this._totalTime = keyFrames[i].end.x;
                    keyFrames[i].cacheCurveData();
                }
            }
            this.updateBindData(propertyData);
        };
        /**
        * @language zh_CN
        * 移除曲线动画数据
        * @prame property 属性名
        * @returns AnimCurve[] 曲线动画帧
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.removeAnimCurve = function (property) {
            var propertyData = null;
            for (var i = 0; i < this._propertyArray.length; i++) {
                if (this._propertyArray[i].property == property) {
                    propertyData = this._propertyArray[i];
                    this._propertyArray.splice(i, 1);
                    return propertyData.keyFrames;
                }
            }
        };
        /**
        * @language zh_CN
        * 设置属性是否循环播放
        * @prame property 属性名
        * @prame isLoop 是否循环播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.setPropertyLoop = function (property, isLoop) {
            var propertyData = null;
            for (var i = 0; i < this._propertyArray.length; i++) {
                if (this._propertyArray[i].property == property) {
                    propertyData = this._propertyArray[i];
                    propertyData.isLoop = isLoop;
                    break;
                }
            }
        };
        /**
        * @language zh_CN
        * 绑定需要驱动的Object3D对象
        * @prame target Object3D对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.bindObject3D = function (target) {
            this._target = target;
            for (var i = 0; i < this._propertyArray.length; i++) {
                this.updateBindData(this._propertyArray[i]);
            }
        };
        PropertyAnim.prototype.updateBindData = function (propertyData) {
            if (!this._target) {
                return;
            }
            propertyData.target = this._target;
            var strArray = propertyData.property.split('.');
            for (var i = 0; i < strArray.length - 1; i++) {
                propertyData.target = propertyData.target[strArray[i]];
            }
            propertyData.name = strArray[strArray.length - 1];
        };
        /**
        * @language zh_CN
        * 播放属性动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.play = function () {
            if (this._play) {
                return;
            }
            this._play = true;
            this._timePosition = 0;
            for (var i = 0; i < this._propertyArray.length; i++) {
                this._propertyArray[i].timePosition = 0;
            }
        };
        /**
        * @language zh_CN
        * 停止播放属性动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.stop = function () {
            this._play = false;
        };
        Object.defineProperty(PropertyAnim.prototype, "timePosition", {
            /**
            * @language zh_CN
            * 时间位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._timePosition;
            },
            /**
            * @language zh_CN
            * 时间位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (value == this._timePosition) {
                    return;
                }
                var delay = value - this._timePosition;
                this._timePosition = value;
                if (this.isLoop) {
                    this._timePosition = value % this._totalTime;
                    if (this._timePosition < 0) {
                        this._timePosition += this._totalTime;
                    }
                }
                else {
                    if (this._timePosition < 0) {
                        this._timePosition = 0;
                        this._event3D.eventType = egret3d.PropertyAnimEvent3D.EVENT_PLAY_COMPLETE;
                        this._event3D.target = this;
                        this.dispatchEvent(this._event3D);
                        this.stop();
                    }
                    else if (this._timePosition > this._totalTime) {
                        this._timePosition = this._totalTime;
                        this._event3D.eventType = egret3d.PropertyAnimEvent3D.EVENT_PLAY_COMPLETE;
                        this._event3D.target = this;
                        this.dispatchEvent(this._event3D);
                        this.stop();
                    }
                }
                if (!this._target) {
                    return;
                }
                var propertyData;
                var keyFrames;
                for (var i = 0; i < this._propertyArray.length; i++) {
                    propertyData = this._propertyArray[i];
                    keyFrames = propertyData.keyFrames;
                    var valueTime = propertyData.timePosition + delay;
                    if (valueTime == propertyData.timePosition) {
                        continue;
                    }
                    var timeLength = keyFrames[keyFrames.length - 1].end.x;
                    propertyData.timePosition = valueTime;
                    if (propertyData.isLoop) {
                        propertyData.timePosition = value % timeLength;
                        if (propertyData.timePosition < 0) {
                            propertyData.timePosition += timeLength;
                        }
                    }
                    else {
                        if (propertyData.timePosition < 0) {
                            propertyData.timePosition = 0;
                            continue;
                        }
                        else if (propertyData.timePosition > timeLength) {
                            propertyData.timePosition = timeLength;
                            continue;
                        }
                    }
                    for (var j = 0; j < keyFrames.length - 1; j++) {
                        if (keyFrames[j].start.x <= propertyData.timePosition && keyFrames[j].end.x > propertyData.timePosition) {
                            propertyData.target[propertyData.name] = keyFrames[j].calculateValue(propertyData.timePosition);
                            break;
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PropertyAnim.prototype, "totalTime", {
            /**
            * @language zh_CN
            * 动画总时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._totalTime;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 更新动画数据
        * @prame delay 延迟时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.update = function (delay) {
            if (!this._play) {
                return;
            }
            var beginTime = this.timePosition;
            this.timePosition += delay * this.speed;
            if (this.timePosition < beginTime) {
                this._event3D.eventType = egret3d.PropertyAnimEvent3D.EVENT_PLAY_COMPLETE;
                this._event3D.target = this;
                this.dispatchEvent(this._event3D);
            }
        };
        /**
        * @language zh_CN
        * 克隆属性动画对象
        * @returns PropertyAnim 新的属性动画对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.clone = function () {
            var pro = new PropertyAnim();
            pro._propertyArray = this._propertyArray;
            return pro;
        };
        return PropertyAnim;
    }(egret3d.EventDispatcher));
    egret3d.PropertyAnim = PropertyAnim;
    /**
    * @private
    * @language zh_CN
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PropertyData = (function () {
        function PropertyData() {
        }
        return PropertyData;
    }());
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Joint
    * @classdesc
    * Joint 类表示骨骼关节，属于骨架类的组成部分， Joint类属于骨架实现的内部类，无需直接实例化。
    *
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample animation/skeletonAnimation/Joint.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Joint = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @param name 骨骼名称
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Joint(name) {
            /**
            * @language zh_CN
            * 父骨骼名称
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.parent = null;
            this.name = name;
            this.parentIndex = -1;
            this.scale = new egret3d.Vector3D(1, 1, 1);
            this.orientation = new egret3d.Quaternion();
            this.translation = new egret3d.Vector3D();
            this.localMatrix = new egret3d.Matrix4_4();
            this.worldMatrix = new egret3d.Matrix4_4();
            this.worldMatrixValid = false;
        }
        /**
        * @language zh_CN
        * 克隆新骨骼对象
        * @returns Joint 新骨骼对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Joint.prototype.clone = function () {
            var joint = new Joint(this.name);
            joint.parent = this.parent;
            joint.parentIndex = this.parentIndex;
            joint.scale.copyFrom(this.scale);
            joint.orientation.copyFrom(this.orientation);
            joint.translation.copyFrom(this.translation);
            joint.localMatrix.copyFrom(this.localMatrix);
            joint.worldMatrix.copyFrom(this.worldMatrix);
            joint.worldMatrixValid = this.worldMatrixValid;
            return joint;
        };
        /**
        * @language zh_CN
        * 构建骨骼本地矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Joint.prototype.buildLocalMatrix = function (scale, rotation, translation) {
            this.scale.copyFrom(scale);
            this.translation.copyFrom(translation);
            if (rotation instanceof egret3d.Vector3D) {
                this.orientation.fromEulerAngles(rotation.x, rotation.y, rotation.z);
            }
            else {
                this.orientation.copyFrom(rotation);
            }
            this.localMatrix.makeTransform(this.translation, this.scale, this.orientation);
        };
        /**
        * @language zh_CN
        * 构建骨骼逆矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Joint.prototype.buildInverseMatrix = function (scale, rotation, translation) {
            if (!this.inverseMatrix) {
                this.inverseMatrix = new egret3d.Matrix4_4();
            }
            if (rotation instanceof egret3d.Vector3D) {
                this.inverseMatrix.recompose([translation, rotation, scale]);
            }
            else {
                this.inverseMatrix.makeTransform(translation, scale, rotation);
            }
        };
        return Joint;
    }());
    egret3d.Joint = Joint;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Skeleton
    * @classdesc
    * Skeleton 类表示骨架类，其中包含若干个 Joint（骨骼关节） 对象。
    *
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample animation/skeletonAnimation/Skeleton.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Skeleton = (function () {
        function Skeleton() {
            /**
            * @language zh_CN
            * 骨架包含的骨骼
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.joints = [];
        }
        /**
        * @language zh_CN
        * 克隆新骨架对象
        * @returns Skeleton 新骨架对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Skeleton.prototype.clone = function () {
            var skeleton = new Skeleton();
            for (var i = 0; i < this.joints.length; i++) {
                skeleton.joints.push(this.joints[i].clone());
            }
            return skeleton;
        };
        Object.defineProperty(Skeleton.prototype, "jointNum", {
            /**
            * @language zh_CN
            * 骨骼数量
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.joints.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 通过名称查找指定骨骼
        * @param name 骨骼名称
        * @return 骨骼对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Skeleton.prototype.findJoint = function (name) {
            for (var i = 0; i < this.joints.length; i++) {
                if (this.joints[i].name == name)
                    return this.joints[i];
            }
            return null;
        };
        /**
        * @language zh_CN
        * 通过名称查找骨骼索引编号
        * @param name 骨骼名称
        * @returns number 骨骼索引编号
        * @version Egret 3.0
        * @platform Web,Native
        */
        Skeleton.prototype.findJointIndex = function (name) {
            for (var i = 0; i < this.joints.length; i++) {
                if (this.joints[i].name == name)
                    return i;
            }
            return -1;
        };
        return Skeleton;
    }());
    egret3d.Skeleton = Skeleton;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var SkeletonPose = (function () {
        function SkeletonPose() {
            /**
            * @language zh_CN
            * 骨架包含的骨骼
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.joints = [];
            ///**
            //* @language zh_CN
            //* GPU所需的骨骼缓存数据
            //* @version Egret 3.0
            //* @platform Web,Native
            //*/
            //public cacheData: Float32Array;
            ///**
            //* @language zh_CN
            //* GPU所需的骨骼缓存数据是否有效
            //* @version Egret 3.0
            //* @platform Web,Native
            //*/
            //public cacheDataValid: boolean;
            this._temp_q0 = new egret3d.Quaternion();
            this._temp_q1 = new egret3d.Quaternion();
            this._temp_q2 = new egret3d.Quaternion();
            this._temp_v0 = new egret3d.Vector3D();
            this._temp_v1 = new egret3d.Vector3D();
            this._temp_v2 = new egret3d.Vector3D();
        }
        /**
        * @language zh_CN
        * 克隆新骨架对象
        * @returns Skeleton 新骨架对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.clone = function () {
            var skeletonPose = new SkeletonPose();
            skeletonPose.frameTime = this.frameTime;
            for (var i = 0; i < this.joints.length; i++) {
                skeletonPose.joints.push(this.joints[i].clone());
            }
            return skeletonPose;
        };
        /**
        * @language zh_CN
        * 骨架插值计算
        * @param skeletonA 骨架A
        * @param skeletonB 骨架B
        * @param t 时间因子(0~1);
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.lerp = function (skeletonPoseA, skeletonPoseB, t) {
            this.joints = [];
            this.frameTime = (skeletonPoseB.frameTime - skeletonPoseA.frameTime) * t + skeletonPoseA.frameTime;
            for (var i = 0; i < skeletonPoseA.joints.length; ++i) {
                var jointA = skeletonPoseA.joints[i];
                var jointB = skeletonPoseB.joints[i];
                var joint = new egret3d.Joint(jointA.name);
                joint.name = jointA.name;
                joint.parent = jointA.parent;
                joint.parentIndex = jointA.parentIndex;
                joint.scale.lerp(jointA.scale, jointB.scale, t);
                joint.orientation.lerp(jointA.orientation, jointB.orientation, t);
                joint.translation.lerp(jointA.translation, jointB.translation, t);
                joint.buildLocalMatrix(joint.scale, joint.orientation, joint.translation);
                joint.worldMatrixValid = jointA.worldMatrixValid;
                if (joint.worldMatrixValid) {
                    //pos rot scale
                    var decomposeA = jointA.worldMatrix.decompose(egret3d.Orientation3D.QUATERNION);
                    var decomposeB = jointB.worldMatrix.decompose(egret3d.Orientation3D.QUATERNION);
                    //pos;
                    this._temp_v0.lerp(decomposeA[0], decomposeB[0], t);
                    //rot;
                    this._temp_q1.x = decomposeA[1].x;
                    this._temp_q1.y = decomposeA[1].y;
                    this._temp_q1.z = decomposeA[1].z;
                    this._temp_q1.w = decomposeA[1].w;
                    this._temp_q2.x = decomposeB[1].x;
                    this._temp_q2.y = decomposeB[1].y;
                    this._temp_q2.z = decomposeB[1].z;
                    this._temp_q2.w = decomposeB[1].w;
                    this._temp_q0.lerp(this._temp_q1, this._temp_q2, t);
                    //scale;
                    this._temp_v1.lerp(decomposeA[2], decomposeB[2], t);
                    joint.worldMatrix.makeTransform(this._temp_v0, this._temp_v1, this._temp_q0);
                }
                this.joints.push(joint);
            }
            //this.calculateJointWorldMatrix();
            return this;
        };
        /**
        * @language zh_CN
        * 计算当前骨架内所有骨骼的世界矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.calculateJointWorldMatrix = function () {
            for (var i = 0; i < this.joints.length; ++i) {
                this.calculateAbsoluteMatrix(i);
            }
        };
        //递归函数，用于计算骨骼世界矩阵
        SkeletonPose.prototype.calculateAbsoluteMatrix = function (jointIndex) {
            var joint = this.joints[jointIndex];
            if (joint.parentIndex >= 0) {
                this.calculateAbsoluteMatrix(joint.parentIndex);
            }
            if (!joint.worldMatrixValid) {
                joint.worldMatrix.copyFrom(joint.localMatrix);
                if (joint.parentIndex >= 0) {
                    joint.worldMatrix.append(this.joints[joint.parentIndex].worldMatrix);
                }
                joint.worldMatrixValid = true;
            }
        };
        /**
        * @language zh_CN
        * 更新GPU所需的骨骼缓存数据
        * @param skeleton 蒙皮骨骼骨架
        * @returns Float32Array 缓存数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.updateGPUCacheData = function (skeleton, skeletonMatrixData) {
            var jointMatrix = new egret3d.Matrix4_4();
            for (var i = 0; i < skeleton.joints.length; ++i) {
                for (var j = 0; j < this.joints.length; ++j) {
                    if (skeleton.joints[i].name != this.joints[j].name)
                        continue;
                    jointMatrix.copyFrom(skeleton.joints[i].inverseMatrix);
                    jointMatrix.append(this.joints[j].worldMatrix);
                    var test = jointMatrix.decompose(egret3d.Orientation3D.QUATERNION);
                    skeletonMatrixData[i * 8 + 0] = test[1].x;
                    skeletonMatrixData[i * 8 + 1] = test[1].y;
                    skeletonMatrixData[i * 8 + 2] = test[1].z;
                    skeletonMatrixData[i * 8 + 3] = test[1].w;
                    skeletonMatrixData[i * 8 + 4] = test[0].x;
                    skeletonMatrixData[i * 8 + 5] = test[0].y;
                    skeletonMatrixData[i * 8 + 6] = test[0].z;
                    skeletonMatrixData[i * 8 + 7] = 1;
                    break;
                }
            }
            return skeletonMatrixData;
        };
        /**
        * @language zh_CN
        * 通过名称查找指定骨骼
        * @param name 骨骼名称
        * @return 骨骼对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.findJoint = function (name) {
            for (var i = 0; i < this.joints.length; i++) {
                if (this.joints[i].name == name)
                    return this.joints[i];
            }
            return null;
        };
        /**
        * @language zh_CN
        * 通过名称查找骨骼索引编号
        * @param name 骨骼名称
        * @returns number 骨骼索引编号
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.findJointIndex = function (name) {
            for (var i = 0; i < this.joints.length; i++) {
                if (this.joints[i].name == name)
                    return i;
            }
            return -1;
        };
        /**
        * @language zh_CN
        * 重置骨骼世界矩阵;
        * @param name 骨骼名称
        * @returns number 骨骼索引编号
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.resetWorldMatrix = function () {
            for (var i = 0; i < this.joints.length; i++) {
                this.joints[i].worldMatrixValid = false;
            }
        };
        return SkeletonPose;
    }());
    egret3d.SkeletonPose = SkeletonPose;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var SkeletonAnimationClip = (function () {
        function SkeletonAnimationClip() {
            /**
            * @language zh_CN
            * ÿ֡��SkeletonPose
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.poseArray = [];
            this.animationName = "";
        }
        Object.defineProperty(SkeletonAnimationClip.prototype, "timeLength", {
            /**
            * @language zh_CN
            * ʱ�䳤��
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this.poseArray.length <= 0) {
                    return 0;
                }
                return this.poseArray[this.poseArray.length - 1].frameTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationClip.prototype, "jointNum", {
            /**
            * @language zh_CN
            * ��������
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this.poseArray.length <= 0) {
                    return 0;
                }
                return this.poseArray[0].joints.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * ��¡SkeletonAnimationClip����
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimationClip.prototype.clone = function () {
            var skeletonAnimationClip = new SkeletonAnimationClip();
            skeletonAnimationClip.animationName = this.animationName;
            skeletonAnimationClip.poseArray = this.poseArray;
            return skeletonAnimationClip;
        };
        return SkeletonAnimationClip;
    }());
    egret3d.SkeletonAnimationClip = SkeletonAnimationClip;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var SkeletonAnimationState = (function () {
        function SkeletonAnimationState(name) {
            /**
            * @language zh_CN
            * State����
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.name = "";
            /**
            * @language zh_CN
            * �ں�Ȩ��ֵ
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.weight = 1.0;
            this._skeleton = null;
            this._timeLength = 0;
            this._timePosition = 0;
            this._skeletonAnimation = null;
            this._skeletonAnimationClip = null;
            this.name = name;
        }
        Object.defineProperty(SkeletonAnimationState.prototype, "skeleton", {
            /**
            * @language zh_CN
            * ��Ƥ�Ǽ�
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._skeleton;
            },
            /**
            * @language zh_CN
            * ��Ƥ�Ǽ�
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (skeleton) {
                this._skeleton = skeleton;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationState.prototype, "skeletonAnimation", {
            /**
            * @language zh_CN
            * ��������������
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._skeletonAnimation;
            },
            /**
            * @language zh_CN
            * ��������������
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (skeletonAnimation) {
                this._skeletonAnimation = skeletonAnimation;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationState.prototype, "skeletonAnimationClip", {
            /**
            * @language zh_CN
            * �����������
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._skeletonAnimationClip;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationState.prototype, "timeLength", {
            /**
            * @language zh_CN
            * ����ʱ�䳤��
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._timeLength;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * ��� SkeletonAnimationClip ����
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimationState.prototype.addAnimationClip = function (animationClip) {
            if (!this._skeletonAnimationClip) {
                this._skeletonAnimationClip = new egret3d.SkeletonAnimationClip();
            }
            else {
                this._skeletonAnimationClip.poseArray = [];
            }
            if (animationClip.poseArray.length < 2) {
                this._skeletonAnimationClip.poseArray = animationClip.poseArray;
            }
            else {
                var skeletonPoseA = animationClip.poseArray[0];
                var skeletonPoseB = animationClip.poseArray[1];
                var nCount = Math.round((skeletonPoseB.frameTime - skeletonPoseA.frameTime) / egret3d.SkeletonAnimation.fps);
                if (nCount <= 1) {
                    this._skeletonAnimationClip.poseArray = animationClip.poseArray;
                }
                else {
                    for (var i = 1; i < animationClip.poseArray.length; ++i) {
                        skeletonPoseA = animationClip.poseArray[i - 1];
                        skeletonPoseB = animationClip.poseArray[i];
                        for (var j = 0; j < nCount; j++) {
                            var skeletonPose = new egret3d.SkeletonPose();
                            skeletonPose.lerp(skeletonPoseA, skeletonPoseB, j / nCount);
                            this._skeletonAnimationClip.poseArray.push(skeletonPose);
                        }
                    }
                    this._skeletonAnimationClip.poseArray.push(animationClip.poseArray[animationClip.poseArray.length - 1].clone());
                }
            }
            this._timeLength = this._skeletonAnimationClip.poseArray[this._skeletonAnimationClip.poseArray.length - 1].frameTime;
        };
        Object.defineProperty(SkeletonAnimationState.prototype, "timePosition", {
            /**
            * @language zh_CN
            * ʱ��λ��
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._timePosition;
            },
            /**
            * @language zh_CN
            * ʱ��λ��
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (value == this._timePosition) {
                    return;
                }
                this._timePosition = value;
                if (this._skeletonAnimation.isLoop) {
                    this._timePosition = value % this._timeLength;
                    if (this._timePosition < 0) {
                        this._timePosition += this._timeLength;
                    }
                }
                else {
                    if (this._timePosition < 0) {
                        this._timePosition = 0;
                        if (this.name == this._skeletonAnimation.currentAnimName) {
                            this._skeletonAnimation.stop();
                        }
                    }
                    else if (this._timePosition > this._timeLength) {
                        this._timePosition = this._timeLength;
                        if (this.name == this._skeletonAnimation.currentAnimName) {
                            this._skeletonAnimation.stop();
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationState.prototype, "currentSkeletonPose", {
            /**
            * @language zh_CN
            * ��ȡ��ǰ֡��SkeletonPose
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._skeletonAnimationClip.poseArray[this.currentFrameIndex];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationState.prototype, "currentFrameIndex", {
            /**
            * @language zh_CN
            * ��ȡ��ǰ֡����
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return Math.floor(this._timePosition / egret3d.SkeletonAnimation.fps);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationState.prototype, "frameNum", {
            /**
            * @language zh_CN
            * ��ȡ֡����
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (!this._skeletonAnimationClip) {
                    return 0;
                }
                return this._skeletonAnimationClip.poseArray.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * ��ȡSkeletonPose
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimationState.prototype.getSkeletonPose = function (index) {
            return this._skeletonAnimationClip.poseArray[index];
        };
        /**
        * @language zh_CN
        * ��¡SkeletonAnimationState����
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimationState.prototype.clone = function () {
            var skeletonAnimationState = new SkeletonAnimationState(this.name);
            skeletonAnimationState._skeleton = this._skeleton;
            skeletonAnimationState._timeLength = this._timeLength;
            skeletonAnimationState._skeletonAnimation = this._skeletonAnimation;
            skeletonAnimationState._skeletonAnimationClip = this._skeletonAnimationClip;
            return skeletonAnimationState;
        };
        return SkeletonAnimationState;
    }());
    egret3d.SkeletonAnimationState = SkeletonAnimationState;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.SkeletonAnimation
    * @classdesc
    * SkeletonAnimation 类表示骨骼动画控制类
    *
    * 骨骼动画控制类中管理若干个 SkeletonAnimationClip（骨骼动画） 对象，每个SkeletonAnimationClip对象，都是对*.eam 文件的实例。
    * @includeExample anim/skeletonAnimation/SkeletonAnimation.ts
    * @see egret3d.SkeletonAnimationClip
    * @version Egret 3.0
    * @platform Web,Native
    */
    var SkeletonAnimation = (function (_super) {
        __extends(SkeletonAnimation, _super);
        function SkeletonAnimation(skeleton) {
            _super.call(this);
            /**
            * @language zh_CN
            * 播放速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.speed = 1;
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.event3D = new egret3d.Event3D();
            this.isLoop = true;
            this._isPlay = false;
            this._animTime = 0;
            this._skeleton = null;
            this._animStateNames = [];
            this._animStates = [];
            this._skeletonMatrixData = null;
            this._blendSpeed = 300;
            this._blendSkeleton = null;
            this._blendList = [];
            this._bindList = {};
            this._temp_quat = new egret3d.Quaternion();
            this._temp_vec3 = new egret3d.Vector3D();
            this._currentFrame = 0;
            this._changeFrameTime = 0;
            this._oldFrameIndex = 0;
            this._isPlay = false;
            this._skeleton = skeleton;
            this._skeletonMatrixData = new Float32Array(this._skeleton.jointNum * 8);
            for (var i = 0; i < this._skeleton.jointNum; ++i) {
                this._skeletonMatrixData[i * 8 + 3] = 1;
                this._skeletonMatrixData[i * 8 + 7] = 1;
            }
        }
        /**
        * @language zh_CN
        * 添加骨骼动画剪辑对象
        * @param animState 骨骼动画状态对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.addSkeletonAnimationClip = function (animationClip) {
            var animState = new egret3d.SkeletonAnimationState(animationClip.animationName);
            animState.skeletonAnimation = this;
            animState.skeleton = this._skeleton;
            animState.addAnimationClip(animationClip);
            this.addAnimState(animState);
        };
        Object.defineProperty(SkeletonAnimation.prototype, "skeletonAnimationController", {
            /**
            * @language zh_CN
            * 骨骼动画控制器
            * @returns SkeletonAnimation 骨骼动画对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 添加骨骼动画状态对象
        * @param animState 骨骼动画状态对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.addAnimState = function (animState) {
            for (var i = 0; i < this._animStates.length; i++) {
                if (this._animStates[i].name == animState.name) {
                    return;
                }
            }
            animState.skeleton = this._skeleton;
            this._animStates.push(animState);
            this._animStateNames.push(animState.name);
        };
        /**
        * @language zh_CN
        * 移除骨骼动画状态对象
        * @param animState 骨骼动画状态对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.removeAnimState = function (animState) {
            for (var i = 0; i < this._animStates.length; i++) {
                if (this._animStates[i].name == animState.name) {
                    animState.skeleton = null;
                    this._animStates.slice(i, 1);
                    this._animStateNames.slice(i, 1);
                    return;
                }
            }
        };
        /**
        * @language zh_CN
        * 播放骨骼动画
        * @param animName 动画名称
        * @param speed 播放速度
        * @param reset 是否重置
        * @param prewarm 是否预热
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.play = function (animName, speed, reset, prewarm) {
            if (speed === void 0) { speed = 1; }
            if (reset === void 0) { reset = true; }
            if (prewarm === void 0) { prewarm = true; }
            var playSkeletonAnimationState = null;
            for (var i = 0; i < this._animStates.length; i++) {
                if (this._animStates[i].name == animName) {
                    playSkeletonAnimationState = this._animStates[i];
                    break;
                }
            }
            if (!playSkeletonAnimationState) {
                return;
            }
            this._currentAnimName = animName;
            this._blendList.push(playSkeletonAnimationState);
            playSkeletonAnimationState.weight = this._blendList.length > 1 ? 0 : 1;
            if (reset) {
                this._animTime = playSkeletonAnimationState.timePosition = 0;
            }
            this.speed = speed;
            this._isPlay = true;
        };
        /**
        * @language zh_CN
        * 暂停骨骼动画播放（停留在当前帧）
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.pause = function () {
            this._isPlay = false;
        };
        /**
        * @language zh_CN
        * 停止骨骼动画播放（停留在第一帧）
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.stop = function () {
            this._isPlay = false;
        };
        /**
        * @language zh_CN
        * 更新骨骼动画
        * @param time 总时间
        * @param delay 延迟时间
        * @param geometry 该值无效
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.update = function (time, delay, geometry) {
            if (!this._isPlay) {
                return;
            }
            if (this._blendList.length <= 0) {
                return;
            }
            var mainState = this._blendList[this._blendList.length - 1];
            var delayTime = delay * this.speed;
            this._changeFrameTime += delayTime;
            var count = Math.floor(Math.abs(this._changeFrameTime / SkeletonAnimation.fps));
            for (var i = 0; i < count; ++i) {
                this.event3D.eventType = egret3d.SkeletonAnimationEvent3D.EVENT_FRAME_CHANGE;
                this.event3D.target = this;
                if (delayTime < 0) {
                    this.event3D.data = ((this._oldFrameIndex - 1 - i) % mainState.frameNum);
                    if (this.event3D.data < 0) {
                        this.event3D.data += mainState.frameNum;
                    }
                }
                else {
                    this.event3D.data = (this._oldFrameIndex + 1 + i) % mainState.frameNum;
                }
                this.dispatchEvent(this.event3D);
                if (this.event3D.data == (mainState.frameNum - 1)) {
                    this.event3D.eventType = egret3d.SkeletonAnimationEvent3D.EVENT_PLAY_COMPLETE;
                    this.dispatchEvent(this.event3D);
                }
                this._changeFrameTime += (delayTime > 0) ? -SkeletonAnimation.fps : SkeletonAnimation.fps;
            }
            this._oldFrameIndex = this.event3D.data;
            this.animTime += delay * this.speed;
        };
        /**
        * @private
        * @language zh_CN
        * 将骨骼信息更新给GPU
        * @param time 当前时间
        * @param delay 当前帧时间
        * @param usage PassUsage
        * @param geometry 子几何信息
        * @param context3DProxy 上下文信息
        * @param modeltransform 模型矩阵
        * @param camera3D 相机
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (usage.uniform_time) {
                context3DProxy.uniform1f(usage.uniform_time.uniformIndex, this.animTime);
            }
            context3DProxy.uniform4fv(usage.uniform_PoseMatrix.uniformIndex, this._skeletonMatrixData);
        };
        /**
        * @language zh_CN
        * 克隆骨骼动画对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.clone = function () {
            var skeletonAnimation = new SkeletonAnimation(this._skeleton);
            skeletonAnimation._blendSpeed = this._blendSpeed;
            skeletonAnimation.isLoop = this.isLoop;
            skeletonAnimation._animStateNames = this._animStateNames.concat([]);
            for (var i = 0; i < this._animStates.length; i++) {
                skeletonAnimation._animStates.push(this._animStates[i].clone());
            }
            return skeletonAnimation;
        };
        Object.defineProperty(SkeletonAnimation.prototype, "jointNum", {
            /**
            * @language zh_CN
            * 骨架骨骼数量
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._skeleton.joints.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimation.prototype, "animStateNames", {
            /**
            * @language zh_CN
            * 动画名列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._animStateNames;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimation.prototype, "animStates", {
            /**
            * @language zh_CN
            * 动画状态对象列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._animStates;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimation.prototype, "animTime", {
            /**
            * @language zh_CN
            * 动画时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._animTime;
            },
            /**
            * @language zh_CN
            * 动画时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._blendList.length <= 0) {
                    return;
                }
                if (this._blendList[this._blendList.length - 1].timePosition == value) {
                    return;
                }
                var delay = value - this._animTime;
                if (this._blendSpeed <= 0) {
                    if (this._blendList.length > 1) {
                        this._blendList.splice(0, this._blendList.length - 1);
                    }
                    this._blendList[0].weight = 1.0;
                    this._blendList[0].timePosition += delay;
                }
                else {
                    var blendSpeed = Math.abs(delay / this._blendSpeed);
                    for (var i = 0; i < this._blendList.length; ++i) {
                        var animationState = this._blendList[i];
                        if (i != this._blendList.length - 1) {
                            animationState.weight = Math.max(0, animationState.weight - blendSpeed);
                            if (animationState.weight <= 0) {
                                this._blendList.splice(i, 1);
                                --i;
                                continue;
                            }
                        }
                        else {
                            animationState.weight = Math.min(1, animationState.weight + blendSpeed);
                        }
                        animationState.timePosition += delay;
                    }
                }
                this._animTime = this._blendList[this._blendList.length - 1].timePosition;
                var animationStateA = this._blendList[0];
                var currentSkeletonA = animationStateA.currentSkeletonPose;
                if (this._blendList.length <= 1) {
                    currentSkeletonA.updateGPUCacheData(this._skeleton, this._skeletonMatrixData);
                    this.updateBindList(currentSkeletonA);
                }
                else {
                    var animationStateB = this._blendList[1];
                    var currentSkeletonB = animationStateB.currentSkeletonPose;
                    if (!this._blendSkeleton) {
                        this._blendSkeleton = currentSkeletonA.clone();
                    }
                    this._blendSkeleton.lerp(currentSkeletonA, currentSkeletonB, animationStateB.weight);
                    this._blendSkeleton.resetWorldMatrix();
                    this._blendSkeleton.calculateJointWorldMatrix();
                    this._blendSkeleton.updateGPUCacheData(this._skeleton, this._skeletonMatrixData);
                    this.updateBindList(this._blendSkeleton);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimation.prototype, "timeLength", {
            /**
            * @language zh_CN
            * 动画时间长度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._blendList.length <= 0) {
                    return 0;
                }
                return this._blendList[this._blendList.length - 1].timeLength;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimation.prototype, "frameIndex", {
            /**
            * @language zh_CN
            * 动画帧索引
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.animTime / SkeletonAnimation.fps;
            },
            /**
            * @language zh_CN
            * 动画帧索引
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.animTime = value * SkeletonAnimation.fps;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimation.prototype, "blendSpeed", {
            /**
            * @language zh_CN
            * 融合速度(默认300毫秒)
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._blendSpeed;
            },
            /**
            * @language zh_CN
            * 融合速度(默认300毫秒)
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._blendSpeed = Math.max(value, 0);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimation.prototype, "currentAnimName", {
            /**
            * @language zh_CN
            * 当前播放的动画名称
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._currentAnimName;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 当前动画是否正在播放
        * @returns 是否在播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.isPlay = function () {
            return this._isPlay;
        };
        /**
        * @language zh_CN
        * 绑定3D对象到骨骼
        * @param jointName 骨骼名称
        * @param obj3d 3D对象
        * @returns boolean 是否成功
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.bindToJointPose = function (jointName, object3D) {
            var jointIndex = this._animStates[0].skeletonAnimationClip.poseArray[0].findJointIndex(jointName);
            if (jointIndex < 0) {
                return false;
            }
            var list = null;
            if (this._bindList[jointIndex]) {
                list = this._bindList[jointIndex];
            }
            else {
                list = new Array();
                this._bindList[jointIndex] = list;
            }
            list.push(object3D);
            return true;
        };
        SkeletonAnimation.prototype.updateBindList = function (skeletonPose) {
            var list = null;
            var jointPose = null;
            var object3D = null;
            for (var jointIndex in this._bindList) {
                list = this._bindList[jointIndex];
                if (list.length <= 0)
                    continue;
                jointPose = skeletonPose.joints[jointIndex];
                if (!jointPose)
                    continue;
                for (var i = 0; i < list.length; i++) {
                    object3D = list[i];
                    this._temp_quat.fromMatrix(jointPose.worldMatrix);
                    this._temp_quat.toEulerAngles(this._temp_vec3);
                    object3D.rotationX = this._temp_vec3.x;
                    object3D.rotationY = this._temp_vec3.y;
                    object3D.rotationZ = this._temp_vec3.z;
                    ///object3D.scaleX = jointPose.worldMatrix.scale.x;
                    ///object3D.scaleY = jointPose.worldMatrix.scale.y;
                    ///object3D.scaleZ = jointPose.worldMatrix.scale.z;
                    object3D.x = jointPose.worldMatrix.position.x;
                    object3D.y = jointPose.worldMatrix.position.y;
                    object3D.z = jointPose.worldMatrix.position.z;
                }
            }
        };
        /**
        * @language zh_CN
        * 动画速率
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.fps = 1000 / 60;
        return SkeletonAnimation;
    }(egret3d.EventDispatcher));
    egret3d.SkeletonAnimation = SkeletonAnimation;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Channel
     * @classdesc
     * Channel 类控制应用程序中的声音，对声音执行更精细的控制。每个声音均分配给一个声道，而且应用程序可以具有混合在一起的多个声道。
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Channel = (function () {
        /**
        * @language zh_CN
        * 创建一个新的 Channel 对象。
        * @param sound {Sound} Sound 对象 音频的数据源。
        * @param {Object} options {any} ["volume":1,"loop":true volume] 回放音量, 0 到 1 ， loop 是否循环播放。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Channel(sound, options) {
            /**
            * @language zh_CN
            * 音量，范围从 0（静音）至 1（最大幅度）。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.volume = 1.0;
            /**
            * @language zh_CN
            * 是否循环播放 使声音播放结束时重新开始播放。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.loop = false;
            /**
            * @language zh_CN
            * 当前播放速度。1.0 正常速度。0.5 半速（更慢）。2.0 倍速（更快）。-1.0 向后。正常速度。-0.5 向后，半速。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.pitch = 1.0;
            options = options || {};
            if (options.volume)
                this.volume = options.volume;
            if (options.loop)
                this.loop = options.loop;
            if (options.pitch)
                this.pitch = options.pitch;
            this.sound = sound;
            this.paused = false;
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                this.context = egret3d.AudioManager.instance.context;
                this.startTime = 0;
                this.startOffset = 0;
                this.source = null;
                this.gain = this.context.createGain();
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.sound.audio) {
                    this.source = this.sound.audio.cloneNode(false);
                    this.source.pause();
                }
            }
        }
        /**
        * @language zh_CN
        * 开始在该声道中播放声音。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.play = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    throw new Error("Call stop() before calling play()");
                }
                this.createSource();
                if (!this.source) {
                    return;
                }
                this.startTime = this.context.currentTime;
                this.source.start(0, this.startOffset % this.source.buffer.duration);
            }
            else if (egret3d.AudioManager.instance.hasAudio) {
                this.paused = false;
                this.source.play();
            }
            this.setVolume(this.volume);
            this.setLoop(this.loop);
            this.setPitch(this.pitch);
        };
        /**
        * @language zh_CN
        * 暂时停止在该声道中播放声音。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.pause = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    this.startOffset += this.context.currentTime - this.startTime;
                    this.source.stop(0);
                    this.source = null;
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.source) {
                    this.source.pause();
                }
            }
            this.paused = true;
        };
        /**
        * @language zh_CN
        * 从暂停的位置继续在该声道中播放声音。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.unpause = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source || !this.paused) {
                    throw new Error('Call pause() before unpausing.');
                }
                this.createSource();
                if (!this.source) {
                    return;
                }
                this.startTime = this.context.currentTime;
                this.source.start(0, this.startOffset % this.source.buffer.duration);
                // Initialize volume and loop
                this.setVolume(this.volume);
                this.setLoop(this.loop);
                this.setPitch(this.pitch);
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                this.source.play();
            }
            this.paused = false;
        };
        /**
        * @language zh_CN
        * 停止在该声道中播放声音。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.stop = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    this.source.stop(0);
                    this.startOffset = 0;
                    this.source = null;
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.source) {
                    this.source.pause();
                    this.source.currentTime = 0;
                }
            }
        };
        Channel.prototype.setLoop = function (value) {
            if (this.source) {
                this.source.loop = value;
            }
        };
        Channel.prototype.setVolume = function (value) {
            if (this.gain) {
                this.gain.gain.value = value * egret3d.AudioManager.instance.volume;
            }
            else if (this.source) {
                this.source.volume = value * egret3d.AudioManager.instance.volume;
            }
        };
        Channel.prototype.setPitch = function (value) {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    this.source.playbackRate.value = value;
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.source) {
                    this.source.playbackRate = value;
                }
            }
        };
        /**
        * @language zh_CN
        * 是否正在播放。
        * @returns {boolean}
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.isPlaying = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                return (!this.paused);
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                return (!this.source.paused);
            }
        };
        /**
        * @language zh_CN
        * 音频持续时间。
        * @returns {number}
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.getDuration = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    return this.source.buffer.duration;
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.source) {
                    var d = this.source.duration;
                    if (d === d) {
                        return d;
                    }
                }
            }
            return 0;
        };
        Channel.prototype.createSource = function () {
            var _this = this;
            if (this.sound.buffer) {
                this.source = this.context.createBufferSource();
                this.source.buffer = this.sound.buffer;
                this.source.connect(this.gain);
                this.gain.connect(this.context.destination);
                if (this.loop) {
                    this.source.onended = function () { return _this.play(); };
                }
            }
        };
        return Channel;
    }());
    egret3d.Channel = Channel;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Channel3d
     * @classdesc
     * Channel3d 类控制应用程序中 在三维空间中播放的声音。每个声音均分配给一个声道，而且应用程序可以具有混合在一起的多个声道。
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Channel3d = (function (_super) {
        __extends(Channel3d, _super);
        /**
        * @language zh_CN
        * 创建一个新的 Channel3d 对象。
        * @param sound {Sound} Sound 对象 音频的数据源。
        * @param {Object} options {any} ["volume":1,"loop":true volume] 回放音量, 0 到 1 ， loop 是否循环播放。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Channel3d(sound, options) {
            _super.call(this, sound, options);
            this._position = new egret3d.Vector3D();
            this._velocity = new egret3d.Vector3D();
            if (egret3d.AudioManager.instance.hasAudioContext())
                this._panner = this.context.createPanner();
            this._maxDistance = 10000; // default maxDistance
            this._minDistance = 1;
            this._rollOffFactor = 1;
            this._listener = new egret3d.Vector3D();
        }
        Object.defineProperty(Channel3d.prototype, "listener", {
            /**
            * @language zh_CN
            * 返回监听者位置。
            * @returns Vector3D 监听者位置。
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._listener;
            },
            /**
            * @language zh_CN
            * 设置监听者位置。
            * @param value Vector3D监听者位置。
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._listener.copyFrom(value);
                if (egret3d.AudioManager.instance.hasAudio()) {
                    if (this.source) {
                        var factor = this.fallOff(this._listener, this.position, this.minDistance, this.maxDistance, this.rollOffFactor);
                        this.source.volume = this.volume * factor;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "position", {
            /**
            * @language zh_CN
            * 三维空间中的位置。
            * @returns {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._position;
            },
            /**
            * @language zh_CN
            * 三维空间中的位置。
            * @param opsition {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (position) {
                this._position.copyFrom(position);
                if (egret3d.AudioManager.instance.hasAudioContext()) {
                    this._panner.setPosition(position.x, position.y, position.z);
                }
                if (egret3d.AudioManager.instance.hasAudio()) {
                    if (this.source) {
                        var factor = this.fallOff(this._listener, this.position, this.minDistance, this.maxDistance, this.rollOffFactor);
                        this.source.volume = this.volume * factor;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "velocity", {
            /**
            * @language zh_CN
            * 传播方向。
            * @returns {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._velocity;
            },
            /**
            * @language zh_CN
            * 传播方向。
            * @param velocity {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (velocity) {
                this._velocity.copyFrom(velocity);
                if (egret3d.AudioManager.instance.hasAudioContext())
                    this._panner.setVelocity(velocity.x, velocity.y, velocity.z);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "maxDistance", {
            /**
            * @language zh_CN
            * 最大距离。
            * @returns {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._maxDistance;
            },
            /**
            * @language zh_CN
            * 最大距离。
            * @param max{Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (max) {
                this._maxDistance = max;
                if (egret3d.AudioManager.instance.hasAudioContext())
                    this._panner.maxDistance = max;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "minDistance", {
            /**
            * @language zh_CN
            * 最小距离。
            * @returns {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._minDistance;
            },
            /**
            * @language zh_CN
            * 最小距离。
            * @param min{Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (min) {
                this._minDistance = min;
                if (egret3d.AudioManager.instance.hasAudioContext())
                    this._panner.refDistance = min;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "rollOffFactor", {
            /**
            * @language zh_CN
            * rollOff 系数。
            * @returns {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rollOffFactor;
            },
            /**
            * @language zh_CN
            * rollOff 系数。
            * @param factor {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (factor) {
                this._rollOffFactor = factor;
                if (this._panner)
                    this._panner.rolloffFactor = factor;
            },
            enumerable: true,
            configurable: true
        });
        Channel3d.prototype.createSource = function () {
            if (this.sound.buffer) {
                this.source = this.context.createBufferSource();
                this.source.buffer = this.sound.buffer;
                // Connect up the nodes
                this.source.connect(this._panner);
                this._panner.connect(this.gain);
                this.gain.connect(this.context.destination);
            }
        };
        // Fall off function which should be the same as the one in the Web Audio API,
        // taken from OpenAL
        Channel3d.prototype.fallOff = function (posOne, posTwo, refDistance, maxDistance, rolloffFactor) {
            var distance = egret3d.Vector3D.distance(posOne, posTwo);
            if (distance < refDistance) {
                return 1;
            }
            else if (distance > maxDistance) {
                return 0;
            }
            else {
                //var numerator = refDistance + (rolloffFactor * (distance - refDistance));
                //if (numerator !== 0) {
                //    return refDistance / numerator;
                //} else {
                //    return 1;
                //}
                return 1 - distance / (maxDistance - refDistance);
            }
        };
        return Channel3d;
    }(egret3d.Channel));
    egret3d.Channel3d = Channel3d;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Sound
     * @classdesc
     * Sound 类允许您在应用程序中使用声音。</p>
     * 使用 Sound 类可以创建 Sound 对象、将外部 MP3 文件加载到该对象并播放该文件、关闭声音流，以及访问有关声音的数据，如有关流中字节数和 ID3 元数据的信息。</p>
     * 可通过以下项对声音执行更精细的控制：声音源（声音的 Channel 和 Channel3d）用于控制向计算机扬声器输出声音的属性。  </p>
     * @see egret3d.EventDispatcher
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Sound = (function (_super) {
        __extends(Sound, _super);
        /**
        * @language zh_CN
        * 创建一个新的 Sound 对象。一旦某个 Sound 对象加载完成声音文件，就不能再将另一个声音文件加载到该 Sound 对象中。要加载另一个声音文件，请创建新的 Sound 对象。
        * @param {String}   指向外部音频文件的 URL。
        * @param {Function} 一个可选的音频文件加载成功的事件处理函数。
        * @param {Function} 一个可选的音频文件加载失败的事件处理函数。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Sound(url, success, error) {
            var _this = this;
            if (success === void 0) { success = null; }
            if (error === void 0) { error = null; }
            _super.call(this);
            /**
            * @language zh_CN
            * HTML音频 数据源。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.audio = null;
            this._event = new egret3d.Event3D();
            this._success = success;
            this._error = error;
            this.isLoaded = false;
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (egret3d.AudioManager.instance.isSupported(url, this.audio)) {
                    console.warn('Audio format not supported');
                    this._event.eventType = Sound.SOUND_ERROR;
                    this._event.target = this;
                    this.dispatchEvent(this._event);
                    error(this);
                }
                else {
                    if (egret3d.AudioManager.instance.context) {
                        this.loadAudioFile(url);
                    }
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                try {
                    this.audio = new Audio();
                }
                catch (e) {
                    console.warn("No support for Audio element");
                    this._event.eventType = Sound.SOUND_ERROR;
                    this._event.target = this;
                    this.dispatchEvent(this._event);
                    if (error)
                        error(this);
                    return;
                }
                if (egret3d.AudioManager.instance.isSupported(url, this.audio)) {
                    console.warn('Audio format not supported');
                    this._event.eventType = Sound.SOUND_ERROR;
                    this._event.target = this;
                    this.dispatchEvent(this._event);
                    if (error)
                        error(this);
                }
                else {
                    this.audio.src = url;
                    this.audio.addEventListener("canplaythrough", function (ev) { return _this.oncanplaythrough(ev); });
                    this.audio.addEventListener("ended", function (ev) { return _this.onended(ev); });
                    this.audio.load();
                }
            }
        }
        Object.defineProperty(Sound.prototype, "buffer", {
            /**
            * @language zh_CN
            * Web音频 数据源。
            * @returns {AudioBuffer}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._buffer;
            },
            enumerable: true,
            configurable: true
        });
        Sound.prototype.loadAudioFile = function (url) {
            var _this = this;
            if (this.xhr == null)
                this.xhr = new XMLHttpRequest(); //通过XHR下载音频文件
            this.xhr.open('GET', url, true);
            this.xhr.responseType = 'arraybuffer';
            this.xhr.onload = function (e) { return _this.audioLoadend(e); };
            this.xhr.send();
        };
        Sound.prototype.audioLoadend = function (e) {
            var _this = this;
            egret3d.AudioManager.instance.context.decodeAudioData(this.xhr.response, function (buffer) { return _this.decodeSuccessCallback(buffer); });
        };
        Sound.prototype.decodeSuccessCallback = function (buffer) {
            this._buffer = buffer;
            this._event.eventType = Sound.SOUND_SUCCESS;
            this._event.target = this;
            this._event.data = buffer;
            this.dispatchEvent(this._event);
            if (this._success) {
                this._success(this);
            }
        };
        Sound.prototype.onended = function (ev) {
        };
        Sound.prototype.oncanplaythrough = function (ev) {
            if (!this.isLoaded) {
                this.isLoaded = true;
                this._event.eventType = Sound.SOUND_SUCCESS;
                this._event.target = this;
                this._event.data = ev;
                this.dispatchEvent(this._event);
                if (this._success) {
                    this._success(this);
                }
            }
        };
        /**
        * @language zh_CN
        * Sound 加載成功事件
        * @version Egret 3.0
        * @platform Web,Native
        */
        Sound.SOUND_SUCCESS = "SoundSuccess";
        /**
        * @language zh_CN
        * Sound 加載失敗事件
        * @version Egret 3.0
        * @platform Web,Native
        */
        Sound.SOUND_ERROR = "SoundError";
        return Sound;
    }(egret3d.EventDispatcher));
    egret3d.Sound = Sound;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.AudioManager
    * @classdesc
    * AudioManager 类允许您在应用程序中 播放 HTML5 Audio 和 Web Audio。
    * @includeExample audio/AudioManager.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var AudioManager = (function () {
        /**
        * @language zh_CN
        * 创建一个新的 AudioManager 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function AudioManager() {
            /**
            * @language zh_CN
            * 音量，范围从 0（静音）至 1（最大幅度）。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.volume = 1;
            this.codecs = {};
            if (this.hasAudioContext()) {
                if (typeof AudioContext !== 'undefined') {
                    this.context = new AudioContext();
                }
            }
        }
        /**
        * @language zh_CN
        * 是否支持 HTML5 Audio tag API。
        * @returns {boolean}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.hasAudio = function () {
            return (typeof Audio !== 'undefined');
        };
        /**
        * @language zh_CN
        * 是否支持 Web Audio API。
        * @returns {boolean}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.hasAudioContext = function () {
            return !!(typeof AudioContext !== 'undefined');
        };
        /**
        * @language zh_CN
        * 浏览器是否可以播放这种音频类型。
        * @param url 指向外部音频文件的 URL。
        * @param audio {HTMLAudioElement} HTMLAudio元素
        * @returns {boolean}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.isSupported = function (url, audio) {
            if (this.codecs == null) {
                if (audio == null)
                    audio = new Audio();
                this.codecs = {
                    mp3: !!audio.canPlayType('audio/mpeg;').replace(/^no$/, ''),
                    opus: !!audio.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
                    ogg: !!audio.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
                    wav: !!audio.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
                    aac: !!audio.canPlayType('audio/aac;').replace(/^no$/, ''),
                    m4a: !!(audio.canPlayType('audio/x-m4a;') || audio.canPlayType('audio/m4a;') || audio.canPlayType('audio/aac;')).replace(/^no$/, ''),
                    mp4: !!(audio.canPlayType('audio/x-mp4;') || audio.canPlayType('audio/mp4;') || audio.canPlayType('audio/aac;')).replace(/^no$/, ''),
                    weba: !!audio.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')
                };
            }
            var ext = url.match(/^data:audio\/([^;,]+);/i);
            if (!ext) {
                ext = url.split('?', 1)[0].match(/\.([^.]+)$/);
            }
            if (ext) {
                ext = ext[1].toLowerCase();
            }
            return this.codecs[ext];
        };
        /**
        * @language zh_CN
        * 生成一个新的 Sound 对象 ，将声音数据加载到 Sound 对象中。
        * @param url {String}   指向外部音频文件的 URL。
        * @param success {Function} 一个可选的音频文件加载成功的事件处理函数。
        * @param error {Function} 一个可选的音频文件加载失败的事件处理函数。
        * @returns {Sound}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.createSound = function (url, success, error) {
            if (success === void 0) { success = null; }
            if (error === void 0) { error = null; }
            return new egret3d.Sound(url, success, error);
        };
        /**
        * @language zh_CN
        * 生成一个新的 Channel 对象来播放该声音。此方法返回 Channel 对象，访问该对象可停止声音并监控音量。
        * @param sound{Sound} 要播放的声音数据。
        * @param options{any}   ["volume":1,"loop":true volume] 回放音量, 0 到 1 ， loop 是否循环播放。
        * @returns {Channel}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.playSound = function (sound, options) {
            options = options || {};
            var channel = new egret3d.Channel(sound, options);
            channel.play();
            return channel;
        };
        /**
        * @language zh_CN
        * 生成一个新的 Channel3d 对象来播放该声音。此方法返回 Channel3d 对象，访问该对象可停止声音并监控音量。
        * @param sound {Sound}  要播放的声音数据。
        * @param position {Vector3D} 在三维空间中播放的位置。
        * @param options {any} ["volume":1,"loop":true volume] 回放音量, 0 到 1 ， loop 是否循环播放。
        * @returns {Channel}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.playSound3d = function (sound, position, options) {
            options = options || {};
            var channel = new egret3d.Channel3d(sound, options);
            channel.position = position;
            if (options.volume) {
                channel.volume = options.volume;
            }
            if (options.loop) {
                channel.loop = options.loop;
            }
            if (options.maxDistance) {
                channel.maxDistance = options.maxDistance;
            }
            if (options.minDistance) {
                channel.minDistance = options.minDistance;
            }
            if (options.rollOffFactor) {
                channel.rollOffFactor = options.rollOffFactor;
            }
            channel.play();
            return channel;
        };
        Object.defineProperty(AudioManager, "instance", {
            /**
            * @language zh_CN
            * AudioManager类的单例模式，返回一个 AudioManager 对象。
            * @returns AudioManager
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._instance == null) {
                    this._instance = new AudioManager();
                }
                return this._instance;
            },
            enumerable: true,
            configurable: true
        });
        return AudioManager;
    }());
    egret3d.AudioManager = AudioManager;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.ControllerBase
    * @classdesc
    * 控制器 基类, 抽象控制器的一些数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ControllerBase = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @param targetObject 控制的目标
        */
        function ControllerBase(targetObject, lookAtObject) {
            if (targetObject === void 0) { targetObject = null; }
            if (lookAtObject === void 0) { lookAtObject = null; }
            this._autoUpdate = true;
            this._origin = new egret3d.Vector3D(0.0, 0.0, 0.0);
            this._target = targetObject;
            this._lookAtObject = lookAtObject;
        }
        Object.defineProperty(ControllerBase.prototype, "target", {
            /**
            * @language zh_CN
            *
            * @returns 返回当前的目标
            */
            get: function () {
                return this._target;
            },
            /**
            * @language zh_CN
            *
            * @param val 当前的目标
            */
            set: function (val) {
                if (this._target == val)
                    return;
                ///if (this._target && _autoUpdate)
                ///    this._target._controller = null;
                this._target = val;
                ///if (this._target && _autoUpdate)
                ///    this._target._controller = this;
                ///notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ControllerBase.prototype, "autoUpdate", {
            /**
            * @language zh_CN
            *
            * @returns 是否自动更新
            */
            get: function () {
                return this._autoUpdate;
            },
            /**
            * @language zh_CN
            *
            * @param val 是否自动更新
            */
            set: function (val) {
                if (this._autoUpdate == val)
                    return;
                this._autoUpdate = val;
            },
            enumerable: true,
            configurable: true
        });
        ControllerBase.prototype.notifyUpdate = function () {
            ///if (_targetObject && _targetObject.implicitPartition && _autoUpdate)
            ///    _targetObject.implicitPartition.markForUpdate(_targetObject);
        };
        /**
        * @language zh_CN
        * 数据更新
        */
        ControllerBase.prototype.update = function () {
            ///throw null ;
        };
        return ControllerBase;
    }());
    egret3d.ControllerBase = ControllerBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.LookAtController
    * @classdesc
    * look at 摄像机控制器 。</p>
    * 指定摄像机看向的目标对象。</p>
    * 1.按下鼠标左键并移动鼠标可以使摄像机绕着目标进行旋转。</p>
    * 2.按下键盘的(w s a d) 可以摄像机(上 下 左 右)移动。</p>
    * 3.滑动鼠标滚轮可以控制摄像机的视距。</p>
    *
    * @includeExample controller/ctl/LookAtController.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var LookAtController = (function (_super) {
        __extends(LookAtController, _super);
        /**
        * @language zh_CN
        * 控制的目标相机，目标对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function LookAtController(targetObject, lookAtObject, needCtl, needAlt) {
            if (targetObject === void 0) { targetObject = null; }
            if (lookAtObject === void 0) { lookAtObject = null; }
            if (needCtl === void 0) { needCtl = false; }
            if (needAlt === void 0) { needAlt = false; }
            _super.call(this, targetObject);
            this._origin = new egret3d.Vector3D(0.0, 0.0, 0.0);
            this._lookAtPosition = new egret3d.Vector3D();
            this._eyesPos = new egret3d.Vector3D();
            this._up = egret3d.Vector3D.Y_AXIS;
            this._eyesLength = 0;
            this._rotaEyesLine = new egret3d.Vector3D(0, 0, 1);
            this._rotaAngle = new egret3d.Vector3D();
            this._matRot = new egret3d.Matrix4_4();
            this._quaRot = new egret3d.Quaternion();
            this._tempVec = new egret3d.Vector3D();
            this._matTemp = new egret3d.Matrix4_4();
            this._mouseDown = false;
            this._mouseRightDown = false;
            this._screenMoveStartDetail = new egret3d.Point();
            this._screenMoveDelay = new egret3d.Point();
            this._isUpdate = false;
            this._elapsed = 0;
            this._speed = 3;
            this._xAngle = 0;
            this._ctl = false;
            this._alt = false;
            this._shift = false;
            this._needctl = false;
            this._needalt = false;
            this._needshift = false;
            this._keyArray = new Array();
            /**
            * @language zh_CN
            * 目标点偏移
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lookAtOffset = new egret3d.Vector3D(0, 0, 0);
            /**
            * @language zh_CN
            * 是否第一人称相机
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.firstCamera = false;
            this._needctl = needCtl;
            this._needalt = needAlt;
            this._keyArray.push(false);
            this._keyArray.push(false);
            this._keyArray.push(false);
            this._keyArray.push(false);
            if (lookAtObject)
                this.lookAtObject = lookAtObject;
            else
                this.lookAtPosition = new egret3d.Vector3D();
            this._eyesPos.copyFrom(targetObject.position);
            this._lookAtPosition.copyFrom(lookAtObject.position.add(this.lookAtOffset));
            this._target.lookAt(this._eyesPos, this._lookAtPosition);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_MOVE, this.mouseMove, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_WHEEL, this.mouseWheel, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.mouseUp, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_DOWN, this.mouseDown, this);
            egret3d.Input.addEventListener(egret3d.KeyEvent3D.KEY_UP, this.keyUp, this);
            egret3d.Input.addEventListener(egret3d.KeyEvent3D.KEY_DOWN, this.keyDown, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_END, this.touchUp, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_START, this.touchDown, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_MOVE, this.touchMove, this);
        }
        LookAtController.prototype.scaleSpeed = function (value) {
            this._speed *= value;
        };
        LookAtController.prototype.mouseMove = function (m) {
            if (this._mouseDown && (this._needctl ? this._ctl : true)) {
                this._rotaAngle.y += egret3d.Input.mouseOffsetX;
                this._rotaAngle.x += egret3d.Input.mouseOffsetY;
                this._rotaAngle.y %= 360;
                this._rotaAngle.x %= 360;
            }
        };
        LookAtController.prototype.mouseWheel = function (m) {
            this.distance = this._eyesLength - egret3d.Input.wheelDelta * 0.1;
        };
        LookAtController.prototype.mouseUp = function (m) {
            switch (m.mouseCode) {
                case egret3d.MouseCode.Mouse_Left:
                    this._mouseDown = false;
                    break;
                case egret3d.MouseCode.Mouse_Right:
                    this._mouseRightDown = false;
                    break;
            }
        };
        LookAtController.prototype.mouseDown = function (m) {
            switch (m.mouseCode) {
                case egret3d.MouseCode.Mouse_Left:
                    this._mouseDown = true;
                    break;
                case egret3d.MouseCode.Mouse_Right:
                    this._mouseRightDown = true;
                    break;
            }
        };
        LookAtController.prototype.touchMove = function (t) {
            if (t.targetTouches.length == 1) {
                this.mouseMove(null);
            }
            else {
                this.mouseWheel(null);
            }
        };
        LookAtController.prototype.touchUp = function (m) {
            this._mouseDown = false;
        };
        LookAtController.prototype.touchDown = function (m) {
            this._mouseDown = true;
        };
        LookAtController.prototype.keyDown = function (key) {
            switch (key.keyCode) {
                case egret3d.KeyCode.Key_W:
                    this._keyArray[0] = true;
                    break;
                case egret3d.KeyCode.Key_A:
                    this._keyArray[1] = true;
                    break;
                case egret3d.KeyCode.Key_S:
                    this._keyArray[2] = true;
                    break;
                case egret3d.KeyCode.Key_D:
                    this._keyArray[3] = true;
                    break;
                case egret3d.KeyCode.Key_Q:
                    this._keyArray[4] = true;
                    break;
                case egret3d.KeyCode.Key_E:
                    this._keyArray[5] = true;
                    break;
                case egret3d.KeyCode.Key_Control_L:
                    this._ctl = true;
                    break;
                case egret3d.KeyCode.Key_Alt_L:
                    this._alt = true;
                    break;
            }
        };
        LookAtController.prototype.keyUp = function (key) {
            switch (key.keyCode) {
                case egret3d.KeyCode.Key_W:
                    this._keyArray[0] = false;
                    break;
                case egret3d.KeyCode.Key_A:
                    this._keyArray[1] = false;
                    break;
                case egret3d.KeyCode.Key_S:
                    this._keyArray[2] = false;
                    break;
                case egret3d.KeyCode.Key_D:
                    this._keyArray[3] = false;
                    break;
                case egret3d.KeyCode.Key_Q:
                    this._keyArray[4] = false;
                    break;
                case egret3d.KeyCode.Key_E:
                    this._keyArray[5] = false;
                    break;
                case egret3d.KeyCode.Key_Control_L:
                    this._ctl = false;
                    break;
                case egret3d.KeyCode.Key_Alt_L:
                    this._alt = false;
                    break;
            }
        };
        Object.defineProperty(LookAtController.prototype, "lookAtPosition", {
            /**
            * @language zh_CN
            * 返回目标的位置
            *
            * @returns 目标的位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._lookAtPosition;
            },
            /**
            * @language zh_CN
            * 设置目标坐标
            *
            * @param val 摄像机看向的目标点
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._lookAtObject)
                    this._lookAtObject = null;
                this._lookAtPosition.copyFrom(val.add(this.lookAtOffset));
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "lookAtObject", {
            /**
            * @language zh_CN
            *
            * 返回目标对象
            * @returns 目标对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._lookAtObject;
            },
            /**
            * @language zh_CN
            *
            * 设置目标对象
            * @param val 目标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._lookAtObject == val)
                    return;
                this._lookAtObject = val;
                this._lookAtPosition.copyFrom(this._lookAtObject.position.add(this.lookAtOffset));
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "distance", {
            /**
            * @language zh_CN
            * 得到目标和相机的距离
            * @returns number 距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._eyesLength;
            },
            /**
            * @language zh_CN
            * 设置目标和相机的距离
            * @param length 距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (length) {
                this._eyesLength = length;
                if (this._eyesLength < 1) {
                    this._eyesLength = 1;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "rotationX", {
            /**
            * @language zh_CN
            * 得到相机x轴旋转
            * @returns x 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rotaAngle.x;
            },
            /**
            * @language zh_CN
            * 设置相机x轴旋转
            * @param x 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (x) {
                this._rotaAngle.x = x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "rotationY", {
            /**
            * @language zh_CN
            * 得到相机x轴旋转
            * @returns y 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rotaAngle.y;
            },
            /**
            * @language zh_CN
            * 设置相机y轴旋转
            * @param y 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (y) {
                this._rotaAngle.y = y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "rotationZ", {
            /**
            * @language zh_CN
            * 得到相机x轴旋转
            * @returns z 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rotaAngle.z;
            },
            /**
            * @language zh_CN
            * 设置相机z轴旋转
            * @param z 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (z) {
                this._rotaAngle.z = z;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 控制器数据更新
        * @version Egret 3.0
        * @platform Web,Native
        */
        LookAtController.prototype.update = function () {
            if (this._target) {
                if (this._target.isController == false) {
                    return;
                }
                if (this._keyArray[0]) {
                    this._tempVec.copyFrom(this._rotaEyesLine);
                    this._tempVec.y = 0;
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(this._speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.add(this._tempVec));
                    this._lookAtObject.position = this._tempVec;
                }
                if (this._keyArray[1]) {
                    this._tempVec.copyFrom(this._rotaEyesLine);
                    this._matTemp.identity();
                    this._matTemp.appendRotation(90, egret3d.Vector3D.Y_AXIS);
                    this._tempVec.copyFrom(this._matTemp.transformVector(this._tempVec));
                    this._tempVec.y = 0;
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(this._speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.subtract(this._tempVec));
                    this._lookAtObject.position = this._tempVec;
                }
                if (this._keyArray[2]) {
                    this._tempVec.copyFrom(this._rotaEyesLine);
                    this._tempVec.y = 0;
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(this._speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.subtract(this._tempVec));
                    this._lookAtObject.position = this._tempVec;
                }
                if (this._keyArray[3]) {
                    this._tempVec.copyFrom(this._rotaEyesLine);
                    this._matTemp.identity();
                    this._matTemp.appendRotation(90, egret3d.Vector3D.Y_AXIS);
                    this._tempVec.copyFrom(this._matTemp.transformVector(this._tempVec));
                    this._tempVec.y = 0;
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(this._speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.add(this._tempVec));
                    this._lookAtObject.position = this._tempVec;
                }
                if (this._keyArray[4]) {
                    this._quaRot.fromEulerAngles(this._rotaAngle.x, this._rotaAngle.y, 0);
                    this._tempVec.copyFrom(this._quaRot.transformVector(egret3d.Vector3D.Y_AXIS));
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(this._speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.add(this._tempVec));
                    this._lookAtObject.position = this._tempVec;
                }
                if (this._keyArray[5]) {
                    this._quaRot.fromEulerAngles(this._rotaAngle.x, this._rotaAngle.y, 0);
                    this._tempVec.copyFrom(this._quaRot.transformVector(egret3d.Vector3D.Y_AXIS));
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(this._speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.subtract(this._tempVec));
                    this._lookAtObject.position = this._tempVec;
                }
                this._quaRot.fromEulerAngles(this._rotaAngle.x, this._rotaAngle.y, 0);
                this._rotaEyesLine.copyFrom(this._quaRot.transformVector(egret3d.Vector3D.Z_AXIS));
                this._rotaEyesLine.normalize();
                this._tempVec.copyFrom(this._rotaEyesLine);
                this._tempVec.scaleBy(this._eyesLength);
                this._eyesPos.copyFrom(this._lookAtPosition.subtract(this._tempVec));
                if (this._lookAtObject) {
                    this._lookAtPosition.copyFrom(this._lookAtObject.position.add(this.lookAtOffset));
                }
                this._quaRot.fromEulerAngles(this._rotaAngle.x, this._rotaAngle.y, this._rotaAngle.z);
                this._tempVec.copyFrom(this._up);
                this._tempVec.copyFrom(this._quaRot.transformVector(this._tempVec));
                this._tempVec.normalize();
                if (this.firstCamera) {
                    this._lookAtObject.rotationY = this._rotaAngle.y;
                    this._lookAtObject.rotationX = this._rotaAngle.x;
                }
                this._target.lookAt(this._eyesPos, this._lookAtPosition, this._tempVec);
            }
        };
        return LookAtController;
    }(egret3d.ControllerBase));
    egret3d.LookAtController = LookAtController;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.HoverController
    * @classdesc
    * 摄像机控制器 ,实现摄像机平滑移动
    * 指定摄像机看向的目标对象
    * 1.按下鼠标左键并移动鼠标(或手机手指滑动)可以使摄像机绕着目标进行旋转.
    * 2.滑动鼠标滚轮(或双指滑动)可以控制摄像机的视距.
    *
    * 示例:
    * @includeExample controller/ctl/HoverController.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var HoverController = (function (_super) {
        __extends(HoverController, _super);
        /**
        * @language zh_CN
        * @param targetObject 控制的目标相机，目标对象
        * @param lookAtObject 相机看向的对象
        * @param panAngle y轴旋转
        * @param tiltAngle x轴旋转
        * @param distance 相机距离
        * @param minTiltAngle 最小x轴旋转
        * @param maxTiltAngle 最大x轴旋转
        * @param minPanAngle 最小y轴旋转
        * @param maxPanAngle 最大y轴旋转
        * @param steps 平滑时分为几步
        * @param yFactor 旋转时Y轴的一个相对变化值
        * @param wrapPanAngle 是否开启 PanAngle 角度限制
        * @version Egret 3.0
        * @platform Web,Native
        */
        function HoverController(targetObject, lookAtObject, panAngle, tiltAngle, distance, minTiltAngle, maxTiltAngle, minPanAngle, maxPanAngle, steps, yFactor, wrapPanAngle) {
            if (targetObject === void 0) { targetObject = null; }
            if (lookAtObject === void 0) { lookAtObject = null; }
            if (panAngle === void 0) { panAngle = 0; }
            if (tiltAngle === void 0) { tiltAngle = 90; }
            if (distance === void 0) { distance = 100; }
            if (minTiltAngle === void 0) { minTiltAngle = -90; }
            if (maxTiltAngle === void 0) { maxTiltAngle = 90; }
            if (minPanAngle === void 0) { minPanAngle = NaN; }
            if (maxPanAngle === void 0) { maxPanAngle = NaN; }
            if (steps === void 0) { steps = 8; }
            if (yFactor === void 0) { yFactor = 2; }
            if (wrapPanAngle === void 0) { wrapPanAngle = false; }
            _super.call(this, targetObject, lookAtObject);
            this._currentPanAngle = 0;
            this._currentTiltAngle = 90;
            this._panAngle = 0;
            this._tiltAngle = 90;
            this._distance = 1000;
            this._minPanAngle = -Infinity;
            this._maxPanAngle = Infinity;
            this._minTiltAngle = -90;
            this._maxTiltAngle = 90;
            this._maxDistance = 5000;
            this._minDistance = -5000;
            this._steps = 8;
            this._yFactor = 2;
            this._wrapPanAngle = false;
            this._lookAtPosition = new egret3d.Vector3D(0.0, 0.0, 0.0);
            this._mouseDown = false;
            this._mouseRightDown = false;
            this._keyArray = new Array();
            this.distance = distance;
            this.panAngle = panAngle;
            this.tiltAngle = tiltAngle;
            this.minPanAngle = minPanAngle || -Infinity;
            this.maxPanAngle = maxPanAngle || Infinity;
            this.minTiltAngle = minTiltAngle;
            this.maxTiltAngle = maxTiltAngle;
            this.steps = steps;
            this.yFactor = yFactor;
            this.wrapPanAngle = wrapPanAngle;
            //values passed in contrustor are applied immediately
            this._currentPanAngle = this._panAngle;
            this._currentTiltAngle = this._tiltAngle;
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_MOVE, this.mouseMove, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_WHEEL, this.mouseWheel, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.mouseUp, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_DOWN, this.mouseDown, this);
            egret3d.Input.addEventListener(egret3d.KeyEvent3D.KEY_UP, this.keyUp, this);
            egret3d.Input.addEventListener(egret3d.KeyEvent3D.KEY_DOWN, this.keyDown, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_END, this.touchUp, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_START, this.touchDown, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_MOVE, this.touchMove, this);
        }
        HoverController.prototype.mouseMove = function (m) {
            if (this._mouseDown) {
                this._tiltAngle += egret3d.Input.mouseOffsetY * 0.1;
                this._tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
                this._panAngle += egret3d.Input.mouseOffsetX * 0.1;
                this._panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
            }
        };
        HoverController.prototype.mouseWheel = function (m) {
            this._distance -= egret3d.Input.wheelDelta * 0.1;
            this._distance = Math.max(this._minDistance, Math.min(this._maxDistance, this._distance));
        };
        HoverController.prototype.mouseUp = function (m) {
            switch (m.mouseCode) {
                case egret3d.MouseCode.Mouse_Left:
                    this._mouseDown = false;
                    break;
                case egret3d.MouseCode.Mouse_Right:
                    this._mouseRightDown = false;
                    break;
            }
        };
        HoverController.prototype.mouseDown = function (m) {
            switch (m.mouseCode) {
                case egret3d.MouseCode.Mouse_Left:
                    this._mouseDown = true;
                    break;
                case egret3d.MouseCode.Mouse_Right:
                    this._mouseRightDown = true;
                    break;
            }
        };
        HoverController.prototype.touchMove = function (t) {
            if (t.targetTouches.length == 1) {
                this.mouseMove(null);
            }
            else {
                this.mouseWheel(null);
            }
        };
        HoverController.prototype.touchUp = function (m) {
            this._mouseDown = false;
        };
        HoverController.prototype.touchDown = function (m) {
            this._mouseDown = true;
        };
        HoverController.prototype.keyDown = function (key) {
            switch (key.keyCode) {
                case egret3d.KeyCode.Key_W:
                    this._keyArray[0] = true;
                    break;
                case egret3d.KeyCode.Key_A:
                    this._keyArray[1] = true;
                    break;
                case egret3d.KeyCode.Key_S:
                    this._keyArray[2] = true;
                    break;
                case egret3d.KeyCode.Key_D:
                    this._keyArray[3] = true;
                    break;
            }
        };
        HoverController.prototype.keyUp = function (key) {
            switch (key.keyCode) {
                case egret3d.KeyCode.Key_W:
                    this._keyArray[0] = false;
                    break;
                case egret3d.KeyCode.Key_A:
                    this._keyArray[1] = false;
                    break;
                case egret3d.KeyCode.Key_S:
                    this._keyArray[2] = false;
                    break;
                case egret3d.KeyCode.Key_D:
                    this._keyArray[3] = false;
                    break;
            }
        };
        Object.defineProperty(HoverController.prototype, "lookAtPosition", {
            /**
            * @language zh_CN
            * 返回目标的位置
            *
            * @returns 目标的位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._lookAtPosition;
            },
            /**
            * @language zh_CN
            * 设置目标坐标
            *
            * @param val 摄像机看向的目标点
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                this._lookAtPosition = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "steps", {
            /**
            * @private
            */
            get: function () {
                return this._steps;
            },
            /**
            * @private
            */
            set: function (val) {
                val = (val < 1) ? 1 : val;
                if (this._steps == val)
                    return;
                this._steps = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "panAngle", {
            /**
            * @language zh_CN
            * 得到相机y轴旋转角度
            * @returns 相机y轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._panAngle;
            },
            /**
            * @language zh_CN
            * 设置相机y轴旋转
            * @param val 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                val = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, val));
                if (this._panAngle == val)
                    return;
                this._panAngle = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "tiltAngle", {
            /**
            * @language zh_CN
            * 得到相机x轴旋转角度
            * @returns 相机x轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._tiltAngle;
            },
            /**
            * @language zh_CN
            * 设置相机x轴旋转
            * @param val 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                val = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, val));
                if (this._tiltAngle == val)
                    return;
                this._tiltAngle = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "distance", {
            /**
            * @language zh_CN
            * 得到目标和相机的距离
            * @returns 目标和相机的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._distance;
            },
            /**
            * @language zh_CN
            * 设置目标和相机的距离
            * @param val 距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._distance == val)
                    return;
                this._distance = this._distance = Math.max(this._minDistance, Math.min(this._maxDistance, val));
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "minPanAngle", {
            /**
            * @language zh_CN
            * 得到相机最小y轴旋转角度
            * @returns 相机最小x轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._minPanAngle;
            },
            /**
            * @language zh_CN
            * 设置相机最小y轴旋转角度
            * @param val 相机最小x轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._minPanAngle == val)
                    return;
                this._minPanAngle = val;
                this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "maxPanAngle", {
            /**
            * @language zh_CN
            * 得到相机最大y轴旋转角度
            * @returns 相机最大y轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._maxPanAngle;
            },
            /**
            * @language zh_CN
            * 设置相机最大y轴旋转角度
            * @param val 相机最大y轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._maxPanAngle == val)
                    return;
                this._maxPanAngle = val;
                this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "minTiltAngle", {
            /**
            * @language zh_CN
            * 得到相机最小x轴旋转角度
            * @returns 相机最小x轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._minTiltAngle;
            },
            /**
            * @language zh_CN
            * 设置相机最小x轴旋转角度
            * @param val 相机最小x轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._minTiltAngle == val)
                    return;
                this._minTiltAngle = val;
                this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "maxTiltAngle", {
            /**
            * @language zh_CN
            * 得到相机最大x轴旋转角度
            * @returns 相机最大x轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._maxTiltAngle;
            },
            /**
            * @language zh_CN
            * 设置相机最大x轴旋转角度
            * @param val 相机最大x轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._maxTiltAngle == val)
                    return;
                this._maxTiltAngle = val;
                this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "maxDistance", {
            /**
            * @language zh_CN
            * 得到相机和目标最大的距离
            * @returns 相机和目标最大的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._maxDistance;
            },
            /**
            * @language zh_CN
            * 设置相机和目标最大的距离
            * @param val 相机和目标最大的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._maxDistance == val)
                    return;
                this._maxDistance = val;
                this._distance = Math.max(this._minDistance, Math.min(this._maxDistance, this._distance));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "minDistance", {
            /**
            * @language zh_CN
            * 得到相机和目标最小的距离
            * @returns 相机和目标最小的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._maxDistance;
            },
            /**
            * @language zh_CN
            * 设置相机和目标最小的距离
            * @param val 相机和目标最小的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._minDistance == val)
                    return;
                this._minDistance = val;
                this._distance = Math.max(this._minDistance, Math.min(this._maxDistance, this._distance));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "yFactor", {
            /**
            * @private
            */
            get: function () {
                return this._yFactor;
            },
            /**
            * @private
            */
            set: function (val) {
                if (this._yFactor == val)
                    return;
                this._yFactor = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "wrapPanAngle", {
            /**
            * @private
            */
            get: function () {
                return this._wrapPanAngle;
            },
            /**
            * @private
            */
            set: function (val) {
                if (this._wrapPanAngle == val)
                    return;
                this._wrapPanAngle = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 控制器数据更新
        * @param interpolate
        * @version Egret 3.0
        * @platform Web,Native
        */
        HoverController.prototype.update = function (interpolate) {
            if (interpolate === void 0) { interpolate = true; }
            if (this._tiltAngle != this._currentTiltAngle || this._panAngle != this._currentPanAngle) {
                this.notifyUpdate();
                if (this._wrapPanAngle) {
                    if (this._panAngle < 0)
                        this._panAngle = (this._panAngle % 360) + 360;
                    else
                        this._panAngle = this._panAngle % 360;
                    if (this._panAngle - this._currentPanAngle < -180)
                        this._currentPanAngle -= 360;
                    else if (this._panAngle - this._currentPanAngle > 180)
                        this._currentPanAngle += 360;
                }
                if (interpolate) {
                    this._currentTiltAngle += (this._tiltAngle - this._currentTiltAngle) / (this.steps + 1);
                    this._currentPanAngle += (this._panAngle - this._currentPanAngle) / (this.steps + 1);
                }
                else {
                    this._currentPanAngle = this._panAngle;
                    this._currentTiltAngle = this._tiltAngle;
                }
                //snap coords if angle differences are close
                if ((Math.abs(this._tiltAngle - this._currentTiltAngle) < 0.01) && (Math.abs(this._panAngle - this._currentPanAngle) < 0.01)) {
                    this._currentTiltAngle = this._tiltAngle;
                    this._currentPanAngle = this._panAngle;
                }
            }
            var pos = (this._lookAtObject) ? this._lookAtObject.position : (this._lookAtPosition) ? this._lookAtPosition : this._origin;
            var p = new egret3d.Vector3D();
            p.x = pos.x + this.distance * Math.sin(this._currentPanAngle * egret3d.MathUtil.DEGREES_TO_RADIANS) * Math.cos(this._currentTiltAngle * egret3d.MathUtil.DEGREES_TO_RADIANS);
            p.z = pos.z + this.distance * Math.cos(this._currentPanAngle * egret3d.MathUtil.DEGREES_TO_RADIANS) * Math.cos(this._currentTiltAngle * egret3d.MathUtil.DEGREES_TO_RADIANS);
            p.y = pos.y + this.distance * Math.sin(this._currentTiltAngle * egret3d.MathUtil.DEGREES_TO_RADIANS) * this.yFactor;
            if (this._target) {
                if (this._lookAtPosition)
                    this._target.lookAt(p, this._lookAtPosition);
            }
        };
        return HoverController;
    }(egret3d.ControllerBase));
    egret3d.HoverController = HoverController;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    (function (InternalFormat) {
        InternalFormat[InternalFormat["PixelArray"] = 0] = "PixelArray";
        InternalFormat[InternalFormat["CompressData"] = 1] = "CompressData";
        InternalFormat[InternalFormat["ImageData"] = 2] = "ImageData";
    })(egret3d.InternalFormat || (egret3d.InternalFormat = {}));
    var InternalFormat = egret3d.InternalFormat;
    ;
    /**
    * @private
    */
    //export class ColorFormat {
    //    ColorFormat_RGBA8888
    //} 
    /**
    * @private
    */
    (function (FrameBufferType) {
        FrameBufferType[FrameBufferType["shadowFrameBufrfer"] = 0] = "shadowFrameBufrfer";
        FrameBufferType[FrameBufferType["defaultFrameBuffer"] = 1] = "defaultFrameBuffer";
        FrameBufferType[FrameBufferType["positionFrameBuffer"] = 2] = "positionFrameBuffer";
        FrameBufferType[FrameBufferType["normalFrameBuffer"] = 3] = "normalFrameBuffer";
        FrameBufferType[FrameBufferType["specularFrameBuffer"] = 4] = "specularFrameBuffer";
        FrameBufferType[FrameBufferType["leftEyeFrameBuffer"] = 5] = "leftEyeFrameBuffer";
        FrameBufferType[FrameBufferType["rightEyeFrameBuffer"] = 6] = "rightEyeFrameBuffer";
        FrameBufferType[FrameBufferType["nextFrameBuffer"] = 7] = "nextFrameBuffer";
    })(egret3d.FrameBufferType || (egret3d.FrameBufferType = {}));
    var FrameBufferType = egret3d.FrameBufferType;
    /**
    * @private
    */
    (function (FrameBufferFormat) {
        FrameBufferFormat[FrameBufferFormat["FLOAT_RGB"] = 0] = "FLOAT_RGB";
        FrameBufferFormat[FrameBufferFormat["FLOAT_RGBA"] = 1] = "FLOAT_RGBA";
        FrameBufferFormat[FrameBufferFormat["UNSIGNED_BYTE_RGB"] = 2] = "UNSIGNED_BYTE_RGB";
        FrameBufferFormat[FrameBufferFormat["UNSIGNED_BYTE_RGBA"] = 3] = "UNSIGNED_BYTE_RGBA";
    })(egret3d.FrameBufferFormat || (egret3d.FrameBufferFormat = {}));
    var FrameBufferFormat = egret3d.FrameBufferFormat;
    /**
    * @language zh_CN
    * 渲染混合模式
    * BlendMode 类中的一个值，用于指定要使用的混合模式。 内部绘制位图的方法有两种。 如果启用了混合模式或外部剪辑遮罩，则将通过向矢量渲染器添加有位图填充的正方形来绘制位图。 如果尝试将此属性设置为无效值，则 Flash 运行时会将此值设置为 BlendMode.NORMAL。
    * blendMode 属性影响显示对象的每个像素。每个像素都由三种原色（红色、绿色和蓝色）组成，每种原色的值介于 0x00 和 0xFF 之间。Flash Player 或 Adobe AIR 将影片剪辑中一个像素的每种原色与背景中像素的对应颜色进行比较。例如，如果 blendMode 设置为 BlendMode.LIGHTEN，则 Flash Player 或 Adobe AIR 会将显示对象的红色值与背景的红色值进行比较，然后使用两者中较亮的一种颜色作为显示颜色的红色成分的值。
    * 下表将对 blendMode 设置进行说明。BlendMode 类定义可使用的字符串值。表中的插图显示应用于交叠于显示对象 (1) 之上的圆形显示对象 (2) 的 blendMode 值。
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (BlendMode) {
        /**
         * @language zh_CN
         * 将显示对象的每个像素的 Alpha 值应用于背景。
         * @version Egret 3.0
         * @platform Web,Native
         */
        BlendMode[BlendMode["ALPHA"] = 0] = "ALPHA";
        /**
         * @language zh_CN
         * 强制为该显示对象创建一个透明度组。
         * @version Egret 3.0
         * @platform Web,Native
         */
        BlendMode[BlendMode["LAYER"] = 1] = "LAYER";
        /**
        * @language zh_CN
        * 该显示对象出现在背景前面。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["NORMAL"] = 2] = "NORMAL";
        /**
        * @language zh_CN
        * 将显示对象的原色值与背景颜色的原色值相乘，然后除以 0xFF 进行标准化，从而得到较暗的颜色。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["MULTIPLY"] = 3] = "MULTIPLY";
        /**
        * @language zh_CN
        * 将显示对象的原色值添加到它的背景颜色中，上限值为 0xFF。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["ADD"] = 4] = "ADD";
        /**
        * @language zh_CN
        * 从背景颜色的值中减去显示对象原色的值，下限值为 0。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["SUB"] = 5] = "SUB";
        /**
        * @language zh_CN
        * 将显示对象颜色的补色（反色）与背景颜色的补色相除。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["DIV"] = 6] = "DIV";
        /**
        * @language zh_CN
        * 将显示对象颜色的补色（反色）与背景颜色的补色相乘，会产生漂白效果。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["SCREEN"] = 7] = "SCREEN";
        /**
        * @language zh_CN
        * 将显示对象的原色值添加到它的背景颜色中(较ADD稍微暗一些)，上限值为 0xFF。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["SOFT_ADD"] = 8] = "SOFT_ADD";
    })(egret3d.BlendMode || (egret3d.BlendMode = {}));
    var BlendMode = egret3d.BlendMode;
    /**
     * @class egret3d.ContextSamplerType
     * @classdesc
     * 贴图采样类型
     */
    var ContextSamplerType = (function () {
        function ContextSamplerType() {
        }
        return ContextSamplerType;
    }());
    egret3d.ContextSamplerType = ContextSamplerType;
    /**
    * @class egret3d.DrawMode
    * @classdesc
    * 渲染模式
    * LINES 线框显示模式
    * POINTS 点显示模式
    * TRIANGLES 三角形显示模式
    * LINE_STRIP 连接线显示模式
    */
    var DrawMode = (function () {
        function DrawMode() {
        }
        return DrawMode;
    }());
    egret3d.DrawMode = DrawMode;
    /**
    * @class egret3d.Egret3DDrive
    * @classdesc
    * 3d 驱动 一些配置类型
    */
    var ContextConfig = (function () {
        function ContextConfig() {
        }
        /**
        * @private
        */
        ContextConfig.Direct3D_Opengl_Auto = "Direct3D_Opengl_Auto";
        /**
        * @private
        */
        ContextConfig.Direct3D_9_0 = "Direct3D_9_0";
        /**
        * @private
        */
        ContextConfig.Direct3D_10_0 = "Direct3D_10_0";
        /**
        * @private
        */
        ContextConfig.Direct3D_11_0 = "Direct3D_11_0";
        /**
        * @private
        */
        ContextConfig.OpenGLES_2_0 = "OpenGLES_2_0";
        /**
        * @private
        */
        ContextConfig.OpenGLES_3_0 = "OpenGLES_3_0";
        /**
        * @private
        */
        ContextConfig.OpenGL = "OpenGL";
        /**
        * @private
        */
        ContextConfig.ColorFormat_DXT1_RGB = 0;
        /**
        * @private
        */
        ContextConfig.ColorFormat_DXT1_RGBA = 0;
        /**
        * @private
        */
        ContextConfig.ColorFormat_DXT3_RGBA = 0;
        /**
        * @private
        */
        ContextConfig.ColorFormat_DXT5_RGBA = 0;
        return ContextConfig;
    }());
    egret3d.ContextConfig = ContextConfig;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Context3DProxy
    * @classdesc
    * Context3DProxy 类提供了用于呈现几何定义图形的上下文。</p>
    *
    * 渲染上下文包括一个绘图表面及其关联的资源和状态。</p>
    * Context3DProxy 渲染上下文是一个可编程的管道，基于OpenGL ES 2.0规范。</p>
    * 您可以通过提供适当的顶点和像素片段程序来创建 2D/3D渲染器，不同的平台有不同的硬件限制，对于移动端限制要求比较大。</p>
    * 一个canvas 只能申请一个Context3DProxy。</p>
    *
    * @see egret3d.Program3D
    * @see egret3d.IndexBuffer3D
    * @see egret3d.VertexBuffer3D
    * @see egret3d.Texture2D
    * @see egret3d.Shader
    * @see egret3d.CubeTexture
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Context3DProxy = (function () {
        function Context3DProxy() {
            /**
            * @language zh_CN
            * @private
            * 渲染3D 的驱动设备是否存在，或者丢失。
            * 一般情况下，当切换程序的时候，设备将会丢失，
            * 这个时候就需要快速重新申请设备，并将相应的资源buffer，texture重新提交至显卡
            */
            this.isLost = false;
            //-------cache-------
            this.DEPTH_TEST = false;
            this.CULL_FACE = false;
            this.BLEND = false;
            this.blend_Factors_src = -1;
            this.blend_Factors_dst = -1;
            this.cullingMode = -1;
            this.depthCompareMode = -1;
            this.vertexFormat = -1;
        }
        //--------------
        /**
        * @private
        * @language zh_CN
        * get GPU Context3DProxy
        * 注册并初始化相关 GPU 参数配置信息
        * 用于设置显卡的相关参数
        */
        Context3DProxy.prototype.register = function () {
            var ext = Context3DProxy.gl.getExtension('WEBGL_compressed_texture_s3tc');
            var OES_texture_float_linear = Context3DProxy.gl.getExtension("OES_texture_float_linear");
            var OES_texture_float = Context3DProxy.gl.getExtension("OES_texture_float");
            var OES_texture_half_float = Context3DProxy.gl.getExtension("OES_texture_half_float");
            var OES_texture_half_float_linear = Context3DProxy.gl.getExtension("OES_texture_half_float_linear");
            var OES_standard_derivatives = Context3DProxy.gl.getExtension("OES_standard_derivatives");
            var GL_OES_standard_derivatives = Context3DProxy.gl.getExtension("GL_OES_standard_derivatives");
            var WEBGL_draw_buffers = Context3DProxy.gl.getExtension("WEBGL_draw_buffers");
            var WEBGL_depth_texture = Context3DProxy.gl.getExtension("WEBGL_depth_texture");
            egret3d.ContextConfig.BLEND = Context3DProxy.gl.BLEND;
            egret3d.DrawMode.TRIANGLES = Context3DProxy.gl.TRIANGLES;
            egret3d.DrawMode.POINTS = Context3DProxy.gl.POINTS;
            egret3d.DrawMode.LINES = Context3DProxy.gl.LINES;
            egret3d.DrawMode.LINE_STRIP = Context3DProxy.gl.LINE_STRIP;
            egret3d.ContextConfig.FLOAT = Context3DProxy.gl.FLOAT;
            egret3d.ContextConfig.VERTEX_SHADER = Context3DProxy.gl.VERTEX_SHADER;
            egret3d.ContextConfig.FRAGMENT_SHADER = Context3DProxy.gl.FRAGMENT_SHADER;
            egret3d.ContextConfig.FRONT = Context3DProxy.gl.FRONT;
            egret3d.ContextConfig.BACK = Context3DProxy.gl.BACK;
            egret3d.ContextConfig.FRONT_AND_BACK = Context3DProxy.gl.FRONT_AND_BACK;
            egret3d.ContextConfig.DEPTH_BUFFER_BIT = Context3DProxy.gl.DEPTH_BUFFER_BIT;
            egret3d.ContextConfig.ELEMENT_ARRAY_BUFFER = Context3DProxy.gl.ELEMENT_ARRAY_BUFFER;
            egret3d.ContextConfig.UNSIGNED_SHORT = Context3DProxy.gl.UNSIGNED_SHORT;
            egret3d.ContextConfig.NEAREST = Context3DProxy.gl.NEAREST;
            egret3d.ContextConfig.REPEAT = Context3DProxy.gl.REPEAT;
            egret3d.ContextConfig.ONE = Context3DProxy.gl.ONE;
            egret3d.ContextConfig.ZERO = Context3DProxy.gl.ZERO;
            egret3d.ContextConfig.SRC_ALPHA = Context3DProxy.gl.SRC_ALPHA;
            egret3d.ContextConfig.ONE_MINUS_SRC_ALPHA = Context3DProxy.gl.ONE_MINUS_SRC_ALPHA;
            egret3d.ContextConfig.SRC_COLOR = Context3DProxy.gl.SRC_COLOR;
            egret3d.ContextConfig.ONE_MINUS_SRC_COLOR = Context3DProxy.gl.ONE_MINUS_SRC_COLOR;
            ;
            egret3d.ContextConfig.ColorFormat_RGB565 = Context3DProxy.gl.RGB565;
            egret3d.ContextConfig.ColorFormat_RGBA5551 = Context3DProxy.gl.RGB5_A1;
            egret3d.ContextConfig.ColorFormat_RGBA4444 = Context3DProxy.gl.RGBA4;
            egret3d.ContextConfig.ColorFormat_RGBA8888 = Context3DProxy.gl.RGBA;
            egret3d.ContextConfig.DEPTH_TEST = Context3DProxy.gl.DEPTH_TEST;
            egret3d.ContextConfig.CULL_FACE = Context3DProxy.gl.CULL_FACE;
            egret3d.ContextConfig.BLEND = Context3DProxy.gl.BLEND;
            egret3d.ContextConfig.LEQUAL = Context3DProxy.gl.LEQUAL;
            if (ext) {
                egret3d.ContextConfig.ColorFormat_DXT1_RGB = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
                egret3d.ContextConfig.ColorFormat_DXT1_RGBA = ext.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                egret3d.ContextConfig.ColorFormat_DXT3_RGBA = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                egret3d.ContextConfig.ColorFormat_DXT5_RGBA = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
            egret3d.ContextSamplerType.TEXTURE_0 = Context3DProxy.gl.TEXTURE0;
            egret3d.ContextSamplerType.TEXTURE_1 = Context3DProxy.gl.TEXTURE1;
            egret3d.ContextSamplerType.TEXTURE_2 = Context3DProxy.gl.TEXTURE2;
            egret3d.ContextSamplerType.TEXTURE_3 = Context3DProxy.gl.TEXTURE3;
            egret3d.ContextSamplerType.TEXTURE_4 = Context3DProxy.gl.TEXTURE4;
            egret3d.ContextSamplerType.TEXTURE_5 = Context3DProxy.gl.TEXTURE5;
            egret3d.ContextSamplerType.TEXTURE_6 = Context3DProxy.gl.TEXTURE6;
            egret3d.ContextSamplerType.TEXTURE_7 = Context3DProxy.gl.TEXTURE7;
            egret3d.ContextSamplerType.TEXTURE_8 = Context3DProxy.gl.TEXTURE8;
            console.log("requst GPU Config", Context3DProxy.gl);
            egret3d.ShaderPool.register(this);
        };
        //public creatBackBuffer(x: number, y: number, width: number, height: number) {
        //    this._canvas.style.left = x.toString();
        //    this._canvas.style.top = y.toString();
        //    this._canvas.width = width;
        //    this._canvas.height = height;
        //    this.viewPort(x, y, width, height);
        //}
        /**
        * @language zh_CN
        * 视口设置定义，用来确定我们定义的视口在canvas中的所在位置
        * @param x 屏幕坐标 X
        * @param y 屏幕坐标 Y
        * @param width  宽度
        * @param height 高度
        * @see egret3d.Egret3DCanvas
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.viewPort = function (x, y, width, height) {
            Context3DProxy.gl.viewport(x, egret3d.ContextConfig.canvasRectangle.height - height - y, width, height);
        };
        /**
        * @language zh_CN
        * 创建 显卡程序
        * @param vsShader
        * @param fsShader
        * @returns Program3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.creatProgram = function (vsShader, fsShader) {
            var shaderProgram = Context3DProxy.gl.createProgram();
            Context3DProxy.gl.attachShader(shaderProgram, vsShader.shader);
            Context3DProxy.gl.attachShader(shaderProgram, fsShader.shader);
            Context3DProxy.gl.linkProgram(shaderProgram);
            var p = Context3DProxy.gl.getProgramParameter(shaderProgram, Context3DProxy.gl.LINK_STATUS);
            if (!p) {
                alert("vsShader error" + Context3DProxy.gl.getShaderInfoLog(vsShader.shader));
                alert("fsShader error" + Context3DProxy.gl.getShaderInfoLog(fsShader.shader));
            }
            var program = new egret3d.Program3D(shaderProgram);
            return program;
        };
        /**
        * @language zh_CN
        * 创建 顶点索引流
        * @param indexData
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.creatIndexBuffer = function (indexData) {
            var indexDataArray = new Int16Array(indexData);
            var indexBuffer = Context3DProxy.gl.createBuffer();
            Context3DProxy.gl.bindBuffer(Context3DProxy.gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            Context3DProxy.gl.bufferData(Context3DProxy.gl.ELEMENT_ARRAY_BUFFER, indexDataArray, Context3DProxy.gl.STATIC_DRAW);
            var ib = new egret3d.IndexBuffer3D(indexBuffer);
            ib.arrayBuffer = indexDataArray;
            return ib;
        };
        /**
        * @language zh_CN
        * 提交索引数据
        * @param indexBuffer3D 索引buffer
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uploadIndexBuffer = function (indexBuffer3D) {
            Context3DProxy.gl.bindBuffer(Context3DProxy.gl.ARRAY_BUFFER, indexBuffer3D.buffer);
            Context3DProxy.gl.bufferData(Context3DProxy.gl.ARRAY_BUFFER, indexBuffer3D.arrayBuffer, Context3DProxy.gl.DYNAMIC_DRAW);
        };
        /**
        * @language zh_CN
        * 创建 顶点数据流
        * @param vertexData
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.creatVertexBuffer = function (vertexData, dawType) {
            if (dawType === void 0) { dawType = Context3DProxy.gl.STATIC_DRAW; }
            var vertexDataArray = new Float32Array(vertexData);
            var vertexBuffer = Context3DProxy.gl.createBuffer();
            Context3DProxy.gl.bindBuffer(Context3DProxy.gl.ARRAY_BUFFER, vertexBuffer);
            Context3DProxy.gl.bufferData(Context3DProxy.gl.ARRAY_BUFFER, vertexDataArray, dawType);
            var vb = new egret3d.VertexBuffer3D(vertexBuffer);
            vb.arrayBuffer = vertexDataArray;
            return vb;
        };
        /**
        * @language zh_CN
        * 提交顶点数据
        * @param vertexBuffer3D 顶点buffer
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uploadVertexBuffer = function (vertexBuffer3D) {
            Context3DProxy.gl.bindBuffer(Context3DProxy.gl.ARRAY_BUFFER, vertexBuffer3D.buffer);
            Context3DProxy.gl.bufferData(Context3DProxy.gl.ARRAY_BUFFER, vertexBuffer3D.arrayBuffer, Context3DProxy.gl.DYNAMIC_DRAW);
        };
        /// public upLoadTextureData(mipLevel: number, texture: Texture2D , data:any ) {
        ///     /// 启用二维纹理
        ///     ///Context3DProxy.gl.enable( Context3DProxy.gl.TEXTURE );
        ///     Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_2D, texture.texture2D);
        ///     ///if (typeof (data) == HTMLImageElement) {
        ///     /// Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_2D, mipLevel, Context3DProxy.gl.RGBA, Context3DProxy.gl.RGBA, Context3DProxy.gl.UNSIGNED_BYTE, data);
        ///     ///}
        ///     Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_2D, mipLevel, Context3DProxy.gl.RGBA, 128, 128, 0, Context3DProxy.gl.RGBA, Context3DProxy.gl.UNSIGNED_BYTE, data ) ;
        ///
        ///     Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_MIN_FILTER, Context3DProxy.gl.NEAREST);
        ///     Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_MAG_FILTER, Context3DProxy.gl.NEAREST);
        ///     Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_WRAP_S, Context3DProxy.gl.REPEAT);
        ///     Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_WRAP_T, Context3DProxy.gl.REPEAT);
        /// }
        /**
        * @language zh_CN
        * 设置2D纹理状态 来确定贴图的采样方式
        * @param min_filter
        * @param mag_filter
        * @param wrap_u_filter
        * @param wrap_v_filter
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setTexture2DSamplerState = function (min_filter, mag_filter, wrap_u_filter, wrap_v_filter) {
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_MIN_FILTER, min_filter);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_MAG_FILTER, mag_filter);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_WRAP_S, wrap_u_filter);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_WRAP_T, wrap_v_filter);
        };
        /**
        * @language zh_CN
        * 提交2D纹理
        * @param mipLevel
        * @param texture
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.upLoadTextureData = function (mipLevel, texture) {
            Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_2D, texture.texture);
            Context3DProxy.gl.pixelStorei(Context3DProxy.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
            if (texture.internalFormat == egret3d.InternalFormat.ImageData) {
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_2D, 0, Context3DProxy.gl.RGBA, Context3DProxy.gl.RGBA, Context3DProxy.gl.UNSIGNED_BYTE, texture.imageData);
            }
            else if (texture.internalFormat == egret3d.InternalFormat.CompressData) {
                this.upLoadCompressedTexture2D(mipLevel, texture);
            }
            else if (texture.internalFormat == egret3d.InternalFormat.PixelArray) {
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_2D, mipLevel, texture.colorFormat, texture.mimapData[mipLevel].width, texture.mimapData[mipLevel].height, texture.border, texture.colorFormat, Context3DProxy.gl.UNSIGNED_BYTE, texture.mimapData[mipLevel].data);
            }
            //Context3DProxy.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL
            //Context3DProxy.gl.pixelStorei(Context3DProxy.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
            if (texture.useMipmap)
                Context3DProxy.gl.generateMipmap(Context3DProxy.gl.TEXTURE_2D);
            var min_filter = (texture.smooth && texture.useMipmap) ? Context3DProxy.gl.LINEAR_MIPMAP_LINEAR : Context3DProxy.gl.LINEAR;
            var mag_filter = texture.smooth ? Context3DProxy.gl.LINEAR : Context3DProxy.gl.LINEAR;
            var wrap_u_filter = true ? Context3DProxy.gl.REPEAT : Context3DProxy.gl.CLAMP_TO_EDGE;
            var wrap_v_filter = true ? Context3DProxy.gl.REPEAT : Context3DProxy.gl.CLAMP_TO_EDGE;
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_MIN_FILTER, min_filter);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_MAG_FILTER, mag_filter);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_WRAP_S, wrap_u_filter);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_WRAP_T, wrap_v_filter);
        };
        /**
        * @language zh_CN
        * 提交2D压缩纹理，用硬件来解析dds贴图
        * @param mipLevel
        * @param texture
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.upLoadCompressedTexture2D = function (mipLevel, texture) {
            Context3DProxy.gl.compressedTexImage2D(Context3DProxy.gl.TEXTURE_2D, mipLevel, texture.colorFormat, texture.mimapData[mipLevel].width, texture.mimapData[mipLevel].height, texture.border, texture.mimapData[mipLevel].data);
        };
        /**
        * @language zh_CN
        * 创建 2维贴图 向显卡提交buffer申请 并创建Texture2D对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.creatTexture2D = function () {
            var texture = new egret3d.Texture2D();
            texture.texture = Context3DProxy.gl.createTexture();
            return texture;
        };
        /**
        * @language zh_CN
        * 创建 Cube贴图 向显卡提交buffer申请 并创建Texture3D对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.creatCubeTexture = function () {
            var texture = new egret3d.Texture3D();
            texture.texture = Context3DProxy.gl.createTexture();
            return texture;
        };
        /**
        * @language zh_CN
        * @private
        * @param tex
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uploadCubetexture = function (tex) {
            /// 创建纹理并绑定纹理数据
            Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_CUBE_MAP, tex.texture);
            if (tex.image_right.mimapData && tex.image_right.mimapData.length > 0)
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, Context3DProxy.gl.RGB, tex.image_right.mimapData[0].width, tex.image_right.mimapData[0].height, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_right.mimapData[0].data);
            else
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_right.imageData);
            if (tex.image_left.mimapData && tex.image_left.mimapData.length > 0)
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, Context3DProxy.gl.RGB, tex.image_right.mimapData[0].width, tex.image_right.mimapData[0].height, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_right.mimapData[0].data);
            else
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_left.imageData);
            if (tex.image_left.mimapData && tex.image_left.mimapData.length > 0)
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, Context3DProxy.gl.RGB, tex.image_up.mimapData[0].width, tex.image_up.mimapData[0].height, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_up.mimapData[0].data);
            else
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_up.imageData);
            if (tex.image_left.mimapData && tex.image_left.mimapData.length > 0)
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, Context3DProxy.gl.RGB, tex.image_down.mimapData[0].width, tex.image_down.mimapData[0].height, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_down.mimapData[0].data);
            else
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_down.imageData);
            if (tex.image_left.mimapData && tex.image_left.mimapData.length > 0)
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, Context3DProxy.gl.RGB, tex.image_back.mimapData[0].width, tex.image_back.mimapData[0].height, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_back.mimapData[0].data);
            else
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_back.imageData);
            if (tex.image_left.mimapData && tex.image_left.mimapData.length > 0)
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, Context3DProxy.gl.RGB, tex.image_front.mimapData[0].width, tex.image_front.mimapData[0].height, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_front.mimapData[0].data);
            else
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_front.imageData);
            ///Context3DProxy.gl.generateMipmap(Context3DProxy.gl.TEXTURE_CUBE_MAP);
            ///gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
            ///Context3DProxy.gl.texParameterf(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_MAG_FILTER, Context3DProxy.gl.LINEAR_MIPMAP_NEAREST);
            ///Context3DProxy.gl.texParameterf(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_MIN_FILTER, Context3DProxy.gl.LINEAR_MIPMAP_NEAREST);
            ///Context3DProxy.gl.texParameterf(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_WRAP_S, Context3DProxy.gl.CLAMP_TO_EDGE);
            ///Context3DProxy.gl.texParameterf(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_WRAP_T, Context3DProxy.gl.CLAMP_TO_EDGE);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_MAG_FILTER, Context3DProxy.gl.LINEAR);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_MIN_FILTER, Context3DProxy.gl.LINEAR);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_WRAP_S, Context3DProxy.gl.CLAMP_TO_EDGE);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_WRAP_T, Context3DProxy.gl.CLAMP_TO_EDGE);
            ///Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_MIN_FILTER, min_filter);
            ///Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_MAG_FILTER, mag_filter);
            ///Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_WRAP_S, wrap_u_filter);
            ///Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_WRAP_T, wrap_v_filter);
        };
        /**
        * @language zh_CN
        * @private
        * @param width
        * @param height
        * @param format
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.createFramebuffer = function (width, height, format) {
            var rttframeBuffer = Context3DProxy.gl.createFramebuffer();
            var texture2D = this.creatTexture2D();
            var depthRenderbuffer = Context3DProxy.gl.createRenderbuffer();
            Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_2D, texture2D.texture);
            var float = new Float32Array(32 * 32 * 4);
            for (var i = 0; i < 32 * 32; i++) {
                float[i] = 1.0;
                float[i + 1] = 1.0;
                float[i + 2] = 1.0;
                float[i + 3] = 1.0;
            }
            switch (format) {
                case egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB:
                    Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_2D, 0, Context3DProxy.gl.RGB, width, height, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, null);
                    break;
                case egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGBA:
                    Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_2D, 0, Context3DProxy.gl.RGBA, width, height, 0, Context3DProxy.gl.RGBA, Context3DProxy.gl.UNSIGNED_BYTE, null);
                    break;
                case egret3d.FrameBufferFormat.FLOAT_RGB:
                    Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_2D, 0, Context3DProxy.gl.RGB, width, height, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.FLOAT, float);
                    break;
                case egret3d.FrameBufferFormat.FLOAT_RGBA:
                    Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_2D, 0, Context3DProxy.gl.RGBA, width, height, 0, Context3DProxy.gl.RGBA, Context3DProxy.gl.FLOAT, float);
                    break;
            }
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_MAG_FILTER, Context3DProxy.gl.NEAREST);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_MIN_FILTER, Context3DProxy.gl.NEAREST);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_WRAP_S, Context3DProxy.gl.CLAMP_TO_EDGE);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_WRAP_T, Context3DProxy.gl.CLAMP_TO_EDGE);
            //Context3DProxy.gl.generateMipmap(Context3DProxy.gl.TEXTURE_2D);  
            Context3DProxy.gl.bindFramebuffer(Context3DProxy.gl.FRAMEBUFFER, rttframeBuffer);
            Context3DProxy.gl.framebufferTexture2D(Context3DProxy.gl.FRAMEBUFFER, Context3DProxy.gl.COLOR_ATTACHMENT0, Context3DProxy.gl.TEXTURE_2D, texture2D.texture, 0);
            ///配置渲染缓冲 
            Context3DProxy.gl.bindRenderbuffer(Context3DProxy.gl.RENDERBUFFER, depthRenderbuffer);
            Context3DProxy.gl.renderbufferStorage(Context3DProxy.gl.RENDERBUFFER, Context3DProxy.gl.DEPTH_COMPONENT16, width, height);
            texture2D.width = width;
            texture2D.height = height;
            texture2D.frameBuffer = rttframeBuffer;
            texture2D.renderbuffer = depthRenderbuffer;
            Context3DProxy.gl.bindFramebuffer(Context3DProxy.gl.FRAMEBUFFER, null);
            Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_2D, null);
            Context3DProxy.gl.bindRenderbuffer(Context3DProxy.gl.RENDERBUFFER, null);
            return texture2D;
        };
        /**
        * @language zh_CN
        * @private
        * @param texture
        * @param enableDepthAndStencil
        * @param surfaceSelector
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setRenderToTexture = function (texture, enableDepthAndStencil, surfaceSelector) {
            if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
            if (surfaceSelector === void 0) { surfaceSelector = 0; }
            if (enableDepthAndStencil) {
            }
            Context3DProxy.gl.viewport(0, 0, texture.width, texture.height);
            Context3DProxy.gl.scissor(0, 0, texture.width, texture.height);
            Context3DProxy.gl.bindFramebuffer(Context3DProxy.gl.FRAMEBUFFER, texture.frameBuffer);
            Context3DProxy.gl.clearColor(0, 0, 0, 1);
            Context3DProxy.gl.clear(Context3DProxy.gl.COLOR_BUFFER_BIT | Context3DProxy.gl.DEPTH_BUFFER_BIT);
            Context3DProxy.gl.framebufferTexture2D(Context3DProxy.gl.FRAMEBUFFER, Context3DProxy.gl.COLOR_ATTACHMENT0, Context3DProxy.gl.TEXTURE_2D, texture.texture, 0);
            Context3DProxy.gl.framebufferRenderbuffer(Context3DProxy.gl.FRAMEBUFFER, Context3DProxy.gl.DEPTH_ATTACHMENT, Context3DProxy.gl.RENDERBUFFER, texture.renderbuffer);
        };
        /**
        * @language zh_CN
        * 设置渲染缓冲为屏幕
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setRenderToBackBuffer = function () {
            Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_2D, null);
            Context3DProxy.gl.bindFramebuffer(Context3DProxy.gl.FRAMEBUFFER, null);
            Context3DProxy.gl.bindRenderbuffer(Context3DProxy.gl.RENDERBUFFER, null);
        };
        /**
        * @language zh_CN
        * 向显卡请求创建顶点shader对象
        * @param source shader代码内容
        * @returns Shader shader对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.creatVertexShader = function (source) {
            var shader = Context3DProxy.gl.createShader(Context3DProxy.gl.VERTEX_SHADER);
            Context3DProxy.gl.shaderSource(shader, source);
            Context3DProxy.gl.compileShader(shader);
            var tmpShader = new egret3d.Shader(shader);
            tmpShader.id = (egret3d.Shader.ID_COUNT++).toString();
            return tmpShader;
        };
        /**
        * @language zh_CN
        * 向显卡请求创建片段shader对象
        * @param source shader代码内容
        * @returns Shader shader对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.creatFragmentShader = function (source) {
            var shader = Context3DProxy.gl.createShader(Context3DProxy.gl.FRAGMENT_SHADER);
            Context3DProxy.gl.shaderSource(shader, source);
            Context3DProxy.gl.compileShader(shader);
            var tmpShader = new egret3d.Shader(shader);
            tmpShader.id = (egret3d.Shader.ID_COUNT++).toString();
            return tmpShader;
        };
        /**
        * @language zh_CN
        * 清除渲染buffer
        * @param BUFFER_BIT
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.clear = function (BUFFER_BIT) {
            Context3DProxy.gl.clear(BUFFER_BIT);
        };
        /**
        * @language zh_CN
        * 清除渲染区域的颜色 深度
        * @param r 红色值
        * @param g 绿色值
        * @param b 蓝色值
        * @param a alpha值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.clearColor = function (r, g, b, a) {
            Context3DProxy.gl.clearColor(r, g, b, a);
        };
        ///**
        //* @language zh_CN
        //* 清除渲染区域的 深度
        //* @param depth
        //*/
        //public clearDepth(depth: number=1.0) {
        //    Context3DProxy.gl.clearDepth(depth);
        //    Context3DProxy.gl.clear(Context3DProxy.gl.DEPTH_BUFFER_BIT);
        //}
        /**
        * @language zh_CN
        * 清除渲染区域的 模板
        * @param stencil 模板值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.clearStencil = function (stencil) {
            Context3DProxy.gl.clearStencil(stencil);
        };
        /**
        * @language zh_CN
        * 使用显卡着色器
        * @param program 设置当学显卡当前渲染程序
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setProgram = function (program) {
            this.programChange = false;
            if (this.program == program)
                return;
            this.programChange = true;
            this.program = program;
            Context3DProxy.gl.useProgram(program.program);
        };
        /**
        * @language zh_CN
        * 获取矩阵变量ID
        * @param program
        * @param name
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.getUniformLocation = function (programe3D, name) {
            return Context3DProxy.gl.getUniformLocation(programe3D.program, name);
        };
        /**
        * @language zh_CN
        * 传值给shader一个float
        * @param location 指明要更改的uniform变量
        * @param x  uniform变量变量值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform1f = function (location, x) {
            Context3DProxy.gl.uniform1f(location, x);
        };
        /**
        * @language zh_CN
        * 传值给shader 一个vec3(float, float, float) 也可以是一个vec3数组
        * @param location 指明要更改的uniform变量
        * @param v uniform变量变量值Float32Array[3]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform1fv = function (location, v) {
            Context3DProxy.gl.uniform1fv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader一个int
        * @param location 指明要更改的uniform变量
        * @param x uniform变量变量值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform1i = function (location, x) {
            Context3DProxy.gl.uniform1i(location, x);
        };
        /**
        * @language zh_CN
        * 传值给shader一个int数组
        * @param location 指明要更改的uniform变量
        * @param v int数组的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform1iv = function (location, v) {
            Context3DProxy.gl.uniform1iv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader两个float
        * @param location 指明要更改的uniform变量
        * @param x float x 的值
        * @param y float y 的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform2f = function (location, x, y) {
            Context3DProxy.gl.uniform2f(location, x, y);
        };
        /**
        * @language zh_CN
        * 传值给shader vec(float, float)
        * @param location 指明要更改的uniform变量
        * @param v Float32Array[2]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform2fv = function (location, v) {
            Context3DProxy.gl.uniform2fv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader 两个int值
        * @param location 指明要更改的uniform变量
        * @param x number x 的值
        * @param y number y 的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform2i = function (location, x, y) {
            Context3DProxy.gl.uniform2i(location, x, y);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location 指明要更改的uniform变量
        * @param v
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform2iv = function (location, v) {
            Context3DProxy.gl.uniform2iv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader 3个float
        * @param location 指明要更改的uniform变量
        * @param x
        * @param y
        * @param z
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform3f = function (location, x, y, z) {
            Context3DProxy.gl.uniform3f(location, x, y, z);
        };
        /**
        * @language zh_CN
        * 传值给shader vec3(float, float, float)
        * @param location 指明要更改的uniform变量
        * @param v Float32Array[3]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform3fv = function (location, v) {
            Context3DProxy.gl.uniform3fv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader 3个int
        * @param location 指明要更改的uniform变量
        * @param x
        * @param y
        * @param z
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform3i = function (location, x, y, z) {
            Context3DProxy.gl.uniform3i(location, x, y, z);
        };
        /**
        * @language zh_CN
        * 传值给shader vec3(int, int, int)
        * @param location 指明要更改的uniform变量
        * @param v Int32Array[3]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform3iv = function (location, v) {
            Context3DProxy.gl.uniform3iv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader 4个float值
        * @param location 指明要更改的uniform变量
        * @param x
        * @param y
        * @param z
        * @param w
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform4f = function (location, x, y, z, w) {
            Context3DProxy.gl.uniform4f(location, x, y, z, w);
        };
        /**
        * @language zh_CN
        * 传值给shader vec(float, float, float, float)
        * @param location 指明要更改的uniform变量
        * @param v Float32Array[4]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform4fv = function (location, v) {
            Context3DProxy.gl.uniform4fv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader 4个int值
        * @param location 指明要更改的uniform变量
        * @param x
        * @param y
        * @param z
        * @param w
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform4i = function (location, x, y, z, w) {
            Context3DProxy.gl.uniform4i(location, x, y, z, w);
        };
        /**
        * @language zh_CN
        * 传值给shader vec4(int, int, int, int)
        * @param location 指明要更改的uniform变量
        * @param v Int32Array[4]
        */
        Context3DProxy.prototype.uniform4iv = function (location, v) {
            Context3DProxy.gl.uniform4iv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader 2 * 2矩阵
        * @param location 指明要更改的uniform变量
        * @param transpose 是否转置
        * @param value 矩阵值 Float32Array[4]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniformMatrix2fv = function (location, transpose, value) {
            Context3DProxy.gl.uniformMatrix2fv(location, transpose, value);
        };
        /**
        * @language zh_CN
        * 传值给shader 3 * 3矩阵
        * @param location 指明要更改的uniform变量
        * @param transpose 是否转置
        * @param value 矩阵值 Float32Array[9]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniformMatrix3fv = function (location, transpose, value) {
            Context3DProxy.gl.uniformMatrix3fv(location, transpose, value);
        };
        /**
        * @language zh_CN
        * 传值给shader 4 * 4矩阵
        * @param location 指明要更改的uniform变量
        * @param transpose 是否转置
        * @param value 矩阵值 Float32Array[16]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniformMatrix4fv = function (location, transpose, value) {
            Context3DProxy.gl.uniformMatrix4fv(location, transpose, value);
        };
        /**
        * @language zh_CN
        * 设置 绘制混合模式
        * @param src
        * @param dst
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setBlendFactors = function (src, dst) {
            if (this.blend_Factors_src == src && this.blend_Factors_dst == dst)
                return;
            this.blend_Factors_src = src;
            this.blend_Factors_dst = dst;
            Context3DProxy.gl.blendFunc(src, dst);
        };
        /**
        * @language zh_CN
        * 设置 绘制剔除模式
        * @param mode
        * @see egret3d.ContextConfig.FRONT
        * @see egret3d.ContextConfig.BACK
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setCulling = function (mode) {
            if (this.cullingMode == mode)
                return;
            this.cullingMode = mode;
            Context3DProxy.gl.cullFace(mode);
        };
        /**
        * @language zh_CN
        * 开启 深度测试模式
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.enableDepth = function () {
            if (this.DEPTH_TEST)
                return;
            this.DEPTH_TEST = true;
            Context3DProxy.gl.enable(egret3d.ContextConfig.DEPTH_TEST);
        };
        /**
        * @language zh_CN
        * 关闭 深度测试模式
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.disableDepth = function () {
            if (!this.DEPTH_TEST)
                return;
            this.DEPTH_TEST = false;
            Context3DProxy.gl.disable(egret3d.ContextConfig.DEPTH_TEST);
        };
        /**
        * @language zh_CN
        * 开启 剔除面模式
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.enableCullFace = function () {
            if (this.CULL_FACE)
                return;
            this.CULL_FACE = true;
            Context3DProxy.gl.enable(egret3d.ContextConfig.CULL_FACE);
        };
        /**
        * @language zh_CN
        * 关闭 剔除面模式
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.disableCullFace = function () {
            if (!this.CULL_FACE)
                return;
            this.CULL_FACE = false;
            Context3DProxy.gl.disable(egret3d.ContextConfig.CULL_FACE);
        };
        /**
        * @language zh_CN
        * 开启 混合模式
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.enableBlend = function () {
            if (this.BLEND)
                return;
            this.BLEND = true;
            Context3DProxy.gl.enable(egret3d.ContextConfig.BLEND);
        };
        /**
        * @language zh_CN
        * 关闭 混合模式
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.disableBlend = function () {
            if (!this.BLEND)
                return;
            this.BLEND = false;
            Context3DProxy.gl.disable(egret3d.ContextConfig.BLEND);
        };
        ///**
        // * @language zh_CN
        // * 开启 绘制模式
        // * @param cap
        // * @version Egret 3.0
        // * @platform Web,Native
        // */
        //public enable(cap: number) {
        //    Context3DProxy.gl.enable(cap);
        //}
        ///**
        //* @language zh_CN
        //* 关闭 绘制模式
        //* @param cap
        //* @version Egret 3.0
        //* @platform Web,Native
        //*/
        //public disable(cap: number) {
        //    Context3DProxy.gl.disable(cap);
        //}
        /**
        * @language zh_CN
        * 开启 深度模式 及 深度测试比较模式
        * @param flag
        * @param compareMode
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.depthFunc = function (compareMode) {
            if (compareMode === void 0) { compareMode = 0; }
            if (this.depthCompareMode == compareMode)
                return;
            this.depthCompareMode = compareMode;
            Context3DProxy.gl.depthFunc(compareMode);
        };
        /**
        * @language zh_CN
        * 开启 深度模式 及 深度测试比较模式
        * @param flag
        * @param compareMode
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.enableDepthTest = function (flag, compareMode) {
            if (compareMode === void 0) { compareMode = 0; }
            if (flag)
                Context3DProxy.gl.enable(Context3DProxy.gl.DEPTH_TEST);
        };
        /**
        * @language zh_CN
        * 获取顶点着色器变量 索引
        * @param programe
        * @param attribName
        * @returns 着色器变量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.getShaderAttribLocation = function (programe, attribName) {
            return Context3DProxy.gl.getAttribLocation(programe.program, attribName);
        };
        /**
        * @language zh_CN
        * 指定顶点着色器变量索引及结构
        * @param index 变量索引
        * @param size  数据个数
        * @param dataType  数据类型
        * @param normalized 是否单位化
        * @param stride 字节数
        * @param offset 当前变量字节偏移
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.vertexAttribPointer = function (index, size, dataType, normalized, stride, offset) {
            Context3DProxy.gl.vertexAttribPointer(index, size, dataType, normalized, stride, offset);
            Context3DProxy.gl.enableVertexAttribArray(index);
        };
        /**
        * @language zh_CN
        * 关闭顶点着色器变量索引
        * @param index 变量索引
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.clearVaPointer = function (index) {
            Context3DProxy.gl.disableVertexAttribArray(index);
        };
        /**
        * @language zh_CN
        * 检查激活 的顶点结构
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.isActiveVertexFormat = function (format) {
            //if (this.vertexFormat == format && !this.programChange )
            //    return true;
            //this.vertexFormat = format;
            return false;
        };
        /**
        * @language zh_CN
        * 激活的顶点结构
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.activeVertexFormat = function (format) {
            this.vertexFormat = format;
        };
        /**
        * @language zh_CN
        * 关闭顶点着色器变量索引
        * @param index 变量索引
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.unActiveVertexFormat = function () {
            this.vertexFormat = -1;
            for (var i = 0; i < 12; i++) {
                this.clearVaPointer(i);
            }
        };
        /**
        * @language zh_CN
        * @private
        * 实时传入显卡顶点着色器变量数组数据
        * @param floats
        * @param offest
        * @param numLen
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setVertexShaderConstData = function (floats, offest, numLen) {
            Context3DProxy.gl.vertexAttrib4fv(offest, floats.subarray(offest, numLen));
        };
        /**
        * @language zh_CN
        * @private
        * 实时传入显卡片段着色器变量数组数据
        * @param floats
        * @param offest
        * @param numLen
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setFragmentShaderConstData = function (floats, offest, numLen) {
        };
        /**
        * @language zh_CN
        * 设置贴图采样 第一个参数并不是类型
        * @param samplerIndex  ContextSamplerType
        * @param uniLocation
        * @param index
        * @param texture
        * @see egret3d.ContextSamplerType
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setTexture2DAt = function (samplerIndex, uniLocation, index, texture) {
            Context3DProxy.gl.activeTexture(samplerIndex);
            Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_2D, texture.texture);
            Context3DProxy.gl.uniform1i(uniLocation, index);
        };
        Context3DProxy.prototype.disableTexture2DAt = function (samplerIndex, uniLocation, index) {
            //Context3DProxy.gl.activeTexture(samplerIndex);
            //Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_2D, null );
            //Context3DProxy.gl.uniform1i(uniLocation, index);
        };
        /**
        * @language zh_CN
        * 设置贴图采样 第一个参数并不是类型
        * @param samplerIndex  ContextSamplerType
        * @param uniLocation
        * @param index
        * @param texture
        * @see egret3d.ContextSamplerType
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setCubeTextureAt = function (samplerIndex, uniLocation, index, texture) {
            if (!texture) {
                return;
            }
            Context3DProxy.gl.activeTexture(samplerIndex);
            Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_CUBE_MAP, texture.texture);
            Context3DProxy.gl.uniform1i(uniLocation, index);
        };
        /**
        * @language zh_CN
        * @private
        * 设置矩形裁切区域
        * @param rectangle
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setScissorRectangle = function (x, y, width, height) {
            Context3DProxy.gl.scissor(x, egret3d.ContextConfig.canvasRectangle.height - height - y, width, height);
        };
        /**
        * @language zh_CN
        * @private
        * 设置模板测试
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setStencilReferenceValue = function () {
        };
        /**
        * @language zh_CN
        * @private
        * 设置模板测试
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setStencilActions = function (triangleFace, compareMode, actionOnBothPass, actionOnDepthFail, actionOnDepthPassStencilFail) {
        };
        /**
        * @language zh_CN
        * 绑定顶点Buffer
        * @param vertexBuffer
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.bindVertexBuffer = function (vertexBuffer) {
            Context3DProxy.gl.bindBuffer(Context3DProxy.gl.ARRAY_BUFFER, vertexBuffer.buffer);
        };
        /**
       * @language zh_CN
       * 绑定顶点索引Buffer
       * @param vertexBuffer
       * @version Egret 3.0
       * @platform Web,Native
       */
        Context3DProxy.prototype.bindIndexBuffer = function (indexBuffer) {
            Context3DProxy.gl.bindBuffer(Context3DProxy.gl.ELEMENT_ARRAY_BUFFER, indexBuffer.buffer);
        };
        /**
        * @language zh_CN
        * 绘制模型元素
        * @param type 图元类型
        * @param first 第一个顶点索引
        * @param length 顶点个数
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.drawArrays = function (type, first, length) {
            Context3DProxy.gl.drawArrays(type, first, length);
        };
        /**
        * @language zh_CN
        * 绘制模型元素
        * @param type 图元类型
        * @param indexBuffer 索引数据
        * @param offset 顶点索引偏移 (字节数)
        * @param length 顶点个数
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.drawElement = function (type, offset, length) {
            Context3DProxy.gl.drawElements(type, length, Context3DProxy.gl.UNSIGNED_SHORT, offset);
        };
        /**
        * @language zh_CN
        * @private
        * 绘制提交
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.flush = function () {
            Context3DProxy.gl.flush();
        };
        return Context3DProxy;
    }());
    egret3d.Context3DProxy = Context3DProxy;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.FrameBuffer
    * @classdesc
    * FrameBuffer 类提供了用于呈现几何定义图形的上下文的帧缓冲对象。</p>
    *
    * 渲染上下文包括一个绘图表面及其关联的资源帧缓冲对象。</p>
    * 通过context creatFrameBuffer 来创建，不能直接使用 new 的方式实例化。</p>
    * @see egret3d.Program3D
    * @see egret3d.IndexBuffer3D
    * @see egret3d.VertexBuffer3D
    * @see egret3d.Texture2D
    * @see egret3d.Shader
    * @see egret3d.CubeTexture
    * @version Egret 3.0
    * @platform Web,Native
    */
    var FrameBuffer = (function () {
        function FrameBuffer() {
        }
        return FrameBuffer;
    }());
    egret3d.FrameBuffer = FrameBuffer;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.IndexBuffer3D
    * @classdesc
    * IndexBuffer3D 用于表示顶点索引列表，由图形子系统保留的图形元素构成。</p>
    *
    * 定义一个立方图纹理，以便在渲染期间使用。立方体贴图可用于多种渲染技术，例如环境图、skyboxes 和 skylight 光照。</p>
    * 不能直接创建 CubeTexture 对象，而应使用 Context3DProxy createCubeTexture()。</p>
    *
    * 由 IndexBuffer3D 对象管理的索引可用于从顶点流中选择顶点。索引为 16 位无符号整数。所允许的最大索引值为 65535 (0xffff)。图形子系统不会保留对提供给此对象的顶点的引用。修改或丢弃上载到此对象中的数据不会影响已存储的值。</p>

    * 无法直接实例化 IndexBuffer3D。使用 Context3DProxy.CreateIndexBuffer() 可创建实例。</p>
    * @see egret3d.Context3DProxy
    * @see egret3d.CubeTexture
    * @version Egret 3.0
    * @platform Web,Native
    */
    var IndexBuffer3D = (function () {
        /**
        * @language zh_CN
        * 构造
        * @param buffer webglbuffer
        */
        function IndexBuffer3D(buffer) {
            this.buffer = buffer;
        }
        return IndexBuffer3D;
    }());
    egret3d.IndexBuffer3D = IndexBuffer3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @class egret3d.IndexBuffer3D
     * @classdesc
     * IndexBuffer3D 用于表示顶点索引列表，由图形子系统保留的图形元素构成。</p>
     * VertexBuffer3D 类表示上载到渲染上下文的一组顶点数据。</p>
     * 使用 VertexBuffer3D 对象定义与一组顶点中每个点相关联的数据。</p>
     * 您可以从 Vector 数组或 ByteArray 上载顶点数据。（上载完成后，将不再引用原始数组中的数据；更改或放弃源数组不会更改顶点数据。）</p>
     * 与每个顶点相关联的数据采用应用程序定义的格式，并用作顶点着色器程序的输入。</p>
     * 使用 Context3DProxy.vertexAttribPointer  函数标识哪些值属于哪个顶点程序输入。</p>
     * 一个顶点程序最多可以使用 8 个输入（也称为顶点属性寄存器）。</p>
     * 每个输入可能需要 1 到 4 个 32 位值。</p>
     * 例如，一个顶点的 [x,y,z] 位置坐标可以作为包含 3 个 32 位值的矢量传递到顶点程序。</p>
     * 您最多可以为每个点提供 64 个 32 位值（256 字节）数据（但在这种情况下，单个顶点着色器无法使用所有数据）。</p>
     * @see egret3d.Context3DProxy
     * @see egret3d.CubeTexture
     * @version Egret 3.0
     * @platform Web,Native
     */
    var VertexBuffer3D = (function () {
        /**
        * @language zh_CN
        * 构造
        * @param buffer WebGLBuffer
        * @version Egret 3.0
        * @platform Web,Native
        */
        function VertexBuffer3D(buffer) {
            this.buffer = buffer;
        }
        return VertexBuffer3D;
    }());
    egret3d.VertexBuffer3D = VertexBuffer3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.MipmapData
    * @classdesc
    * 一个贴图的不同LOD层级数据。</p>
    * 生成 mipmap 可以使用 TextureUtil.generateMipMaps() 来制作lod mipmapdata。</p>
    *
    *
    * @see egret3d.openGLES.Program3D
    * @see egret3d.openGLES.IndexBuffer3D
    * @see egret3d.openGLES.VertexBuffer3D
    * @see egret3d.openGLES.Texture2D
    * @see egret3d.openGLES.Shader
    * @see egret3d.openGLES.CubeTexture
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MipmapData = (function () {
        /**
        * @language zh_CN
        * 创建一个MipmapData 对象
        * @param data 数据内容
        * @param width 宽度
        * @param height 高度
        * @version Egret 3.0
        * @platform Web,Native
        */
        function MipmapData(data, width, height) {
            this.data = data;
            this.width = width;
            this.height = height;
        }
        return MipmapData;
    }());
    egret3d.MipmapData = MipmapData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Program3D
    * @classdesc
    * Program3D 类表示上载到渲染上下文的一对渲染程序（也称为“编译后的着色器”）。</p>
    *
    * 由 Program3D 对象管理的程序控制 drawTriangles 调用期间的整个三角形渲染。使用 upload 方法将二进制字节码上载到渲染上下文。（上载完成后，将不再引用原始字节数组中的数据；更改或放弃源字节数组不会更改该程序。）。</p>
    * 这些程序始终由两个相互关联的部分组成：顶点程序和片段程序。</p>
    * 顶点程序会操作 VertexBuffer3D 中定义的数据，负责将顶点投影到剪辑空间，并将任何所需的顶点数据（例如颜色）传递到片段着色器。</p>
    * 片段着色器会操作顶点程序传递给它的属性，并为三角形的每个栅格化片段生成颜色，最终形成像素颜色。请注意，片段程序在 3D 编程文献中具有多个名称，包括片段着色器和像素着色器。</p>
    * 通过将相应 Program3D 实例传递到 Context3DProxy setProgram() 方法，指定后续渲染操作要使用的程序对。</p>
    * 您无法直接创建 Program3D 对象；请改用 Context3DProxy createProgram() 方法。</p>
    *
    * @see egret3d.Program3D
    * @see egret3d.IndexBuffer3D
    * @see egret3d.VertexBuffer3D
    * @see egret3d.Texture2D
    * @see egret3d.Shader
    * @see egret3d.CubeTexture
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Program3D = (function () {
        /**
        * @language zh_CN
        * 构造
        * @param pg3D WebGLProgram对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Program3D(pg3D) {
            this.program = pg3D;
        }
        return Program3D;
    }());
    egret3d.Program3D = Program3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Texture2D
    * @classdesc
    * Texture 类表示上载到渲染上下文的二维纹理。</p>
    *
    * 定义一个 2D 纹理，以便在渲染期间使用。</p>
    * 无法直接实例化 Texture。使用 Context3DProxy createTexture() 方法创建实例。</p>
    * @see egret3d.Program3D
    * @see egret3d.IndexBuffer3D
    * @see egret3d.VertexBuffer3D
    * @see egret3d.Texture2D
    * @see egret3d.Shader
    * @see egret3d.CubeTexture
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Texture2D = (function () {
        /**
         * @language zh_CN
         * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
         */
        function Texture2D() {
            /**
             * @language zh_CN
             * 是否使用mipmap
             */
            this.useMipmap = true;
            /**
            * @language zh_CN
            * 是否自动模糊
           * @version Egret 3.0
           * @platform Web,Native
            */
            this.smooth = true;
            this.border = 0;
            this.useMipmap = true;
            this.imageData = null;
            this.colorFormat = egret3d.ContextConfig.ColorFormat_RGBA8888;
            this.internalFormat = egret3d.InternalFormat.PixelArray;
            this.mimapData = new Array();
        }
        return Texture2D;
    }());
    egret3d.Texture2D = Texture2D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Shader
    * @classdesc
    * Shader 类表示上载到渲染上下文的一对渲染程序中的 顶点找色shader，或片段着色的shader 。</p>
    *
    * shader 是基于 opengl es 2.0 标准 也就是webgl版本的shader着色器。</p>
    *
    * @see egret3d.Program3D
    * @see egret3d.IndexBuffer3D
    * @see egret3d.VertexBuffer3D
    * @see egret3d.Texture2D
    * @see egret3d.Shader
    * @see egret3d.CubeTexture
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Shader = (function () {
        /**
        * @language zh_CN
        * 构造
        * @param shader WebGLShader对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Shader(shader) {
            this._shader = shader;
        }
        Object.defineProperty(Shader.prototype, "shader", {
            /**
            * @language zh_CN
            * @private
            * WebGLShader 的引用
            */
            get: function () {
                return this._shader;
            },
            enumerable: true,
            configurable: true
        });
        /**
      * @language zh_CN
      * @private
      * 声明 shader 为顶点 类型
      * @see egret3d.ShaderPool
      */
        Shader.vertex = 0;
        /**
   * @language zh_CN
   * @private
   * 声明 shader 为片段 类型
   * @see egret3d.ShaderPool
   */
        Shader.fragment = 1;
        /**
       * @language zh_CN
       * @private
       * 获取已经有的shader 的ID
       */
        Shader.ID_COUNT = 0;
        return Shader;
    }());
    egret3d.Shader = Shader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Texture3D
    * @classdesc
    * 由6加Texture2D 组成
    * 可以使一个6面体上贴出不同的贴图
    * @see egret3d.Program3D
    * @see egret3d.IndexBuffer3D
    * @see egret3d.VertexBuffer3D
    * @see egret3d.Texture2D
    * @see egret3d.Shader
    * @see egret3d.CubeTexture
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Texture3D = (function () {
        /**
         * @language zh_CN
         * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
         */
        function Texture3D() {
            this.border = 0;
            this.useMipmap = true;
            this.colorformat = egret3d.ContextConfig.ColorFormat_RGBA8888;
            this.internalformat = egret3d.InternalFormat.PixelArray;
            this.mimapData = new Array();
        }
        return Texture3D;
    }());
    egret3d.Texture3D = Texture3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Object3D
    * @classdesc
    * 拣选类型，拣选时可以分为，包围盒拣选、模型拣选返回模型拣选到的位置、模型拣选返回模型拣选到的UV坐标
    * 这几种拣选方式
    * 设置鼠标拣选的类型，鼠标拣选不同的类型有不同的效果作用，还有性能
    * 需要的拣选精度越高，性能要求就越高，反之亦然
    *
    * @see egret3d.Picker
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (PickType) {
        /**
        * 包围盒拣选
        */
        PickType[PickType["BoundPick"] = 0] = "BoundPick";
        /**
        * 模型拣选返回模型拣选到的位置
        */
        PickType[PickType["PositionPick"] = 1] = "PositionPick";
        /**
        * 模型拣选返回模型拣选到的UV坐标
        */
        PickType[PickType["UVPick"] = 2] = "UVPick";
    })(egret3d.PickType || (egret3d.PickType = {}));
    var PickType = egret3d.PickType;
    ;
    /**
    * @class egret3d.Object3D
    * @classdesc
    * 3d空间中的实体对象。
    * 场景图中的Object3D对象是一个树型结构，对象中包含了变换信息.
    * 这些变换信息应用于所有的子对象,子对象也有自己的变换信息,最终
    * 的变换信息要结合父对象的变换信息
    * 每个Object3D对象在生成时会创建一个包围盒
    *
    * @see egret3d.Vector3D
    * @see egret3d.Matrix4_4
    * @see egret3d.Quaternion
    * @see egret3d.Bound
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Object3D = (function (_super) {
        __extends(Object3D, _super);
        /**
        * @language zh_CN
        * 如果直接实例化这个类，就会生成一个空的3D容器，可以往里添加3D显示对象，作为对象的父级，但是本身没有渲染属性。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Object3D() {
            _super.call(this);
            this._modelMatrix3D = new egret3d.Matrix4_4();
            this._transformChange = true;
            this._pos = new egret3d.Vector3D();
            this._rot = new egret3d.Vector3D();
            this._sca = new egret3d.Vector3D(1, 1, 1);
            this._orientation = new egret3d.Quaternion();
            this._axis = new egret3d.Vector3D();
            this._angle = 0;
            this._globalPos = new egret3d.Vector3D();
            this._globalRot = new egret3d.Vector3D();
            this._globalSca = new egret3d.Vector3D(1, 1, 1);
            this._globalOrientation = new egret3d.Quaternion();
            this._qut = new egret3d.Quaternion();
            this._vec = new egret3d.Vector3D();
            this._active = false;
            this._isRoot = true;
            /**
            * @language zh_CN
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.canPick = false;
            /**
            * @language zh_CN
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.renderLayer = 0;
            /**
            * @language zh_CN
            * 当前对象名
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.name = "";
            /**
            * @language zh_CN
            * 当前对象id
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.id = 0;
            /**
            * @language zh_CN
            * 渲染层级 。</p>
            * 渲染时分组进行依次渲染 前16位表示tag,后16位表示layer。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.layer = 0x00000000;
            /**
            * @language zh_CN
            * 父亲节点
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.parent = null;
            /**
            * @language zh_CN
            * 子对象列表。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.childs = new Array();
            /**
            * @language zh_CN
            * 是否控制，当摄像机被绑定摄像机动画时，这个值为false.
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.isController = true;
            /**
            * @language zh_CN
            * 是否关闭
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.isDisable = false;
            /**
            * @language zh_CN
            * 是否可见
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.visible = true;
            /**
            * @language zh_CN
            * 鼠标拣选类型。</p>
            * 设置鼠标的拣选类型，可通过 PickType来进行设置。</p>
            * 快速拣选默认使用 正方形包围盒子。</p>
            * 高精度型需要 PositionPick ， uv pick 等。</p>
            * @see egret3d.PickType
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.pickType = PickType.BoundPick;
            /**
            * @language zh_CN
            * 鼠标检测数据
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.pickResult = new egret3d.PickResult();
            /**
            * @language zh_CN
            * 是否开启拣选检测。</p>
            * 设定这个物件是否具有 鼠标交互能力的开关。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.enablePick = false;
            /**
            * @language zh_CN
            * 是否开启检测LOD盒子，每个物体的碰撞盒子中有一个小的盒子，当开启这个盒子后，
            * 鼠标检测就是用的这个小盒子来进行检测
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.mouseChilder = false;
            /**
            * @language zh_CN
            * 是否开启相机视锥裁剪 默认为true
            * 设定这个物件是否具有 视锥体裁剪功能，为否的话，将永远不参加场景渲染剔除树，无论是否在显示范围内都会进行相关的渲染逻辑运算。</p>
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.enableCulling = true;
            this.id = ++Object3D.s_id;
        }
        Object.defineProperty(Object3D.prototype, "bound", {
            /**
            * @language zh_CN
            * 獲取对象模型包围盒。</p>
            * 每个场景物件都需要有的 包围盒子，可以自定义包围盒形状大小，也可以根据模型本身生成。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._bound;
            },
            /**
            * @language zh_CN
            * 設置对象模型包围盒。</p>
            * 每个场景物件都需要有的 包围盒子，可以自定义包围盒形状大小，也可以根据模型本身生成。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (bound) {
                this._bound = bound;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "currentBound", {
            /**
            * @language zh_CN
            * 对象模型当前使用包围盒。
            * @see mouseChilder 根据这个值取不同的包围盒为true取大包围盒 false取子包围盒
            *
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this.mouseChilder) {
                    return this.bound.childBound;
                }
                return this.bound;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "position", {
            /**
            * @language zh_CN
            * 返回位移。</p>
            * 获取容器的坐标位置，基于父节点的位置坐标。</p>
            * @returns 位移
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos;
            },
            /**
            * @language zh_CN
            * 设置位移。</p>
            * 设置基于父节点的位置坐标，当父容器发生变化时，子节点也会变化。</p>
            * @param vec 位移
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (vec) {
                this.updateTransformChange(true);
                this._pos.copyFrom(vec);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotation", {
            /**
            * @language zh_CN
            * 返回旋转。</p>
            * 获取容器的旋转信息，基于父节点的旋转信息 欧拉角信息。</p>
            * @returns 旋转 欧拉角信息
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot;
            },
            /**
            * @language zh_CN
            * 设置旋转 。</p>
            * 设置基于父节点的旋转信息 欧拉角信息，当父容器发生变化时，子节点也会变化。</p>
            * @param vec 旋转 欧拉角信息
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._rot.x = value.x;
                this._rot.y = value.y;
                this._rot.z = value.z;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "orientation", {
            /**
            * @language zh_CN
            * 返回旋转。</p>
            * 返回 基于四元素的旋转信息。</p>
            * @returns 旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._orientation;
            },
            /**
            * @language zh_CN
            * 设置旋转。</p>
            * 设置旋转 基于四元素 旋转信息，当父容器发生变化时，子节点也会变化。</p>
            * @param value 旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._orientation.copyFrom(value);
                this._orientation.toEulerAngles(this._rot);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "orientationX", {
            /**
            * @language zh_CN
            * 设置旋转 分量x
            * @param value 分量x
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._orientation.x = value;
                this._orientation.toEulerAngles(this._rot);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "orientationY", {
            /**
            * @language zh_CN
            * 设置旋转 分量y
            * @param value 分量y
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._orientation.y = value;
                this._orientation.toEulerAngles(this._rot);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "orientationZ", {
            /**
            * @language zh_CN
            * 设置旋转 分量z
            * @param value 分量z
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._orientation.z = value;
                this._orientation.toEulerAngles(this._rot);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "orientationW", {
            /**
            * @language zh_CN
            * 设置旋转 分量w
            * @param value 分量w
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._orientation.w = value;
                this._orientation.toEulerAngles(this._rot);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scale", {
            /**
            * @language zh_CN
            * 返回缩放。</p>
            * 返回基于父容器的缩放信息。</p>
            * @returns 缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca;
            },
            /**
            * @language zh_CN
            * 设置缩放。</p>
            * 设置基于父容器的缩放信息，当父容器发生变化时，子节点也会变化。</p>
            * @param vec 缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                this.updateTransformChange(true);
                this._sca = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "x", {
            /**
            * @language zh_CN
            * 返回x坐标
            * 返回基于父容器的位置坐标信息值
            * @returns x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos.x;
            },
            /**
            * @language zh_CN
            * 设置x坐标。</p>
            * 设置基于父容器的位置信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._pos.x == value)
                    return;
                this._pos.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "y", {
            /**
            * @language zh_CN
            * 返回y坐标
            *
            * 返回基于父容器的位置坐标信息值
            * @returns y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos.y;
            },
            /**
            * @language zh_CN
            * 设置y坐标。</p>
            * 设置基于父容器的位置信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._pos.y == value)
                    return;
                this._pos.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "z", {
            /**
            * @language zh_CN
            * 返回z坐标
            *
            * 返回基于父容器的位置坐标信息值
            * @returns z坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos.z;
            },
            /**
            * @language zh_CN
            * 设置z坐标。</p>
            * 设置基于父容器的位置信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value z坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._pos.z == value)
                    return;
                this._pos.z = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotationX", {
            /**
            * @language zh_CN
            * 返回x旋转
            *
            * 返回基于父容器的位置旋转信息值
            * @returns x旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot.x;
            },
            /**
            * @language zh_CN
            * 设置x轴旋转。</p>
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value x轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._rot.x == value)
                    return;
                this._rot.x = value;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this._angle = this._orientation.toAxisAngle(this._axis);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotationY", {
            /**
            * @language zh_CN
            * 返回y旋转
            *
            * 返回基于父容器的位置旋转信息值
            * @returns y旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot.y;
            },
            /**
            * @language zh_CN
            * 设置y轴旋转。</p>
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value y轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._rot.y == value)
                    return;
                this._rot.y = value;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this._angle = this._orientation.toAxisAngle(this._axis);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotationZ", {
            /**
            * @language zh_CN
            * 返回z旋转
            *
            * 返回基于父容器的位置旋转信息值
            * @returns z旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot.z;
            },
            /**
            * @language zh_CN
            * 设置z轴旋转。</p>
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value z轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._rot.z == value)
                    return;
                this._rot.z = value;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this._angle = this._orientation.toAxisAngle(this._axis);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleX", {
            /**
            * @language zh_CN
            * 返回x缩放
            * 返回基于父容器的缩放信息值
            * @returns x缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca.x;
            },
            /**
            * @language zh_CN
            * 设置x轴缩放。</p>
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value x轴缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._sca.x == value)
                    return;
                this._sca.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleY", {
            /**
            * @language zh_CN
            * 返回y缩放
            * 返回基于父容器的缩放信息值
            * @returns y缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca.y;
            },
            /**
            * @language zh_CN
            * 设置y轴缩放
            *
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value y轴缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._sca.y == value)
                    return;
                this._sca.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleZ", {
            /**
            * @language zh_CN
            * 返回z缩放
            * 返回基于父容器的缩放信息值
            * @returns z缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca.z;
            },
            /**
            * @language zh_CN
            * 设置z轴缩放
            *
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value z轴缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._sca.z == value)
                    return;
                this._sca.z = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 以axis轴为中心进行旋转
        * 设置基于父容器的旋转信息，数值通过axis的角度进行设置。当父容器发生变化时，子节点也会变化，值不变
        * @param axis 中心轴
        * @param angle 旋转的角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.setRotationFromAxisAngle = function (axis, angle) {
            axis.normalize();
            this.updateTransformChange(true);
            this._orientation.fromAxisAngle(axis, angle);
            this._orientation.toEulerAngles(this._rot);
            this._axis.copyFrom(axis);
            this._angle = angle;
        };
        Object.defineProperty(Object3D.prototype, "modelMatrix", {
            /**
            * @language zh_CN
            * 返回 object 世界渲染矩阵
            * 如果有父亲节点对象的话，要乘以父对象的变换.
            * @returns object 世界渲染矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.updateModelMatrix();
                }
                return this._modelMatrix3D;
            },
            /**
            * @language zh_CN
            * 设置 object 世界渲染矩阵
            * @param matrix 世界矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (matrix) {
                var tas = matrix.decompose(egret3d.Orientation3D.QUATERNION);
                this.globalPosition = tas[0];
                egret3d.MathUtil.CALCULATION_QUATERNION.x = tas[1].x;
                egret3d.MathUtil.CALCULATION_QUATERNION.y = tas[1].y;
                egret3d.MathUtil.CALCULATION_QUATERNION.z = tas[1].z;
                egret3d.MathUtil.CALCULATION_QUATERNION.w = tas[1].w;
                this.globalOrientation = egret3d.MathUtil.CALCULATION_QUATERNION;
                this.globalScale = tas[2];
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 返回 object 世界渲染矩阵
        * 如果有父亲节点对象的话，要乘以父对象的变换.
        * @private
        * @returns object 世界渲染矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.updateModelMatrix = function () {
            if (this.parent != null) {
                var parentOrientation = this.parent.globalOrientation;
                this._globalOrientation.multiply(parentOrientation, this._orientation);
                this._globalOrientation.toEulerAngles(this._globalRot);
                var parentScale = this.parent.globalScale;
                this._globalSca.copyFrom(parentScale.multiply(this._sca));
                parentOrientation.transformVector(parentScale.multiply(this._pos), this._globalPos);
                this._globalPos.copyFrom(this._globalPos.add(this.parent.globalPosition));
            }
            else {
                this._globalOrientation.copyFrom(this._orientation);
                this._globalPos.copyFrom(this._pos);
                this._globalSca.copyFrom(this._sca);
                this._globalRot.copyFrom(this._rot);
            }
            this.onMakeTransform();
            this.onUpdateTransform();
            this._transformChange = false;
        };
        Object3D.prototype.onUpdateTransform = function () {
        };
        Object3D.prototype.onMakeTransform = function () {
            this._modelMatrix3D.makeTransform(this._globalPos, this._globalSca, this._globalOrientation);
        };
        Object.defineProperty(Object3D.prototype, "globalX", {
            /**
            * @language zh_CN
            * 返回 object 世界位置 x
            * @returns object 世界位置x
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalPosition.x;
            },
            /**
            * @language zh_CN
            * 设置 object 世界位置 x
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalPosition);
                this._vec.x = value;
                this.globalPosition = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalY", {
            /**
            * @language zh_CN
            * 返回 object 世界位置 y
            * @returns object 世界位置 y
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalPosition.y;
            },
            /**
            * @language zh_CN
            * 设置 object 世界位置 y
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalPosition);
                this._vec.y = value;
                this.globalPosition = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalZ", {
            /**
            * @language zh_CN
            * 返回 object 世界位置 z
            * @returns object 世界位置 z
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalPosition.z;
            },
            /**
            * @language zh_CN
            * 设置 object 世界位置 z
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalPosition);
                this._vec.z = value;
                this.globalPosition = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalPosition", {
            /**
            * @language zh_CN
            * 返回 object 世界位置
            * 返回世界坐标系的 全局位置坐标
            * @returns object 世界位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._globalPos;
            },
            /**
            * @language zh_CN
            * 设置 object 世界位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (pos) {
                if (this.parent) {
                    this.parent.globalOrientation.inverse(this._qut);
                    pos.subtract(this.parent.globalPosition, this._vec);
                    this._qut.transformVector(this._vec, this._vec);
                    this._vec.divided(this.parent.globalScale, this._vec);
                    this.position = this._vec;
                }
                else {
                    this.position = pos;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalRotationX", {
            /**
            * @language zh_CN
            * 返回 object 世界旋转x
            * @returns object 世界旋转x
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalRotation.x;
            },
            /**
            * @language zh_CN
            * 设置 object 世界旋转 x
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalRotation);
                this._vec.x = value;
                this.globalRotation = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalRotationY", {
            /**
            * @language zh_CN
            * 返回 object 世界旋转y
            * @returns object 世界旋转y
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalRotation.y;
            },
            /**
            * @language zh_CN
            * 设置 object 世界旋转 y
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalRotation);
                this._vec.y = value;
                this.globalRotation = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalRotationZ", {
            /**
            * @language zh_CN
            * 返回 object 世界旋转z
            * @returns object 世界旋转z
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalRotation.z;
            },
            /**
            * @language zh_CN
            * 设置 object 世界旋转 z
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalRotation);
                this._vec.z = value;
                this.globalRotation = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalRotation", {
            /**
            * @language zh_CN
            * 返回 object 世界旋转
            * 返回世界坐标系的 全局旋转信息
            * @returns object 世界旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._globalRot;
            },
            /**
            * @language zh_CN
            * 设置 object 世界旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (rot) {
                this._qut.fromEulerAngles(rot.x, rot.y, rot.z);
                this.globalOrientation = this._qut;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalScale", {
            /**
            * @language zh_CN
            * 返回 object 世界缩放
            * 返回世界坐标系的 全局缩放信息
            * @returns object 世界缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._globalSca;
            },
            /**
            * @language zh_CN
            * 设置 object 世界缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (sca) {
                if (this.parent) {
                    sca.divided(this.parent.globalScale, this._vec);
                    this.scale = this._vec;
                }
                else {
                    this.scale = sca;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalScaleX", {
            /**
            * @language zh_CN
            * 获取 object 世界缩放 x
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalScale.x;
            },
            /**
            * @language zh_CN
            * 设置 object 世界缩放 x
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalScale);
                this._vec.x = value;
                this.globalScale = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalScaleY", {
            /**
            * @language zh_CN
            * 获取 object 世界缩放 y
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalScale.y;
            },
            /**
            * @language zh_CN
            * 设置 object 世界缩放 y
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalScale);
                this._vec.y = value;
                this.globalScale = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalScaleZ", {
            /**
            * @language zh_CN
            * 获取 object 世界缩放 z
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalScale.z;
            },
            /**
            * @language zh_CN
            * 设置 object 世界缩放 z
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalScale);
                this._vec.z = value;
                this.globalScale = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalOrientation", {
            /**
            * @language zh_CN
            * 返回 object 世界旋转 四元数
            * 返回世界坐标系的 全局旋转信息，数据类型是 四元素
            * @returns object 世界旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._globalOrientation;
            },
            /**
            * @language zh_CN
            * 设置 object 世界旋转 四元数
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (ori) {
                if (this.parent) {
                    this.parent.globalOrientation.inverse(this._qut);
                    this._qut.multiply(this._qut, ori);
                    this.orientation = this._qut;
                }
                else {
                    this.orientation = ori;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 增加一个子对象,并返回当前子对象
        * 在容器中添加子对象，如果有显示接口的，将会放到场景显示树种进行渲染逻辑运算，及渲染
        * @param child 增加的子对象
        * @returns 子对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.addChild = function (child) {
            this.childs.push(child);
            Object3D.renderListChange = true;
            child.parent = this;
            child._isRoot = false;
            child.updateTransformChange(true);
            return child;
        };
        /**
        * @language zh_CN
        * 增加一个子对象,并返回当前子对象
        * 在容器中添加子对象，如果有显示接口的，将会放到场景显示树种进行渲染逻辑运算，及渲染
        * @param child 增加的子对象
        * @param index 子对象的下标
        * @returns 子对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.addChildAt = function (child, index) {
            if (index < 0) {
                this.childs.splice(0, 0, child);
            }
            else if (index >= this.childs.length) {
                this.childs.push(child);
            }
            else {
                this.childs.splice(index, 0, child);
            }
            child.parent = this;
            child.updateTransformChange(true);
            return child;
        };
        /**
        * @language zh_CN
        * 返回下标为index的子对象
        * @private
        * @param index 子对象下标
        * @returns 如果有就返回子对象,否则就返回null.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.getChildAt = function (index) {
            if (index < 0 || index >= this.childs.length)
                return null;
            return this.childs[index];
        };
        /**
        * @language zh_CN
        * @private
        * 返回子对角child的下标
        * @param child 子对象
        * @returns 如果有就返回子对象的下标,否则就返回-1.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.getChildIndex = function (child) {
            for (var index = 0; index < this.childs.length; ++index) {
                if (this.childs[index] != child) {
                    continue;
                }
                return index;
            }
            return -1;
        };
        /**
        * @language zh_CN
        * 移除child子对象 并返回
        * 移除显示列表中的指定对象，如果为空将会返回
        * @param child 子对象
        * @returns Object3D 如果成功就返回child,否则返回null
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.removeChild = function (child) {
            for (var index = 0; index < this.childs.length; ++index) {
                if (this.childs[index] != child) {
                    continue;
                }
                child.parent = null;
                this.childs.splice(index, 1);
                return child;
            }
            child.updateTransformChange(true);
            return null;
        };
        /**
        * @language zh_CN
        * 移除下标为index的子对象 并返回
        * @private
        * @param index 子对象的下标
        * @returns 如果成功就返回child,否则返回null
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.removeChildAt = function (index) {
            if (index < 0 || index >= this.childs.length)
                return null;
            var object3D = this.childs[index];
            object3D.parent = null;
            this.childs.splice(index, 1);
            object3D.updateTransformChange(true);
            return object3D;
        };
        /**
        * @language zh_CN
        * 设置子对象的下标
        * @private
        * @param child 子对象
        * @param index 子对象的下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.setChildIndex = function (child, index) {
            for (var i = 0; i < this.childs.length; ++i) {
                if (this.childs[i] != child) {
                    continue;
                }
                if (i == index) {
                    return;
                }
                else if (index > i) {
                    for (var m = i; m > index; --m) {
                        this.childs[m] = this.childs[m - 1];
                    }
                }
                else if (index < i) {
                    for (var m = i; m < index; ++m) {
                        this.childs[m] = this.childs[m + 1];
                    }
                }
                this.childs[index] = child;
                return;
            }
        };
        /**
        * @language zh_CN
        * @private
        * 交换对象
        * @param other 交换中的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.swapObject = function (other) {
            var parent = other.parent;
            var childs = new Array();
            for (var i = 0; i < other.childs.length; ++i) {
                childs[i] = other.childs[i];
            }
            if (this.parent) {
                var index = this.parent.getChildIndex(this);
                this.parent.childs[index] = other;
            }
            if (other.parent) {
                var index = other.parent.getChildIndex(other);
                other.parent.childs[index] = this;
            }
            other.parent = this.parent;
            this.parent = parent;
            other.childs.length = 0;
            for (var i = 0; i < this.childs.length; ++i) {
                other.childs[i] = this.childs[i];
                other.childs[i].parent = other;
            }
            this.childs.length = 0;
            for (var i = 0; i < childs.length; ++i) {
                this.childs[i] = childs[i];
                this.childs[i].parent = this;
            }
            this.updateTransformChange(true);
            other.updateTransformChange(true);
        };
        /**
        * @language zh_CN
        * @private
        * 交换子对象的位置
        * @param child1 子对象1
        * @param child2 子对象2
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.swapChildren = function (child1, child2) {
            var index1 = 0, index2 = 0;
            for (; index1 < this.childs.length; ++index1) {
                if (this.childs[index1] != child1) {
                    continue;
                }
                for (; index2 < this.childs.length; ++index2) {
                    if (this.childs[index2] != child2) {
                        continue;
                    }
                    var tmp = this.childs[index1];
                    this.childs[index1] = this.childs[index2];
                    this.childs[index2] = tmp;
                    break;
                }
                return;
            }
        };
        /**
        * @language zh_CN
        * @private
        * 交换子对象的位置
        * @param index1 子对象1下标
        * @param index2 子对象2下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.swapChildrenAt = function (index1, index2) {
            if (index1 < 0 || index1 >= this.childs.length)
                return;
            if (index2 < 0 || index2 >= this.childs.length)
                return;
            var tmp = this.childs[index1];
            this.childs[index1] = this.childs[index2];
            this.childs[index2] = tmp;
        };
        /**
        * @language zh_CN
        * 当前对象对视位置
        * @private
        * @param pos 对象的位置
        * @param target 目标的位置
        * @param up 向上的方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.lookAt = function (pos, target, up) {
            if (up === void 0) { up = egret3d.Vector3D.Y_AXIS; }
        };
        Object.defineProperty(Object3D.prototype, "lookAtPosition", {
            /**
            * @language zh_CN
            * 返回目标的位置
            *
            * @private
            * @returns 目标的位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return new egret3d.Vector3D();
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 以Object3D name 来查找Object3D
        * @prame name Object3D名字
        * @returns Object3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.findObject3D = function (name) {
            var object3d = null;
            for (var i = 0; i < this.childs.length; ++i) {
                if (this.childs[i].name == name) {
                    object3d = this.childs[i];
                    return object3d;
                }
                object3d = this.childs[i].findObject3D(name);
                if (object3d) {
                    return object3d;
                }
            }
            return object3d;
        };
        /**
        * @language zh_CN
        * 以Object3D id 来查找Object3D
        * @prame id Object3D id
        * @returns Object3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.findObject3DToID = function (id) {
            var object3d = null;
            for (var i = 0; i < this.childs.length; ++i) {
                if (this.childs[i].id == id) {
                    object3d = this.childs[i];
                    return object3d;
                }
                object3d = this.childs[i].findObject3DToID(id);
                if (object3d) {
                    return object3d;
                }
            }
            return object3d;
        };
        Object3D.prototype.updateTransformChange = function (change) {
            this._transformChange = change;
            ///Octree.getInstance().checkObject3D(obj);
            for (var i = 0; i < this.childs.length; ++i) {
                this.childs[i].updateTransformChange(change);
            }
        };
        /**
        * @language zh_CN
        * 绑定一个属性动画对象
        * @param proAnimation 属性动画对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.bindAnimation = function (proAnimation) {
            this.proAnimation = proAnimation;
            this.proAnimation.bindObject3D(this);
        };
        /**
        * @language zh_CN
        * 当前对象数据更新
        * @private
        * @param camera 当前渲染的摄相机
        * @param time 当前时间
        * @param delay 每帧时间间隔
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.update = function (time, delay, camera) {
            if (this.proAnimation) {
                this.proAnimation.update(delay);
            }
        };
        /**
        * @language zh_CN
        * 返回对象的屏幕坐标
        * 获取当前物体的屏幕坐标值，一般用来指定屏幕相关的ui绑定及其他功能
        * @param camera 对象渲染的摄像机
        * @returns 对象的屏幕坐标
        * @version Egret 3.0
        * @platform Web,Native
        */
        //public getScreenPosition(camera: Camera3D): Vector3D {
        //    this._mat.copyFrom(camera.viewProjectionMatrix);
        //    this._mat.append(this.modelMatrix);
        //    return this._mat.transformVector(Context3DProxy.globalPosition);
        //}
        /**
        * @language zh_CN
        * 释放所有数据
        * 是否内存中的相关数据连接引用，移除逻辑运算，从主渲染刘表中挪出
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.dispose = function () {
            if (this.parent)
                this.parent.removeChild(this);
            //if (this.geometry) {
            //    this.geometry.dispose();
            //    this.geometry = null;
            //}
            //if (this.material) {
            //    this.material.dispose();
            //    this.material = null;
            //}
            for (var i = 0; i < this.childs.length; i++) {
                this.childs[i].dispose();
            }
        };
        /**
         * @private
         * @language zh_CN
         * 当前对象名
         * @version Egret 3.0
         * @platform Web,Native
         */
        Object3D.renderListChange = true;
        Object3D.s_id = 0;
        return Object3D;
    }(egret3d.EventDispatcher));
    egret3d.Object3D = Object3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.IRender
    * @classdesc
    * 场景中的可见物体，可渲染的对象。
    * 在渲染之前会将渲染树中对象进行筛选.
    * 只有IRender对象才会进入渲染管线
    * @see egret3d.Object3D
    * @see egret3d.Geometry
    * @version Egret 3.0
    * @platform Web,Native
    */
    var IRender = (function (_super) {
        __extends(IRender, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function IRender() {
            _super.call(this);
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.multiMaterial = {};
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._materialCount = 0;
            /**
            * @language zh_CN
            * 动作对象，控制骨骼动画。</p>
            * 可拓展的动画功能属性，动画功能的驱动类总接口。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.animation = null;
        }
        IRender.prototype.update = function (time, delay, camera) {
            _super.prototype.update.call(this, time, delay, camera);
        };
        return IRender;
    }(egret3d.Object3D));
    egret3d.IRender = IRender;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.Entity
    * @classdesc
    * 3d空间中的实体对象 extends Object3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Entity = (function (_super) {
        __extends(Entity, _super);
        /**
        * @language zh_CN
        * constructor
        */
        function Entity() {
            _super.call(this);
        }
        return Entity;
    }(egret3d.Object3D));
    egret3d.Entity = Entity;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Mesh
    * @classdesc
    * 3d模型网格 生成渲染模型
    * 创建一个Mesh网格数据和材质数据是必需的，如果是动态模型就加上动画数据
    * 继承Object3D对象，场景中实体渲染对象
    *
    * @see egret3d.Object3D
    * @see egret3d.Geometry
    * @see egret3d.MaterialBase
    * @see egret3d.IAnimation
    * @see egret3d.SkeletonAnimation
    *
    * 示例:
    * @includeExample core/node/Mesh.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Mesh = (function (_super) {
        __extends(Mesh, _super);
        /**
        * @language zh_CN
        * 构建一个Mesh对象
        * @param geometry 模型数据
        * @param material 模型材质
        * @param animation 模型动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Mesh(geometry, material, animation) {
            if (animation === void 0) { animation = null; }
            _super.call(this);
            this.geometry = geometry;
            if (animation) {
                this.animation = animation;
            }
            else {
                if (geometry) {
                    if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_SKIN) {
                        this.animation = new egret3d.SkeletonAnimation(this.geometry.skeleton);
                    }
                }
            }
            this.material = material ? material : new egret3d.TextureMaterial();
            this.addSubMaterial(0, this.material);
            this.bound = this.buildBoundBox();
        }
        /**
        * @private
        */
        Mesh.prototype.setMaterialByID = function () {
        };
        Object.defineProperty(Mesh.prototype, "aabb", {
            /**
            * @private
            */
            get: function () {
                return this._aabbBox;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        */
        Mesh.prototype.initAABB = function () {
            this._aabbBox = new egret3d.QuadAABB();
            var box = this.bound;
            this._aabbBox.maxPosX = box.max.x;
            this._aabbBox.maxPosY = box.max.z;
            this._aabbBox.minPosX = box.min.x;
            this._aabbBox.minPosY = box.min.z;
        };
        Object.defineProperty(Mesh.prototype, "isTriangle", {
            /**
            * @private
            */
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Mesh.prototype.onUpdateTransform = function () {
            this._aabbBox.setOffset(this._pos);
        };
        Object.defineProperty(Mesh.prototype, "lightGroup", {
            /**
            * @language zh_CN
            * 设置材质 lightGroup 。
            * 设置材质球接受的灯光组。
            * @param lightGroup LightGroup
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (lightGroup) {
                this._lightGroup = lightGroup;
                for (var id in this.multiMaterial) {
                    this.multiMaterial[id].lightGroup = this._lightGroup;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 增加一个材质
        * @param id 材质id
        * @param material 模型材质
        * @version Egret 3.0
        * @platform Web,Native
        */
        Mesh.prototype.addSubMaterial = function (id, material) {
            if (!this.multiMaterial[id]) {
                this._materialCount++;
            }
            this.multiMaterial[id] = material;
            material.lightGroup = this._lightGroup;
        };
        /**
        * @language zh_CN
        * 删除一个材质
        * @param id 材质id
        * @version Egret 3.0
        * @platform Web,Native
        */
        Mesh.prototype.removeSubMaterial = function (id) {
            if (this.multiMaterial[id]) {
                delete this.multiMaterial[id];
                this._materialCount--;
            }
        };
        /**
        * @language zh_CN
        * 用ID得到一个材质
        * @param id 材质id
        * @version Egret 3.0
        * @platform Web,Native
        */
        Mesh.prototype.getMaterial = function (id) {
            return this.multiMaterial[id];
        };
        /**
        * @language zh_CN
        * 得到所有材质的个数
        * @returns number
        * @version Egret 3.0
        * @platform Web,Native
        */
        Mesh.prototype.materialCount = function () {
            return this._materialCount;
        };
        /**
        * @language zh_CN
        * 克隆一个模型
        * @returns 克隆后的模型
        * @version Egret 3.0
        * @platform Web,Native
        */
        Mesh.prototype.clone = function () {
            var ani = null;
            if (this.animation) {
                ani = this.animation.clone();
            }
            var cloneMesh = new Mesh(this.geometry, this.material, ani);
            cloneMesh.multiMaterial = this.multiMaterial;
            return cloneMesh;
        };
        /**
        * @language zh_CN
        * 当前对象数据更新，只有在视锥内的对象才会执行此更新
        * @param camera 当前渲染的摄相机
        * @param time 当前时间
        * @param delay 每帧时间间隔
        * @version Egret 3.0
        * @platform Web,Native
        */
        Mesh.prototype.update = function (time, delay, camera) {
            _super.prototype.update.call(this, time, delay, camera);
            if (this.isDisable)
                return;
            if (this.animation) {
                this.animation.update(time, delay, this.geometry);
            }
            if (this.geometry.subGeometrys.length <= 0) {
                this.geometry.buildDefaultSubGeometry();
            }
        };
        /**
        * @language zh_CN
        * @private
        * 生成包围盒
        */
        Mesh.prototype.buildBoundBox = function () {
            if (!this.geometry) {
                return null;
            }
            var bound = new egret3d.BoundBox(this);
            bound.min.copyFrom(new egret3d.Vector3D(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE));
            bound.max.copyFrom(new egret3d.Vector3D(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE));
            for (var i = 0; i < this.geometry.verticesData.length; i += this.geometry.vertexAttLength) {
                if (bound.max.x < this.geometry.verticesData[i]) {
                    bound.max.x = this.geometry.verticesData[i];
                }
                if (bound.max.y < this.geometry.verticesData[i + 1]) {
                    bound.max.y = this.geometry.verticesData[i + 1];
                }
                if (bound.max.z < this.geometry.verticesData[i + 2]) {
                    bound.max.z = this.geometry.verticesData[i + 2];
                }
                if (bound.min.x > this.geometry.verticesData[i]) {
                    bound.min.x = this.geometry.verticesData[i];
                }
                if (bound.min.y > this.geometry.verticesData[i + 1]) {
                    bound.min.y = this.geometry.verticesData[i + 1];
                }
                if (bound.min.z > this.geometry.verticesData[i + 2]) {
                    bound.min.z = this.geometry.verticesData[i + 2];
                }
            }
            bound.fillBox(bound.min, bound.max);
            bound.createChild();
            this.bound = bound;
            this.initAABB();
            return bound;
        };
        return Mesh;
    }(egret3d.IRender));
    egret3d.Mesh = Mesh;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Billboard
     * @classdesc
     * 公告板渲染对象 始终面朝摄像机的面板
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Billboard = (function (_super) {
        __extends(Billboard, _super);
        /**
         * @language zh_CN
         * 指定材质，和公告板宽、高，构建一个公告板
         * @param material 渲染材质
         * @param geometry 几何数据，默认参数为null 为null会在内部创建一个PlaneGeometry
         * @param width 公告板宽度 默认参数为 100
         * @param height 公告板高度 默认参数为 100
         * @version Egret 3.0
         * @platform Web,Native
         */
        function Billboard(material, geometry, width, height) {
            if (geometry === void 0) { geometry = null; }
            if (width === void 0) { width = 100; }
            if (height === void 0) { height = 100; }
            if (geometry == null) {
                geometry = new egret3d.PlaneGeometry(width, height, 1, 1, 1, 1, egret3d.Vector3D.Z_AXIS);
            }
            _super.call(this, geometry, material);
            if (!this.bound) {
                this.bound = this.buildBoundBox();
            }
        }
        /**
        * @language zh_CN
        * 数据更新，不前对象的旋转和摄像机的旋转一致
        * @param camera 当前渲染的摄相机
        * @param time 当前时间
        * @param delay 间隔时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        Billboard.prototype.update = function (time, delay, camera) {
            //this._qut.fromEulerAngles(-90, 0, 0);
            //this._qut.multiply(camera.globalOrientation, this._qut);
            this.globalOrientation = camera.globalOrientation;
        };
        return Billboard;
    }(egret3d.Mesh));
    egret3d.Billboard = Billboard;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Sky
    * @classdesc
    * 场景中天空盒子，是6面体cube，以6张无缝结合的贴图构成.
    *
    * @see egret3d.CubeTexture
    * @see egret3d.CubeTextureMaterial
    *
    * 示例:
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample core/node/Sky.ts
    */
    var Sky = (function (_super) {
        __extends(Sky, _super);
        /**
        * @language zh_CN
        * 构建一个天空盒子对象
        * @param geometry 天空模型数据
        * @param material 天空材质
        * @param camera 天空渲染相机
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Sky(geometry, material, camera) {
            if (camera === void 0) { camera = null; }
            _super.call(this, geometry, material);
            this.camera = camera;
            material.cullMode = egret3d.ContextConfig.FRONT;
            material.ambientColor = 0xffffff;
            if (!this.bound) {
                this.bound = this.buildBoundBox();
            }
        }
        /**
        * @language zh_CN
        * 当前对象数据更新，只有在视锥内的对象才会执行此更新
        * @param camera 当前渲染的摄相机
        * @param time 当前时间
        * @param delay 每帧时间间隔
        * @version Egret 3.0
        * @platform Web,Native
        */
        Sky.prototype.update = function (time, delay, camera) {
            _super.prototype.update.call(this, time, delay, camera);
            if (this.camera) {
                this.position = this.camera.globalPosition;
            }
        };
        return Sky;
    }(egret3d.Mesh));
    egret3d.Sky = Sky;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Wireframe
     * @classdesc
     * 渲染线框 以线的形式渲染顶点。
     * 使用LINES的模式进行渲染。
     * 会使用两个索引来进行渲染一个线段。
     * 实例化一个Wireframe对象之后需要把geometry顶点数据和索引数据填充
     * @see egret3d.Geometry.setVerticesForIndex
     * @see egret3d.Geometry.indexData
     * @see egret3d.Geometry
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Wireframe = (function (_super) {
        __extends(Wireframe, _super);
        /**
         * @language zh_CN
         * @version Egret 3.0
         * @platform Web,Native
         */
        function Wireframe() {
            _super.call(this, new egret3d.Geometry(), new egret3d.ColorMaterial(0xff0000));
            this.material.drawMode = egret3d.DrawMode.LINES;
            this.geometry.vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0;
        }
        return Wireframe;
    }(egret3d.Mesh));
    egret3d.Wireframe = Wireframe;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    *@language zh_CN
    * @class egret3d.LightType
    *灯光类型
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (LightType) {
        /**
        *@language zh_CN
        * 点光源
        * @version Egret 3.0
        * @platform Web,Native
        */
        LightType[LightType["pointlight"] = 0] = "pointlight";
        /**
        *@language zh_CN
        * 平行光
        * @version Egret 3.0
        * @platform Web,Native
        */
        LightType[LightType["directlight"] = 1] = "directlight";
        /**
        *@language zh_CN
        * 聚光灯
        * @version Egret 3.0
        * @platform Web,Native
        */
        LightType[LightType["spotLightlight"] = 2] = "spotLightlight";
    })(egret3d.LightType || (egret3d.LightType = {}));
    var LightType = egret3d.LightType;
    /**
    * @class egret3d.DirectLight
    * @classdesc
    * 灯光的基础类型。</p>
    * 所有的灯光基本要素 灯光的颜色，强度，位置，方向。</p>
    * 颜色的色值均是16进制 red:0xffff0000 argb的定义模式。</p>
    * 每个材质球所能最大使用的灯光建议别太多，能省则省，尤其是移动端，能用灯光缓存图 lightmap 最好。</p>
    * @see egret3d.Object3D
    * @see egret3d.LightGroup
    * @see egret3d.LightBase
    * @see egret3d.PointLight
    * @see egret3d.SpotLight
    * @version Egret 3.0
    * @platform Web,Native
    */
    var LightBase = (function (_super) {
        __extends(LightBase, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function LightBase() {
            _super.call(this);
            /**
           *@language zh_CN
           * 灯光在配置表中的id，用于和贴图建立绑定关系
           * @version Egret 3.0
           * @platform Web,Native
           */
            this.lightId = -1;
            /**
            *@language zh_CN
            * 灯光类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lightType = -1;
            /**
             * @language zh_CN
             *@private
             * 环境颜色
             */
            this._ambient = new egret3d.Vector3D(0.0, 0.0, 0.0);
            /**
             * @language zh_CN
             *@private
             * 漫反射
             */
            this._diffuse = new egret3d.Vector3D(1.0, 1.0, 1.0);
            // /**
            // * @language zh_CN  
            // *@private
            // * 背光颜色
            // */
            //protected _halfColor: Vector3D = new Vector3D(1.0, 1.0, 1.0);
            /**
             * @language zh_CN
             *@private
             * 镜面反射
             */
            this._specular = new egret3d.Vector3D(1.0, 1.0, 1.0);
            /**
             * @language zh_CN
             *@private
             */
            this._halfVector = new egret3d.Vector3D(1.0, 1.0, 1.0);
            /**
             * @language zh_CN
             *@private
             * @param value 强度
             */
            this._intensity = 1;
            this._radius = 100;
            this._falloff = 100;
            /**
            *@language zh_CN
            *@private
            * @param value 背光强度
            */
            this._halfIntensity = 0.0;
            /**
             * @language zh_CN
             *@private
             */
            this._spotExponent = 1.1;
            /**
             * @language zh_CN
             *@private
             */
            this._spotCutoff = 0.7;
            /**
             * @language zh_CN
             *@private
             */
            this._spotCosCutoff = 0.1;
            /**
             * @language zh_CN
             *@private
             */
            this._constantAttenuation = 0.1;
            /**
             * @language zh_CN
             *@private
             */
            this._linearAttenuation = 0.1;
            /**
             * @language zh_CN
             *@private
             */
            this._quadraticAttenuation = 0.1;
            /**
             * @language zh_CN
             *@private
             */
            this._lightIndex = -1;
            /**
             * @language zh_CN
             *@private
             */
            this.len = 25;
            /**
             * @language zh_CN
             *@private
             */
            this._change = true;
            /**
             * @language zh_CN
             *@private
             */
            this.lightViewPos = new egret3d.Vector3D();
        }
        Object.defineProperty(LightBase.prototype, "intensity", {
            /**
            * @language zh_CN
            * 得到灯光强度。</p>
            * 影响灯光的强弱显示，值的范围0~没有上限，但是值过大会导致画面过度曝光。</p>
            * @returns number 灯光强度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._intensity;
            },
            /**
            * @language zh_CN
            * 设置灯光强度。</p>
            * 影响灯光的强弱显示，值的范围0~没有上限，但是值过大会导致画面过度曝光。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._intensity != value) {
                    this._intensity = value;
                    this._change = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "halfIntensity", {
            /**
            * @language zh_CN
            * 得到背光灯光强度。</p>
            * 影响背光灯光的强弱显示，值的范围0~没有上限，但是值过大会导致画面过度曝光。</p>
            * @returns number 背光灯光的强弱
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._halfIntensity;
            },
            /**
            * @language zh_CN
            * 设置背光灯光强度。</p>
            * 影响背光灯光的强弱显示，值的范围0~没有上限，但是值过大会导致画面过度曝光。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._halfIntensity != value) {
                    this._halfIntensity = value;
                    this._change = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "ambient", {
            /**
            * @language zh_CN
            * 获取 灯光环境颜色。</p>
            * 物体在未受到光的直接照射的地方 模拟间接环境光颜色，会影响背光面的颜色。</p>
            * @returns number ambient  灯光环境颜色
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return 0;
            },
            /**
            * @language zh_CN
            * 设置灯光环境颜色。</p>
            * 物体在未受到光的直接照射的地方 模拟间接环境光颜色，会影响背光面的颜色。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this._ambient.w = (color >> 24 & 0xff) / 255;
                this._ambient.x = (color >> 16 & 0xff) / 255;
                this._ambient.y = (color >> 8 & 0xff) / 255;
                this._ambient.z = (color & 0xff) / 255;
                this._change = false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "diffuse", {
            /**
            * @language zh_CN
            * 设置灯光漫反射颜色。</p>
            * 直接影响最终灯光的颜色色值 16进制的颜色 例如 red：0xffff0000。</p>
            * 也可以通过 diffusePower 来改变这个值的总体强弱。</p>
            * @returns number diffuse
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return 0;
            },
            /**
            * @language zh_CN
            * 设置灯光漫反射颜色。</p>
            * 直接影响最终灯光的颜色色值 16进制的颜色, 例如 red：0xffff0000。</p>
            * 也可以通过 diffusePower 来改变这个值的总体强弱
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this._diffuse.w = (color >> 24 & 0xff) / 255;
                this._diffuse.x = (color >> 16 & 0xff) / 255;
                this._diffuse.y = (color >> 8 & 0xff) / 255;
                this._diffuse.z = (color & 0xff) / 255;
                this._change = false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "specular", {
            /**
            * @language zh_CN
            * 在灯光方向与物体和相机成一个反光角度的时候，就会产生反光，高光，而不同的物体会有不同的颜色色值，尤其是金属。</p>
            * 16进制的颜色 例如 red：0xffff0000。</p>
            * 也可以通过 specularPower 来改变这个值的总体强弱。</p>
            * @returns number  灯光镜面高光反射颜色
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return 0;
            },
            /**
            * @language zh_CN
            * 设置灯光镜面高光反射颜色。</p>
            * 在灯光方向与物体和相机成一个反光角度的时候，就会产生反光，高光，而不同的物体会有不同的颜色色值，尤其是金属。</p>
            * 16进制的颜色 例如 red：0xffff0000。</p>
            * 也可以通过 specularPower 来改变这个值的总体强弱。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this._specular.w = (color >> 24 & 0xff) / 255;
                this._specular.x = (color >> 16 & 0xff) / 255;
                this._specular.y = (color >> 8 & 0xff) / 255;
                this._specular.z = (color & 0xff) / 255;
                this._change = false;
            },
            enumerable: true,
            configurable: true
        });
        LightBase.prototype.init = function () {
        };
        /**
         * @language zh_CN
         * @private
         * 更新灯光数据
         * @param index 灯光ID
         * @param lightData 灯光数据
         */
        LightBase.prototype.updateLightData = function (camera, index, lightData) {
        };
        return LightBase;
    }(egret3d.Object3D));
    egret3d.LightBase = LightBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.DirectLight
    * @classdesc
    *
    * 点光源
    * 所有的灯光基本要素 灯光的颜色，强度，位置，方向
    * 颜色的色值均是16进制 red:0xffff0000 argb的定义模式
    * 每个材质球所能最大使用的灯光建议别太多，能省则省，尤其是移动端，能用灯光缓存图 lightmap 最好
    * 点光源是游戏中常常用到的动态光源，实时渲染中，灯光的数量会直接影响渲染性能
    * @see egret3d.Object3D
    * @see egret3d.LightGroup
    * @see egret3d.LightBase
    * @see egret3d.PointLight
    * @see egret3d.SpotLight
    * @includeExample lights/PointLight.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        /**
        * @language zh_CN
        * 创建一个点光源
        * @param color 灯光颜色值
        * @version Egret 3.0
        * @platform Web,Native
        */
        function PointLight(color) {
            _super.call(this);
            this.scenePosMat = new egret3d.Matrix4_4();
            this.lightType = egret3d.LightType.pointlight;
            this.diffuse = color;
        }
        Object.defineProperty(PointLight.prototype, "radius", {
            /**
            * @language zh_CN
            * 获取灯光半径
            * @returns number 灯光半径
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._radius;
            },
            /**
            * @language zh_CN
            * 设置灯光半径
            * @param value 灯光半径
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._radius = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointLight.prototype, "falloff", {
            /**
            * @language zh_CN
            * 获取灯光衰减度
            * @returns number 灯光衰减度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._falloff;
            },
            /**
            * @language zh_CN
            * 设置灯光衰减度
            * @param value 灯光衰减度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._falloff = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * @private
        * 更新灯光数据
        * @param index 灯光ID
        * @param lightData 灯光数据
        */
        PointLight.prototype.updateLightData = function (camera, index, lightData) {
            //this.scenePosMat.identity();
            //this.scenePosMat.copyFrom(this.modelMatrix);
            //this.scenePosMat.multiply(camera.viewMatrix);
            //this.scenePosMat.multiply(camera.projectMatrix);
            //PointLight.scenePos.x = this.globalPosition.x;
            //PointLight.scenePos.y = this.globalPosition.y;
            //PointLight.scenePos.z = this.globalPosition.z;
            //PointLight.scenePos.w = 1.0;
            //this.scenePosMat.transformVector4(PointLight.scenePos, PointLight.scenePos);
            //PointLight.scenePos.x = PointLight.scenePos.x ;
            //PointLight.scenePos.y = PointLight.scenePos.y ;
            //PointLight.scenePos.z = PointLight.scenePos.z ;
            lightData[index * PointLight.stride] = this.globalPosition.x;
            lightData[index * PointLight.stride + 1] = this.globalPosition.y;
            lightData[index * PointLight.stride + 2] = this.globalPosition.z;
            lightData[index * PointLight.stride + 3] = this._diffuse.x * this._intensity;
            lightData[index * PointLight.stride + 4] = this._diffuse.y * this._intensity;
            lightData[index * PointLight.stride + 5] = this._diffuse.z * this._intensity;
            //lightData[index * PointLight.stride + 6] = this._ambient.x;
            //lightData[index * PointLight.stride + 7] = this._ambient.y;
            //lightData[index * PointLight.stride + 8] = this._ambient.z;
            //lightData[index * PointLight.stride + 9] = this._intensity;
            //lightData[index * PointLight.stride + 10] = this._radius;
            //lightData[index * PointLight.stride + 11] = this._falloff;
        };
        PointLight.scenePos = new egret3d.Vector3D();
        /**
         * @language zh_CN
         * @private
         * 点光源的数据长度
         */
        PointLight.stride = 6;
        return PointLight;
    }(egret3d.LightBase));
    egret3d.PointLight = PointLight;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.DirectLight
    * @classdesc
    * spot 的灯光 也就是筒灯
    * 所有的灯光基本要素 灯光的颜色，强度，位置，方向
    * 颜色的色值均是16进制 red:0xffff0000 argb的定义模式
    * 每个材质球所能最大使用的灯光建议别太多，能省则省，尤其是移动端，能用灯光缓存图 lightmap 最好
    * spot light 可以直接想象为点光源照了个罩子，有方向且有范围的灯光
    * @see egret3d.Object3D
    * @see egret3d.LightGroup
    * @see egret3d.LightBase
    * @see egret3d.PointLight
    * @see egret3d.SpotLight
    * @version Egret 3.0
    * @platform Web,Native
    */
    var SpotLight = (function (_super) {
        __extends(SpotLight, _super);
        /**
        * @language zh_CN
        * 创建一个聚光源
        * @param color 灯光颜色值
        * @version Egret 3.0
        * @platform Web,Native
        */
        function SpotLight(color) {
            _super.call(this);
            this.diffuse = color;
            this.lightType = egret3d.LightType.spotLightlight;
        }
        Object.defineProperty(SpotLight.prototype, "spotCosCutoff", {
            /**
            * @language zh_CN
            *
            * spot 的 裁切范围
            * spot light 照射范围的大小指数
            * @returns number Cutoff -spot 的 裁切范围
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._spotCosCutoff;
            },
            /**
            * @language zh_CN
            *
            * spot 的 裁切范围
            * spot light 照射范围的大小指数
            * @param value Cutoff
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._spotCosCutoff = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "spotExponent", {
            /**
            * @language zh_CN
            *
            * spot 的 灯光强弱
            * spot light 灯光圆形范围内随半径大小改变发生的灯光强弱指数
            * @returns number 灯光强弱指数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._spotExponent;
            },
            /**
            * @language zh_CN
            * spot 的 灯光强弱
            * spot light 灯光圆形范围内随半径大小改变发生的灯光强弱指数
            *
            * @param value 灯光强弱指数
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._spotExponent = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "constantAttenuation", {
            /**
            * @language zh_CN
            * spot 的 灯光衰减
            * spot light 灯光圆形范围内随半径大小改变发生的灯光衰减常数指数
            * @returns number 持续衰减
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._constantAttenuation;
            },
            /**
            * @language zh_CN
            *
            * spot 的 灯光衰减
            * spot light 灯光圆形范围内随半径大小改变发生的灯光衰减常数指数
            * @param value 持续衰减
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._constantAttenuation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "linearAttenuation", {
            /**
            * @language zh_CN
            *
            * spot 的 灯光线性衰减
            * spot light 灯光圆形范围内随半径大小改变发生的灯光线性衰减
            * @returns number 线性衰减
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._linearAttenuation;
            },
            /**
            * @language zh_CN
            *
            * spot 的 灯光线性衰减
            * spot light 灯光圆形范围内随半径大小改变发生的灯光线性衰减
            * @param value 线性衰减
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._linearAttenuation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "quadraticAttenuation", {
            /**
            * @language zh_CN
            *
            * spot 的 灯光线性2次衰减
            * spot light 灯光圆形范围内随半径大小改变发生的灯光线性2次衰减
            * @returns number 返回2次衰减
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._quadraticAttenuation;
            },
            /**
            * @language zh_CN
            *
            * spot 的 灯光线性2次衰减
            * spot light 灯光圆形范围内随半径大小改变发生的灯光线性2次衰减
            * @param value 2次衰减
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._quadraticAttenuation = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         * @private
         * 更新灯光数据
         * @param index 灯光ID
         * @param lightData 灯光数据
         */
        SpotLight.prototype.updateLightData = function (camera, index, lightData) {
            lightData[index * SpotLight.stride] = this.globalPosition.x;
            lightData[index * SpotLight.stride + 1] = this.globalPosition.y;
            lightData[index * SpotLight.stride + 2] = this.globalPosition.z;
            lightData[index * SpotLight.stride + 3] = this.globalRotation.x * egret3d.MathUtil.DEGREES_TO_RADIANS;
            lightData[index * SpotLight.stride + 4] = this.globalRotation.y * egret3d.MathUtil.DEGREES_TO_RADIANS;
            lightData[index * SpotLight.stride + 5] = this.globalRotation.z * egret3d.MathUtil.DEGREES_TO_RADIANS;
            lightData[index * SpotLight.stride + 6] = this._diffuse.x;
            lightData[index * SpotLight.stride + 7] = this._diffuse.y;
            lightData[index * SpotLight.stride + 8] = this._diffuse.z;
            lightData[index * SpotLight.stride + 9] = this._spotExponent;
            lightData[index * SpotLight.stride + 10] = this._spotCosCutoff;
            lightData[index * SpotLight.stride + 11] = this._constantAttenuation;
            lightData[index * SpotLight.stride + 12] = this._linearAttenuation;
            lightData[index * SpotLight.stride + 13] = this._quadraticAttenuation;
        };
        /**
         * @language zh_CN
         * @priavete
         */
        SpotLight.stride = 14;
        return SpotLight;
    }(egret3d.LightBase));
    egret3d.SpotLight = SpotLight;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.DirectLight
    * @classdesc
    * 平行灯光</p>
    * 平行光是一种只有方向，强弱度，没有大小范围的灯光，一般情况下，directlight 可以产生阴影;</p>
    * 如果要产生阴影 需要设置 egret3d.ShadowRender.castShadowLight = directLight; 及其他相关模型的设置.</p>
    *
    * @see egret3d.LightGroup
    * @see egret3d.LightBase
    * @see egret3d.PointLight
    * @see egret3d.SpotLight
    * @includeExample lights/DirectLight.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var DirectLight = (function (_super) {
        __extends(DirectLight, _super);
        /**
        * @language zh_CN
        * 创建一个平行光对象
        * @param dir 光线的方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        function DirectLight(dir) {
            _super.call(this);
            dir.normalize();
            this.lightType = egret3d.LightType.directlight;
            this._rot.x = dir.x;
            this._rot.y = dir.y;
            this._rot.z = dir.z;
        }
        Object.defineProperty(DirectLight.prototype, "ambient", {
            /**
            * @language zh_CN
            *
            * 背光颜色
            * 模拟间接光照而开发的背光，而不用去同时打两盏不同方向的组合灯光，可以优化显示效果
            * @param color 背光颜色色值
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this._ambient.w = (color >> 24 & 0xff) / 255;
                this._ambient.x = (color >> 16 & 0xff) / 255;
                this._ambient.y = (color >> 8 & 0xff) / 255;
                this._ambient.z = (color & 0xff) / 255;
                this._change = false;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         *
         * 是否产生阴影
         * 模拟间接光照而开发的背光，而不用去同时打两盏不同方向的组合灯光，可以优化显示效果
         * @param color 背光颜色色值
         */
        //public set castShadow(value: boolean) {
        //if (value )
        //    RttManager.getInstance().shadowMapRender.castShadowLight = this; 
        //}
        /**
         * @language en_US
         * @param index
         * @param lightData
         */
        /**
         * @language zh_CN
         * @private
         * 更新灯光数据
         * @param index 灯光ID
         * @param lightData 灯光数据
         */
        DirectLight.prototype.updateLightData = function (camera, index, lightData) {
            //camera.viewMatrix.mat3TransformVector(this._rot, this.lightViewPos);
            lightData[index * DirectLight.stride + 0] = this._rot.x;
            lightData[index * DirectLight.stride + 1] = this._rot.y;
            lightData[index * DirectLight.stride + 2] = this._rot.z;
            lightData[index * DirectLight.stride + 3] = this._diffuse.x * this._intensity;
            lightData[index * DirectLight.stride + 4] = this._diffuse.y * this._intensity;
            lightData[index * DirectLight.stride + 5] = this._diffuse.z * this._intensity;
            //lightData[index * DirectLight.stride + 6] = this._ambient.x;
            //lightData[index * DirectLight.stride + 7] = this._ambient.y;
            //lightData[index * DirectLight.stride + 8] = this._ambient.z;
            //lightData[index * DirectLight.stride + 9] = this._intensity;
            //lightData[index * DirectLight.stride + 10] = this._halfIntensity;
        };
        /**
        * @language zh_CN
        * @private
        * 光源数据结构长度
        */
        DirectLight.stride = 6;
        return DirectLight;
    }(egret3d.LightBase));
    egret3d.DirectLight = DirectLight;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @class egret3d.DirectLight
   * @classdesc
   *
   * 灯光组。</p>
   * 把需要使用的灯光，放入一个组里面，然后给材质进行渲染。
   * @see egret3d.Object3D
   * @see egret3d.LightBase
   * @see egret3d.PointLight
   * @see egret3d.SpotLight
   * @version Egret 3.0
   * @platform Web,Native
   */
    var LightGroup = (function () {
        /**
        * @language zh_CN
        * 创建一个灯光组
        * @version Egret 3.0
        * @platform Web,Native
        */
        function LightGroup() {
            /**
            * @language zh_CN
            * 灯光个数
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lightNum = 0;
            this.directLightList = new Array();
            this.spotLightList = new Array();
            this.pointLightList = new Array();
        }
        /**
        * @language zh_CN
        * 为灯光组,添加一个灯光
        * @param light Light
        * @version Egret 3.0
        * @platform Web,Native
        */
        LightGroup.prototype.addLight = function (light) {
            switch (light.lightType) {
                case egret3d.LightType.directlight:
                    this.directLightList.push(light);
                    this.lightNum++;
                    break;
                case egret3d.LightType.pointlight:
                    this.pointLightList.push(light);
                    this.lightNum++;
                    break;
                case egret3d.LightType.spotLightlight:
                    this.spotLightList.push(light);
                    this.lightNum++;
                    break;
            }
        };
        /**
        * @private
        * @language zh_CN
        * 删除一个灯光
        * @param light Light
        * @version Egret 3.0
        * @platform Web,Native
        */
        LightGroup.prototype.removeLight = function (light) {
            switch (light.lightType) {
                case egret3d.LightType.directlight:
                    var index = this.directLightList.indexOf(light);
                    if (index >= 0 && index < this.directLightList.length) {
                        this.directLightList.splice(index, 1);
                        this.lightNum--;
                    }
                    break;
                case egret3d.LightType.pointlight:
                    var index = this.pointLightList.indexOf(light);
                    if (index >= 0 && index < this.pointLightList.length) {
                        this.pointLightList.splice(index, 1);
                        this.lightNum--;
                    }
                    break;
                case egret3d.LightType.spotLightlight:
                    var index = this.spotLightList.indexOf(light);
                    if (index >= 0 && index < this.spotLightList.length) {
                        this.spotLightList.splice(index, 1);
                        this.lightNum--;
                    }
                    break;
            }
        };
        return LightGroup;
    }());
    egret3d.LightGroup = LightGroup;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.CollectBase
    * @classdesc
    * @version Egret 3.0
    * @platform Web,Native
    * Object3D 渲染对象收集器基类
    */
    var CollectBase = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param root 渲染根节点
        */
        function CollectBase() {
            this._num = 0;
            this._objDict = {};
            this.renderList = new Array();
            this.mousePickList = new Array();
            this._nodes = new Array();
        }
        Object.defineProperty(CollectBase.prototype, "root", {
            get: function () {
                return this.rootScene;
            },
            set: function (rootScene) {
                this.rootScene = rootScene;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 数据更新
        * @param camera 当前摄像机
        */
        CollectBase.prototype.update = function (camera) {
            this.renderList = this._nodes;
            this.renderList.length = 0;
            camera.frustum.update(camera);
        };
        /**
        * @language zh_CN
        * 查找一个对象在渲染列表的下标
        * @param obj 要查找的对象
        * @returns 返回对象在渲染列表的下标
        */
        CollectBase.prototype.findRenderObject = function (obj) {
            for (var i = 0; i < this.renderList.length; ++i) {
                if (this.renderList[i] === obj) {
                    return i;
                }
            }
            return -1;
        };
        return CollectBase;
    }());
    egret3d.CollectBase = CollectBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.EntityCollect
    * @classdesc
    * Object3D 渲染对象收集器,把渲染对象进行可视筛选，
    * 并且划分渲染层级，依次排序到加入列表.
    *
    * @see egret3d.Scene3D
    * @see egret3d.View3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EntityCollect = (function (_super) {
        __extends(EntityCollect, _super);
        /**
        * @language zh_CN
        * constructor
        * @param root 渲染根节点
        * @version Egret 3.0
        * @platform Web,Native
        */
        function EntityCollect() {
            _super.call(this);
            this._normalRenderItems = [];
            this._alphaRenderItems = [];
        }
        EntityCollect.prototype.applyRender = function (child, camera) {
            if (!child.visible) {
                return;
            }
            if (child["material"])
                this.addRenderList(child, camera);
            for (var i = 0; i < child.childs.length; i++) {
                this.applyRender(child.childs[i], camera);
            }
        };
        /**
        * @language zh_CN
        * 尝试将一个渲染对象，进行视锥体裁剪，放入到渲染队列中
        * @param root 渲染根节点
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.addRenderList = function (renderItem, camera) {
            if (renderItem.enableCulling) {
                if (!camera.isVisibleToCamera(renderItem)) {
                    return;
                }
            }
            if (renderItem.material != null && renderItem.material.materialData.alphaBlending) {
                //layer.alphaObjects.push(renderItem);
                this._alphaRenderItems.push(renderItem);
            }
            else {
                this._normalRenderItems.push(renderItem);
            }
            if (renderItem.enablePick) {
                this.mousePickList.push(renderItem);
            }
            //var layer: Layer = this.findLayer(renderItem);
            //var tag: Tag = this.findTag(renderItem);
            //if (renderItem.material != null && renderItem.material.materialData.alphaBlending) {
            //    //layer.alphaObjects.push(renderItem);
            //    this._alphaRenderItems.push(renderItem);
            //}
            //else {
            //    this._normalRenderItems.push(renderItem);
            //}
        };
        /**
        * @language zh_CN
        * 数据更新 处理需要渲染的对象
        * @param camera 当前摄像机
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.update = function (camera) {
            _super.prototype.update.call(this, camera);
            this._normalRenderItems.length = 0;
            this._alphaRenderItems.length = 0;
            this.renderList.length = 0;
            this.mousePickList.length = 0;
            this.clearLayerList();
            if (this.rootScene.quad) {
                var box = camera.frustum.box;
                var quadList = this.rootScene.quad.getNodesByAABB(box.min.x, box.min.z, box.max.x, box.max.z);
                //var time3: number = new Date().getTime();
                this.appendQuadList(quadList, camera);
            }
            else {
                this.applyRender(this.rootScene.root, camera);
            }
            for (var i = 0; i < this._normalRenderItems.length; ++i) {
                this.renderList.push(this._normalRenderItems[i]);
            }
            for (var i = 0; i < this._alphaRenderItems.length; ++i) {
                this.renderList.push(this._alphaRenderItems[i]);
            }
            //for (var i: number = 0; i < this._layerTags.length; ++i) {
            //    this._layerTags[i].clearDepth = true;
            //    for (var j: number = 0; j < this._layerTags[i].layers.length; ++j) {
            //        for (var k: number = 0; k < this._layerTags[i].layers[j].objects.length; ++k) {
            //            this.renderList.push(this._layerTags[i].layers[j].objects[k]);
            //        }
            //        this._layerTags[i].layers[j].alphaObjects.sort((a: Object3D, b: Object3D) => this.sort(a, b, camera));
            //        for (var k: number = 0; k < this._layerTags[i].layers[j].alphaObjects.length; ++k) {
            //            this.renderList.push(this._layerTags[i].layers[j].alphaObjects[k]);
            //        }
            //    }
            //}
        };
        /**
        * @language zh_CN
        * 根据当前场景的节点分布情况，生成四叉树
        * @version Egret 3.0
        * @param quadList   需要被判定是否在视锥体里的节点列表
        * @param camera     相机
        * @platform Web,Native
        */
        EntityCollect.prototype.appendQuadList = function (quadList, camera) {
            var mesh;
            var node;
            for (var _i = 0, quadList_1 = quadList; _i < quadList_1.length; _i++) {
                node = quadList_1[_i];
                if (!(node instanceof egret3d.Mesh))
                    continue;
                mesh = node;
                if (mesh && mesh.visible && mesh["material"])
                    this.addRenderList(mesh, camera);
            }
        };
        //protected findLayer(object3d: Object3D): Layer {
        //    var typeIndex: number = object3d.layer >> 24;
        //    var layerIndex: number = object3d.layer & 0x00FFFFFF;
        //    if (typeIndex < this._tags.length && typeIndex >= 0) {
        //        if (layerIndex < this._tags[typeIndex].layers.length && layerIndex >= 0) {
        //            return this._tags[typeIndex].layers[layerIndex];
        //        }
        //    }
        //    return this._tags[0].layers[0];
        //}
        //protected findTag(object3d: Object3D): Tag {
        //    var typeIndex: number = object3d.layer >> 24;
        //    if (typeIndex < this._tags.length && typeIndex >= 0) {
        //        return this._tags[typeIndex];
        //    }
        //    return this._tags[0];
        //}
        EntityCollect.prototype.clearLayerList = function () {
            //for (var i: number = 0; i < this._tags.length; ++i) {
            //    for (var j: number = 0; j < this._tags[i].layers.length; ++j) {
            //        this._tags[i].layers[j].objects.length = 0;
            //        this._tags[i].layers[j].alphaObjects.length = 0;
            //    }
            //}
        };
        EntityCollect.prototype.sort = function (a, b, camera) {
            var dis_0 = egret3d.Vector3D.distance(a.globalPosition, camera.position);
            var dis_1 = egret3d.Vector3D.distance(b.globalPosition, camera.position);
            if (dis_0 > dis_1) {
                return -1;
            }
            else if (dis_0 < dis_1) {
                return 1;
            }
            return 0;
        };
        return EntityCollect;
    }(egret3d.CollectBase));
    egret3d.EntityCollect = EntityCollect;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.Frustum
    * @classdesc
    * 摄像机视椎体,计算出摄像机的可视范围.
    *
    * @see egret3d.Camera3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Frustum = (function () {
        /**
        * @language zh_CN
        * 构造
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Frustum() {
            this._vtxNum = 8;
            this._planeNum = 6;
            this._vertex = new Array();
            for (var i = 0; i < this._vtxNum; ++i) {
                this._vertex.push(new egret3d.Vector3D());
            }
            this._pos = new egret3d.Vector3D();
            this._plane = new Array();
            for (var i = 0; i < 6; ++i) {
                this._plane.push(new egret3d.Plane3D());
            }
            this.box = new egret3d.BoundBox(null, new egret3d.Vector3D(), new egret3d.Vector3D());
            ///this.box = new CubeBoxBound(new Vector3D(99999.0, 99999.0, 99999.0), new Vector3D(-99999.0, -99999.0, -99999.0));
            this.center = new egret3d.Vector3D();
        }
        /**
        * @language zh_CN
        * 生成一个视椎体
        * @param fovY 观察时y 轴方向的角度，就是观察范围夹角。
        * @param aspectRatio 纵横比，在视空间宽度除以高度.
        * @param nearPlane 近裁剪面位置Z值.
        * @param farPlane 远裁剪面位置Z值.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.makeFrustum = function (fovY, aspectRatio, nearPlane, farPlane) {
            ///var tangent: number = Math.tan(fovY / 2.0 * (Math.PI / 180.0));
            var tangent = Math.tan(fovY / 2.0 * (Math.PI / 180.0));
            var nearHeight = nearPlane * tangent;
            var nearWidth = nearHeight * aspectRatio;
            var farHeight = farPlane * tangent;
            var farWidth = farHeight * aspectRatio;
            /// near top right
            this._vertex[0].x = nearWidth;
            this._vertex[0].y = nearHeight;
            this._vertex[0].z = nearPlane;
            /// near top left
            this._vertex[1].x = -nearWidth;
            this._vertex[1].y = nearHeight;
            this._vertex[1].z = nearPlane;
            /// near bottom left
            this._vertex[2].x = -nearWidth;
            this._vertex[2].y = -nearHeight;
            this._vertex[2].z = nearPlane;
            /// near bottom right
            this._vertex[3].x = nearWidth;
            this._vertex[3].y = -nearHeight;
            this._vertex[3].z = nearPlane;
            /// far top right
            this._vertex[4].x = farWidth;
            this._vertex[4].y = farHeight;
            this._vertex[4].z = farPlane;
            /// far top left
            this._vertex[5].x = -farWidth;
            this._vertex[5].y = farHeight;
            this._vertex[5].z = farPlane;
            /// far bottom left
            this._vertex[6].x = -farWidth;
            this._vertex[6].y = -farHeight;
            this._vertex[6].z = farPlane;
            /// far bottom right
            this._vertex[7].x = farWidth;
            this._vertex[7].y = -farHeight;
            this._vertex[7].z = farPlane;
        };
        /**
        * @language zh_CN
        * 数据更新.
        * @param camera 视椎的摄像机.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.update = function (camera) {
            this.makeFrustum(camera.fieldOfView, camera.aspectRatio, camera.near, camera.far);
            /// 摄像机变化之后的顶点也变化;
            var vtx = new Array();
            var mat = new egret3d.Matrix4_4();
            mat.copyFrom(camera.modelMatrix);
            ///mat.invert(); /// 眼睛的世界矩阵;
            this._curVer = vtx;
            for (var i = 0; i < this._vtxNum; ++i) {
                vtx.push(mat.transformVector(this._vertex[i]));
            }
            this.box.max.x = this.box.max.y = this.box.max.z = -Number.MAX_VALUE;
            this.box.min.x = this.box.min.y = this.box.min.z = Number.MAX_VALUE;
            for (var i = 0; i < vtx.length; ++i) {
                if (this.box.max.x < vtx[i].x) {
                    this.box.max.x = vtx[i].x;
                }
                if (this.box.max.y < vtx[i].y) {
                    this.box.max.y = vtx[i].y;
                }
                if (this.box.max.z < vtx[i].z) {
                    this.box.max.z = vtx[i].z;
                }
                if (this.box.min.x > vtx[i].x) {
                    this.box.min.x = vtx[i].x;
                }
                if (this.box.min.y > vtx[i].y) {
                    this.box.min.y = vtx[i].y;
                }
                if (this.box.min.z > vtx[i].z) {
                    this.box.min.z = vtx[i].z;
                }
            }
            this.box.calculateBox();
            this._plane[0].fromPoints(vtx[4], vtx[5], vtx[6]); /// 远平面(far);
            this._plane[1].fromPoints(vtx[1], vtx[6], vtx[5]); /// 左平面(left);
            this._plane[2].fromPoints(vtx[0], vtx[4], vtx[7]); /// 右平面(right);
            this._plane[3].fromPoints(vtx[1], vtx[0], vtx[3]); /// 近平面(near);
            this._plane[4].fromPoints(vtx[1], vtx[5], vtx[4]); /// 上平面(top);
            this._plane[5].fromPoints(vtx[3], vtx[7], vtx[6]); /// 下平面(bottom);
            for (var i = 0; i < this._planeNum; i++) {
                this._plane[i].normalize();
            }
            var nearCenter = new egret3d.Vector3D();
            nearCenter.copyFrom(vtx[0].subtract(vtx[2]));
            nearCenter.scaleBy(0.5);
            nearCenter.copyFrom(vtx[2].add(nearCenter));
            var farCenter = new egret3d.Vector3D();
            farCenter.copyFrom(vtx[4].subtract(vtx[6]));
            farCenter.scaleBy(0.5);
            farCenter.copyFrom(vtx[6].add(farCenter));
            this.center.copyFrom(farCenter.subtract(nearCenter));
            this.center.scaleBy(0.5);
            this.center.copyFrom(nearCenter.add(this.center));
        };
        /**
        * @language zh_CN
        * 检测一个坐标点是否在视椎体内
        * @param pos 检测的坐标
        * @returns 在视椎内返回ture
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.inPoint = function (pos) {
            var dis = 0;
            for (var i = 0; i < this._plane.length; ++i) {
                dis = this._plane[i].distance(pos);
                if (dis > 0.0) {
                    return false;
                }
            }
            return true;
        };
        /**
        * @language zh_CN
        * 检测一个球是否在视椎体内
        * @param center 球的坐标
        * @param radius 球的半径
        * @returns 在视椎内返回ture
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.inSphere = function (center, radius) {
            var dis = 0;
            for (var i = 0; i < this._plane.length; ++i) {
                dis = this._plane[i].distance(center);
                if (dis > radius) {
                    return false;
                }
            }
            return true;
        };
        /**
        * @language zh_CN
        * 检测一个盒子是否在视椎体内
        * @param box 盒子
        * @returns 在视椎内返回ture
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.inBox = function (box) {
            var v = new Array();
            var dis = 0;
            var temp = new egret3d.Vector3D();
            for (var i = 0; i < this._plane.length; ++i) {
                var incount = box.vexData.length / 3;
                for (var j = 0; j < box.vexData.length; j += 3) {
                    temp.setTo(box.vexData[j], box.vexData[j + 1], box.vexData[j + 2]);
                    temp.copyFrom(box.transform.transformVector(temp));
                    dis = this._plane[i].distance(temp);
                    if (dis > 0) {
                        incount--;
                    }
                }
                if (incount <= 0) {
                    return false;
                }
            }
            return true;
        };
        return Frustum;
    }());
    egret3d.Frustum = Frustum;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.Layer
    * @classdesc
    * Object3D 渲染Layer
    * 每个Layer分两个渲染列表，一个是有alpha的对象列表，另一个是没有alpha的对象列表
    * 不同的Layer层级可以使用不同的渲染方式，来达到各组不同的渲染效果.
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Layer = (function () {
        function Layer() {
            /**
            * @language zh_CN
            * 是否清理深度
            */
            this.clearDepth = false;
            /**
            * @language zh_CN
            * 层级清理深度状态
            */
            this.cleanState = true;
        }
        return Layer;
    }());
    egret3d.Layer = Layer;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.Tag
    * @classdesc
    * Object3D 渲染tag
    * 图形属性标签页的属性，由layer列表组成，共用深度信息
    * 渲染每个tag他们的深度信息是不清理的
    *
    * @see egret3d.Layer
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Tag = (function () {
        function Tag() {
            /**
           * @language zh_CN
           * 没有alpha的对象列表
           */
            this.objects = new Array();
            /**
             * @language zh_CN
             * layer 列表
             */
            this.layers = new Array();
            /**
            * @language zh_CN
            * 有alpha的对象列表
            */
            this.alphaObjects = new Array();
            this.clearDepth = false;
        }
        return Tag;
    }());
    egret3d.Tag = Tag;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Picker
    * @classdesc
    * 射线对场景中的实体对像进行检测。</p>
    * 以摄像机向场景中产生的一条射线对所有场景中的对象进行拾取。</p>
    * 根据性能的需要分为几种拣选类型。</p>
    * 1.包围盒拣选。</p>
    * 2.模型拣选返回模型拣选到的位置。</p>
    * 3.模型拣选返回模型拣选到的UV坐标。</p>
    *
    * @see egret3d.Ray
    * @see egret3d.PickType
    *
    * 示例:鼠标拣选模型,拣选到的进行绕Y轴旋转
    * @includeExample core/traverse/Picker.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Picker = (function () {
        function Picker() {
        }
        /**
        * @language zh_CN
        * 返回鼠标拾取对象得到的所有对象,调用之前到设置被拣选对象的pickType.
        * @param canvas 当前canvas
        * @param view 当前检测view
        * @param objects 检测的对象列表
        * @param childBox 检测是否用子包围盒 默认false就可以了
        * @returns 拾取的object列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        Picker.pickObject3DList = function (canvas, view, objects, childBox, target) {
            if (childBox === void 0) { childBox = false; }
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Array();
            }
            target.length = 0;
            var ray = this.ray;
            if (egret3d.Input.mouseX < view.x || egret3d.Input.mouseX > x + view.width || egret3d.Input.mouseY < view.y || egret3d.Input.mouseY > y + view.height) {
                return target;
            }
            var x = egret3d.Input.mouseX - view.x;
            var y = egret3d.Input.mouseY - view.y;
            ray.CalculateAndTransformRay(view.width, view.height, view.camera3D.modelMatrix, view.camera3D.projectMatrix, x, y);
            for (var i = 0; i < objects.length; ++i) {
                var renderItem = objects[i];
                var inPos = new egret3d.Vector3D();
                switch (renderItem.pickType) {
                    case egret3d.PickType.BoundPick:
                        if (renderItem.bound != null) {
                            var bound = renderItem.bound;
                            if (childBox) {
                                bound = renderItem.currentBound;
                                if (bound) {
                                    if (ray.IntersectMesh(bound.vexData, bound.indexData, bound.vexLength, bound.indexData.length / 3, 0, renderItem.modelMatrix, renderItem.pickResult)) {
                                        target.push(objects[i]);
                                    }
                                }
                            }
                            else {
                                if (ray.IntersectMesh(bound.vexData, bound.indexData, bound.vexLength, bound.indexData.length / 3, 0, renderItem.modelMatrix, renderItem.pickResult)) {
                                    target.push(objects[i]);
                                }
                            }
                        }
                        break;
                    case egret3d.PickType.PositionPick:
                        var uvoffset = 0;
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_POSITION) {
                            uvoffset += egret3d.Geometry.positionSize;
                        }
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_NORMAL) {
                            uvoffset += egret3d.Geometry.normalSize;
                        }
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_TANGENT) {
                            uvoffset += egret3d.Geometry.tangentSize;
                        }
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_COLOR) {
                            uvoffset += egret3d.Geometry.colorSize;
                        }
                        if (ray.IntersectMeshEx(renderItem, uvoffset, renderItem.pickResult)) {
                            target.push(objects[i]);
                        }
                        break;
                    case egret3d.PickType.UVPick:
                        var uvoffset = 0;
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_POSITION) {
                            uvoffset += egret3d.Geometry.positionSize;
                        }
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_NORMAL) {
                            uvoffset += egret3d.Geometry.normalSize;
                        }
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_TANGENT) {
                            uvoffset += egret3d.Geometry.tangentSize;
                        }
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_COLOR) {
                            uvoffset += egret3d.Geometry.colorSize;
                        }
                        if (ray.IntersectMeshEx(renderItem, uvoffset, renderItem.pickResult)) {
                            target.push(objects[i]);
                        }
                        break;
                }
            }
            return target;
        };
        Picker.ray = new egret3d.Ray();
        return Picker;
    }());
    egret3d.Picker = Picker;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.GeometryType
     * @classdesc
     * @version Egret 3.0
     * @platform Web,Native
     */
    (function (GeometryType) {
        GeometryType[GeometryType["normal_geometry"] = 0] = "normal_geometry";
        GeometryType[GeometryType["skin_geometry"] = 1] = "skin_geometry";
        GeometryType[GeometryType["particle_geometry"] = 2] = "particle_geometry";
    })(egret3d.GeometryType || (egret3d.GeometryType = {}));
    var GeometryType = egret3d.GeometryType;
    /**
     * @language zh_CN
     * @class egret3d.VertexFormat
     * @classdesc
     * 顶点数据格式类型 是由2进制组成 一个顶点可以由多个类型组成
     * @version Egret 3.0
     * @platform Web,Native
     */
    (function (VertexFormat) {
        /**
         * @private
         * @language zh_CN
         * 顶点坐标
         * @version Egret 3.0
         * @platform Web,Native
         */
        VertexFormat[VertexFormat["VF_POSITION"] = 1] = "VF_POSITION";
        /**
         * @private
         * @language zh_CN
         * 顶点法线
         * @version Egret 3.0
         * @platform Web,Native
         */
        VertexFormat[VertexFormat["VF_NORMAL"] = 2] = "VF_NORMAL";
        /**
         * @private
         * @language zh_CN
         * 顶点切线
         * @version Egret 3.0
         * @platform Web,Native
         */
        VertexFormat[VertexFormat["VF_TANGENT"] = 4] = "VF_TANGENT";
        /**
         * @private
         * @language zh_CN
         * 顶点颜色
         * @version Egret 3.0
         * @platform Web,Native
         */
        VertexFormat[VertexFormat["VF_COLOR"] = 8] = "VF_COLOR";
        /**
         * @private
         * @language zh_CN
         * 顶点uv
         * @version Egret 3.0
         * @platform Web,Native
         */
        VertexFormat[VertexFormat["VF_UV0"] = 16] = "VF_UV0";
        /**
         * @private
         * @language zh_CN
         * 顶点第二uv
         * @version Egret 3.0
         * @platform Web,Native
         */
        VertexFormat[VertexFormat["VF_UV1"] = 32] = "VF_UV1";
        /**
         * @private
         * @language zh_CN
         * 顶点蒙皮信息
         * @version Egret 3.0
         * @platform Web,Native
         */
        VertexFormat[VertexFormat["VF_SKIN"] = 64] = "VF_SKIN";
    })(egret3d.VertexFormat || (egret3d.VertexFormat = {}));
    var VertexFormat = egret3d.VertexFormat;
    /**
     * @language zh_CN
     * @class egret3d.Geometry
     * @classdesc
     * 表示几何形状 子集
     * @see egret3d.VertexBuffer3D
     * @see egret3d.IndexBuffer3D
     * @see egret3d.SubGeometry
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Geometry = (function () {
        function Geometry() {
            /**
             * @language zh_CN
             * 模型的类别，是属于 静态模型，还是蒙皮动画模型，还是粒子模型，还是 特定模型
             *
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.geomtryType = -1;
            /**
            * @language zh_CN
            * 顶点格式
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._vertexFormat = 0;
            /**
            * @language zh_CN
            * 顶点属性长度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.vertexAttLength = 0;
            /**
            * @language zh_CN
            * 顶点数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.verticesData = new Array();
            /**
            * @language zh_CN
            * 索引数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.indexData = new Array();
            /**
            * @private
            * @language zh_CN
            * 顶点坐标数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.source_positionData = new Array();
            /**
            * @private
            * @language zh_CN
            * 顶点法线数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.source_normalData = new Array();
            /**
            * @private
            * @language zh_CN
            * 顶点切线数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.source_tangentData = new Array();
            /**
            * @private
            * @language zh_CN
            * 顶点颜色数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.source_colorData = new Array();
            /**
            * @private
            * @language zh_CN
            * 顶点uv数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.source_uvData = new Array();
            /**
            * @private
            * @language zh_CN
            * 顶点第二uv数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.source_uv2Data = new Array();
            /**
            * @private
            * @language zh_CN
            * 顶点第二uv数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.source_SkinData = new Array();
            /**
            * @language zh_CN
            * 面翻转，仅对系统 geometry 有效
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.faceOrBack = false;
            /**
            * @language zh_CN
            * geometry子集
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.subGeometrys = new Array();
            /**
            * @language zh_CN
            * @private
            * buffer 需要重新提交的时候
            */
            this._bufferDiry = true;
            this._vertexCount = -1;
        }
        Object.defineProperty(Geometry.prototype, "vertexCount", {
            /**
            * @language zh_CN
            * 得到顶点的数量
            * @returns number 顶点的数量
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._vertexCount < 0) {
                    this._vertexCount = this.verticesData.length / this.vertexAttLength;
                }
                return this._vertexCount;
            },
            /**
            * @language zh_CN
            * 设置顶点的数量
            * @param value 顶点的数量
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vertexCount = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * @private
        */
        Geometry.prototype.buildDefaultSubGeometry = function () {
            var subGeometry = new egret3d.SubGeometry();
            subGeometry.matID = 0;
            subGeometry.geometry = this;
            subGeometry.start = 0;
            subGeometry.count = this.indexData ? this.indexData.length : 0;
            this.subGeometrys.push(subGeometry);
        };
        Object.defineProperty(Geometry.prototype, "vertexFormat", {
            /**
            * @language zh_CN
            * 获取顶点格式
            * @returns number 顶点格式
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._vertexFormat;
            },
            /**
            * @language zh_CN
            * 使用和定义顶点的数据结构
            *<p>例如 vertexFormat( VertexFormat.VF_POSITION )
            *设置这样的定义后,就会增加这样的数据顶点数据结构，
            *如果源文件中没有这样的数据结构，
            *就会通过计算的方式计算补全，
            *不能计算的就默认为0
            *@param vertexFormat 需要定义的顶点格式类型 VertexFormat.VF_COLOR | VertexFormat.VF_UV1
            * this.useVertexFormat( VertexFormat.VF_POSITION | VertexFormat.VF_NORMAL | VertexFormat.VF_COLOR |  VertexFormat.VF_UV0 | VertexFormat.VF_UV1 );//定义了一个完整的数据结构
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (vertexFormat) {
                this._vertexFormat = vertexFormat;
                if (this.vertexFormat & VertexFormat.VF_POSITION) {
                    this.vertexAttLength += Geometry.positionSize;
                }
                if (this.vertexFormat & VertexFormat.VF_NORMAL) {
                    this.vertexAttLength += Geometry.normalSize;
                }
                if (this.vertexFormat & VertexFormat.VF_TANGENT) {
                    this.vertexAttLength += Geometry.tangentSize;
                }
                if (this.vertexFormat & VertexFormat.VF_COLOR) {
                    this.vertexAttLength += Geometry.colorSize;
                }
                if (this.vertexFormat & VertexFormat.VF_UV0) {
                    this.vertexAttLength += Geometry.uvSize;
                }
                if (this.vertexFormat & VertexFormat.VF_UV1) {
                    this.vertexAttLength += Geometry.uv2Size;
                }
                if (this.vertexFormat & VertexFormat.VF_SKIN) {
                    this.vertexAttLength += Geometry.skinSize;
                }
                this.vertexSizeInBytes = this.vertexAttLength * 4;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * 根据顶点格式生成顶点buffer
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.prototype.calculateVertexFormat = function () {
            this.vertexCount = this.source_positionData.length / Geometry.positionSize;
            for (var i = 0; i < this.vertexCount; ++i) {
                if (this.vertexFormat & VertexFormat.VF_POSITION) {
                    this.verticesData.push(this.source_positionData[i * Geometry.positionSize]);
                    this.verticesData.push(this.source_positionData[i * Geometry.positionSize + 1]);
                    this.verticesData.push(this.source_positionData[i * Geometry.positionSize + 2]);
                }
                if (this.vertexFormat & VertexFormat.VF_NORMAL) {
                    this.verticesData.push(this.source_normalData[i * Geometry.normalSize]);
                    this.verticesData.push(this.source_normalData[i * Geometry.normalSize + 1]);
                    this.verticesData.push(this.source_normalData[i * Geometry.normalSize + 2]);
                }
                if (this.vertexFormat & VertexFormat.VF_TANGENT) {
                    this.verticesData.push(this.source_tangentData[i * Geometry.tangentSize]);
                    this.verticesData.push(this.source_tangentData[i * Geometry.tangentSize + 1]);
                    this.verticesData.push(this.source_tangentData[i * Geometry.tangentSize + 2]);
                }
                if (this.vertexFormat & VertexFormat.VF_COLOR) {
                    this.verticesData.push(this.source_colorData[i * Geometry.colorSize]);
                    this.verticesData.push(this.source_colorData[i * Geometry.colorSize + 1]);
                    this.verticesData.push(this.source_colorData[i * Geometry.colorSize + 2]);
                    this.verticesData.push(this.source_colorData[i * Geometry.colorSize + 3]);
                }
                if (this.vertexFormat & VertexFormat.VF_UV0) {
                    this.verticesData.push(this.source_uvData[i * Geometry.uvSize]);
                    this.verticesData.push(this.source_uvData[i * Geometry.uvSize + 1]);
                }
                if (this.vertexFormat & VertexFormat.VF_UV1) {
                    this.verticesData.push(this.source_uv2Data[i * Geometry.uv2Size]);
                    this.verticesData.push(this.source_uv2Data[i * Geometry.uv2Size + 1]);
                }
                if (this.vertexFormat & VertexFormat.VF_SKIN) {
                    for (var j = 0; j < Geometry.skinSize; ++j) {
                        this.verticesData.push(this.source_SkinData[i * Geometry.skinSize + j]);
                    }
                }
            }
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.prototype.activeState = function (time, delay, context3DProxy, camera3D) {
            if (this._bufferDiry) {
                this._bufferDiry = false;
                this.upload(context3DProxy);
            }
            context3DProxy.bindVertexBuffer(this.sharedVertexBuffer);
            context3DProxy.bindIndexBuffer(this.sharedIndexBuffer);
        };
        /**
        * @language zh_CN
        * 提交顶点数据 如果顶点数据有变化的话,需要调用此函数重新提交
        * @param context3DProxy 上下文设备
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.prototype.upload = function (context3DProxy) {
            if (!this.sharedIndexBuffer && !this.sharedVertexBuffer) {
                this.sharedIndexBuffer = context3DProxy.creatIndexBuffer(this.indexData);
                this.sharedVertexBuffer = context3DProxy.creatVertexBuffer(this.verticesData);
            }
            else {
                this.sharedVertexBuffer.arrayBuffer.set(this.verticesData);
                context3DProxy.uploadVertexBuffer(this.sharedVertexBuffer);
            }
        };
        /**
        * @language zh_CN
        * 由顶点索引根据格式拿到顶点数据
        * @param index 顶点索引
        * @param vf 得到顶点的需要的数据格式
        * @param target 得到数据返回目标可以为null
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.prototype.getVertexForIndex = function (index, vf, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Array();
            }
            if (index < 0 || index >= this.verticesData.length) {
                return target;
            }
            var offset = 0;
            if (this.vertexFormat & VertexFormat.VF_POSITION) {
                if (vf & VertexFormat.VF_POSITION) {
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 0]);
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 1]);
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 2]);
                }
                offset += Geometry.positionSize;
            }
            if (this.vertexFormat & VertexFormat.VF_NORMAL) {
                if (vf & VertexFormat.VF_NORMAL) {
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 0]);
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 1]);
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 2]);
                }
                offset += Geometry.normalSize;
            }
            if (this.vertexFormat & VertexFormat.VF_TANGENT) {
                if (vf & VertexFormat.VF_TANGENT) {
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 0]);
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 1]);
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 2]);
                }
                offset += Geometry.tangentSize;
            }
            if (this.vertexFormat & VertexFormat.VF_COLOR) {
                if (vf & VertexFormat.VF_COLOR) {
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 0]);
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 1]);
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 2]);
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 3]);
                }
                offset += Geometry.colorSize;
            }
            if (this.vertexFormat & VertexFormat.VF_UV0) {
                if (vf & VertexFormat.VF_UV0) {
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 0]);
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 1]);
                }
                offset += Geometry.uvSize;
            }
            if (this.vertexFormat & VertexFormat.VF_UV1) {
                if (vf & VertexFormat.VF_UV1) {
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 0]);
                    target.push(this.verticesData[index * this.vertexAttLength + offset + 1]);
                }
                offset += Geometry.uv2Size;
            }
            if (this.vertexFormat & VertexFormat.VF_SKIN) {
                if (vf & VertexFormat.VF_SKIN) {
                    for (var j = 0; j < Geometry.skinSize; ++j) {
                        target.push(this.verticesData[index * this.vertexAttLength + offset + j]);
                    }
                }
                offset += Geometry.skinSize;
            }
            return target;
        };
        /**
        * @language zh_CN
        * 由顶点索引根据格式设置顶点数据
        * @param index 顶点索引
        * @param vf 设置顶点的需要的数据格式
        * @param src 设置的数据
        * @param vertexCount 设置的顶点数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.prototype.setVerticesForIndex = function (index, vf, src, vertexCount) {
            if (vertexCount === void 0) { vertexCount = 1; }
            var offset = 0;
            var srcOffset = 0;
            for (var i = 0; i < vertexCount; ++i) {
                offset = 0;
                if (this.vertexFormat & VertexFormat.VF_POSITION) {
                    if (vf & VertexFormat.VF_POSITION) {
                        this.verticesData[index * this.vertexAttLength + offset + 0] = src[srcOffset + 0];
                        this.verticesData[index * this.vertexAttLength + offset + 1] = src[srcOffset + 1];
                        this.verticesData[index * this.vertexAttLength + offset + 2] = src[srcOffset + 2];
                        srcOffset += Geometry.positionSize;
                    }
                    else {
                        this.verticesData[index * this.vertexAttLength + offset + 0] = 0;
                        this.verticesData[index * this.vertexAttLength + offset + 1] = 0;
                        this.verticesData[index * this.vertexAttLength + offset + 2] = 0;
                    }
                    offset += Geometry.positionSize;
                }
                if (this.vertexFormat & VertexFormat.VF_NORMAL) {
                    if (vf & VertexFormat.VF_NORMAL) {
                        this.verticesData[index * this.vertexAttLength + offset + 0] = src[srcOffset + 0];
                        this.verticesData[index * this.vertexAttLength + offset + 1] = src[srcOffset + 1];
                        this.verticesData[index * this.vertexAttLength + offset + 2] = src[srcOffset + 2];
                        srcOffset += Geometry.normalSize;
                    }
                    else {
                        this.verticesData[index * this.vertexAttLength + offset + 0] = 0;
                        this.verticesData[index * this.vertexAttLength + offset + 1] = 0;
                        this.verticesData[index * this.vertexAttLength + offset + 2] = 0;
                    }
                    offset += Geometry.normalSize;
                }
                if (this.vertexFormat & VertexFormat.VF_TANGENT) {
                    if (vf & VertexFormat.VF_TANGENT) {
                        this.verticesData[index * this.vertexAttLength + offset + 0] = src[srcOffset + 0];
                        this.verticesData[index * this.vertexAttLength + offset + 1] = src[srcOffset + 1];
                        this.verticesData[index * this.vertexAttLength + offset + 2] = src[srcOffset + 2];
                        srcOffset += Geometry.tangentSize;
                    }
                    else {
                        this.verticesData[index * this.vertexAttLength + offset + 0] = 0;
                        this.verticesData[index * this.vertexAttLength + offset + 1] = 0;
                        this.verticesData[index * this.vertexAttLength + offset + 2] = 0;
                    }
                    offset += Geometry.tangentSize;
                }
                if (this.vertexFormat & VertexFormat.VF_COLOR) {
                    if (vf & VertexFormat.VF_COLOR) {
                        this.verticesData[index * this.vertexAttLength + offset + 0] = src[srcOffset + 0];
                        this.verticesData[index * this.vertexAttLength + offset + 1] = src[srcOffset + 1];
                        this.verticesData[index * this.vertexAttLength + offset + 2] = src[srcOffset + 2];
                        this.verticesData[index * this.vertexAttLength + offset + 3] = src[srcOffset + 3];
                        srcOffset += Geometry.colorSize;
                    }
                    else {
                        this.verticesData[index * this.vertexAttLength + offset + 0] = 1;
                        this.verticesData[index * this.vertexAttLength + offset + 1] = 1;
                        this.verticesData[index * this.vertexAttLength + offset + 2] = 1;
                        this.verticesData[index * this.vertexAttLength + offset + 3] = 1;
                    }
                    offset += Geometry.colorSize;
                }
                if (this.vertexFormat & VertexFormat.VF_UV0) {
                    if (vf & VertexFormat.VF_UV0) {
                        this.verticesData[index * this.vertexAttLength + offset + 0] = src[srcOffset + 0];
                        this.verticesData[index * this.vertexAttLength + offset + 1] = src[srcOffset + 1];
                        srcOffset += Geometry.uvSize;
                    }
                    else {
                        this.verticesData[index * this.vertexAttLength + offset + 0] = 0;
                        this.verticesData[index * this.vertexAttLength + offset + 1] = 0;
                    }
                    offset += Geometry.uvSize;
                }
                if (this.vertexFormat & VertexFormat.VF_UV1) {
                    if (vf & VertexFormat.VF_UV1) {
                        this.verticesData[index * this.vertexAttLength + offset + 0] = src[srcOffset + 0];
                        this.verticesData[index * this.vertexAttLength + offset + 1] = src[srcOffset + 1];
                        srcOffset += Geometry.uv2Size;
                    }
                    else {
                        this.verticesData[index * this.vertexAttLength + offset + 0] = 0;
                        this.verticesData[index * this.vertexAttLength + offset + 1] = 0;
                    }
                    offset += Geometry.uv2Size;
                }
                if (this.vertexFormat & VertexFormat.VF_SKIN) {
                    if (vf & VertexFormat.VF_SKIN) {
                        for (var j = 0; j < Geometry.skinSize; ++j) {
                            this.verticesData[index * this.vertexAttLength + offset + j] = src[srcOffset + j];
                        }
                        srcOffset += Geometry.skinSize;
                    }
                    else {
                        for (var j = 0; j < Geometry.skinSize; ++j) {
                            this.verticesData[index * this.vertexAttLength + offset + j] = 0;
                        }
                    }
                    offset += Geometry.skinSize;
                }
                index++;
            }
        };
        /**
        * @language zh_CN
        * 获取顶点索引数据
        * @param start 数据开始位置
        * @param count 需要的索引数据，默认参数为-1，如果为-1那么取从start后面的所有索引数据
        * @param target 取到之后的数据，默认参数为null，如果为null那么就会new Array<number>进行返回
        * @returns Array<number> 索引数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.prototype.getVertexIndices = function (start, count, target) {
            if (count === void 0) { count = -1; }
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Array();
            }
            count == -1 ? count = this.indexData.length : count;
            for (var i = 0; i < count - start; ++i) {
                target[i] = this.indexData[i + start];
            }
            return target;
        };
        /**
        * @language zh_CN
        * 设置顶点索引数据
        * @param start 数据开始位置
        * @param indices 数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.prototype.setVertexIndices = function (start, indices) {
            for (var i = 0; i < indices.length; ++i) {
                this.indexData[start + i] = indices[i];
            }
        };
        /**
        * @language zh_CN
        * 顶点坐标大小
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.positionSize = 3;
        /**
        * @language zh_CN
        * 顶点法线大小
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.normalSize = 3;
        /**
        * @language zh_CN
        * 顶点切线大小
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.tangentSize = 3;
        /**
        * @language zh_CN
        * 顶点色大小
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.colorSize = 4;
        /**
        * @language zh_CN
        * 顶点uv大小
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.uvSize = 2;
        /**
        * @language zh_CN
        * 顶点uv2大小
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.uv2Size = 2;
        /**
        * @language zh_CN
        * 顶点uv2大小
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.skinSize = 8;
        return Geometry;
    }());
    egret3d.Geometry = Geometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.GeometryData
     * @classdesc
     * GeometryData类 表示几何形状数据
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/GeometryData.ts
     */
    var GeometryData = (function () {
        function GeometryData() {
            /**
            * @language zh_CN
            * 顶点属性长度
            */
            this.vertexAttLength = 17;
            /**
            * @language zh_CN
            * 顶点长度
            */
            this.vertLen = 0;
            /**
            * @language zh_CN
            * 面数
            */
            this.faces = 0;
            /**
            * @language zh_CN
            * 索引数据
            */
            this.source_indexData = new Array();
            /**
            * @language zh_CN
            * 顶点数据
            */
            this.source_vertexData = new Array();
            /**
            * @language zh_CN
            * 顶点色数据
            */
            this.source_vertexColorData = new Array();
            /**
            * @language zh_CN
            * 顶点法线
            */
            this.source_normalData = new Array();
            /**
            * @language zh_CN
            * 顶点切线数据
            */
            this.source_tangtData = new Array();
            /**
            * @language zh_CN
            * 顶点uv数据
            */
            this.source_uvData = new Array();
            /**
            * @language zh_CN
            * 顶点uv2数据
            */
            this.source_uv2Data = new Array();
            /**
            * @language zh_CN
            * 蒙皮数据
            */
            this.source_skinData = new Array();
            /**
            * @language zh_CN
            * 顶点索引
            */
            this.vertexIndex = 0;
            /**
            * @language zh_CN
            * 索引数据数组
            */
            this.indices = new Array();
            /**
            * @language zh_CN
            * 顶点数据数组(x、y、z)三个number为一个顶点数据
            */
            this.vertices = new Array();
            /**
            * @language zh_CN
            * 法线数据数组(x、y、z)三个number为一个法线数据
            */
            this.normals = new Array();
            /**
            * @language zh_CN
            * 切线数据数组(x、y、z)三个number为一个切线数据
            */
            this.tangts = new Array();
            /**
            * @language zh_CN
            * 顶点颜色数据数组
            */
            this.verticesColor = new Array();
            /**
            * @language zh_CN
            * 第一套UV数据数组
            */
            this.uvs = new Array();
            /**
            * @language zh_CN
            * 第二套UV数据数组
            */
            this.uv2s = new Array();
            /**
            * @language zh_CN
            * 蒙皮数据数组
            */
            this.skinMesh = new Array();
            /**
            * @language zh_CN
            * 面法线数据数组
            */
            this.faceNormals = new Array();
            /**
            * @language zh_CN
            * 面权重数据数组
            */
            this.faceWeights = new Array();
            /**
              * @language zh_CN
              * 顶点索引数据
              */
            this.vertexIndices = new Array();
            /**
            * @language zh_CN
            * uv索引数据
            */
            this.uvIndices = new Array();
            /**
            * @language zh_CN
            * uv2索引数据
            */
            this.uv2Indices = new Array();
            /**
            * @language zh_CN
            * 法线索引数据
            */
            this.normalIndices = new Array();
            /**
            * @language zh_CN
            * 顶点色索引数据
            */
            this.colorIndices = new Array();
            /**
            * @language zh_CN
            * 索引数据数组
            */
            this.indexIds = new Array(); // used for real index lookups
            this.matCount = 0;
            this.material = {};
        }
        /**
        * @language zh_CN
        *
        * 构建顶点数据数组
        * @param source 未组合顶点数据的GeometryData对象
        * @param vertexFormat 生成顶点格式
        * @returns 经过组合并生成顶点数据数组的新GeometryData对象
        */
        GeometryData.buildGeomtry = function (source, vertexFormat) {
            var target = new egret3d.Geometry();
            target.vertexFormat = vertexFormat;
            target.skeleton = source.skeleton;
            var vertex = new egret3d.Vector3D();
            var normal = new egret3d.Vector3D(1.0, 1.0, 1.0);
            var color = new egret3d.Vector3D(1.0, 1.0, 1.0, 1.0);
            var uv_0 = new egret3d.UV(1, 0);
            var uv_1 = new egret3d.UV(1, 0);
            var index = 0;
            for (var faceIndex = 0; faceIndex < source.faces; faceIndex++) {
                target.indexData.push(faceIndex * 3 + 0, faceIndex * 3 + 2, faceIndex * 3 + 1);
                for (var i = 0; i < 3; i++) {
                    index = source.vertexIndices[faceIndex * 3 + i] * egret3d.Geometry.positionSize;
                    vertex.x = source.source_vertexData[index + 0];
                    vertex.y = source.source_vertexData[index + 1];
                    vertex.z = source.source_vertexData[index + 2];
                    if (source.normalIndices && source.source_normalData && source.source_normalData.length > 0) {
                        index = source.normalIndices[faceIndex * 3 + i] * egret3d.Geometry.normalSize;
                        normal.x = source.source_normalData[index + 0];
                        normal.y = source.source_normalData[index + 1];
                        normal.z = source.source_normalData[index + 2];
                    }
                    if (source.colorIndices && source.source_vertexColorData && source.source_vertexColorData.length > 0) {
                        index = source.colorIndices[faceIndex * 3 + i] * egret3d.Geometry.colorSize;
                        color.x = source.source_vertexColorData[index + 0];
                        color.y = source.source_vertexColorData[index + 1];
                        color.z = source.source_vertexColorData[index + 2];
                        color.w = source.source_vertexColorData[index + 3];
                    }
                    if (source.uvIndices && source.source_uvData && source.source_uvData.length > 0) {
                        index = source.uvIndices[faceIndex * 3 + i] * egret3d.Geometry.uvSize;
                        uv_0.u = source.source_uvData[index + 0];
                        uv_0.v = source.source_uvData[index + 1];
                    }
                    if (source.uv2Indices && source.source_uv2Data && source.source_uv2Data.length > 0) {
                        index = source.uv2Indices[faceIndex * 3 + i] * egret3d.Geometry.uvSize;
                        uv_1.u = source.source_uv2Data[index + 0];
                        uv_1.v = source.source_uv2Data[index + 1];
                    }
                    if (vertexFormat & egret3d.VertexFormat.VF_POSITION) {
                        target.source_positionData.push(vertex.x);
                        target.source_positionData.push(vertex.y);
                        target.source_positionData.push(vertex.z);
                    }
                    if (vertexFormat & egret3d.VertexFormat.VF_NORMAL) {
                        target.source_normalData.push(normal.x);
                        target.source_normalData.push(normal.y);
                        target.source_normalData.push(normal.z);
                    }
                    if (vertexFormat & egret3d.VertexFormat.VF_TANGENT) {
                        target.source_tangentData.push(0);
                        target.source_tangentData.push(0);
                        target.source_tangentData.push(0);
                    }
                    if (vertexFormat & egret3d.VertexFormat.VF_COLOR) {
                        target.source_colorData.push(color.x);
                        target.source_colorData.push(color.y);
                        target.source_colorData.push(color.z);
                        target.source_colorData.push(color.w);
                    }
                    if (vertexFormat & egret3d.VertexFormat.VF_UV0) {
                        target.source_uvData.push(uv_0.u);
                        target.source_uvData.push(uv_0.v);
                    }
                    if (vertexFormat & egret3d.VertexFormat.VF_UV1) {
                        target.source_uv2Data.push(uv_1.u);
                        target.source_uv2Data.push(uv_1.v);
                    }
                    if (vertexFormat & egret3d.VertexFormat.VF_SKIN) {
                        if (source.source_skinData != null && source.source_skinData.length > 0) {
                            index = source.vertexIndices[faceIndex * 3 + i] * egret3d.Geometry.skinSize;
                            target.source_SkinData.push(source.source_skinData[index + 0], source.source_skinData[index + 2], source.source_skinData[index + 4], source.source_skinData[index + 6], source.source_skinData[index + 1], source.source_skinData[index + 3], source.source_skinData[index + 5], source.source_skinData[index + 7]);
                        }
                        else {
                            target.source_SkinData.push(0, 0, 0, 0, 0, 0, 0, 0);
                        }
                    }
                }
            }
            target.calculateVertexFormat();
            // GeometryData.updateFaceTangents(target);
            for (var i = 0; i < source.matCount; ++i) {
                var subGeometry = new egret3d.SubGeometry();
                subGeometry.matID = i;
                subGeometry.geometry = target;
                subGeometry.start = source.material[i].start * 3 * Uint16Array.BYTES_PER_ELEMENT;
                subGeometry.count = source.material[i].count * 3;
                subGeometry.textureDiffuse = source.material[i].textureDiffuse;
                subGeometry.textureNormal = source.material[i].textureNormal;
                subGeometry.textureSpecular = source.material[i].textureSpecular;
                target.subGeometrys.push(subGeometry);
            }
            return target;
        };
        //private static translateMaterialGroup(geomtryData: GeometryData): GeometryData {
        //    var faces: Array<FaceData> = geomtryData.source_faceData;
        //    var face: FaceData;
        //    var numFaces: number = faces.length;
        //    var numVerts: number;
        //    var targetGeomtryData: GeometryData = new GeometryData();
        //    targetGeomtryData.vertexAttLength = geomtryData.vertexAttLength;
        //    var j: number;
        //    for (var i: number = 0; i < numFaces; ++i) {
        //        face = faces[i];
        //        numVerts = face.indexIds.length - 1;
        //        for (j = 1; j < numVerts; ++j) {
        //            this.translateVertexData(face, j, geomtryData, targetGeomtryData);
        //            this.translateVertexData(face, 0, geomtryData, targetGeomtryData);
        //            this.translateVertexData(face, j + 1, geomtryData, targetGeomtryData);
        //        }
        //    }
        //    if (targetGeomtryData.vertices.length > 0) {
        //        targetGeomtryData.vertLen = (targetGeomtryData.vertices.length / 3) * geomtryData.vertexAttLength;
        //       targetGeomtryData.vertexDatas = new Array<number>(targetGeomtryData.vertLen)
        //        //this.updateFaceTangents(targetGeomtryData);
        //        //this.updateFaceNormals(targetGeomtryData);
        //        this.combinGeomtryData(targetGeomtryData);
        //    }
        //    return targetGeomtryData;
        //}
        //private static translateVertexData(face: FaceData, vertexIndex: number, sourceGeomtryData: GeometryData, targetGeomtryData: GeometryData) {
        //    var index: number;
        //    var vertex: Vector3D;
        //    var color: Vector3D;
        //    var vertexNormal: Vector3D;
        //    var uv: UV;
        //    if (!targetGeomtryData.indices[face.indexIds[vertexIndex]]) {
        //        index = targetGeomtryData.vertexIndex;
        //        targetGeomtryData.indices[face.indexIds[vertexIndex]] = ++targetGeomtryData.vertexIndex;
        //        vertex = sourceGeomtryData.source_vertexData[face.vertexIndices[vertexIndex] - 1];
        //        targetGeomtryData.vertices.push(vertex.x, vertex.y, vertex.z);
        //        if (sourceGeomtryData.source_vertexColorData != null && sourceGeomtryData.source_vertexColorData.length > 0) {
        //            color = sourceGeomtryData.source_vertexColorData[face.vertexIndices[vertexIndex] - 1]
        //            targetGeomtryData.verticesColor.push(color.r, color.g, color.b, color.a);
        //        }
        //        if (sourceGeomtryData.source_skinData != null && sourceGeomtryData.source_skinData.length > 0) {
        //            targetGeomtryData.skinMesh.push(
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 0],
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 2],
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 4],
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 6],
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 1],
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 3],
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 5],
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 7]
        //                );
        //        }
        //        if (face.normalIndices.length > 0) {
        //            vertexNormal = sourceGeomtryData.source_normalData[face.normalIndices[vertexIndex] - 1];
        //            targetGeomtryData.normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);
        //        }
        //        if (face.uvIndices.length > 0) {
        //            try {
        //                uv = sourceGeomtryData.source_uvData[face.uvIndices[vertexIndex] - 1];
        //                targetGeomtryData.uvs.push(uv.u, uv.v);
        //                if (sourceGeomtryData.source_uv2Data.length > 0) {
        //                    uv = sourceGeomtryData.source_uv2Data[face.uv2Indices[vertexIndex] - 1];
        //                    targetGeomtryData.uv2s.push(uv.u, uv.v);
        //                }
        //            } catch (e) {
        //                switch (vertexIndex) {
        //                    case 0:
        //                        targetGeomtryData.uvs.push(0, 1);
        //                        break;
        //                    case 1:
        //                        targetGeomtryData.uvs.push(.5, 0);
        //                        break;
        //                    case 2:
        //                        targetGeomtryData.uvs.push(1, 1);
        //                }
        //            }
        //        }
        //    } else
        //        index = targetGeomtryData.indices[face.indexIds[vertexIndex]] - 1;
        //    targetGeomtryData.indices.push(index);
        //}
        /**
        * 4 pos
        * 3 normal
        * 4 color
        * 2 uv
        * 2 uv2s
        * length 15
        */
        GeometryData.combinGeomtryData = function (geomtrtData, needTangent) {
            if (needTangent === void 0) { needTangent = true; }
            var index = 0;
            var v = 0;
            var n = 0;
            var t = 0;
            var u1 = 0;
            var u2 = 0;
            var c = 0;
            var skin = 0;
            var data = geomtrtData.vertexDatas;
            while (index < geomtrtData.vertLen) {
                data[index++] = geomtrtData.vertices[v++];
                data[index++] = geomtrtData.vertices[v++];
                data[index++] = geomtrtData.vertices[v++];
                if (geomtrtData.normals && geomtrtData.normals.length) {
                    data[index++] = geomtrtData.normals[n++];
                    data[index++] = geomtrtData.normals[n++];
                    data[index++] = geomtrtData.normals[n++];
                }
                else {
                    data[index++] = 0;
                    data[index++] = 0;
                    data[index++] = 0;
                }
                if (geomtrtData.tangts) {
                    index++;
                    index++;
                    index++;
                }
                else {
                    data[index++] = 0;
                    data[index++] = 0;
                    data[index++] = 0;
                }
                if (geomtrtData.source_vertexColorData && geomtrtData.source_vertexColorData.length) {
                    data[index++] = geomtrtData.verticesColor[c++];
                    data[index++] = geomtrtData.verticesColor[c++];
                    data[index++] = geomtrtData.verticesColor[c++];
                    data[index++] = geomtrtData.verticesColor[c++];
                }
                else {
                    data[index++] = 1;
                    data[index++] = 1;
                    data[index++] = 1;
                    data[index++] = 1;
                }
                if (geomtrtData.uvs && geomtrtData.uvs.length) {
                    data[index++] = geomtrtData.uvs[u1++];
                    data[index++] = geomtrtData.uvs[u1++];
                    if (geomtrtData.uv2s && geomtrtData.uv2s.length) {
                        data[index++] = geomtrtData.uv2s[u2++];
                        data[index++] = geomtrtData.uv2s[u2++];
                    }
                    else {
                        data[index++] = geomtrtData.uvs[u2++];
                        data[index++] = geomtrtData.uvs[u2++];
                    }
                }
                else {
                    data[index++] = 0;
                    data[index++] = 0;
                    data[index++] = 0;
                    data[index++] = 0;
                }
                if (geomtrtData.skinMesh && geomtrtData.skinMesh.length) {
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                }
            }
            //if (needTangent)
            //    this.updateFaceTangents(geomtrtData
        };
        /**
         * @private
         * Updates the normals for each face.
         */
        GeometryData.updateFaceNormals = function (geomtrtData) {
            var i = 0, j = 0, k = 0;
            var index;
            var len = geomtrtData.indices.length;
            var x1, x2, x3;
            var y1, y2, y3;
            var z1, z2, z3;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var d;
            var vertices = geomtrtData.vertexDatas;
            var posStride = 17;
            var posOffset = 3;
            //if (_useFaceWeights)
            //    _faceWeights ||= new Vector.<number>(len / 3, true);
            while (i < len) {
                index = posOffset + geomtrtData.indices[i++] * posStride;
                x1 = vertices[index];
                y1 = vertices[index + 1];
                z1 = vertices[index + 2];
                index = posOffset + geomtrtData.indices[i++] * posStride;
                x2 = vertices[index];
                y2 = vertices[index + 1];
                z2 = vertices[index + 2];
                index = posOffset + geomtrtData.indices[i++] * posStride;
                x3 = vertices[index];
                y3 = vertices[index + 1];
                z3 = vertices[index + 2];
                dx1 = x3 - x1;
                dy1 = y3 - y1;
                dz1 = z3 - z1;
                dx2 = x2 - x1;
                dy2 = y2 - y1;
                dz2 = z2 - z1;
                cx = dz1 * dy2 - dy1 * dz2;
                cy = dx1 * dz2 - dz1 * dx2;
                cz = dy1 * dx2 - dx1 * dy2;
                d = Math.sqrt(cx * cx + cy * cy + cz * cz);
                // length of cross product = 2*triangle area
                if (true) {
                    var w = d * 10000;
                    if (w < 1)
                        w = 1;
                    geomtrtData.faceWeights[k++] = w;
                }
                d = 1 / d;
                geomtrtData.faceNormals[j++] = cx * d;
                geomtrtData.faceNormals[j++] = cy * d;
                geomtrtData.faceNormals[j++] = cz * d;
            }
            //_faceNormalsDirty = false;
        };
        /**
         * Updates the vertex normals based on the geometry.
         */
        GeometryData.updateVertexNormals = function (geomtrtData) {
            this.updateFaceNormals(geomtrtData);
            var v1;
            var f1 = 0, f2 = 1, f3 = 2;
            var lenV = geomtrtData.vertexDatas.length;
            var normalStride = 17;
            var normalOffset = 3;
            //target ||= new Vector.<Number>(lenV, true);
            //v1 = normalOffset;
            //while(v1 < lenV) {
            //    target[v1] = 0.0;
            //    target[v1 + 1] = 0.0;
            //    target[v1 + 2] = 0.0;
            //    v1 += normalStride;
            //}
            var i = 0, k = 0;
            var lenI = geomtrtData.indices.length;
            var index;
            var weight;
            while (i < lenI) {
                weight = geomtrtData.faceWeights[k++];
                index = normalOffset + geomtrtData.indices[i++] * normalStride;
                geomtrtData.vertexDatas[index] += geomtrtData.faceNormals[f1] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f2] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f3] * weight;
                index = normalOffset + geomtrtData.indices[i++] * normalStride;
                geomtrtData.vertexDatas[index] += geomtrtData.faceNormals[f1] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f2] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f3] * weight;
                index = normalOffset + geomtrtData.indices[i++] * normalStride;
                geomtrtData.vertexDatas[index] += geomtrtData.faceNormals[f1] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f2] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f3] * weight;
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            //v1 = normalOffset;
            //    while(v1 < lenV) {
            //        var vx: Number = target[v1];
            //        var vy: Number = target[v1 + 1];
            //        var vz: Number = target[v1 + 2];
            //        var d: Number = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
            //        target[v1] = vx * d;
            //        target[v1 + 1] = vy * d;
            //        target[v1 + 2] = vz * d;
            //        v1 += normalStride;
            //    }
            //_vertexNormalsDirty = false;
        };
        GeometryData.updateFaceTangents = function (geometry) {
            var i = 0;
            var index1, index2, index3;
            var len = geometry.indexData.length;
            var ui, vi;
            var v0;
            var dv1, dv2;
            var denom;
            var x0, y0, z0;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var vertices = geometry.verticesData;
            //   var uvs: Array<number> = geometry.source_uvData;
            var posStride = geometry.vertexAttLength;
            var posOffset = 0;
            var texStride = geometry.vertexAttLength;
            var texOffset = 0;
            if (geometry.vertexFormat & egret3d.VertexFormat.VF_TANGENT)
                texOffset += egret3d.Geometry.positionSize + egret3d.Geometry.normalSize + egret3d.Geometry.tangentSize;
            if (geometry.vertexFormat & egret3d.VertexFormat.VF_COLOR)
                texOffset += egret3d.Geometry.colorSize;
            while (i < len) {
                index1 = geometry.indexData[i];
                index2 = geometry.indexData[i + 1];
                index3 = geometry.indexData[i + 2];
                ui = texOffset + index1 * texStride;
                v0 = vertices[ui];
                ui = texOffset + index2 * texStride;
                dv1 = vertices[ui] - v0;
                ui = texOffset + index3 * texStride;
                dv2 = vertices[ui] - v0;
                vi = posOffset + index1 * posStride;
                x0 = vertices[vi];
                y0 = vertices[(vi + 1)];
                z0 = vertices[(vi + 2)];
                vi = posOffset + index2 * posStride;
                dx1 = vertices[(vi)] - x0;
                dy1 = vertices[(vi + 1)] - y0;
                dz1 = vertices[(vi + 2)] - z0;
                vi = posOffset + index3 * posStride;
                dx2 = vertices[(vi)] - x0;
                dy2 = vertices[(vi + 1)] - y0;
                dz2 = vertices[(vi + 2)] - z0;
                cx = dv2 * dx1 - dv1 * dx2;
                cy = dv2 * dy1 - dv1 * dy2;
                cz = dv2 * dz1 - dv1 * dz2;
                denom = 1 / Math.sqrt(cx * cx + cy * cy + cz * cz);
                geometry.source_tangentData[i++] = denom * cx;
                geometry.source_tangentData[i++] = denom * cy;
                geometry.source_tangentData[i++] = denom * cz;
            }
            var k;
            var lenI = geometry.indexData.length;
            var index;
            var weight;
            var f1 = 0, f2 = 1, f3 = 2;
            var tangentOffset = egret3d.Geometry.positionSize + egret3d.Geometry.normalSize;
            var tangentStride = geometry.vertexAttLength;
            i = 0;
            while (i < lenI) {
                weight = 1;
                index = tangentOffset + geometry.indexData[i++] * tangentStride;
                geometry.verticesData[index++] += geometry.source_tangentData[f1] * weight;
                geometry.verticesData[index++] += geometry.source_tangentData[f2] * weight;
                geometry.verticesData[index] += geometry.source_tangentData[f3] * weight;
                index = tangentOffset + geometry.indexData[i++] * tangentStride;
                geometry.verticesData[index++] += geometry.source_tangentData[f1] * weight;
                geometry.verticesData[index++] += geometry.source_tangentData[f2] * weight;
                geometry.verticesData[index] += geometry.source_tangentData[f3] * weight;
                index = tangentOffset + geometry.indexData[i++] * tangentStride;
                geometry.verticesData[index++] += geometry.source_tangentData[f1] * weight;
                geometry.verticesData[index++] += geometry.source_tangentData[f2] * weight;
                geometry.verticesData[index] += geometry.source_tangentData[f3] * weight;
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            var lenV = geometry.verticesData.length;
            i = tangentOffset;
            while (i < lenV) {
                var vx = geometry.verticesData[i];
                var vy = geometry.verticesData[i + 1];
                var vz = geometry.verticesData[i + 2];
                var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                geometry.verticesData[i] = vx * d;
                geometry.verticesData[i + 1] = vy * d;
                geometry.verticesData[i + 2] = vz * d;
                i += geometry.vertexAttLength;
            }
        };
        return GeometryData;
    }());
    egret3d.GeometryData = GeometryData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.SubGeometry
     * @classdesc
     * 表示几何形状 子集 不同的子集渲染时使用的材质会不同。
     * 这样就可以用不同的材质来共用相同的geometry buffer
     *
     * @see egret3d.Geometry
     * @version Egret 3.0
     * @platform Web,Native
     */
    var SubGeometry = (function () {
        /**
        * @language zh_CN
        * 创建一个SubGeometry
        */
        function SubGeometry() {
            /**
             * @language zh_CN
             * 顶点索引
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.start = 0;
            /**
             * @language zh_CN
             * 顶点数量
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.count = 0;
            /**
             * @language zh_CN
             * 材质ID
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.matID = 0;
            this.preAttList = new Array();
        }
        /**
        * @private
        * @language zh_CN
        */
        SubGeometry.prototype.upload = function (passUsage, contextPorxy) {
            passUsage.attributeDiry = false;
            var offsetBytes = 0;
            passUsage["attributeList"] = [];
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_POSITION) {
                if (passUsage.attribute_position) {
                    if (!passUsage.attribute_position.uniformIndex) {
                        passUsage.attribute_position.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_position.varName);
                    }
                    passUsage.attribute_position.size = egret3d.Geometry.positionSize;
                    passUsage.attribute_position.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_position.normalized = false;
                    passUsage.attribute_position.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_position.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_position);
                }
                offsetBytes += egret3d.Geometry.positionSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_NORMAL) {
                if (passUsage.attribute_normal) {
                    if (!passUsage.attribute_normal.uniformIndex) {
                        passUsage.attribute_normal.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_normal.varName);
                    }
                    passUsage.attribute_normal.size = egret3d.Geometry.normalSize;
                    passUsage.attribute_normal.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_normal.normalized = false;
                    passUsage.attribute_normal.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_normal.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_normal);
                }
                offsetBytes += egret3d.Geometry.normalSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_TANGENT) {
                if (passUsage.attribute_tangent) {
                    if (!passUsage.attribute_tangent.uniformIndex) {
                        passUsage.attribute_tangent.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_tangent.varName);
                    }
                    passUsage.attribute_tangent.size = egret3d.Geometry.tangentSize;
                    passUsage.attribute_tangent.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_tangent.normalized = false;
                    passUsage.attribute_tangent.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_tangent.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_tangent);
                }
                offsetBytes += egret3d.Geometry.tangentSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_COLOR) {
                if (passUsage.attribute_color) {
                    if (!passUsage.attribute_color.uniformIndex) {
                        passUsage.attribute_color.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_color.varName);
                    }
                    passUsage.attribute_color.size = egret3d.Geometry.colorSize;
                    passUsage.attribute_color.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_color.normalized = false;
                    passUsage.attribute_color.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_color.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_color);
                }
                offsetBytes += egret3d.Geometry.colorSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_UV0) {
                if (passUsage.attribute_uv0) {
                    if (!passUsage.attribute_uv0.uniformIndex) {
                        passUsage.attribute_uv0.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_uv0.varName);
                    }
                    passUsage.attribute_uv0.size = egret3d.Geometry.uvSize;
                    passUsage.attribute_uv0.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_uv0.normalized = false;
                    passUsage.attribute_uv0.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_uv0.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_uv0);
                }
                offsetBytes += egret3d.Geometry.uvSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_UV1) {
                if (passUsage.attribute_uv1) {
                    if (!passUsage.attribute_uv1.uniformIndex) {
                        passUsage.attribute_uv1.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_uv1.varName);
                    }
                    passUsage.attribute_uv1.size = egret3d.Geometry.uv2Size;
                    passUsage.attribute_uv1.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_uv1.normalized = false;
                    passUsage.attribute_uv1.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_uv1.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_uv1);
                }
                offsetBytes += egret3d.Geometry.uv2Size * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_SKIN) {
                if (passUsage.attribute_boneIndex) {
                    if (!passUsage.attribute_boneIndex.uniformIndex) {
                        passUsage.attribute_boneIndex.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_boneIndex.varName);
                    }
                    passUsage.attribute_boneIndex.size = egret3d.Geometry.skinSize / 2;
                    passUsage.attribute_boneIndex.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_boneIndex.normalized = false;
                    passUsage.attribute_boneIndex.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_boneIndex.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_boneIndex);
                }
                offsetBytes += egret3d.Geometry.skinSize / 2 * Float32Array.BYTES_PER_ELEMENT;
                if (passUsage.attribute_boneWeight) {
                    if (!passUsage.attribute_boneWeight.uniformIndex) {
                        passUsage.attribute_boneWeight.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_boneWeight.varName);
                    }
                    passUsage.attribute_boneWeight.size = egret3d.Geometry.skinSize / 2;
                    passUsage.attribute_boneWeight.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_boneWeight.normalized = false;
                    passUsage.attribute_boneWeight.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_boneWeight.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_boneWeight);
                }
                offsetBytes += egret3d.Geometry.skinSize / 2 * Float32Array.BYTES_PER_ELEMENT;
            }
            for (var i = 0; i < this.preAttList.length; ++i) {
                var var0 = this.preAttList[i];
                var attribute = passUsage[var0.name];
                if (attribute) {
                    if (!attribute.uniformIndex) {
                        attribute.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, attribute.varName);
                        attribute.size = var0.size;
                        attribute.dataType = egret3d.ContextConfig.FLOAT;
                        attribute.normalized = false;
                        attribute.stride = this.geometry.vertexSizeInBytes;
                        attribute.offsetBytes = offsetBytes;
                        passUsage["attributeList"].push(attribute);
                    }
                }
                offsetBytes += var0.size * Float32Array.BYTES_PER_ELEMENT;
            }
        };
        SubGeometry.prototype.activeState = function (time, delay, passUsage, contextProxy) {
            if (passUsage.attributeDiry)
                this.upload(passUsage, contextProxy);
            contextProxy.unActiveVertexFormat();
            //if (!SubGeometry.use) {
            //    SubGeometry.use = true;
            for (var i = 0; i < passUsage["attributeList"].length; i++) {
                var attribute = passUsage["attributeList"][i];
                if (attribute.uniformIndex >= 0)
                    contextProxy.vertexAttribPointer(attribute.uniformIndex, attribute.size, attribute.dataType, attribute.normalized, attribute.stride, attribute.offsetBytes);
            }
            //}
            //if (!contextProxy.isActiveVertexFormat(this.geometry.vertexFormat)) {
            //    contextProxy.unActiveVertexFormat()
            //    contextProxy.activeVertexFormat(this.geometry.vertexFormat);
            //    for (var i: number = 0; i < passUsage["attributeList"].length; i++) {
            //        var attribute: GLSL.Attribute = passUsage["attributeList"][i];
            //        if (attribute.uniformIndex >= 0)
            //            contextProxy.vertexAttribPointer(attribute.uniformIndex, attribute.size, attribute.dataType, attribute.normalized, attribute.stride, attribute.offsetBytes);
            //    }
            //}
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        SubGeometry.prototype.deactiveState = function (passUsage, contextProxy) {
            //contextProxy.unActiveVertexFormat()
            //for (var i: number = 0; i < passUsage["attributeList"].length; i++) {
            //    var attribute: GLSL.Attribute = passUsage["attributeList"][i];
            //    if (attribute.uniformIndex >= 0)
            //        contextProxy.clearVaPointer(attribute.uniformIndex);
            //}
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        SubGeometry.use = false;
        return SubGeometry;
    }());
    egret3d.SubGeometry = SubGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.CubeGeometry
     * @classdesc
     * CubeGeometry类 表示立方体</p>
     *
     * 示例：</p>
     * 用 CubeGeometry 对象创建一个mesh，并给予默认纹理材质TextureMaterial（默认为棋盘格纹理）; </p>
     <pre>
      var box: egret3d.Mesh = new egret3d.Mesh( new egret3d.CubeGeometry(), new egret3d.TextureMaterial() );
     </pre>
     *
     * @see egret3d.Geometry
     * @see egret3d.Mesh
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/CubeGeometry.ts
     */
    var CubeGeometry = (function (_super) {
        __extends(CubeGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param width 宽度 默认为80
        * @param height 高度 默认为80
        * @param depth 深度 默认为80
        * @version Egret 3.0
        * @platform Web,Native
        */
        function CubeGeometry(width, height, depth) {
            if (width === void 0) { width = 80; }
            if (height === void 0) { height = 80; }
            if (depth === void 0) { depth = 80; }
            _super.call(this);
            this._width = 80;
            this._height = 80;
            this._depth = 80;
            this._width = width;
            this._height = height;
            this._depth = depth;
            this.buildGeomtry(true);
        }
        Object.defineProperty(CubeGeometry.prototype, "width", {
            /**
            * @language zh_CN
            * Cube宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "height", {
            /**
            * @language zh_CN
            * Cube高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "depth", {
            /**
            * @language zh_CN
            * Cube深度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._depth;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * 生成网格
        * @version Egret 3.0
        * @platform Web,Native
        */
        CubeGeometry.prototype.buildGeomtry = function (front) {
            this.vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_UV1;
            this.verticesData = new Array();
            this.indexData = new Array();
            this.verticesData.push(-this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, -this._width * 0.5, this._height * 0.5, -this._depth * 0.5, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, this._width * 0.5, this._height * 0.5, -this._depth * 0.5, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0, this._width * 0.5, this._height * 0.5, -this._depth * 0.5, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0, this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, -this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, -this._width * 0.5, -this._height * 0.5, this._depth * 0.5, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, this._width * 0.5, -this._height * 0.5, this._depth * 0.5, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, this._width * 0.5, this._height * 0.5, this._depth * 0.5, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, this._width * 0.5, this._height * 0.5, this._depth * 0.5, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, -this._width * 0.5, this._height * 0.5, this._depth * 0.5, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0, -this._width * 0.5, -this._height * 0.5, this._depth * 0.5, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, -this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, this._width * 0.5, -this._height * 0.5, this._depth * 0.5, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, this._width * 0.5, -this._height * 0.5, this._depth * 0.5, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, -this._width * 0.5, -this._height * 0.5, this._depth * 0.5, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0, -this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, this._width * 0.5, this._height * 0.5, -this._depth * 0.5, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, this._width * 0.5, this._height * 0.5, this._depth * 0.5, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, this._width * 0.5, this._height * 0.5, this._depth * 0.5, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, this._width * 0.5, -this._height * 0.5, this._depth * 0.5, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0, this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, this._width * 0.5, this._height * 0.5, -this._depth * 0.5, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, -this._width * 0.5, this._height * 0.5, -this._depth * 0.5, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, -this._width * 0.5, this._height * 0.5, this._depth * 0.5, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, -this._width * 0.5, this._height * 0.5, this._depth * 0.5, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, this._width * 0.5, this._height * 0.5, this._depth * 0.5, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0, this._width * 0.5, this._height * 0.5, -this._depth * 0.5, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, -this._width * 0.5, this._height * 0.5, -this._depth * 0.5, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, -this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, -this._width * 0.5, -this._height * 0.5, this._depth * 0.5, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, -this._width * 0.5, -this._height * 0.5, this._depth * 0.5, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, -this._width * 0.5, this._height * 0.5, this._depth * 0.5, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0, -this._width * 0.5, this._height * 0.5, -this._depth * 0.5, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0);
            if (front) {
                this.indexData.push(0, 2, 1, 3, 5, 4, 6, 8, 7, 9, 11, 10, 12, 14, 13, 15, 17, 16, 18, 20, 19, 21, 23, 22, 24, 26, 25, 27, 29, 28, 30, 32, 31, 33, 35, 34);
            }
            else {
                this.indexData.push(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35);
            }
            this.buildDefaultSubGeometry();
        };
        return CubeGeometry;
    }(egret3d.Geometry));
    egret3d.CubeGeometry = CubeGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.CylinderGeometry
     * @classdesc
     * CylinderGeometry类 表示圆柱体</p>
     *
     * 示例：</p>
     * 用 CylinderGeometry 对象创建一个mesh，并给予默认纹理材质TextureMaterial（默认为棋盘格纹理)</p>
     <pre>
     var box: egret3d.Mesh = new egret3d.Mesh( new egret3d.CylinderGeometry(), new egret3d.TextureMaterial() );
     </pre>
     * @see egret3d.Geometry
     * @version Egret 3.0
     * @platform Web,Native
     */
    var CylinderGeometry = (function (_super) {
        __extends(CylinderGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param height 宽度 默认为100
        * @param radius 半径 默认为200
        * @version Egret 3.0
        * @platform Web,Native
        */
        function CylinderGeometry(height, radius) {
            if (height === void 0) { height = 100; }
            if (radius === void 0) { radius = 200; }
            _super.call(this);
            this._height = height;
            this._radius = radius;
            this.buildGeomtry();
        }
        Object.defineProperty(CylinderGeometry.prototype, "height", {
            /**
            * @language zh_CN
            * 圆柱体高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CylinderGeometry.prototype, "radius", {
            /**
            * @language zh_CN
            * 圆柱体半径
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._radius;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * 生成网格
        */
        CylinderGeometry.prototype.buildGeomtry = function () {
            this.vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_UV1;
            this.verticesData = new Array();
            this.indexData = new Array();
            var m_nSegments = 20;
            var nCurrentSegment = 20;
            var rDeltaSegAngle = (2.0 * Math.PI / m_nSegments);
            var rSegmentLength = 1.0 / m_nSegments;
            for (nCurrentSegment = 0; nCurrentSegment <= m_nSegments; nCurrentSegment++) {
                var x0 = this._radius * Math.sin(nCurrentSegment * rDeltaSegAngle);
                var z0 = this._radius * Math.cos(nCurrentSegment * rDeltaSegAngle);
                this.verticesData.push(x0, 0.0 + (this._height / 2.0), z0, x0, 0.0, z0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, x0, 0.0 - (this._height / 2.0), z0, x0, 0.0, z0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0);
            }
            var len_base = this.verticesData.length / 17;
            var topCenter = this.verticesData.length;
            this.verticesData.push(0.0, 0.0 + (this._height / 2.0), 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0);
            var buttomCenter = this.verticesData.length;
            this.verticesData.push(0.0, 0.0 - (this._height / 2.0), 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0);
            for (var i = 0; i < len_base; i++) {
                if ((i & 1) != 0) {
                    this.indexData.push(i, i + 1 >= len_base ? i + 1 - len_base : i + 1, i + 2 >= len_base ? i + 2 - len_base : i + 2, topCenter, i, i + 2 >= len_base ? i + 2 - len_base : i + 2);
                }
                else {
                    this.indexData.push(i + 1 >= len_base ? i + 1 - len_base : i + 1, i, i + 2 >= len_base ? i + 2 - len_base : i + 2, i, buttomCenter, i + 2 >= len_base ? i + 2 - len_base : i + 2);
                }
            }
            var subGeometry = new egret3d.SubGeometry();
            subGeometry.geometry = this;
            subGeometry.start = 0;
            subGeometry.count = this.indexData.length;
            this.subGeometrys.push(subGeometry);
        };
        return CylinderGeometry;
    }(egret3d.Geometry));
    egret3d.CylinderGeometry = CylinderGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.PlaneGeometry
     * @classdesc
     * PlaneGeometry类 表示面板几何体
     *
     * 示例：
     * //用 PlaneGeometry 对象创建一个mesh，并给予默认纹理材质TextureMaterial（默认为棋盘格纹理）;
     * var box: egret3d.Mesh = new egret3d.Mesh( new egret3d.PlaneGeometry(), new egret3d.TextureMaterial() );
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/CubeGeometry.ts
     */
    var PlaneGeometry = (function (_super) {
        __extends(PlaneGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param width 宽度
        * @param height 高度
        * @param segmentsW 宽度分段数
        * @param segmentsH 高度分段数
        * @param uScale U缩放
        * @param vScale V缩放
        * @param aixs 平面的朝向 默认参数为Vector3D.Y_AXIS
        * @param wCenter 是否width以中心位置为(0,0)点
        * @param hCenter 是否height以中心位置为(0,0)点
        */
        function PlaneGeometry(width, height, segmentsW, segmentsH, uScale, vScale, aixs, wCenter, hCenter) {
            if (width === void 0) { width = 500; }
            if (height === void 0) { height = 500; }
            if (segmentsW === void 0) { segmentsW = 1; }
            if (segmentsH === void 0) { segmentsH = 1; }
            if (uScale === void 0) { uScale = 1; }
            if (vScale === void 0) { vScale = 1; }
            if (aixs === void 0) { aixs = egret3d.Vector3D.Y_AXIS; }
            if (wCenter === void 0) { wCenter = true; }
            if (hCenter === void 0) { hCenter = true; }
            _super.call(this);
            this._segmentsW = 1;
            this._segmentsH = 1;
            this._width = 500.0;
            this._height = 500.0;
            this._scaleU = 1;
            this._scaleV = 1;
            this._width = width;
            this._height = height;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._scaleU = uScale;
            this._scaleV = vScale;
            this._wCenter = wCenter;
            this._hCenter = hCenter;
            this.buildGeometry(aixs);
        }
        Object.defineProperty(PlaneGeometry.prototype, "segmentsW", {
            /**
            * @language zh_CN
            * 宽度分段数
            */
            get: function () {
                return this._segmentsW;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "segmentsH", {
            /**
            * @language zh_CN
            * 高度分段数
            */
            get: function () {
                return this._segmentsH;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "width", {
            /**
            * @language zh_CN
            * 宽度
            */
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "height", {
            /**
            * @language zh_CN
            * 宽度
            */
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "scaleU", {
            /**
            * @language zh_CN
            * U缩放
            */
            get: function () {
                return this._scaleU;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "scaleV", {
            /**
            * @language zh_CN
            * U缩放
            */
            get: function () {
                return this._scaleV;
            },
            enumerable: true,
            configurable: true
        });
        PlaneGeometry.prototype.buildGeometry = function (aixs) {
            this.vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0;
            var x, y;
            var numIndices;
            var base;
            var tw = this._segmentsW + 1;
            var numVertices = (this._segmentsH + 1) * tw;
            var stride = this.vertexAttLength;
            var skip = stride - 15;
            numIndices = this._segmentsH * this._segmentsW * 6;
            this.verticesData = new Array(numVertices * stride);
            this.indexData = new Array(numIndices);
            numIndices = 0;
            var point = new egret3d.Vector3D();
            var index = 0;
            for (var yi = 0; yi <= this._segmentsH; ++yi) {
                for (var xi = 0; xi <= this._segmentsW; ++xi) {
                    x = (xi / this._segmentsW - .5) * this._width;
                    y = (yi / this._segmentsH - .5) * this._height;
                    if (this._wCenter == false) {
                        x += this._width / 2;
                    }
                    if (this._hCenter == false) {
                        y += this._height / 2;
                    }
                    switch (aixs) {
                        case egret3d.Vector3D.Y_AXIS:
                            this.verticesData[index++] = x;
                            this.verticesData[index++] = 0;
                            this.verticesData[index++] = y;
                            this.verticesData[index++] = 0;
                            this.verticesData[index++] = 1;
                            this.verticesData[index++] = 0;
                            break;
                        case egret3d.Vector3D.Z_AXIS:
                            this.verticesData[index++] = x;
                            this.verticesData[index++] = y;
                            this.verticesData[index++] = 0;
                            this.verticesData[index++] = 0;
                            this.verticesData[index++] = 0;
                            this.verticesData[index++] = -1;
                            break;
                        case egret3d.Vector3D.X_AXIS:
                            this.verticesData[index++] = 0;
                            this.verticesData[index++] = x;
                            this.verticesData[index++] = y;
                            this.verticesData[index++] = 1;
                            this.verticesData[index++] = 0;
                            this.verticesData[index++] = 0;
                            break;
                        default:
                            this.verticesData[index++] = x;
                            this.verticesData[index++] = 0;
                            this.verticesData[index++] = y;
                            this.verticesData[index++] = 0;
                            this.verticesData[index++] = 1;
                            this.verticesData[index++] = 0;
                            break;
                    }
                    this.verticesData[index++] = 1;
                    this.verticesData[index++] = 0;
                    this.verticesData[index++] = 0;
                    this.verticesData[index++] = 1;
                    this.verticesData[index++] = 1;
                    this.verticesData[index++] = 1;
                    this.verticesData[index++] = 1;
                    this.verticesData[index++] = (xi / this._segmentsW) * this._scaleU;
                    this.verticesData[index++] = (1 - yi / this._segmentsH) * this._scaleV;
                    index += skip;
                    if (xi != this._segmentsW && yi != this._segmentsH) {
                        base = xi + yi * tw;
                        var mult = 1;
                        this.indexData[numIndices++] = base * mult;
                        this.indexData[numIndices++] = (base + tw + 1) * mult;
                        this.indexData[numIndices++] = (base + tw) * mult;
                        this.indexData[numIndices++] = base * mult;
                        this.indexData[numIndices++] = (base + 1) * mult;
                        this.indexData[numIndices++] = (base + tw + 1) * mult;
                    }
                }
            }
            var subGeometry = new egret3d.SubGeometry();
            subGeometry.geometry = this;
            subGeometry.start = 0;
            subGeometry.count = this.indexData.length;
            this.subGeometrys.push(subGeometry);
        };
        return PlaneGeometry;
    }(egret3d.Geometry));
    egret3d.PlaneGeometry = PlaneGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.SphereGeometry
     * @classdesc
     * SphereGeometry类 表示球体
     *
     * 示例：
     * //用 SphereGeometry 对象创建一个mesh，并给予默认纹理材质TextureMaterial（默认为棋盘格纹理）;
     * var box: egret3d.Mesh = new egret3d.Mesh( new egret3d.SphereGeometry(), new egret3d.TextureMaterial() );
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/SphereGeometry.ts
     */
    var SphereGeometry = (function (_super) {
        __extends(SphereGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param r 半径 默认值 100
        * @param segmentsW 宽度分段数 默认值 15
        * @param segmentsH 高度分段数 默认值 15
        * @param faceOrBack 正面或者反面显示
        * @version Egret 3.0
        * @platform Web,Native
        */
        function SphereGeometry(r, segmentsW, segmentsH) {
            if (r === void 0) { r = 100.0; }
            if (segmentsW === void 0) { segmentsW = 15; }
            if (segmentsH === void 0) { segmentsH = 15; }
            _super.call(this);
            this._segmentsW = 50;
            this._segmentsH = 50;
            this._radius = 100;
            this._radius = r;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this.buildSphere(true);
        }
        Object.defineProperty(SphereGeometry.prototype, "segmentsW", {
            /**
            * @language zh_CN
            * 宽度分段数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._segmentsW;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SphereGeometry.prototype, "segmentsH", {
            /**
            * @language zh_CN
            * 高度分段数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._segmentsH;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SphereGeometry.prototype, "radius", {
            /**
            * @language zh_CN
            * 半径
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._radius;
            },
            enumerable: true,
            configurable: true
        });
        SphereGeometry.prototype.buildSphere = function (front) {
            if (front === void 0) { front = true; }
            this.vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_UV1;
            var i = 0, j = 0, triIndex = 0;
            var numVerts = (this._segmentsH + 1) * (this._segmentsW + 1);
            var stride = this.vertexAttLength;
            var skip = stride - 9;
            this.verticesData = new Array(numVerts * stride);
            this.indexData = new Array((this._segmentsH - 1) * this._segmentsW * 6);
            var startIndex = 0;
            var index = 0;
            var comp1 = 0, comp2 = 0, t1 = 0, t2 = 0;
            for (j = 0; j <= this._segmentsH; ++j) {
                startIndex = index;
                var horangle = Math.PI * j / this._segmentsH;
                var z = -this._radius * Math.cos(horangle);
                var ringradius = this._radius * Math.sin(horangle);
                for (i = 0; i <= this._segmentsW; ++i) {
                    var verangle = 2 * Math.PI * i / this._segmentsW;
                    var x = ringradius * Math.cos(verangle);
                    var y = ringradius * Math.sin(verangle);
                    var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
                    var tanLen = Math.sqrt(y * y + x * x);
                    t1 = 0;
                    t2 = tanLen > .007 ? x / tanLen : 0;
                    comp1 = -z;
                    comp2 = y;
                    if (i == this._segmentsW) {
                        this.verticesData[index++] = this.verticesData[startIndex];
                        this.verticesData[index++] = this.verticesData[startIndex + 1];
                        this.verticesData[index++] = this.verticesData[startIndex + 2];
                        this.verticesData[index++] = x * normLen;
                        ;
                        this.verticesData[index++] = comp1 * normLen;
                        ;
                        this.verticesData[index++] = comp2 * normLen;
                        ;
                        this.verticesData[index++] = tanLen > .007 ? -y / tanLen : 1;
                        this.verticesData[index++] = t1;
                        this.verticesData[index++] = t2;
                        this.verticesData[index + 0] = 1.0;
                        this.verticesData[index + 1] = 1.0;
                        this.verticesData[index + 2] = 1.0;
                        this.verticesData[index + 3] = 1.0;
                    }
                    else {
                        this.verticesData[index++] = x;
                        this.verticesData[index++] = comp1;
                        this.verticesData[index++] = comp2;
                        this.verticesData[index++] = x * normLen;
                        this.verticesData[index++] = comp1 * normLen;
                        this.verticesData[index++] = comp2 * normLen;
                        this.verticesData[index++] = tanLen > .007 ? -y / tanLen : 1;
                        this.verticesData[index++] = t1;
                        this.verticesData[index++] = t2;
                        this.verticesData[index] = 1.0;
                        this.verticesData[index + 1] = 1.0;
                        this.verticesData[index + 2] = 1.0;
                        this.verticesData[index + 3] = 1.0;
                    }
                    if (i > 0 && j > 0) {
                        var a = (this._segmentsW + 1) * j + i;
                        var b = (this._segmentsW + 1) * j + i - 1;
                        var c = (this._segmentsW + 1) * (j - 1) + i - 1;
                        var d = (this._segmentsW + 1) * (j - 1) + i;
                        if (j == this._segmentsH) {
                            this.verticesData[index - 9] = this.verticesData[startIndex];
                            this.verticesData[index - 8] = this.verticesData[startIndex + 1];
                            this.verticesData[index - 7] = this.verticesData[startIndex + 2];
                            if (front) {
                                this.indexData[triIndex++] = a;
                                this.indexData[triIndex++] = d;
                                this.indexData[triIndex++] = c;
                            }
                            else {
                                this.indexData[triIndex++] = a;
                                this.indexData[triIndex++] = c;
                                this.indexData[triIndex++] = d;
                            }
                        }
                        else if (j == 1) {
                            if (front) {
                                this.indexData[triIndex++] = a;
                                this.indexData[triIndex++] = c;
                                this.indexData[triIndex++] = b;
                            }
                            else {
                                this.indexData[triIndex++] = a;
                                this.indexData[triIndex++] = b;
                                this.indexData[triIndex++] = c;
                            }
                        }
                        else {
                            if (front) {
                                this.indexData[triIndex++] = a;
                                this.indexData[triIndex++] = d;
                                this.indexData[triIndex++] = c;
                                this.indexData[triIndex++] = a;
                                this.indexData[triIndex++] = c;
                                this.indexData[triIndex++] = b;
                            }
                            else {
                                this.indexData[triIndex++] = a;
                                this.indexData[triIndex++] = c;
                                this.indexData[triIndex++] = d;
                                this.indexData[triIndex++] = a;
                                this.indexData[triIndex++] = b;
                                this.indexData[triIndex++] = c;
                            }
                        }
                    }
                    index += skip;
                }
            }
            //var i: number, j: number;
            var stride = 17;
            var numUvs = (this._segmentsH + 1) * (this._segmentsW + 1) * stride;
            var data;
            var skip = stride - 2;
            var index = 13;
            for (j = 0; j <= this._segmentsH; ++j) {
                for (i = 0; i <= this._segmentsW; ++i) {
                    this.verticesData[index++] = (i / this._segmentsW);
                    this.verticesData[index++] = (j / this._segmentsH);
                    index += skip;
                }
            }
            var subGeometry = new egret3d.SubGeometry();
            subGeometry.geometry = this;
            subGeometry.start = 0;
            subGeometry.count = this.indexData.length;
            this.subGeometrys.push(subGeometry);
        };
        return SphereGeometry;
    }(egret3d.Geometry));
    egret3d.SphereGeometry = SphereGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.GeometryUtil
    * @classdesc
    * 创建Geometry的功能类
    * @see egret3d.Geometry
    * @version Egret 3.0
    * @platform Web,Native
    */
    var GeometryUtil = (function () {
        function GeometryUtil() {
        }
        /**
        * @language zh_CN
        * 创建一个Geometry对象，指定了顶点的数据结构，但是顶点数据需要额外填充
        * @param vertexFromat 顶点数据格式，默认参数为 VertexFormat.VF_POSITION | VertexFormat.VF_NORMAL | VertexFormat.VF_TANGENT | VertexFormat.VF_COLOR | VertexFormat.VF_UV0 | VertexFormat.VF_UV1
        * @returns Geometry Geometry对象
        * @see egret3d.VertexFormat
        * @version Egret 3.0
        * @platform Web,Native
        */
        GeometryUtil.createGeometry = function (vertexFromat) {
            if (vertexFromat === void 0) { vertexFromat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_UV1; }
            var geo = new egret3d.Geometry();
            geo.vertexFormat = vertexFromat;
            return geo;
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        GeometryUtil.createGemetryForType = function (type, gemetry) {
            switch (type) {
                case "CubeGeometry":
                    return new egret3d.CubeGeometry(gemetry.width, gemetry.height, gemetry.depth);
                case "CylinderGeometry":
                    return new egret3d.CylinderGeometry(gemetry.height, gemetry.radius);
                case "ElevationGeometry":
                    return new egret3d.ElevationGeometry(gemetry.heightmap, gemetry.width, gemetry.height, gemetry.depth, gemetry.segmentsW, gemetry.segmentsH);
                case "PlaneGeometry":
                    return new egret3d.PlaneGeometry(gemetry.width, gemetry.height, gemetry.segmentsW, gemetry.segmentsH, gemetry.uScale, gemetry.vScale);
                case "SphereGeometry":
                    return new egret3d.SphereGeometry(gemetry.r, gemetry.segmentsW, gemetry.segmentsH);
            }
            return null;
        };
        return GeometryUtil;
    }());
    egret3d.GeometryUtil = GeometryUtil;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ElevationGeometry = (function (_super) {
        __extends(ElevationGeometry, _super);
        function ElevationGeometry(heightmap, width, height, depth, segmentsW, segmentsH, maxElevation, minElevation) {
            if (width === void 0) { width = 1000; }
            if (height === void 0) { height = 100; }
            if (depth === void 0) { depth = 1000; }
            if (segmentsW === void 0) { segmentsW = 30; }
            if (segmentsH === void 0) { segmentsH = 30; }
            if (maxElevation === void 0) { maxElevation = 255; }
            if (minElevation === void 0) { minElevation = 0; }
            _super.call(this);
            this._width = 100;
            this._height = 100;
            this._segmentsW = 100;
            this._segmentsH = 100;
            this._depth = 100;
            this._minElevation = 100;
            this._maxElevation = 100;
            this._scaleU = 1;
            this._scaleV = 1;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._width = width;
            this._height = height;
            this._depth = depth;
            this._minElevation = minElevation;
            this._maxElevation = maxElevation;
            this._heightmap = heightmap;
            this._canvas = document.createElement("canvas");
            var ctx = this._canvas.getContext("2d");
            this._canvas.width = heightmap.imageData.width;
            this._canvas.height = heightmap.imageData.height;
            ctx.drawImage(heightmap.imageData, 0, 0, heightmap.width, heightmap.height);
            document.body.appendChild(this._canvas);
            this._canvas.hidden = true;
            this.imageData = ctx.getImageData(0, 0, this._heightmap.imageData.width, this._heightmap.imageData.height);
            document.body.removeChild(this._canvas);
            this.buildGeomtry(true);
        }
        /**
       * @private
       * @language zh_CN
       * 生成网格
       * @version Egret 3.0
       * @platform Web,Native
       */
        ElevationGeometry.prototype.buildGeomtry = function (front) {
            this.vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_UV1;
            var x, z;
            var numInds;
            var base;
            var tw = this._segmentsW + 1;
            var numVerts = (this._segmentsH + 1) * tw;
            var uDiv = (this._heightmap.width - 1) / this._segmentsW;
            var vDiv = (this._heightmap.height - 1) / this._segmentsH;
            var u, v;
            var y;
            //if (numVerts == this._subGeometry.numVertices) {
            //    vertices = this._subGeometry.vertexData;
            //    indices = this._subGeometry.indexData;
            // } else {
            this.verticesData = new Array(numVerts * 3);
            this.indexData = new Array(this._segmentsH * this._segmentsW * 6);
            numVerts = 0;
            numInds = 0;
            var col;
            for (var zi = 0; zi <= this._segmentsH; ++zi) {
                for (var xi = 0; xi <= this._segmentsW; ++xi) {
                    x = (xi / this._segmentsW - 0.5) * this._width;
                    z = (zi / this._segmentsH - 0.5) * this._depth;
                    u = Math.floor(xi * uDiv);
                    v = Math.floor((this._segmentsH - zi) * vDiv);
                    col = this.getPixel(u, v) & 0xff;
                    y = (col > this._maxElevation) ? (this._maxElevation / 0xff) * this._height : ((col < this._minElevation) ? (this._minElevation / 0xff) * this._height : (col / 0xff) * this._height);
                    //pos
                    this.verticesData[numVerts++] = x;
                    this.verticesData[numVerts++] = y; //Math.random() * 1000;;
                    this.verticesData[numVerts++] = z;
                    //normal
                    this.verticesData[numVerts++] = 1.0;
                    this.verticesData[numVerts++] = 1.0;
                    this.verticesData[numVerts++] = 1.0;
                    //tan
                    this.verticesData[numVerts++] = -1.0;
                    this.verticesData[numVerts++] = 0.0;
                    this.verticesData[numVerts++] = 0.0;
                    //color
                    this.verticesData[numVerts++] = 1.0;
                    this.verticesData[numVerts++] = 1.0;
                    this.verticesData[numVerts++] = 1.0;
                    this.verticesData[numVerts++] = 1.0;
                    //uv
                    this.verticesData[numVerts++] = xi / this._segmentsW * this._scaleU;
                    this.verticesData[numVerts++] = 1.0 - zi / this._segmentsH * this._scaleV;
                    this.verticesData[numVerts++] = xi / this._segmentsW;
                    this.verticesData[numVerts++] = 1.0 - zi / this._segmentsH;
                    if (xi != this._segmentsW && zi != this._segmentsH) {
                        base = xi + zi * tw;
                        this.indexData[numInds++] = base;
                        this.indexData[numInds++] = base + tw + 1;
                        this.indexData[numInds++] = base + tw;
                        this.indexData[numInds++] = base;
                        this.indexData[numInds++] = base + 1;
                        this.indexData[numInds++] = base + tw + 1;
                    }
                }
            }
            this.updateFaceNormals();
            this.buildDefaultSubGeometry();
        };
        ElevationGeometry.prototype.getPixel = function (x, z) {
            var index = z * (this._heightmap.imageData.width * 4) + x * 4;
            var color = this.imageData.data[index + 3] << 24 | this.imageData.data[index + 0] << 16 | this.imageData.data[index + 1] << 8 | this.imageData.data[index + 2];
            return color;
        };
        ElevationGeometry.prototype.getHeightBypos = function (x, z) {
            var color = this.getPixel(x, z);
            return (color > this._maxElevation) ? (this._maxElevation / 0xff) * this._height : ((color < this._minElevation) ? (this._minElevation / 0xff) * this._height : (color / 0xff) * this._height);
        };
        ElevationGeometry.prototype.updateFaceNormals = function () {
            var i = 0, j = 0, k = 0;
            var index;
            var len = this.indexData.length;
            var x1, x2, x3;
            var y1, y2, y3;
            var z1, z2, z3;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var d;
            var vertices = this.verticesData;
            var posStride = 17;
            var posOffset = 0;
            var faceNormals = [];
            while (i < len) {
                index = posOffset + this.indexData[i + 0] * posStride;
                x1 = vertices[index];
                y1 = vertices[index + 1];
                z1 = vertices[index + 2];
                index = posOffset + this.indexData[i + 1] * posStride;
                x2 = vertices[index];
                y2 = vertices[index + 1];
                z2 = vertices[index + 2];
                index = posOffset + this.indexData[i + 2] * posStride;
                x3 = vertices[index];
                y3 = vertices[index + 1];
                z3 = vertices[index + 2];
                dx1 = x2 - x1;
                dy1 = y2 - y1;
                dz1 = z2 - z1;
                dx2 = x3 - x1;
                dy2 = y3 - y1;
                dz2 = z3 - z1;
                cx = dz1 * dy2 - dy1 * dz2;
                cy = dx1 * dz2 - dz1 * dx2;
                cz = dy1 * dx2 - dx1 * dy2;
                d = Math.sqrt(cx * cx + cy * cy + cz * cz);
                faceNormals[j++] = cz * d;
                faceNormals[j++] = cy * d;
                faceNormals[j++] = cx * d;
                i += 3;
            }
            i = 0;
            var f1 = 0, f2 = 1, f3 = 2;
            var normalStride = this.vertexAttLength;
            var normalOffset = 3;
            while (i < len) {
                index = normalOffset + this.indexData[i++] * normalStride;
                this.verticesData[index++] = faceNormals[f1];
                this.verticesData[index++] = faceNormals[f2];
                this.verticesData[index++] = faceNormals[f3];
                index = normalOffset + this.indexData[i++] * normalStride;
                this.verticesData[index++] = faceNormals[f1];
                this.verticesData[index++] = faceNormals[f2];
                this.verticesData[index++] = faceNormals[f3];
                index = normalOffset + this.indexData[i++] * normalStride;
                this.verticesData[index++] = faceNormals[f1];
                this.verticesData[index++] = faceNormals[f2];
                this.verticesData[index++] = faceNormals[f3];
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
        };
        return ElevationGeometry;
    }(egret3d.Geometry));
    egret3d.ElevationGeometry = ElevationGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Input
     * @classdesc
     * 处理输入设备,鼠标.键盘.触摸。
     * 当点事件产生时如果没有点击到任何的View3D内，
     * 当前事件将不用派发.
     * @includeExample input/Input.ts
     * @see egret3d.EventDispatcher
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Input = (function (_super) {
        __extends(Input, _super);
        /**
        * @language zh_CN
        * 创建一个新的 Input 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Input() {
            var _this = this;
            _super.call(this);
            this._time = 0;
            this._keyStatus = {};
            this._mouseStatus = {};
            this._isTouchStart = false;
            this._mouseEvent3d = new egret3d.MouseEvent3D();
            this._keyEvent3d = new egret3d.KeyEvent3D();
            this._touchEvent3d = new egret3d.TouchEvent3D();
            this._windowsEvent3d = new egret3d.Event3D();
            this._orientationEvent3d = new egret3d.OrientationEvent3D();
            /**
            * @language zh_CN
            * 游戏手柄Stick1事件侦听函数。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.onGamepadStick1 = null;
            /**
            * @language zh_CN
            * 游戏手柄Stick2事件侦听函数。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.onGamepadStick2 = null;
            this._gp = false;
            this._oldPosition1 = null;
            this._oldPosition2 = null;
            window.addEventListener("click", function (e) { return _this.mouseClick(e); }, true);
            window.addEventListener("mousedown", function (e) { return _this.mouseStart(e); }, true);
            window.addEventListener("mouseup", function (e) { return _this.mouseEnd(e); }, true);
            window.addEventListener("mousewheel", function (e) { return _this.mouseWheel(e); }, true);
            window.addEventListener("mousemove", function (e) { return _this.mouseMove(e); }, true);
            window.addEventListener("mouseover", function (e) { return _this.mouseOver(e); }, true);
            window.addEventListener("keydown", function (e) { return _this.keyDown(e); }, true);
            window.addEventListener("keyup", function (e) { return _this.keyUp(e); }, true);
            if (this.canGame()) {
                window.addEventListener("gamepadconnected", function (e) { return _this.ongamepadconnected(e); }, true);
                window.addEventListener("gamepaddisconnected", function (e) { return _this.ongamepaddisconnected(e); }, true);
            }
            window.addEventListener("touchstart", function (e) { return _this.touchStart(e); }, true);
            window.addEventListener("touchend", function (e) { return _this.touchEnd(e); }, true);
            window.addEventListener("touchmove", function (e) { return _this.touchMove(e); }, true);
            window.addEventListener("touchcancel", function (e) { return _this.touchEnd(e); }, true);
            //window.addEventListener("deviceorientation", (e: DeviceOrientationEvent) => this.ondeviceorientation(e), true);
            //window.addEventListener("deviceorientation", (e: DeviceOrientationEvent) => this.ondeviceorientation(e), true);
            //window.addEventListener("devicemotion", (e: DeviceMotionEvent) => this.detectShake(e), true);
            //window.addEventListener("devicemotion", (e: DeviceMotionEvent) => this.detectShake(e), true);
            //window.addEventListener("resize", (e: UIEvent) => this.onWindowsResize(e));
            window.addEventListener("resize", function (e) { return _this.onWindowsResize(e); }, true);
            window.addEventListener("orientationchange", function (e) { return _this.onOrientationChange(e); }, true);
            window.addEventListener("devicemotion", function (e) { return _this.onDeviceMotion(e); }, true);
            window.addEventListener("deviceorientation", function (e) { return _this.onDeviceOrientation(e); }, true);
        }
        Object.defineProperty(Input, "instance", {
            /**
            * @language zh_CN
            * 获取Input类对象的单例。
            * @returns Input
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._instance == null) {
                    this._instance = new Input();
                }
                return this._instance;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 对象注册事件侦听器对象，以使侦听器能够接收事件通知。可以为特定类型的事件和优先级注册事件侦听器。
        * 成功注册一个事件侦听器后，不使用后 需要removeEventListenerAt().
        * @param type {string} 事件的类型。
        * @param callback {Function} 处理事件的侦听器函数。此函数必须接受 Event3D 对象作为其唯一的参数，并且不能返回任何结果，
        * 如下面的示例所示： function(evt:Event3D):void 函数可以有任何名称。
        * @returns 事件ID 返回值 removeEventListenerAt 时会用到
         * @version Egret 3.0
         * @platform Web,Native
        */
        Input.addEventListener = function (type, callback, thisObject) {
            return Input.instance.addEventListener(type, callback, thisObject);
        };
        /**
         * @language zh_CN
         * 根据addEventListener传入的事件数据信息,移除事件侦听器。
         * @param type {string} 事件名。
         * @param callback {Function} 侦听函数。
         * @version Egret 3.0
         * @platform Web,Native
         */
        Input.removeEventListener = function (type, callback, thisObject) {
            Input.instance.removeEventListener(type, callback, thisObject);
        };
        /**
         * @language zh_CN
         * 根据addEventListener 的返回值,移除事件侦听器。
         * @param id  事件id, addEventListener 的返回值.
         * @version Egret 3.0
         * @platform Web,Native
         */
        Input.removeEventListenerAt = function (id) {
            Input.instance.removeEventListenerAt(id);
        };
        Input.prototype.ongamepaddisconnected = function (e) {
            //Debug.instance.trace("Gamepad disconnected!");
            this._gp = false;
        };
        Input.prototype.ongamepadconnected = function (e) {
            //Debug.instance.trace("Gamepad connected!");
            this._gp = true;
        };
        /**
        * @language zh_CN
        * 游戏手柄按钮是否按下。
        * @version Egret 3.0
        * @platform Web,Native
        * @param index {number}
        * @returns {boolean}
        */
        Input.prototype.getGamepadButtonState = function (index) {
            return navigator.getGamepads()[0].buttons[index].pressed;
        };
        /**
        * @language zh_CN
        * 游戏手柄摇杆方向 Stick1 。
        * @version Egret 3.0
        * @platform Web,Native
        * @returns {Vector3D}
        */
        Input.prototype.getGamepadStick1 = function () {
            return new egret3d.Vector3D(navigator.getGamepads()[0].axes[0], navigator.getGamepads()[0].axes[1], 0);
        };
        /**
        * @language zh_CN
        * 游戏手柄摇杆方向 Stick2 。
        * @version Egret 3.0
        * @platform Web,Native
        * @returns {Vector3D}
        */
        Input.prototype.getGamepadStick2 = function () {
            return new egret3d.Vector3D(navigator.getGamepads()[0].axes[2], navigator.getGamepads()[0].axes[3], 0);
        };
        Input.prototype.canGame = function () {
            return "getGamepads" in navigator;
        };
        /**
        * @private
        * @language zh_CN
        * 更新游戏手柄信息。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.reportOnGamepad = function () {
            if (Input.instance.canGame() && Input.instance._gp) {
                if (Input.instance.onGamepadStick1 != null) {
                    Input.instance.onGamepadStick1(Input.instance.getGamepadStick1());
                }
                if (Input.instance.onGamepadStick2 != null) {
                    Input.instance.onGamepadStick2(Input.instance.getGamepadStick2());
                }
            }
        };
        Input.prototype.printout = function () {
            var html = "";
            html += "id: " + navigator.getGamepads()[0].id + "<br/>";
            var len = navigator.getGamepads()[0].buttons.length;
            for (var i = 0; i < len; i++) {
                html += "Button " + (i + 1) + ": ";
                if (this.getGamepadButtonState(i))
                    html += " pressed";
                html += "<br/>";
            }
            var v = this.getGamepadStick1();
            html += "Stick 1" + ": " + v.x + "," + v.y + "<br/>";
            v = this.getGamepadStick2();
            html += "Stick 2" + ": " + v.x + "," + v.y + "<br/>";
            //Debug.instance.trace(html);
        };
        //private detectShake(evt: DeviceMotionEvent) {
        //    var accl = evt.acceleration; //acceleration 排除重力影响的加速度  accelerationIncludingGravity(含重力的加速度)
        //    //x、y 和 z 轴方向加速
        //    if (accl.x > 1.5 || accl.y > 1.5 || accl.z > 1.5) {
        //    } else {
        //    }
        //    //if (this._ondevicemotion && this._ondevicemotion.length > 0) {
        //    //    var x: number = Math.ceil(accl.x * 1000) / 1000;
        //    //    var y: number = Math.ceil(accl.y * 1000) / 1000;
        //    //    var z: number = Math.ceil(accl.z * 1000) / 1000;
        //    //    this._ondevicemotion[0](x, y, z);
        //    //}
        //}
        //private _caheX: number;
        //private _caheY: number;
        //private _caheZ: number;
        //private _delayX: number;
        //private _delayY: number;
        //private _delayZ: number;
        //private _first: boolean = true;
        //private _initAngle: Vector3D = new Vector3D();
        //private ondeviceorientation(e: DeviceOrientationEvent) {
        //    //alpha rotation around the z-axis  between 0 and 360 degrees 
        //    //在围绕 z 轴旋转时（即左右旋转时），y 轴的度数差 0 到 360度 。
        //    //beta Rotation around the x-axis cause the beta angle to change. The range of beta is between -180 and 180 degrees 
        //    //在围绕 x 轴旋转时（即前后旋转时），z 轴的度数差 -180到180度。  
        //    //gamma The gamma angle is associated with the y-axis between -90 and 90 degrees 
        //    //在围绕 y 轴旋转时（即扭转设备时），z 轴的度数差 -90到90度。  
        //    //if (this._ondeviceorientation && this._ondeviceorientation.length > 0) {
        //    //    var alpha: number = Math.round(e.alpha * 100) * 0.01;
        //    //    var beta: number = Math.round(e.beta * 100) * 0.01;
        //    //    var gamma: number = Math.round(e.gamma * 100) * 0.01;
        //    //    if (this._first) {
        //    //        this._initAngle["x"] = alpha;
        //    //        this._initAngle["y"] = beta;
        //    //        this._initAngle["z"] = gamma;
        //    //    }
        //    //    this._delayX = alpha - this._caheX;
        //    //    this._delayY = beta - this._caheY;
        //    //    this._delayZ = gamma - this._caheZ;
        //    //    this._caheX = alpha;
        //    //    this._caheY = beta;
        //    //    this._caheZ = gamma;
        //    //    this._initAngle.x += this._delayX;
        //    //    this._initAngle.y += this._delayY;
        //    //    this._initAngle.z += this._delayZ;
        //    //    for (var i: number = 0; i < this._ondeviceorientation.length; i++) {
        //    //        this._ondeviceorientation[i].callback.call(this._ondeviceorientation[i].thisObject, this._initAngle);
        //    //    }
        //    //}
        //}
        Input.prototype.onPinch = function (x, y, x1, y1) {
            this._oldPosition1 = new egret3d.Point(x, y);
            this._oldPosition2 = new egret3d.Point(x1, y1);
        };
        Input.prototype.onSwipe = function (x, y) {
            Input.mouseX = x;
            Input.mouseY = y;
            this._oldPosition1 = null;
            this._oldPosition2 = null;
            this._time = new Date().getTime();
        };
        Input.prototype.touchStart = function (e) {
            if (!this.deliverMessage()) {
                return;
            }
            e.preventDefault();
            var x1 = e.targetTouches[0].clientX - Input.canvas.x + Input.canvas.offsetX;
            var y1 = e.targetTouches[0].clientY - Input.canvas.y + Input.canvas.offsetY;
            if (e.targetTouches.length == 2) {
                var x2 = e.targetTouches[1].clientX - Input.canvas.x + Input.canvas.offsetX;
                var y2 = e.targetTouches[1].clientY - Input.canvas.y + Input.canvas.offsetY;
                this.onPinch(x1, y1, x2, y2);
            }
            else if (e.targetTouches.length == 1) {
                this.onSwipe(x1, y1);
            }
            this._touchEvent3d.targetTouches = e.targetTouches;
            this._touchEvent3d.target = this;
            if (!this._isTouchStart) {
                this._isTouchStart = true;
                this._touchEvent3d.eventType = egret3d.TouchEvent3D.TOUCH_START;
                this.dispatchEvent(this._touchEvent3d);
            }
        };
        Input.prototype.touchEnd = function (e) {
            if (e.targetTouches.length > 1) {
                var x = e.targetTouches[0].clientX - Input.canvas.x + Input.canvas.offsetX;
                var y = e.targetTouches[0].clientY - Input.canvas.y + Input.canvas.offsetY;
                var x1 = e.targetTouches[1].clientX - Input.canvas.x + Input.canvas.offsetX;
                var y1 = e.targetTouches[1].clientY - Input.canvas.y + Input.canvas.offsetY;
                this.onPinch(x, y, x1, y1);
            }
            else if (e.targetTouches.length == 1) {
                this.onSwipe(e.targetTouches[0].clientX - Input.canvas.x + Input.canvas.offsetX, e.targetTouches[0].clientY - Input.canvas.y + Input.canvas.offsetY);
            }
            else {
                this._oldPosition1 = null;
                this._oldPosition2 = null;
                this._time = 0;
            }
            this._isTouchStart = false;
            this._touchEvent3d.targetTouches = e.targetTouches;
            this._touchEvent3d.target = this;
            this._touchEvent3d.eventType = egret3d.TouchEvent3D.TOUCH_END;
            this.dispatchEvent(this._touchEvent3d);
        };
        Input.prototype.touchMove = function (e) {
            Input.mouseLastX = Input.mouseX;
            Input.mouseLastY = Input.mouseY;
            Input.mouseX = e.targetTouches[0].clientX - Input.canvas.x + Input.canvas.offsetX;
            Input.mouseY = e.targetTouches[0].clientY - Input.canvas.y + Input.canvas.offsetY;
            Input.mouseOffsetX = Input.mouseX - Input.mouseLastX;
            Input.mouseOffsetY = Input.mouseY - Input.mouseLastY;
            e.preventDefault();
            if (e.targetTouches.length > 1) {
                var newPosition1 = new egret3d.Point(Input.mouseX, Input.mouseY);
                var newPosition2 = new egret3d.Point(e.targetTouches[1].clientX - Input.canvas.x + Input.canvas.offsetX, e.targetTouches[1].clientY - Input.canvas.y + Input.canvas.offsetY);
                if (this._oldPosition1 == null)
                    this._oldPosition1 = newPosition1;
                if (this._oldPosition2 == null)
                    this._oldPosition2 = newPosition2;
                if (this.isEnlarge(this._oldPosition1, this._oldPosition2, newPosition1, newPosition2))
                    Input.wheelDelta = 120;
                else
                    Input.wheelDelta = -120;
                this._oldPosition1 = newPosition1;
                this._oldPosition2 = newPosition2;
            }
            else {
            }
            this._touchEvent3d.targetTouches = e.targetTouches;
            this._touchEvent3d.target = this;
            this._touchEvent3d.eventType = egret3d.TouchEvent3D.TOUCH_MOVE;
            this.dispatchEvent(this._touchEvent3d);
        };
        Input.prototype.mouseClick = function (e) {
            if (!this.deliverMessage()) {
                return;
            }
            this._mouseEvent3d.mouseCode = e.button;
            this._mouseEvent3d.target = this;
            this._mouseEvent3d.eventType = egret3d.MouseEvent3D.MOUSE_CLICK;
            this.dispatchEvent(this._mouseEvent3d);
        };
        Input.prototype.mouseEnd = function (e) {
            this._mouseEvent3d.mouseCode = e.button;
            this._mouseEvent3d.target = this;
            this._mouseStatus[this._mouseEvent3d.mouseCode] = false;
            this._mouseEvent3d.eventType = egret3d.MouseEvent3D.MOUSE_UP;
            this.dispatchEvent(this._mouseEvent3d);
        };
        Input.prototype.deliverMessage = function () {
            var view3ds = Input.canvas.view3Ds;
            for (var i = 0; i < view3ds.length; ++i) {
                if (view3ds[i].inView3D(Input.mouseX, Input.mouseY)) {
                    return true;
                }
            }
            return false;
        };
        Input.prototype.mouseStart = function (e) {
            if (!this.deliverMessage()) {
                return;
            }
            this._mouseEvent3d.mouseCode = e.button;
            this._mouseEvent3d.target = this;
            if (!this._mouseStatus[this._mouseEvent3d.mouseCode]) {
                this._mouseStatus[this._mouseEvent3d.mouseCode] = true;
                this._mouseEvent3d.eventType = egret3d.MouseEvent3D.MOUSE_DOWN;
                this.dispatchEvent(this._mouseEvent3d);
            }
        };
        Input.prototype.mouseMove = function (e) {
            Input.mouseLastX = Input.mouseX;
            Input.mouseLastY = Input.mouseY;
            Input.mouseX = e.clientX - Input.canvas.x + Input.canvas.offsetX;
            Input.mouseY = e.clientY - Input.canvas.y + Input.canvas.offsetY;
            Input.mouseOffsetX = Input.mouseX - Input.mouseLastX;
            Input.mouseOffsetY = Input.mouseY - Input.mouseLastY;
            this._mouseEvent3d.target = this;
            this._mouseEvent3d.eventType = egret3d.MouseEvent3D.MOUSE_MOVE;
            this.dispatchEvent(this._mouseEvent3d);
        };
        Input.prototype.mouseOver = function (e) {
            this._mouseEvent3d.target = this;
            this._mouseEvent3d.eventType = egret3d.MouseEvent3D.MOUSE_OVER;
            this.dispatchEvent(this._mouseEvent3d);
        };
        Input.prototype.mouseWheel = function (e) {
            Input.wheelDelta = e.wheelDelta;
            this._mouseEvent3d.target = this;
            this._mouseEvent3d.eventType = egret3d.MouseEvent3D.MOUSE_WHEEL;
            this.dispatchEvent(this._mouseEvent3d);
        };
        Input.prototype.keyDown = function (e) {
            this._keyEvent3d.keyCode = e.keyCode;
            this._keyEvent3d.target = this;
            if (!this._keyStatus[e.keyCode]) {
                this._keyStatus[e.keyCode] = true;
                this._keyEvent3d.eventType = egret3d.KeyEvent3D.KEY_CLICK;
                this.dispatchEvent(this._keyEvent3d);
                this._keyEvent3d.eventType = egret3d.KeyEvent3D.KEY_DOWN;
                this.dispatchEvent(this._keyEvent3d);
            }
        };
        Input.prototype.keyUp = function (e) {
            this._keyEvent3d.keyCode = e.keyCode;
            this._keyEvent3d.target = this;
            if (this._keyStatus[e.keyCode]) {
                this._keyEvent3d.eventType = egret3d.KeyEvent3D.KEY_CLICK;
                this.dispatchEvent(this._keyEvent3d);
            }
            this._keyStatus[e.keyCode] = false;
            this._keyEvent3d.eventType = egret3d.KeyEvent3D.KEY_UP;
            this.dispatchEvent(this._keyEvent3d);
        };
        Input.prototype.onWindowsResize = function (e) {
            this._windowsEvent3d.target = this;
            this._windowsEvent3d.eventType = egret3d.Event3D.RESIZE;
            this.dispatchEvent(this._windowsEvent3d);
        };
        Input.prototype.onOrientationChange = function (e) {
            this._orientationEvent3d.target = this;
            this._orientationEvent3d.eventType = egret3d.OrientationEvent3D.ORIENTATION_CHANGE;
            this.dispatchEvent(this._orientationEvent3d);
        };
        Input.prototype.onDeviceMotion = function (e) {
            this._orientationEvent3d.target = this;
            this._orientationEvent3d.eventType = egret3d.OrientationEvent3D.DEVICE_MOTION;
            this._orientationEvent3d.acceleration = e.acceleration;
            this._orientationEvent3d.accelerationIncludingGravity = e.accelerationIncludingGravity;
            this._orientationEvent3d.rotationRate = e.rotationRate;
            this.dispatchEvent(this._orientationEvent3d);
        };
        Input.prototype.onDeviceOrientation = function (e) {
            this._orientationEvent3d.target = this;
            this._orientationEvent3d.eventType = egret3d.OrientationEvent3D.DEVICE_ORIENTATION;
            this._orientationEvent3d.absolute = e.absolute;
            this._orientationEvent3d.alpha = e.alpha;
            this._orientationEvent3d.beta = e.beta;
            this._orientationEvent3d.gamma = e.gamma;
            this.dispatchEvent(this._orientationEvent3d);
        };
        //返回角度
        Input.prototype.GetSlideAngle = function (dx, dy) {
            return Math.atan2(dy, dx) * 180 / Math.PI;
        };
        /**
        * @language zh_CN
        * 根据起点和终点返回方向
        * @param  startX {Number} 起点X坐标
        * @param  startY {Number} 起点Y坐标
        * @param  endX   {Number} 终点X坐标
        * @param  endY   {Number} 终点Y坐标
        * @returns result {number} 1：向上，2：向下，3：向左，4：向右,0：未滑动
        */
        Input.prototype.GetSlideDirection = function (startX, startY, endX, endY) {
            var dy = startY - endY;
            var dx = endX - startX;
            var result = 0;
            //如果滑动距离太短
            if (Math.abs(dx) < 2 && Math.abs(dy) < 2) {
                return result;
            }
            var angle = this.GetSlideAngle(dx, dy);
            if (angle >= -45 && angle < 45) {
                result = 4;
            }
            else if (angle >= 45 && angle < 135) {
                result = 1;
            }
            else if (angle >= -135 && angle < -45) {
                result = 2;
            }
            else if ((angle >= 135 && angle <= 180) || (angle >= -180 && angle < -135)) {
                result = 3;
            }
            return result;
        };
        Input.prototype.isEnlarge = function (op1, op2, np1, np2) {
            //函数传入上一次触摸两点的位置与本次触摸两点的位置计算出用户的手势
            var leng1 = Math.sqrt((op1.x - op2.x) * (op1.x - op2.x) + (op1.y - op2.y) * (op1.y - op2.y));
            var leng2 = Math.sqrt((np1.x - np2.x) * (np1.x - np2.x) + (np1.y - np2.y) * (np1.y - np2.y));
            if (leng1 < leng2) {
                //放大手势
                return true;
            }
            else {
                //缩小手势
                return false;
            }
        };
        /**
        * @language zh_CN
        * 当前鼠标X坐标。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.mouseX = 0;
        /**
        * @language zh_CN
        * 当前鼠标Y坐标。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.mouseY = 0;
        /**
        * @language zh_CN
        * 鼠标滚轮增量值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.wheelDelta = 0;
        /**
        * @language zh_CN
        * 鼠标X坐标的偏移值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.mouseOffsetX = 0;
        /**
        * @language zh_CN
        * 鼠标Y坐标的偏移值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.mouseOffsetY = 0;
        /**
        * @language zh_CN
        * 上一次鼠标X坐标。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.mouseLastX = 0;
        /**
        * @language zh_CN
        * 上一次鼠标Y坐标。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.mouseLastY = 0;
        Input._instance = null;
        return Input;
    }(egret3d.EventDispatcher));
    egret3d.Input = Input;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3D.OrientationControler
     * @classdesc
     * 陀螺仪控制器
     */
    var OrientationController = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function OrientationController() {
            this.orientation = new egret3d.Vector3D();
            this.screenOrientation = 0;
            this.openDebug = false;
            /**
            * @language zh_CN
            * 偏移旋转
            */
            this.offsetRotation = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 陀螺仪当前旋转角度
            */
            this.fixOritation = new egret3d.Vector3D();
            this.state = -1;
            this.degtorad = Math.PI / 180; // Degree-to-Radian conversion
            this.q = new egret3d.Quaternion();
            this.q1 = new egret3d.Quaternion();
            this.outQ = new egret3d.Quaternion();
            this.fix = new egret3d.Vector3D();
            this.fixinterpolate = new egret3d.Vector3D();
            this.fixAxis = new egret3d.Vector3D();
            this.caheFixAxis = new egret3d.Vector3D();
            this.steps = 1;
            this.interpolate = true;
            if (this.openDebug) {
                this.accDiv = document.createElement("div");
                this.accGravityDiv = document.createElement("div");
                this.rotationRateDiv = document.createElement("div");
                this.orientationRateDiv = document.createElement("div");
                this.stateDiv = document.createElement("div");
                this.accDiv.style.color = "red";
                this.accGravityDiv.style.color = "red";
                this.rotationRateDiv.style.color = "red";
                this.orientationRateDiv.style.color = "red";
                this.stateDiv.style.color = "red";
                this.stateDiv.style.fontSize = "52";
                document.body.appendChild(this.accDiv);
                document.body.appendChild(this.accGravityDiv);
                document.body.appendChild(this.rotationRateDiv);
                document.body.appendChild(this.orientationRateDiv);
                document.body.appendChild(this.stateDiv);
            }
        }
        /**
        * @language zh_CN
        * 初始化
        */
        OrientationController.prototype.start = function () {
            var _this = this;
            this.orientationchangeHandler();
            window.addEventListener("orientationchange", function () { return _this.orientationchangeHandler(); });
            window.addEventListener("devicemotion", function (e) { return _this.motionHandler(e); });
            window.addEventListener("deviceorientation", function (e) { return _this.orientationHandler(e); });
        };
        /**
        * @language zh_CN
        * 释放
        */
        OrientationController.prototype.stop = function () {
            var _this = this;
            window.removeEventListener("orientationchange", function () { return _this.orientationchangeHandler(); });
            window.removeEventListener("devicemotion", function (e) { return _this.motionHandler(e); });
            window.removeEventListener("deviceorientation", function (e) { return _this.orientationHandler(e); });
        };
        /**
        * @language zh_CN
        */
        OrientationController.prototype.orientationchangeHandler = function () {
            if (window.orientation != undefined)
                this.screenOrientation = window.orientation;
            //.this.state = window.orientation;
        };
        /**
        * @language zh_CN
        *
        * @param event
        */
        OrientationController.prototype.motionHandler = function (event) {
            this.acc = event.acceleration;
            this.accGravity = event.accelerationIncludingGravity;
            this.rotationRate = event.rotationRate;
        };
        /**
        * @language zh_CN
        *
        * @param event
        * @returns
        */
        OrientationController.prototype.orientationHandler = function (event) {
            this.orientation.x = event.alpha;
            this.orientation.y = event.beta;
            this.orientation.z = event.gamma;
            if (this.openDebug)
                this.debug();
        };
        OrientationController.prototype.debug = function () {
            //this.accDiv.innerHTML = "<br><br><br> acc-x:" + this.acc.x + "<br>acc-y:" + this.acc.y + "<br>acc-z:" + this.acc.z ;
            this.accGravityDiv.innerHTML = "<br><br> Gravity-x:" + this.orientation.x * egret3d.MathUtil.RADIANS_TO_DEGREES + "<br>Gravity-y:" + this.orientation.y + "<br>Gravity-z:" + this.orientation.z;
            //this.rotationRateDiv.innerHTML = "<br> Rate-x:" + this.rotationRate.alpha + "<br>Rate-y:" + this.rotationRate.gamma + "<br>Rate-z:" + this.rotationRate.beta;
            this.orientationRateDiv.innerHTML = "<br> orientation-x:" + this.fixOritation.x + "<br>orientation-y:" + this.fixOritation.y + "<br>orientation-z:" + this.fixOritation.z;
            //this.orientationRateDiv.innerHTML = "<br> orientation-x:" + this.fixOritation.x * MathUtil.RADIANS_TO_DEGREES + "<br>orientation-y:" + this.fixOritation.y * MathUtil.RADIANS_TO_DEGREES + "<br>orientation-z:" + this.fixOritation.z * MathUtil.RADIANS_TO_DEGREES;
            this.stateDiv.innerHTML = "<br> state: " + this.state;
        };
        /**
        * @language zh_CN
        *
        * @returns number
        */
        OrientationController.prototype.getOrientation = function () {
            switch (window.screen.msOrientation) {
                case 'landscape-primary':
                    return -90;
                case 'landscape-secondary':
                    return 90;
                case 'portrait-secondary':
                    return 180;
                case 'portrait-primary':
                    return 0;
            }
            // this returns 90 if width is greater then height 
            // and window orientation is undefined OR 0
            // if (!window.orientation && window.innerWidth > window.innerHeight)
            //   return 90;
            return window.orientation || 0;
        };
        /**
        * @language zh_CN
        * 由陀螺仪的角度值计算出旋转四元数
        * @param alpha
        * @param beta
        * @param gamma
        * @returns 旋转四元数
        */
        OrientationController.prototype.getQuaternion = function (alpha, beta, gamma) {
            var _x = beta ? beta * this.degtorad : 0; // beta value
            var _y = gamma ? gamma * this.degtorad : 0; // gamma value
            var _z = alpha ? alpha * this.degtorad : 0; // alpha value
            _x = Math.floor(_x * 100) / 100;
            _y = Math.floor(_y * 100) / 100;
            var orient = -this.getOrientation() * this.degtorad; // this.getOrientation()) * this.degtorad ; // O
            this.state = this.getOrientation();
            var cX = Math.cos(_x / 2);
            var cY = Math.cos(_y / 2);
            var cZ = Math.cos(_z / 2);
            var sX = Math.sin(_x / 2);
            var sY = Math.sin(_y / 2);
            var sZ = Math.sin(_z / 2);
            //this.q1.fromAxisAngle(Vector3D.Y_AXIS, alpha * this.degtorad);
            //
            // ZXY quaternion construction.
            //
            this.q.w = cX * cY * cZ - sX * sY * sZ;
            this.q.x = sX * cY * cZ - cX * sY * sZ;
            this.q.y = cX * sY * cZ + sX * cY * sZ;
            this.q.z = cX * cY * sZ + sX * sY * cZ;
            var zee = new egret3d.Vector3D(0, 0, 1);
            var q0 = new egret3d.Quaternion();
            q0.fromAxisAngle(zee, orient);
            this.q.multiply(this.q, q0); // camera looks out the back of the device, not the top
            zee.setTo(-1, 0, 0);
            q0.fromAxisAngle(zee, 90 * this.degtorad);
            this.q.multiply(this.q, q0);
            return this.q;
        };
        /**
        * @language zh_CN
        * 数据更新
        * @param camera3D 当前相机
        */
        OrientationController.prototype.update = function (view3D) {
            this.getBaseQuaternion(this.orientation.x, this.orientation.y, this.orientation.z);
            this.q.toEulerAngles(this.fixOritation);
            if (this.interpolate) {
                this.fixinterpolate.x = (this.fixOritation.x - this.fix.x);
                this.fixinterpolate.y = (this.fixOritation.y - this.fix.y);
                this.fixinterpolate.z = (this.fixOritation.z - this.fix.z);
                this.caheFixAxis.x = this.fixOritation.x / Math.abs(this.fixOritation.x);
                this.caheFixAxis.y = this.fixOritation.y / Math.abs(this.fixOritation.y);
                this.caheFixAxis.z = this.fixOritation.z / Math.abs(this.fixOritation.z);
                if (this.fixAxis.x == this.caheFixAxis.x && this.fixAxis.y == this.caheFixAxis.y && this.fixAxis.z == this.caheFixAxis.z) {
                    this.fix.x += this.fixinterpolate.x / (this.steps + 0.01);
                    this.fix.y += this.fixinterpolate.y / (this.steps + 0.01);
                    this.fix.z += this.fixinterpolate.z / (this.steps + 0.01);
                }
                else {
                    this.fix.x = this.fixOritation.x;
                    this.fix.y = this.fixOritation.y;
                    this.fix.z = this.fixOritation.z;
                    this.fixAxis.x = this.caheFixAxis.x;
                    this.fixAxis.y = this.caheFixAxis.y;
                    this.fixAxis.z = this.caheFixAxis.z;
                }
                view3D.camera3D.rotationX = -this.fix.x;
                view3D.camera3D.rotationY = -this.fix.y;
                view3D.camera3D.rotationZ = this.fix.z;
            }
            else {
                view3D.camera3D.rotationX = -this.fixOritation.x;
                view3D.camera3D.rotationY = -this.fixOritation.y;
                view3D.camera3D.rotationZ = this.fixOritation.z;
            }
            //view3D.scene.rotationX = -90;
        };
        OrientationController.prototype.getBaseQuaternion = function (alpha, beta, gamma) {
            var _x = beta ? beta * this.degtorad : 0; // beta value
            var _y = gamma ? gamma * this.degtorad : 0; // gamma value
            var _z = alpha ? alpha * this.degtorad : 0; // alpha value
            var cX = Math.cos(_x / 2);
            var cY = Math.cos(_y / 2);
            var cZ = Math.cos(_z / 2);
            var sX = Math.sin(_x / 2);
            var sY = Math.sin(_y / 2);
            var sZ = Math.sin(_z / 2);
            //
            // ZXY quaternion construction.
            //
            var w = cX * cY * cZ - sX * sY * sZ;
            var x = sX * cY * cZ - cX * sY * sZ;
            var y = cX * sY * cZ + sX * cY * sZ;
            var z = cX * cY * sZ + sX * sY * cZ;
            this.q.w = w;
            this.q.x = x;
            this.q.y = y;
            this.q.z = z;
            return this.q;
        };
        return OrientationController;
    }());
    egret3d.OrientationController = OrientationController;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var DDS = (function () {
        function DDS() {
            this.mipmaps = new Array();
            this.width = 0;
            this.height = 0;
            this.format = null;
            this.mipmapCount = 1;
        }
        return DDS;
    }());
    egret3d.DDS = DDS;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * dds / st3c compressed texture formats
     */
    (function (DDSFormat) {
        DDSFormat[DDSFormat["RGB_S3TC_DXT1_FORMAT"] = 2001] = "RGB_S3TC_DXT1_FORMAT";
        DDSFormat[DDSFormat["RGBA_S3TC_DXT1_FORMAT"] = 2002] = "RGBA_S3TC_DXT1_FORMAT";
        DDSFormat[DDSFormat["RGBA_S3TC_DXT3_FORMAT"] = 2003] = "RGBA_S3TC_DXT3_FORMAT";
        DDSFormat[DDSFormat["RGBA_S3TC_DXT5_FORMAT"] = 2003] = "RGBA_S3TC_DXT5_FORMAT";
    })(egret3d.DDSFormat || (egret3d.DDSFormat = {}));
    var DDSFormat = egret3d.DDSFormat;
    ;
    /**
     * @private
     * @language zh_CN
     * @class egret3d.DDSParser
     * @classdesc
     * 用 DDSParser 类 解析.dds 文件
     */
    var DDSParser = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function DDSParser() {
        }
        /**
         * @language zh_CN
         * @param buffer 二进制
         * @param loadMipmaps 是否加载mipmaps
         * @returns DDSTexture
         */
        DDSParser.parse = function (buffer, loadMipmaps) {
            if (loadMipmaps === void 0) { loadMipmaps = true; }
            var dds = new egret3d.DDS();
            var headerLengthInt = 31; // The header length in 32 bit ints
            var off_magic = 0;
            var DDS_MAGIC = 0x20534444;
            var DDSD_CAPS = 0x1, DDSD_HEIGHT = 0x2, DDSD_WIDTH = 0x4, DDSD_PITCH = 0x8, DDSD_PIXELFORMAT = 0x1000, DDSD_MIPMAPCOUNT = 0x20000, DDSD_LINEARSIZE = 0x80000, DDSD_DEPTH = 0x800000;
            var DDSCAPS_COMPLEX = 0x8, DDSCAPS_MIPMAP = 0x400000, DDSCAPS_TEXTURE = 0x1000;
            var DDSCAPS2_CUBEMAP = 0x200, DDSCAPS2_CUBEMAP_POSITIVEX = 0x400, DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800, DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000, DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000, DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000, DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000, DDSCAPS2_VOLUME = 0x200000;
            var DDPF_ALPHAPIXELS = 0x1, DDPF_ALPHA = 0x2, DDPF_FOURCC = 0x4, DDPF_RGB = 0x40, DDPF_YUV = 0x200, DDPF_LUMINANCE = 0x20000;
            var FOURCC_DXT1 = DDSParser.fourCCToInt32("DXT1");
            var FOURCC_DXT3 = DDSParser.fourCCToInt32("DXT3");
            var FOURCC_DXT5 = DDSParser.fourCCToInt32("DXT5");
            //Pixel formats
            var RGBA_FORMAT = 1021;
            var off_magic = 0;
            var off_size = 1;
            var off_flags = 2;
            var off_height = 3;
            var off_width = 4;
            var off_mipmapCount = 7;
            var off_pfFlags = 20;
            var off_pfFourCC = 21;
            var off_RGBBitCount = 22;
            var off_RBitMask = 23;
            var off_GBitMask = 24;
            var off_BBitMask = 25;
            var off_ABitMask = 26;
            var off_caps = 27;
            var off_caps2 = 28;
            var off_caps3 = 29;
            var off_caps4 = 30;
            var header = new Int32Array(buffer, 0, headerLengthInt);
            if (header[off_magic] !== DDS_MAGIC) {
                console.error('DDSParser.parse: Invalid magic number in DDS header.');
                return null;
            }
            if (!(header[off_pfFlags] & DDPF_FOURCC)) {
                console.error('DDSParser.parse: Unsupported format, must contain a FourCC code.');
                return null;
            }
            var blockBytes;
            var fourCC = header[off_pfFourCC];
            var isRGBAUncompressed = false;
            switch (fourCC) {
                case FOURCC_DXT1:
                    blockBytes = 8;
                    dds.format = DDSFormat.RGB_S3TC_DXT1_FORMAT;
                    break;
                case FOURCC_DXT3:
                    blockBytes = 16;
                    dds.format = DDSFormat.RGBA_S3TC_DXT3_FORMAT;
                    break;
                case FOURCC_DXT5:
                    blockBytes = 16;
                    dds.format = DDSFormat.RGBA_S3TC_DXT5_FORMAT;
                    break;
                default:
                    if (header[off_RGBBitCount] == 32
                        && header[off_RBitMask] & 0xff0000
                        && header[off_GBitMask] & 0xff00
                        && header[off_BBitMask] & 0xff
                        && header[off_ABitMask] & 0xff000000) {
                        isRGBAUncompressed = true;
                        blockBytes = 64;
                        dds.format = RGBA_FORMAT;
                    }
                    else {
                        console.error('DDSParser.parse: Unsupported FourCC code ', DDSParser.int32ToFourCC(fourCC));
                        return null;
                    }
            }
            dds.mipmapCount = 1;
            if ((header[off_flags] & DDSD_MIPMAPCOUNT) && loadMipmaps !== false) {
                dds.mipmapCount = Math.max(1, header[off_mipmapCount]);
            }
            dds.isCubemap = header[off_caps2] & DDSCAPS2_CUBEMAP ? true : false;
            dds.width = header[off_width];
            dds.height = header[off_height];
            var dataOffset = header[off_size] + 4;
            // Extract mipmaps buffers
            var width = dds.width;
            var height = dds.height;
            var faces = dds.isCubemap ? 6 : 1;
            //是否软解DXT;
            var useSoftwareSolution = false;
            if (dds.format == DDSFormat.RGB_S3TC_DXT1_FORMAT && egret3d.ContextConfig.ColorFormat_DXT1_RGB == 0)
                useSoftwareSolution = true;
            else if (dds.format == DDSFormat.RGBA_S3TC_DXT3_FORMAT && egret3d.ContextConfig.ColorFormat_DXT3_RGBA == 0)
                useSoftwareSolution = true;
            else if (dds.format == DDSFormat.RGBA_S3TC_DXT5_FORMAT && egret3d.ContextConfig.ColorFormat_DXT5_RGBA == 0)
                useSoftwareSolution = true;
            for (var face = 0; face < faces; face++) {
                for (var i = 0; i < dds.mipmapCount; i++) {
                    var byteArray;
                    if (isRGBAUncompressed) {
                        byteArray = DDSParser.loadARGBMip(buffer, dataOffset, width, height);
                        var dataLength = byteArray.length;
                    }
                    else {
                        var dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
                        byteArray = new Uint8Array(buffer, dataOffset, dataLength);
                        if (useSoftwareSolution) {
                            byteArray = DDSParser.softSolutionDXT(width, height, dds.format, byteArray);
                        }
                    }
                    var mipmap = new egret3d.MipmapData(byteArray, width, height);
                    dds.mipmaps.push(mipmap);
                    dataOffset += dataLength;
                    width = Math.max(width * 0.5, 1);
                    height = Math.max(height * 0.5, 1);
                }
                width = dds.width;
                height = dds.height;
            }
            var texture = new egret3d.DDSTexture();
            if (useSoftwareSolution) {
                texture.internalFormat = egret3d.InternalFormat.PixelArray;
                texture.colorFormat = egret3d.ContextConfig.ColorFormat_RGBA8888;
            }
            else {
                texture.internalFormat = egret3d.InternalFormat.CompressData;
                if (FOURCC_DXT1 == fourCC)
                    texture.colorFormat = egret3d.ContextConfig.ColorFormat_DXT1_RGB;
                else if (FOURCC_DXT3 == fourCC)
                    texture.colorFormat = egret3d.ContextConfig.ColorFormat_DXT3_RGBA;
                else if (FOURCC_DXT5 == fourCC)
                    texture.colorFormat = egret3d.ContextConfig.ColorFormat_DXT5_RGBA;
            }
            texture.mimapData = dds.mipmaps;
            return texture;
        };
        DDSParser.loadARGBMip = function (buffer, dataOffset, width, height) {
            var dataLength = width * height * 4;
            var srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);
            var byteArray = new Uint8Array(dataLength);
            var dst = 0;
            var src = 0;
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var b = srcBuffer[src];
                    src++;
                    var g = srcBuffer[src];
                    src++;
                    var r = srcBuffer[src];
                    src++;
                    var a = srcBuffer[src];
                    src++;
                    byteArray[dst] = r;
                    dst++; //r
                    byteArray[dst] = g;
                    dst++; //g
                    byteArray[dst] = b;
                    dst++; //b
                    byteArray[dst] = a;
                    dst++; //a
                }
            }
            return byteArray;
        };
        DDSParser.fourCCToInt32 = function (value) {
            return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
        };
        DDSParser.int32ToFourCC = function (value) {
            return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff69);
        };
        //软解DXT数据块到像素组;
        DDSParser.softSolutionDXT = function (width, height, format, byteArray) {
            var nCount;
            var colorArray = new Uint8Array(width * height * 4);
            //色彩表;
            var colorTab = [new egret3d.Color(), new egret3d.Color(), new egret3d.Color(), new egret3d.Color()];
            //索引表;
            var indexTab = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            switch (format) {
                case DDSFormat.RGB_S3TC_DXT1_FORMAT:
                case DDSFormat.RGBA_S3TC_DXT1_FORMAT:
                    {
                        nCount = byteArray.length / 8;
                        for (var blockIndex = 0; blockIndex < nCount; blockIndex++) {
                            var _16bit_0 = byteArray[blockIndex * 8 + 0] | (byteArray[blockIndex * 8 + 1] << 8);
                            var _16bit_1 = byteArray[blockIndex * 8 + 2] | (byteArray[blockIndex * 8 + 3] << 8);
                            //极端颜色1;
                            colorTab[0].r = (_16bit_0 >> 11) & 0x1F;
                            colorTab[0].g = (_16bit_0 >> 5) & 0x3F;
                            colorTab[0].b = _16bit_0 & 0x1F;
                            colorTab[0].a = 0xFF;
                            //极端颜色2;
                            colorTab[1].r = (_16bit_1 >> 11) & 0x1F;
                            colorTab[1].g = (_16bit_1 >> 5) & 0x3F;
                            colorTab[1].b = _16bit_1 & 0x1F;
                            colorTab[1].a = 0xFF;
                            if (_16bit_0 > _16bit_1) {
                                //线性插值计算出剩下的两个颜色;
                                colorTab[2].lerp(colorTab[0], colorTab[1], 0.33);
                                colorTab[3].lerp(colorTab[0], colorTab[1], 0.66);
                            }
                            else {
                                //线性插值计算出剩下的一个颜色;
                                colorTab[2].lerp(colorTab[0], colorTab[1], 0.5);
                            }
                            //取出16个2位索引;
                            for (var i = 0; i < 4; i++) {
                                indexTab[(i * 4) + 0] = byteArray[blockIndex * 8 + 4 + i] & 0x03;
                                indexTab[(i * 4) + 1] = (byteArray[blockIndex * 8 + 4 + i] >> 2) & 0x03;
                                indexTab[(i * 4) + 2] = (byteArray[blockIndex * 8 + 4 + i] >> 4) & 0x03;
                                indexTab[(i * 4) + 3] = (byteArray[blockIndex * 8 + 4 + i] >> 6) & 0x03;
                            }
                            for (var ci = 0; ci < colorTab.length; ci++) {
                                colorTab[ci].r = colorTab[ci].r * 8;
                                colorTab[ci].g = colorTab[ci].g * 4;
                                colorTab[ci].b = colorTab[ci].b * 8;
                            }
                            //填充像素数组;
                            var globalX = (blockIndex % (width / 4)) * 4;
                            var globalY = Math.floor(blockIndex / (width / 4)) * 4;
                            if (globalY + 0 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[0]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[0]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[0]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 3] = colorTab[indexTab[0]].a;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[1]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[1]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[1]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 3] = colorTab[indexTab[1]].a;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[2]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[2]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[2]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 3] = colorTab[indexTab[2]].a;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[3]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[3]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[3]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 3] = colorTab[indexTab[3]].a;
                                }
                            }
                            if (globalY + 1 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[4]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[4]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[4]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 3] = colorTab[indexTab[4]].a;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[5]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[5]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[5]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 3] = colorTab[indexTab[5]].a;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[6]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[6]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[6]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 3] = colorTab[indexTab[6]].a;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[7]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[7]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[7]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 3] = colorTab[indexTab[7]].a;
                                }
                            }
                            if (globalY + 2 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[8]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[8]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[8]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 3] = colorTab[indexTab[8]].a;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[9]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[9]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[9]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 3] = colorTab[indexTab[9]].a;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[10]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[10]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[10]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 3] = colorTab[indexTab[10]].a;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[11]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[11]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[11]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 3] = colorTab[indexTab[11]].a;
                                }
                            }
                            if (globalY + 3 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[12]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[12]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[12]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 3] = colorTab[indexTab[12]].a;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[13]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[13]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[13]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 3] = colorTab[indexTab[13]].a;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[14]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[14]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[14]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 3] = colorTab[indexTab[14]].a;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[15]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[15]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[15]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 3] = colorTab[indexTab[15]].a;
                                }
                            }
                        }
                    }
                    break;
                case DDSFormat.RGBA_S3TC_DXT3_FORMAT:
                    {
                        nCount = byteArray.length / 16;
                        for (var blockIndex = 0; blockIndex < nCount; blockIndex++) {
                            var _16bit_0 = byteArray[blockIndex * 16 + 8] | (byteArray[blockIndex * 16 + 9] << 8);
                            var _16bit_1 = byteArray[blockIndex * 16 + 10] | (byteArray[blockIndex * 16 + 11] << 8);
                            //极端颜色1;
                            colorTab[0].r = (_16bit_0 >> 11) & 0x1F;
                            colorTab[0].g = (_16bit_0 >> 5) & 0x3F;
                            colorTab[0].b = _16bit_0 & 0x1F;
                            colorTab[0].a = 0xFF;
                            //极端颜色2;
                            colorTab[1].r = (_16bit_1 >> 11) & 0x1F;
                            colorTab[1].g = (_16bit_1 >> 5) & 0x3F;
                            colorTab[1].b = _16bit_1 & 0x1F;
                            colorTab[1].a = 0xFF;
                            if (_16bit_0 > _16bit_1) {
                                //线性插值计算出剩下的两个颜色;
                                colorTab[2].lerp(colorTab[0], colorTab[1], 0.33);
                                colorTab[3].lerp(colorTab[0], colorTab[1], 0.66);
                            }
                            else {
                                //线性插值计算出剩下的一个颜色;
                                colorTab[2].lerp(colorTab[0], colorTab[1], 0.5);
                                colorTab[3].a = 0;
                            }
                            //取出16个2位索引;
                            for (var i = 0; i < 4; i++) {
                                indexTab[(i * 4) + 0] = byteArray[blockIndex * 16 + 12 + i] & 0x03;
                                indexTab[(i * 4) + 1] = (byteArray[blockIndex * 16 + 12 + i] >> 2) & 0x03;
                                indexTab[(i * 4) + 2] = (byteArray[blockIndex * 16 + 12 + i] >> 4) & 0x03;
                                indexTab[(i * 4) + 3] = (byteArray[blockIndex * 16 + 12 + i] >> 6) & 0x03;
                            }
                            for (var ci = 0; ci < colorTab.length; ci++) {
                                colorTab[ci].r = colorTab[ci].r * 8;
                                colorTab[ci].g = colorTab[ci].g * 4;
                                colorTab[ci].b = colorTab[ci].b * 8;
                            }
                            //填充像素数组;
                            var globalX = (blockIndex % (width / 4)) * 4;
                            var globalY = Math.floor(blockIndex / (width / 4)) * 4;
                            if (globalY + 0 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[0]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[0]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[0]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 3] = (byteArray[blockIndex * 16 + 0] & 0x0F) * 17;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[1]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[1]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[1]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 3] = ((byteArray[blockIndex * 16 + 0] >> 4) & 0x0F) * 17;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[2]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[2]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[2]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 3] = (byteArray[blockIndex * 16 + 1] & 0x0F) * 17;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[3]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[3]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[3]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 3] = ((byteArray[blockIndex * 16 + 1] >> 4) & 0x0F) * 17;
                                }
                            }
                            if (globalY + 1 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[4]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[4]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[4]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 3] = (byteArray[blockIndex * 16 + 2] & 0x0F) * 17;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[5]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[5]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[5]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 3] = ((byteArray[blockIndex * 16 + 2] >> 4) & 0x0F) * 17;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[6]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[6]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[6]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 3] = (byteArray[blockIndex * 16 + 3] & 0x0F) * 17;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[7]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[7]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[7]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 3] = ((byteArray[blockIndex * 16 + 3] >> 4) & 0x0F) * 17;
                                }
                            }
                            if (globalY + 2 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[8]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[8]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[8]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 3] = (byteArray[blockIndex * 16 + 4] & 0x0F) * 17;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[9]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[9]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[9]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 3] = ((byteArray[blockIndex * 16 + 4] >> 4) & 0x0F) * 17;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[10]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[10]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[10]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 3] = (byteArray[blockIndex * 16 + 5] & 0x0F) * 17;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[11]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[11]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[11]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 3] = ((byteArray[blockIndex * 16 + 5] >> 4) & 0x0F) * 17;
                                }
                            }
                            if (globalY + 3 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[12]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[12]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[12]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 3] = (byteArray[blockIndex * 16 + 6] & 0x0F) * 17;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[13]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[13]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[13]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 3] = ((byteArray[blockIndex * 16 + 6] >> 4) & 0x0F) * 17;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[14]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[14]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[14]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 3] = (byteArray[blockIndex * 16 + 7] & 0x0F) * 17;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[15]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[15]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[15]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 3] = ((byteArray[blockIndex * 16 + 7] >> 4) & 0x0F) * 17;
                                }
                            }
                        }
                    }
                    break;
                case DDSFormat.RGBA_S3TC_DXT5_FORMAT:
                    break;
            }
            return colorArray;
        };
        return DDSParser;
    }());
    egret3d.DDSParser = DDSParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.PVR
     * @classdesc
     * PVR  object
     */
    var PVR = (function () {
        function PVR() {
        }
        return PVR;
    }());
    egret3d.PVR = PVR;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    (function (PVRFormat) {
        PVRFormat[PVRFormat["RGB_PVRTC_4BPPV1_Format"] = 2100] = "RGB_PVRTC_4BPPV1_Format";
        PVRFormat[PVRFormat["RGB_PVRTC_2BPPV1_Format"] = 2101] = "RGB_PVRTC_2BPPV1_Format";
        PVRFormat[PVRFormat["RGBA_PVRTC_4BPPV1_Format"] = 2102] = "RGBA_PVRTC_4BPPV1_Format";
        PVRFormat[PVRFormat["RGBA_PVRTC_2BPPV1_Format"] = 2103] = "RGBA_PVRTC_2BPPV1_Format";
    })(egret3d.PVRFormat || (egret3d.PVRFormat = {}));
    var PVRFormat = egret3d.PVRFormat;
    ;
    /**
     * @private
     * @language zh_CN
     * @class egret3d.PVRParser
     * @classdesc
     * �� PVRParser �� ����.pvr �ļ�
     */
    var PVRParser = (function () {
        function PVRParser() {
        }
        /**
         * @language zh_CN
         * @param buffer
         */
        PVRParser.parse = function (buffer) {
            var pvr = new egret3d.PVR;
            var headerLengthInt = 13;
            var header = new Uint32Array(buffer, 0, headerLengthInt);
            var pvrDatas = {
                buffer: buffer,
                header: header
            };
            // PVR v3
            if (header[0] === 0x03525650) {
                pvr = PVRParser._parseV3(pvrDatas);
            }
            else if (header[11] === 0x21525650) {
                pvr = PVRParser._parseV2(pvrDatas);
            }
            else {
                console.log("PVRParser unknow pvr format. PVRParser::parse");
            }
            return pvr;
        };
        PVRParser._parseV2 = function (pvrDatas) {
            var header = pvrDatas.header;
            var headerLength = header[0], height = header[1], width = header[2], numMipmaps = header[3], flags = header[4], dataLength = header[5], bpp = header[6], bitmaskRed = header[7], bitmaskGreen = header[8], bitmaskBlue = header[9], bitmaskAlpha = header[10], pvrTag = header[11], numSurfs = header[12];
            var TYPE_MASK = 0xff;
            var PVRTC_2 = 24, PVRTC_4 = 25;
            var formatFlags = flags & TYPE_MASK;
            var bpp, format;
            var _hasAlpha = bitmaskAlpha > 0;
            if (formatFlags === PVRTC_4) {
                format = _hasAlpha ? PVRFormat.RGBA_PVRTC_4BPPV1_Format : PVRFormat.RGB_PVRTC_4BPPV1_Format;
                bpp = 4;
            }
            else if (formatFlags === PVRTC_2) {
                format = _hasAlpha ? PVRFormat.RGBA_PVRTC_2BPPV1_Format : PVRFormat.RGB_PVRTC_2BPPV1_Format;
                bpp = 2;
            }
            else
                throw new Error("pvrtc - unknown format " + formatFlags);
            pvrDatas.dataPtr = headerLength;
            pvrDatas.bpp = bpp;
            pvrDatas.format = format;
            pvrDatas.width = width;
            pvrDatas.height = height;
            pvrDatas.numSurfaces = numSurfs;
            pvrDatas.numMipmaps = numMipmaps + 1;
            // guess cubemap type seems tricky in v2
            // it juste a pvr containing 6 surface (no explicit cubemap type)
            pvrDatas.isCubemap = (numSurfs === 6);
            return PVRParser._extract(pvrDatas);
        };
        PVRParser._parseV3 = function (pvrDatas) {
            var header = pvrDatas.header;
            var bpp, format;
            var metaLen = header[12], pixelFormat = header[2], height = header[6], width = header[7], numSurfs = header[9], numFaces = header[10], numMipmaps = header[11];
            switch (pixelFormat) {
                case 0:
                    bpp = 2;
                    format = PVRFormat.RGB_PVRTC_2BPPV1_Format;
                    break;
                case 1:
                    bpp = 2;
                    format = PVRFormat.RGBA_PVRTC_2BPPV1_Format;
                    break;
                case 2:
                    bpp = 4;
                    format = PVRFormat.RGB_PVRTC_4BPPV1_Format;
                    break;
                case 3:
                    bpp = 4;
                    format = PVRFormat.RGBA_PVRTC_4BPPV1_Format;
                    break;
                default:
                    throw new Error("pvrtc - unsupported PVR format " + pixelFormat);
            }
            pvrDatas.dataPtr = 52 + metaLen;
            pvrDatas.bpp = bpp;
            pvrDatas.format = format;
            pvrDatas.width = width;
            pvrDatas.height = height;
            pvrDatas.numSurfaces = numFaces;
            pvrDatas.numMipmaps = numMipmaps;
            pvrDatas.isCubemap = (numFaces === 6);
            return PVRParser._extract(pvrDatas);
        };
        PVRParser._extract = function (pvrDatas) {
            var pvr = new egret3d.PVR();
            var buffer = pvrDatas.buffer;
            var dataOffset = pvrDatas.dataPtr, bpp = pvrDatas.bpp, numSurfs = pvrDatas.numSurfaces, dataSize = 0, blockSize = 0, blockWidth = 0, blockHeight = 0, widthBlocks = 0, heightBlocks = 0;
            if (bpp === 2) {
                blockWidth = 8;
                blockHeight = 4;
            }
            else {
                blockWidth = 4;
                blockHeight = 4;
            }
            blockSize = (blockWidth * blockHeight) * bpp / 8;
            pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;
            var mipLevel = 0;
            while (mipLevel < pvrDatas.numMipmaps) {
                var sWidth = pvrDatas.width >> mipLevel;
                var sHeight = pvrDatas.height >> mipLevel;
                widthBlocks = sWidth / blockWidth;
                heightBlocks = sHeight / blockHeight;
                // Clamp to minimum number of blocks
                if (widthBlocks < 2) {
                    widthBlocks = 2;
                }
                if (heightBlocks < 2) {
                    heightBlocks = 2;
                }
                dataSize = widthBlocks * heightBlocks * blockSize;
                for (var surfIndex = 0; surfIndex < numSurfs; surfIndex++) {
                    var byteArray = new Uint8Array(buffer, dataOffset, dataSize);
                    var mipmap = {
                        data: byteArray,
                        width: sWidth,
                        height: sHeight
                    };
                    pvr.mipmaps[surfIndex * pvrDatas.numMipmaps + mipLevel] = mipmap;
                    dataOffset += dataSize;
                }
                mipLevel++;
            }
            return pvr;
        };
        return PVRParser;
    }());
    egret3d.PVRParser = PVRParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var TGA = (function () {
        function TGA(data, width, height) {
            this.data = data;
            this.width = width;
            this.height = height;
        }
        return TGA;
    }());
    egret3d.TGA = TGA;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.TGAParser
     * @classdesc
     * 用 TGAParser 类 解析.tga 文件
     */
    var TGAParser = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function TGAParser() {
        }
        /**
         * @language zh_CN
         * @param buffer 二进制流
         * @returns TGATexture
         */
        TGAParser.parse = function (buffer) {
            var TGA_TYPE_NO_DATA = 0, TGA_TYPE_INDEXED = 1, TGA_TYPE_RGB = 2, TGA_TYPE_GREY = 3, TGA_TYPE_RLE_INDEXED = 9, TGA_TYPE_RLE_RGB = 10, TGA_TYPE_RLE_GREY = 11, TGA_ORIGIN_MASK = 0x30, TGA_ORIGIN_SHIFT = 0x04, TGA_ORIGIN_BL = 0x00, TGA_ORIGIN_BR = 0x01, TGA_ORIGIN_UL = 0x02, TGA_ORIGIN_UR = 0x03;
            if (buffer.byteLength < 19) {
                console.error('TGAParser.parse: Not enough data to contain header.');
            }
            var content = new Uint8Array(buffer), offset = 0, header = {
                id_length: content[offset++],
                colormap_type: content[offset++],
                image_type: content[offset++],
                colormap_index: content[offset++] | content[offset++] << 8,
                colormap_length: content[offset++] | content[offset++] << 8,
                colormap_size: content[offset++],
                origin: [
                    content[offset++] | content[offset++] << 8,
                    content[offset++] | content[offset++] << 8
                ],
                width: content[offset++] | content[offset++] << 8,
                height: content[offset++] | content[offset++] << 8,
                pixel_size: content[offset++],
                flags: content[offset++]
            };
            function tgaCheckHeader(header) {
                switch (header.image_type) {
                    // Check indexed type
                    case TGA_TYPE_INDEXED:
                    case TGA_TYPE_RLE_INDEXED:
                        if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {
                            console.error('TGAParser.parse.tgaCheckHeader: Invalid type colormap data for indexed type');
                        }
                        break;
                    // Check colormap type
                    case TGA_TYPE_RGB:
                    case TGA_TYPE_GREY:
                    case TGA_TYPE_RLE_RGB:
                    case TGA_TYPE_RLE_GREY:
                        if (header.colormap_type) {
                            console.error('TGAParser.parse.tgaCheckHeader: Invalid type colormap data for colormap type');
                        }
                        break;
                    // What the need of a file without data ?
                    case TGA_TYPE_NO_DATA:
                        console.error('TGAParser.parse.tgaCheckHeader: No data');
                        break;
                    // Invalid type ?
                    default:
                        console.error('TGAParser.parse.tgaCheckHeader: Invalid type " ' + header.image_type + '"');
                }
                // Check image width and height
                if (header.width <= 0 || header.height <= 0) {
                    console.error('TGAParser.parse.tgaCheckHeader: Invalid image size');
                }
                // Check image pixel size
                if (header.pixel_size !== 8 &&
                    header.pixel_size !== 16 &&
                    header.pixel_size !== 24 &&
                    header.pixel_size !== 32) {
                    console.error('TGAParser.parse.tgaCheckHeader: Invalid pixel size "' + header.pixel_size + '"');
                }
            }
            // Check tga if it is valid format
            tgaCheckHeader(header);
            if (header.id_length + offset > buffer.byteLength) {
                console.error('TGAParser.parse: No data');
            }
            // Skip the needn't data
            offset += header.id_length;
            // Get targa information about RLE compression and palette
            var use_rle = false, use_pal = false, use_grey = false;
            switch (header.image_type) {
                case TGA_TYPE_RLE_INDEXED:
                    use_rle = true;
                    use_pal = true;
                    break;
                case TGA_TYPE_INDEXED:
                    use_pal = true;
                    break;
                case TGA_TYPE_RLE_RGB:
                    use_rle = true;
                    break;
                case TGA_TYPE_RGB:
                    break;
                case TGA_TYPE_RLE_GREY:
                    use_rle = true;
                    use_grey = true;
                    break;
                case TGA_TYPE_GREY:
                    use_grey = true;
                    break;
            }
            // Parse tga image buffer
            function tgaParse(use_rle, use_pal, header, offset, data) {
                var pixel_data, pixel_size, pixel_total, palettes;
                pixel_size = header.pixel_size >> 3;
                pixel_total = header.width * header.height * pixel_size;
                // Read palettes
                if (use_pal) {
                    palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));
                }
                // Read RLE
                if (use_rle) {
                    pixel_data = new Uint8Array(pixel_total);
                    var c, count, i;
                    var shift = 0;
                    var pixels = new Uint8Array(pixel_size);
                    while (shift < pixel_total) {
                        c = data[offset++];
                        count = (c & 0x7f) + 1;
                        // RLE pixels.
                        if (c & 0x80) {
                            // Bind pixel tmp array
                            for (i = 0; i < pixel_size; ++i) {
                                pixels[i] = data[offset++];
                            }
                            // Copy pixel array
                            for (i = 0; i < count; ++i) {
                                pixel_data.set(pixels, shift + i * pixel_size);
                            }
                            shift += pixel_size * count;
                        }
                        else {
                            // Raw pixels.
                            count *= pixel_size;
                            for (i = 0; i < count; ++i) {
                                pixel_data[shift + i] = data[offset++];
                            }
                            shift += count;
                        }
                    }
                }
                else {
                    // RAW Pixels
                    pixel_data = data.subarray(offset, offset += (use_pal ? header.width * header.height : pixel_total));
                }
                return {
                    pixel_data: pixel_data,
                    palettes: palettes
                };
            }
            function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {
                var colormap = palettes;
                var color, i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i++) {
                        color = image[i];
                        imageData[(x + width * y) * 4 + 3] = 255;
                        imageData[(x + width * y) * 4 + 2] = colormap[(color * 3) + 0];
                        imageData[(x + width * y) * 4 + 1] = colormap[(color * 3) + 1];
                        imageData[(x + width * y) * 4 + 0] = colormap[(color * 3) + 2];
                    }
                }
                return imageData;
            }
            function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var color, i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i += 2) {
                        color = image[i + 0] + (image[i + 1] << 8); // Inversed ?
                        imageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;
                        imageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;
                        imageData[(x + width * y) * 4 + 2] = (color & 0x001F) >> 3;
                        imageData[(x + width * y) * 4 + 3] = (color & 0x8000) ? 0 : 255;
                    }
                }
                return imageData;
            }
            function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i += 3) {
                        imageData[(x + width * y) * 4 + 3] = 255;
                        imageData[(x + width * y) * 4 + 2] = image[i + 0];
                        imageData[(x + width * y) * 4 + 1] = image[i + 1];
                        imageData[(x + width * y) * 4 + 0] = image[i + 2];
                    }
                }
                return imageData;
            }
            function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i += 4) {
                        imageData[(x + width * y) * 4 + 2] = image[i + 0];
                        imageData[(x + width * y) * 4 + 1] = image[i + 1];
                        imageData[(x + width * y) * 4 + 0] = image[i + 2];
                        imageData[(x + width * y) * 4 + 3] = image[i + 3];
                    }
                }
                return imageData;
            }
            function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var color, i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i++) {
                        color = image[i];
                        imageData[(x + width * y) * 4 + 0] = color;
                        imageData[(x + width * y) * 4 + 1] = color;
                        imageData[(x + width * y) * 4 + 2] = color;
                        imageData[(x + width * y) * 4 + 3] = 255;
                    }
                }
                return imageData;
            }
            function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i += 2) {
                        imageData[(x + width * y) * 4 + 0] = image[i + 0];
                        imageData[(x + width * y) * 4 + 1] = image[i + 0];
                        imageData[(x + width * y) * 4 + 2] = image[i + 0];
                        imageData[(x + width * y) * 4 + 3] = image[i + 1];
                    }
                }
                return imageData;
            }
            function getTgaRGBA(width, height, image, palette) {
                var x_start, y_start, x_step, y_step, x_end, y_end, data = new Uint8Array(width * height * 4);
                switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {
                    default:
                    case TGA_ORIGIN_UL:
                        x_start = 0;
                        x_step = 1;
                        x_end = width;
                        y_start = 0;
                        y_step = 1;
                        y_end = height;
                        break;
                    case TGA_ORIGIN_BL:
                        x_start = 0;
                        x_step = 1;
                        x_end = width;
                        y_start = height - 1;
                        y_step = -1;
                        y_end = -1;
                        break;
                    case TGA_ORIGIN_UR:
                        x_start = width - 1;
                        x_step = -1;
                        x_end = -1;
                        y_start = 0;
                        y_step = 1;
                        y_end = height;
                        break;
                    case TGA_ORIGIN_BR:
                        x_start = width - 1;
                        x_step = -1;
                        x_end = -1;
                        y_start = height - 1;
                        y_step = -1;
                        y_end = -1;
                        break;
                }
                if (use_grey) {
                    switch (header.pixel_size) {
                        case 8:
                            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        case 16:
                            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        default:
                            console.error('TGAParser.parse.getTgaRGBA: not support this format');
                            break;
                    }
                }
                else {
                    switch (header.pixel_size) {
                        case 8:
                            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);
                            break;
                        case 16:
                            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        case 24:
                            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        case 32:
                            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        default:
                            console.error('TGAParser.parse.getTgaRGBA: not support this format');
                            break;
                    }
                }
                // Load image data according to specific method
                // var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';
                // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );
                return data;
            }
            var result = tgaParse(use_rle, use_pal, header, offset, content);
            var rgbaData = getTgaRGBA(header.width, header.height, result.pixel_data, result.palettes);
            var texture = new egret3d.TGATexture();
            texture.internalFormat = egret3d.InternalFormat.PixelArray;
            texture.colorFormat = egret3d.ContextConfig.ColorFormat_RGBA8888;
            texture.mimapData = [new egret3d.MipmapData(rgbaData, header.width, header.height)];
            return texture;
        };
        return TGAParser;
    }());
    egret3d.TGAParser = TGAParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.EAMParser
     * @classdesc
     * 用 EAMParser 类 解析.eam 文件
     */
    var EAMParser = (function () {
        function EAMParser() {
        }
        /**
         * @language zh_CN
         * @param datas 加载的二进制流
         * @returns SkeletonAnimationClip
         */
        EAMParser.parse = function (datas) {
            var bytes = new egret3d.ByteArray(datas);
            var fileFormatBytes = new egret3d.ByteArray();
            bytes.readBytes(fileFormatBytes, 0, 3);
            var version = bytes.readUnsignedInt();
            if (!egret3d.EAMVersion.versionDictionary[version]) {
                console.log("egret3d engine not found " + version + " version");
                return null;
            }
            return egret3d.EAMVersion.versionDictionary[version](bytes);
        };
        return EAMParser;
    }());
    egret3d.EAMParser = EAMParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.EAMVersion
     * @classdesc
     *
     */
    var EAMVersion = (function () {
        function EAMVersion() {
        }
        EAMVersion.parserVersion_1 = function (bytes) {
            var boneCount = bytes.readUnsignedByte();
            var sampling = bytes.readUnsignedByte();
            if (boneCount <= 0)
                return null;
            var skeletonAnimationClip = new egret3d.SkeletonAnimationClip();
            var boneNameArray = new Array();
            var parentBoneNameArray = new Array();
            for (var i = 0; i < boneCount; i++) {
                boneNameArray.push(bytes.readUTF());
                parentBoneNameArray.push(bytes.readUTF());
            }
            var frameCount = bytes.readInt();
            var nCount = bytes.readInt();
            var orientation = new egret3d.Quaternion();
            var scale = new egret3d.Vector3D();
            var translation = new egret3d.Vector3D();
            for (var i = 0; i < nCount; i++) {
                var skeletonPose = new egret3d.SkeletonPose();
                skeletonPose.frameTime = bytes.readInt() / 60 / 80 * 1000;
                for (var j = 0; j < boneCount; j++) {
                    var jointPose = new egret3d.Joint(boneNameArray[j]);
                    jointPose.parent = parentBoneNameArray[j];
                    jointPose.parentIndex = skeletonPose.findJointIndex(jointPose.parent);
                    orientation.fromEulerAngles(bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES, bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES, bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES);
                    scale.x = bytes.readFloat();
                    scale.y = bytes.readFloat();
                    scale.z = bytes.readFloat();
                    translation.x = bytes.readFloat();
                    translation.y = bytes.readFloat();
                    translation.z = bytes.readFloat();
                    jointPose.buildLocalMatrix(scale, orientation, translation);
                    skeletonPose.joints.push(jointPose);
                }
                skeletonPose.calculateJointWorldMatrix();
                skeletonAnimationClip.poseArray.push(skeletonPose);
            }
            return skeletonAnimationClip;
        };
        EAMVersion.parserVersion_2 = function (bytes) {
            //读取骨骼数;
            var boneCount = bytes.readUnsignedByte();
            //读取采样率;
            var sampling = bytes.readUnsignedByte();
            if (boneCount <= 0)
                return null;
            var skeletonAnimationClip = new egret3d.SkeletonAnimationClip();
            var boneNameArray = new Array();
            var parentBoneNameArray = new Array();
            //读取骨骼名称;
            for (var i = 0; i < boneCount; i++) {
                boneNameArray.push(bytes.readUTF());
                parentBoneNameArray.push(bytes.readUTF());
            }
            //读取帧数;
            var frameCount = bytes.readInt();
            //读取数量;
            var nCount = bytes.readInt();
            var orientation = new egret3d.Quaternion();
            var scale = new egret3d.Vector3D();
            var translation = new egret3d.Vector3D();
            for (var i = 0; i < nCount; i++) {
                var skeletonPose = new egret3d.SkeletonPose();
                //读取该帧时刻;
                skeletonPose.frameTime = bytes.readInt() / 60 / 80 * 1000;
                for (var j = 0; j < boneCount; j++) {
                    var jointPose = new egret3d.Joint(boneNameArray[j]);
                    jointPose.parent = parentBoneNameArray[j];
                    jointPose.parentIndex = skeletonPose.findJointIndex(jointPose.parent);
                    //读取旋转四元数分量;
                    orientation.x = bytes.readFloat();
                    orientation.y = bytes.readFloat();
                    orientation.z = bytes.readFloat();
                    orientation.w = bytes.readFloat();
                    //读取缩放分量;
                    scale.x = bytes.readFloat();
                    scale.y = bytes.readFloat();
                    scale.z = bytes.readFloat();
                    //读取平移分量;
                    translation.x = bytes.readFloat();
                    translation.y = bytes.readFloat();
                    translation.z = bytes.readFloat();
                    jointPose.buildLocalMatrix(scale, orientation, translation);
                    skeletonPose.joints.push(jointPose);
                }
                skeletonPose.calculateJointWorldMatrix();
                skeletonAnimationClip.poseArray.push(skeletonPose);
            }
            return skeletonAnimationClip;
        };
        EAMVersion.parserVersion_3 = function (bytes) {
            return null;
        };
        EAMVersion.versionDictionary = {
            1: function (bytes) { return EAMVersion.parserVersion_1(bytes); },
            2: function (bytes) { return EAMVersion.parserVersion_2(bytes); },
            3: function (bytes) { return EAMVersion.parserVersion_3(bytes); },
        };
        return EAMVersion;
    }());
    egret3d.EAMVersion = EAMVersion;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ECAParser
     * @classdesc
     * 用 EAMParser 类 解析.eca 文件
     */
    var ECAParser = (function () {
        function ECAParser() {
        }
        /**
         * @language zh_CN
         * @param datas 加载的二进制流
         * @returns CameraAnimationController
         */
        ECAParser.parse = function (datas) {
            var bytes = new egret3d.ByteArray(datas);
            var fileFormatBytes = new egret3d.ByteArray();
            bytes.readBytes(fileFormatBytes, 0, 3);
            var version = bytes.readUnsignedInt();
            if (!egret3d.ECAVersion.versionDictionary[version]) {
                console.log("egret3d engine not found " + version + " version");
                return null;
            }
            return egret3d.ECAVersion.versionDictionary[version](bytes);
        };
        return ECAParser;
    }());
    egret3d.ECAParser = ECAParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ECAVersion
     * @classdesc
     */
    var ECAVersion = (function () {
        function ECAVersion() {
        }
        ECAVersion.parserVersion_1 = function (bytes) {
            var cameraAnimationController = new egret3d.CameraAnimationController();
            var nFrame = bytes.readUnsignedInt();
            var cameraAnimationFrame = null;
            var scaling = new egret3d.Vector3D(1, 1, 1, 1);
            while (nFrame--) {
                cameraAnimationFrame = new egret3d.CameraAnimationFrame();
                cameraAnimationFrame.time = bytes.readInt();
                cameraAnimationFrame.fov = bytes.readFloat();
                cameraAnimationFrame.rotation = new egret3d.Vector3D(bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES + 90, bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES, bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES);
                cameraAnimationFrame.translation = new egret3d.Vector3D(bytes.readFloat(), bytes.readFloat(), bytes.readFloat());
                cameraAnimationFrame.matrix = new egret3d.Matrix4_4();
                cameraAnimationFrame.matrix.recompose([cameraAnimationFrame.translation, cameraAnimationFrame.rotation, scaling]);
                cameraAnimationController.cameraAnimationFrames.push(cameraAnimationFrame);
            }
            return cameraAnimationController;
        };
        ECAVersion.versionDictionary = {
            1: function (bytes) { return ECAVersion.parserVersion_1(bytes); },
        };
        return ECAVersion;
    }());
    egret3d.ECAVersion = ECAVersion;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ESMParser
     * @classdesc
     * 用 ESMParser 类 解析.esm 文件
     */
    var ESMParser = (function () {
        function ESMParser() {
        }
        /**
          * @language zh_CN
          * 从二进制流中解析出模型Geometry信息
          * @param datas 加载的二进制流
          * @returns Geometry
          */
        ESMParser.parse = function (datas) {
            var bytes = new egret3d.ByteArray(datas);
            var fileFormatBytes = new egret3d.ByteArray();
            bytes.readBytes(fileFormatBytes, 0, 3);
            var version = bytes.readUnsignedInt();
            if (!egret3d.ESMVersion.versionDictionary[version]) {
                console.log("egret3d engine not found " + version + " version");
                return null;
            }
            var geomtryData = new egret3d.GeometryData();
            egret3d.ESMVersion.versionDictionary[version](bytes, geomtryData);
            var geomtry;
            var vertexFormat = 0;
            if (geomtryData.source_skinData.length > 0) {
                vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_SKIN;
                geomtry = egret3d.GeometryData.buildGeomtry(geomtryData, vertexFormat);
            }
            else {
                vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_UV1;
                geomtry = egret3d.GeometryData.buildGeomtry(geomtryData, vertexFormat);
            }
            return geomtry;
        };
        return ESMParser;
    }());
    egret3d.ESMParser = ESMParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ESMVersion
     * @classdesc
     *
     */
    var ESMVersion = (function () {
        function ESMVersion() {
        }
        ESMVersion.parserVersion_1 = function (bytes, geomtry) {
            var description = bytes.readInt();
            geomtry.matCount = bytes.readInt();
            for (var i = 0; i < geomtry.matCount; ++i) {
                geomtry.material[i] = {};
                geomtry.material[i].matID = bytes.readInt();
                geomtry.material[i].start = bytes.readInt();
                geomtry.material[i].count = bytes.readInt();
                geomtry.material[i].textureDiffuse = bytes.readUTF();
                geomtry.material[i].textureNormal = bytes.readUTF();
                geomtry.material[i].textureSpecular = bytes.readUTF();
            }
            if (description & egret3d.VertexFormat.VF_POSITION) {
                var vertexCount = bytes.readInt();
                for (var i = 0; i < vertexCount; i++) {
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_NORMAL) {
                var vertexNormalCount = bytes.readInt();
                for (var i = 0; i < vertexNormalCount; i++) {
                    geomtry.source_normalData.push(bytes.readFloat());
                    geomtry.source_normalData.push(bytes.readFloat());
                    geomtry.source_normalData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_COLOR) {
                var vertexColorCount = bytes.readInt();
                for (var i = 0; i < vertexColorCount; i++) {
                    geomtry.source_vertexColorData.push(bytes.readFloat());
                    geomtry.source_vertexColorData.push(bytes.readFloat());
                    geomtry.source_vertexColorData.push(bytes.readFloat());
                    geomtry.source_vertexColorData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_UV0) {
                var uvCount = bytes.readInt();
                for (var i = 0; i < uvCount; i++) {
                    geomtry.source_uvData.push(bytes.readFloat());
                    geomtry.source_uvData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_UV1) {
                var uvCount = bytes.readInt();
                for (var i = 0; i < uvCount; i++) {
                    geomtry.source_uv2Data.push(bytes.readFloat());
                    geomtry.source_uv2Data.push(bytes.readFloat());
                }
            }
            geomtry.faces = bytes.readInt();
            for (var i = 0; i < geomtry.faces; i++) {
                geomtry.vertexIndices.push(bytes.readUnsignedInt());
                geomtry.vertexIndices.push(bytes.readUnsignedInt());
                geomtry.vertexIndices.push(bytes.readUnsignedInt());
                if (description & egret3d.VertexFormat.VF_NORMAL) {
                    geomtry.normalIndices.push(bytes.readUnsignedInt());
                    geomtry.normalIndices.push(bytes.readUnsignedInt());
                    geomtry.normalIndices.push(bytes.readUnsignedInt());
                }
                if (description & egret3d.VertexFormat.VF_COLOR) {
                    geomtry.colorIndices.push(bytes.readUnsignedInt());
                    geomtry.colorIndices.push(bytes.readUnsignedInt());
                    geomtry.colorIndices.push(bytes.readUnsignedInt());
                }
                if (description & egret3d.VertexFormat.VF_UV0) {
                    geomtry.uvIndices.push(bytes.readUnsignedInt());
                    geomtry.uvIndices.push(bytes.readUnsignedInt());
                    geomtry.uvIndices.push(bytes.readUnsignedInt());
                }
                if (description & egret3d.VertexFormat.VF_UV1) {
                    geomtry.uv2Indices.push(bytes.readUnsignedInt());
                    geomtry.uv2Indices.push(bytes.readUnsignedInt());
                    geomtry.uv2Indices.push(bytes.readUnsignedInt());
                }
            }
            var nBoneCount = bytes.readUnsignedByte();
            if (nBoneCount > 0) {
                geomtry.skeleton = new egret3d.Skeleton();
            }
            var orientation = new egret3d.Quaternion();
            var rotation = new egret3d.Vector3D();
            var scaling = new egret3d.Vector3D();
            var translation = new egret3d.Vector3D();
            for (var i = 0; i < nBoneCount; ++i) {
                var joint = new egret3d.Joint(null);
                bytes.readInt();
                joint.parentIndex = bytes.readInt();
                joint.name = bytes.readUTF();
                rotation.x = bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES;
                rotation.y = bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES;
                rotation.z = bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES;
                scaling.x = bytes.readFloat();
                scaling.y = bytes.readFloat();
                scaling.z = bytes.readFloat();
                translation.x = bytes.readFloat();
                translation.y = bytes.readFloat();
                translation.z = bytes.readFloat();
                joint.buildInverseMatrix(scaling, rotation, translation);
                geomtry.skeleton.joints.push(joint);
            }
            var nVertsCount = bytes.readInt();
            for (var i = 0; i < nVertsCount; i++) {
                var nCount = bytes.readUnsignedByte();
                for (var j = 0; j < nCount; j++) {
                    geomtry.source_skinData.push(bytes.readUnsignedByte());
                    geomtry.source_skinData.push(bytes.readFloat());
                }
                for (var j = nCount; j < 4; j++) {
                    geomtry.source_skinData.push(0);
                    geomtry.source_skinData.push(0);
                }
            }
        };
        ESMVersion.parserVersion_2 = function (bytes, geomtry) {
            var description = bytes.readInt();
            geomtry.matCount = bytes.readInt();
            for (var i = 0; i < geomtry.matCount; ++i) {
                geomtry.material[i] = {};
                geomtry.material[i].matID = bytes.readInt();
                geomtry.material[i].start = bytes.readInt();
                geomtry.material[i].count = bytes.readInt();
                geomtry.material[i].textureDiffuse = bytes.readUTF();
                geomtry.material[i].textureNormal = bytes.readUTF();
                geomtry.material[i].textureSpecular = bytes.readUTF();
            }
            if (description & egret3d.VertexFormat.VF_POSITION) {
                var vertexCount = bytes.readInt();
                for (var i = 0; i < vertexCount; i++) {
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_NORMAL) {
                var vertexNormalCount = bytes.readInt();
                for (var i = 0; i < vertexNormalCount; i++) {
                    geomtry.source_normalData.push(bytes.readFloat());
                    geomtry.source_normalData.push(bytes.readFloat());
                    geomtry.source_normalData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_COLOR) {
                var vertexColorCount = bytes.readInt();
                for (var i = 0; i < vertexColorCount; i++) {
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                }
            }
            if (description & egret3d.VertexFormat.VF_UV0) {
                var uvCount = bytes.readInt();
                for (var i = 0; i < uvCount; i++) {
                    geomtry.source_uvData.push(bytes.readFloat());
                    geomtry.source_uvData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_UV1) {
                var uvCount = bytes.readInt();
                for (var i = 0; i < uvCount; i++) {
                    geomtry.source_uv2Data.push(bytes.readFloat());
                    geomtry.source_uv2Data.push(bytes.readFloat());
                }
            }
            geomtry.faces = bytes.readInt();
            for (var i = 0; i < geomtry.faces; i++) {
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                if (description & egret3d.VertexFormat.VF_NORMAL) {
                    geomtry.normalIndices.push(bytes.readUnsignedShort());
                    geomtry.normalIndices.push(bytes.readUnsignedShort());
                    geomtry.normalIndices.push(bytes.readUnsignedShort());
                }
                if (description & egret3d.VertexFormat.VF_COLOR) {
                    geomtry.colorIndices.push(bytes.readUnsignedShort());
                    geomtry.colorIndices.push(bytes.readUnsignedShort());
                    geomtry.colorIndices.push(bytes.readUnsignedShort());
                }
                if (description & egret3d.VertexFormat.VF_UV0) {
                    geomtry.uvIndices.push(bytes.readUnsignedShort());
                    geomtry.uvIndices.push(bytes.readUnsignedShort());
                    geomtry.uvIndices.push(bytes.readUnsignedShort());
                }
                if (description & egret3d.VertexFormat.VF_UV1) {
                    geomtry.uv2Indices.push(bytes.readUnsignedShort());
                    geomtry.uv2Indices.push(bytes.readUnsignedShort());
                    geomtry.uv2Indices.push(bytes.readUnsignedShort());
                }
            }
            var nBoneCount = bytes.readUnsignedByte();
            if (nBoneCount > 0) {
                geomtry.skeleton = new egret3d.Skeleton();
            }
            var orientation = new egret3d.Quaternion();
            var rotation = new egret3d.Vector3D();
            var scaling = new egret3d.Vector3D();
            var translation = new egret3d.Vector3D();
            for (var i = 0; i < nBoneCount; ++i) {
                var joint = new egret3d.Joint(null);
                bytes.readInt();
                joint.parentIndex = bytes.readInt();
                joint.name = bytes.readUTF();
                rotation.x = bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES;
                rotation.y = bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES;
                rotation.z = bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES;
                scaling.x = bytes.readFloat();
                scaling.y = bytes.readFloat();
                scaling.z = bytes.readFloat();
                translation.x = bytes.readFloat();
                translation.y = bytes.readFloat();
                translation.z = bytes.readFloat();
                joint.buildInverseMatrix(scaling, rotation, translation);
                geomtry.skeleton.joints.push(joint);
            }
            var nVertsCount = bytes.readInt();
            for (var i = 0; i < nVertsCount; i++) {
                var nCount = bytes.readUnsignedByte();
                for (var j = 0; j < nCount; j++) {
                    geomtry.source_skinData.push(bytes.readUnsignedByte());
                    geomtry.source_skinData.push(bytes.readFloat());
                }
                for (var j = nCount; j < 4; j++) {
                    geomtry.source_skinData.push(0);
                    geomtry.source_skinData.push(0);
                }
            }
        };
        ESMVersion.parserVersion_3 = function (bytes, geomtry) {
            var description = bytes.readInt();
            geomtry.matCount = bytes.readInt();
            for (var i = 0; i < geomtry.matCount; ++i) {
                geomtry.material[i] = {};
                geomtry.material[i].matID = bytes.readInt();
                geomtry.material[i].start = bytes.readInt();
                geomtry.material[i].count = bytes.readInt();
                geomtry.material[i].textureDiffuse = bytes.readUTF();
                geomtry.material[i].textureNormal = bytes.readUTF();
                geomtry.material[i].textureSpecular = bytes.readUTF();
            }
            if (description & egret3d.VertexFormat.VF_POSITION) {
                var vertexCount = bytes.readInt();
                for (var i = 0; i < vertexCount; i++) {
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_NORMAL) {
                var vertexNormalCount = bytes.readInt();
                for (var i = 0; i < vertexNormalCount; i++) {
                    geomtry.source_normalData.push(bytes.readFloat());
                    geomtry.source_normalData.push(bytes.readFloat());
                    geomtry.source_normalData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_COLOR) {
                var vertexColorCount = bytes.readInt();
                for (var i = 0; i < vertexColorCount; i++) {
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                }
            }
            if (description & egret3d.VertexFormat.VF_UV0) {
                var uvCount = bytes.readInt();
                for (var i = 0; i < uvCount; i++) {
                    geomtry.source_uvData.push(bytes.readFloat());
                    geomtry.source_uvData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_UV1) {
                var uvCount = bytes.readInt();
                for (var i = 0; i < uvCount; i++) {
                    geomtry.source_uv2Data.push(bytes.readFloat());
                    geomtry.source_uv2Data.push(bytes.readFloat());
                }
            }
            geomtry.faces = bytes.readInt();
            for (var i = 0; i < geomtry.faces; i++) {
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                if (description & egret3d.VertexFormat.VF_NORMAL) {
                    geomtry.normalIndices.push(bytes.readUnsignedShort());
                    geomtry.normalIndices.push(bytes.readUnsignedShort());
                    geomtry.normalIndices.push(bytes.readUnsignedShort());
                }
                if (description & egret3d.VertexFormat.VF_COLOR) {
                    geomtry.colorIndices.push(bytes.readUnsignedShort());
                    geomtry.colorIndices.push(bytes.readUnsignedShort());
                    geomtry.colorIndices.push(bytes.readUnsignedShort());
                }
                if (description & egret3d.VertexFormat.VF_UV0) {
                    geomtry.uvIndices.push(bytes.readUnsignedShort());
                    geomtry.uvIndices.push(bytes.readUnsignedShort());
                    geomtry.uvIndices.push(bytes.readUnsignedShort());
                }
                if (description & egret3d.VertexFormat.VF_UV1) {
                    geomtry.uv2Indices.push(bytes.readUnsignedShort());
                    geomtry.uv2Indices.push(bytes.readUnsignedShort());
                    geomtry.uv2Indices.push(bytes.readUnsignedShort());
                }
            }
            var nBoneCount = bytes.readUnsignedByte();
            if (nBoneCount > 0) {
                geomtry.skeleton = new egret3d.Skeleton();
            }
            var orientation = new egret3d.Quaternion();
            var rotation = new egret3d.Vector3D();
            var scaling = new egret3d.Vector3D();
            var translation = new egret3d.Vector3D();
            for (var i = 0; i < nBoneCount; ++i) {
                var joint = new egret3d.Joint(null);
                bytes.readInt();
                joint.parentIndex = bytes.readInt();
                joint.name = bytes.readUTF();
                orientation.x = bytes.readFloat();
                orientation.y = bytes.readFloat();
                orientation.z = bytes.readFloat();
                orientation.w = bytes.readFloat();
                scaling.x = bytes.readFloat();
                scaling.y = bytes.readFloat();
                scaling.z = bytes.readFloat();
                translation.x = bytes.readFloat();
                translation.y = bytes.readFloat();
                translation.z = bytes.readFloat();
                joint.buildInverseMatrix(scaling, orientation, translation);
                geomtry.skeleton.joints.push(joint);
            }
            var nVertsCount = bytes.readInt();
            for (var i = 0; i < nVertsCount; i++) {
                var nCount = bytes.readUnsignedByte();
                for (var j = 0; j < nCount; j++) {
                    geomtry.source_skinData.push(bytes.readUnsignedByte());
                    geomtry.source_skinData.push(bytes.readFloat());
                }
                for (var j = nCount; j < 4; j++) {
                    geomtry.source_skinData.push(0);
                    geomtry.source_skinData.push(0);
                }
            }
        };
        ESMVersion.versionDictionary = {
            1: function (bytes, geomtry) { return ESMVersion.parserVersion_1(bytes, geomtry); },
            2: function (bytes, geomtry) { return ESMVersion.parserVersion_2(bytes, geomtry); },
            3: function (bytes, geomtry) { return ESMVersion.parserVersion_3(bytes, geomtry); },
        };
        return ESMVersion;
    }());
    egret3d.ESMVersion = ESMVersion;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.EPAParser
     * @classdesc
     * 用 EPMParser 类 解析.epa 文件
     */
    var EPAParser = (function () {
        function EPAParser() {
        }
        /**
         * @language zh_CN
         * @param datas 加载的二进制流
         * @returns PropertyAnim
         */
        EPAParser.parse = function (datas) {
            var bytes = new egret3d.ByteArray(datas);
            //验证标识头：'E' 'P' 'A' '\0'
            if (bytes.readUnsignedInt() != 0x65706100) {
                return null;
            }
            //版本号;
            var version = bytes.readUnsignedInt();
            if (!egret3d.EPAVersion.versionDictionary[version]) {
                console.log("egret3d engine not found " + version + " version");
                return null;
            }
            return egret3d.EPAVersion.versionDictionary[version](bytes);
        };
        return EPAParser;
    }());
    egret3d.EPAParser = EPAParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.EPAVersion
     * @classdesc
     */
    var EPAVersion = (function () {
        function EPAVersion() {
        }
        EPAVersion.parserVersion_1 = function (bytes) {
            var propertyAnim = new egret3d.PropertyAnim();
            //属性个数;
            var propertyCount = bytes.readUnsignedShort();
            for (var i = 0; i < propertyCount; i++) {
                //属性名称;
                var propertyName = bytes.readUTF();
                var keyFrames = [];
                //曲线数量;
                var curveCount = bytes.readUnsignedShort();
                for (var j = 0; j < curveCount; j++) {
                    var animCurve = new egret3d.AnimCurve();
                    animCurve.type = bytes.readUnsignedInt();
                    animCurve.start.x = bytes.readFloat();
                    animCurve.start.y = bytes.readFloat();
                    animCurve.end.x = bytes.readFloat();
                    animCurve.end.y = bytes.readFloat();
                    animCurve.c1.x = bytes.readFloat();
                    animCurve.c1.y = bytes.readFloat();
                    animCurve.c2.x = bytes.readFloat();
                    animCurve.c2.y = bytes.readFloat();
                    keyFrames.push(animCurve);
                }
                propertyAnim.addAnimCurve(propertyName, keyFrames);
            }
            return propertyAnim;
        };
        EPAVersion.versionDictionary = {
            1: function (bytes) { return EPAVersion.parserVersion_1(bytes); },
        };
        return EPAVersion;
    }());
    egret3d.EPAVersion = EPAVersion;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.XMLParser
    * @classdesc
    * 解析XML文件格式
    * @version Egret 3.0
    * @platform Web,Native
    */
    var XMLParser = (function () {
        function XMLParser() {
        }
        /**
        * @language zh_CN
        *
        * @param xml xml文件
        * @returns any
        */
        XMLParser.parse = function (xml) {
            var xmlDoc = null;
            ///判断浏览器的类型
            ///支持IE浏览器 
            if (!window["DOMParser"] && window["ActiveXObject"]) {
                var xmlDomVersions = ['MSXML.2.DOMDocument.6.0', 'MSXML.2.DOMDocument.3.0', 'Microsoft.XMLDOM'];
                for (var i = 0; i < xmlDomVersions.length; i++) {
                    try {
                        xmlDoc = new ActiveXObject(xmlDomVersions[i]);
                        xmlDoc.async = false;
                        xmlDoc.loadXML(xml); ///loadXML方法载入xml字符串
                        break;
                    }
                    catch (e) {
                    }
                }
            }
            else if (window["DOMParser"] && document.implementation && document.implementation.createDocument) {
                try {
                    /* DOMParser 对象解析 XML 文本并返回一个 XML Document 对象。
                     * 要使用 DOMParser，使用不带参数的构造函数来实例化它，然后调用其 parseFromString() 方法
                     * parseFromString(text, contentType) 参数text:要解析的 XML 标记 参数contentType文本的内容类型
                     * 可能是 "text/xml" 、"application/xml" 或 "application/xhtml+xml" 中的一个。注意，不支持 "text/html"。
                     */
                    var domParser = new DOMParser();
                    xmlDoc = domParser.parseFromString(xml, 'text/xml');
                }
                catch (e) {
                }
            }
            else {
                return null;
            }
            return xmlDoc;
        };
        /**
        * @private
        * @language zh_CN
        * 解析node节点的属性值
        * @version Egret 3.0
        * @platform Web,Native
        */
        XMLParser.eachXmlAttr = function (item, fun) {
            if (item == null || fun == null)
                return;
            var attr;
            for (var i = 0, count = item.attributes.length; i < count; i++) {
                attr = item.attributes[i];
                fun(attr.nodeName, attr.textContent);
            }
        };
        return XMLParser;
    }());
    egret3d.XMLParser = XMLParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.MapLoader
    * @classdesc
    * 加载egret地图类
    * 用于加载和解析egret地图文件的类，加载完毕后，mesh内容已经添加到了container中.
    * 主要封装了esm/eca/png/eam的加载和组装，以及mesh的render method相关信息，和灯光数据的生效.
    * 加载完毕后，会派发事件LoaderEvent3D.LOADER_COMPLETE
    * @see egret3d.EventDispatcher
    *
    * @includeExample loader/parser/map/MapLoader.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MapLoader = (function (_super) {
        __extends(MapLoader, _super);
        /**
        * @language zh_CN
        * 构建一个场景加载对象 构建后直接加载
        * @param name 场景名字 默认为null 不加载 有值时 直接加载
        * @param mapConfig 场景配置文件 默认为"MapConfig.xml"
        * @param path 场景文件路径 默认"resource/scene/"
        * @version Egret 3.0
        * @platform Web,Native
        */
        function MapLoader(name, mapConfig, path) {
            if (name === void 0) { name = null; }
            if (mapConfig === void 0) { mapConfig = "MapConfig.xml"; }
            if (path === void 0) { path = "resource/scene/"; }
            _super.call(this);
            ///**
            //* @language zh_CN
            //* 属性动画对象，加载完成后 需要更新
            //* @version Egret 3.0
            //* @platform Web,Native
            //*/
            //public propertyAnims: Array<PropertyAnim> = new Array<PropertyAnim>();
            /**
            * @language zh_CN
            * 场景对象的所有根节点.
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.container = null;
            /**
            * @language zh_CN
            * 是否自动播放动画  默认不自动播放
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.autoPlayAnimation = false;
            this._pathRoot = "";
            this._path = "";
            this._mapXmlParser = null;
            this._loaderDict = {};
            this._taskCount = 0;
            this._event = new egret3d.LoaderEvent3D();
            this.lightGroup = new egret3d.LightGroup();
            this.huds = new Array();
            this.textures = {};
            this.taskTotal = 0;
            this.taskCurrent = 0;
            this.container = new egret3d.Object3D();
            if (name) {
                this.load(name, mapConfig, path);
            }
        }
        /**
        * @language zh_CN
        * 加载场景
        * @param name 场景名字
        * @param mapConfig 场景配置文件 默认为"MapConfig.xml"
        * @param path 场景文件路径 默认"resource/scene/"
        * @version Egret 3.0
        * @platform Web,Native
        */
        MapLoader.prototype.load = function (name, mapConfig, path) {
            if (mapConfig === void 0) { mapConfig = "MapConfig.xml"; }
            if (path === void 0) { path = "resource/scene/"; }
            this._pathRoot = path + name + "/";
            this._path = this._pathRoot + mapConfig;
            this.taskTotal++;
            var load = this.findLoader(this._path);
            if (!load) {
                load = this.createLoader(this._path);
                load.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onXmlLoad, this);
            }
            else {
                if (load.data) {
                    this.parseXML(load.data);
                }
            }
        };
        MapLoader.prototype.addLoader = function (loader) {
            this._loaderDict[loader.url] = loader;
        };
        MapLoader.prototype.findLoader = function (path) {
            return this._loaderDict[path];
        };
        MapLoader.prototype.parseXML = function (xml) {
            var xmlDoc = egret3d.XMLParser.parse(xml);
            this._mapXmlParser = new egret3d.MapXmlParser(xmlDoc);
            for (var v in this._mapXmlParser.taskDict) {
                this.taskTotal++;
            }
            this.createLight();
            for (var i = 0; i < this._mapXmlParser.nodeList.length; i++) {
                var mapNodeData = this._mapXmlParser.nodeList[i];
                if (!mapNodeData.object3d.parent) {
                    this.container.addChild(mapNodeData.object3d);
                }
                if (mapNodeData.type == "Object3D" || mapNodeData.type == "Camera3D") {
                    this.doLoadEpa(mapNodeData);
                }
                switch (mapNodeData.type) {
                    case "Mesh":
                        if (mapNodeData.path) {
                            var path = this._pathRoot + mapNodeData.path;
                            var esmload = this.findLoader(path);
                            if (!esmload) {
                                esmload = this.createLoader(path);
                                var nodeDatas = [];
                                nodeDatas.push(mapNodeData);
                                esmload["esmnodeData"] = nodeDatas;
                                esmload.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onEsmLoad, this);
                            }
                            else {
                                var nodeDatas = esmload["esmnodeData"];
                                nodeDatas.push(mapNodeData);
                                if (esmload.data) {
                                    this.processMesh(mapNodeData, new egret3d.Mesh(esmload.data, new egret3d.TextureMaterial()));
                                }
                            }
                        }
                        else if (mapNodeData.geometry) {
                            this.processMesh(mapNodeData, new egret3d.Mesh(egret3d.GeometryUtil.createGemetryForType(mapNodeData.geometry.type, mapNodeData.geometry), new egret3d.TextureMaterial()));
                        }
                        break;
                    case "Terrain":
                        if (mapNodeData.path) {
                            var path = this._pathRoot + mapNodeData.path;
                            var heightImgload = this.findLoader(path);
                            if (!heightImgload) {
                                heightImgload = this.createLoader(path);
                                var nodeDatas = [];
                                nodeDatas.push(mapNodeData);
                                heightImgload["heightNodeDatas"] = nodeDatas;
                                heightImgload.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onHeightTextureLoad, this);
                            }
                            else {
                                var nodeDatas = heightImgload["heightNodeDatas"];
                                nodeDatas.push(mapNodeData);
                                var geo = mapNodeData.geometry;
                                if (heightImgload.data) {
                                    var envHeightGeometry = new egret3d.ElevationGeometry(heightImgload.data, geo.width, geo.height, geo.depth, geo.segmentsW, geo.segmentsH);
                                    var mesh = new egret3d.Mesh(envHeightGeometry, new egret3d.TextureMaterial(heightImgload.data));
                                    this.processHeightMesh(mapNodeData, mesh);
                                }
                            }
                        }
                        break;
                    case "ParticleEmitter":
                        if (mapNodeData.path) {
                            var path = this._pathRoot + mapNodeData.path;
                            var load = this.findLoader(path);
                            if (!load) {
                                load = this.createLoader(path);
                                var nodeDatas = [];
                                nodeDatas.push(mapNodeData);
                                load["particleNodeDatas"] = nodeDatas;
                                load.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onParticleXML, this);
                            }
                            else {
                                var nodeDatas = load["particleNodeDatas"];
                                nodeDatas.push(mapNodeData);
                                var particleData = load["particleData"];
                                if (particleData) {
                                    this.processParticle(particleData, mapNodeData);
                                }
                            }
                        }
                        break;
                }
            }
            for (var i = 0; i < this._mapXmlParser.textures.length; ++i) {
                var data = this._mapXmlParser.textures[i];
                var path = this._pathRoot + data.path;
                var textureLoad = this.findLoader(path);
                if (!textureLoad) {
                    textureLoad = this.createLoader(path);
                    textureLoad["name"] = data.name;
                    textureLoad.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onTexture, this);
                }
                else {
                }
            }
            for (var i = 0; i < this._mapXmlParser.hudList.length; ++i) {
                var hudData = this._mapXmlParser.hudList[i];
                var hud = new egret3d.HUD();
                hud.name = hudData.name;
                hud.bothside = hudData.bothside;
                hud.x = hudData.x;
                hud.y = hudData.y;
                hud.rotationX = hudData.rx;
                hud.rotationY = hudData.ry;
                hud.rotationZ = hudData.rz;
                hud.width = hudData.width;
                hud.height = hudData.height;
                if (hudData.vs) {
                    hud.vsShader = hudData.vs;
                }
                if (hudData.fs) {
                    hud.fsShader = hudData.fs;
                }
                this.huds.push(hud);
                hudData.hud = hud;
                if (!hudData.texture) {
                    continue;
                }
                var path = this._pathRoot + hudData.texture;
                var hudLoad = this.findLoader(path);
                if (!hudLoad) {
                    hudLoad = this.createLoader(path);
                    var hudDatas = [];
                    hudDatas.push(hudData);
                    hudLoad["hudDatas"] = hudDatas;
                    hudLoad.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onHudLoad, this);
                }
                else {
                    var hudDatas = hudLoad["hudDatas"];
                    hudDatas.push(hudData);
                    if (hudLoad.data) {
                        hud.diffuseTexture = hudLoad.data;
                    }
                }
            }
        };
        MapLoader.prototype.onParticleXML = function (e) {
            var nodeDatas = e.loader["particleNodeDatas"];
            var text = e.loader.data;
            var particleData = new egret3d.ParticleXmlParser().parse(text);
            e.loader["particleData"] = particleData;
            for (var i = 0; i < nodeDatas.length; ++i) {
                this.processParticle(particleData, nodeDatas[i]);
            }
            this.processTask(e.loader);
        };
        MapLoader.prototype.processParticle = function (particleData, nodeData) {
            var geo = null;
            if (nodeData.geometry) {
                geo = egret3d.GeometryUtil.createGemetryForType(nodeData.geometry.type, nodeData.geometry);
            }
            particleData.materialData = this._mapXmlParser.matDict[nodeData.materialIDs[0]];
            var particleNode = new egret3d.ParticleEmitter(particleData, geo, new egret3d.TextureMaterial());
            nodeData.x *= egret3d.ParticleData.SCALE_VALUE;
            nodeData.y *= egret3d.ParticleData.SCALE_VALUE;
            nodeData.z *= egret3d.ParticleData.SCALE_VALUE;
            nodeData.object3d.position.scaleBy(egret3d.ParticleData.SCALE_VALUE);
            nodeData.object3d.position = nodeData.object3d.position;
            particleNode.name = nodeData.object3d.name;
            particleNode.position = nodeData.object3d.position;
            particleNode.orientation = nodeData.object3d.orientation;
            particleNode.scale = nodeData.object3d.scale;
            nodeData.object3d.swapObject(particleNode);
            nodeData.object3d = particleNode;
            particleNode.play();
            this.processMat(nodeData);
            return particleNode;
        };
        MapLoader.prototype.onXmlLoad = function (e) {
            this.parseXML(e.loader.data);
            this.processTask(e.loader);
        };
        MapLoader.prototype.onTexture = function (e) {
            var textureLoad = e.loader;
            this.textures[textureLoad["name"]] = textureLoad.data;
            this.processTask(textureLoad);
        };
        MapLoader.prototype.onHudLoad = function (e) {
            var hudDatas = e.loader["hudDatas"];
            for (var i = 0; i < hudDatas.length; ++i) {
                var hudData = hudDatas[i];
                hudData.hud.diffuseTexture = e.loader.data;
            }
            this.processTask(e.loader);
        };
        MapLoader.prototype.doLoadEpa = function (mapNodeData) {
            if (mapNodeData.propertyAnims) {
                for (var j = 0; j < mapNodeData.propertyAnims.length; ++j) {
                    var propertyAnimsData = mapNodeData.propertyAnims[j];
                    var path = this._pathRoot + propertyAnimsData["path"];
                    var epaload = this.findLoader(path);
                    if (!epaload) {
                        epaload = this.createLoader(path);
                        var nodeDatas = [];
                        nodeDatas.push(mapNodeData);
                        epaload["epanodeData"] = nodeDatas;
                        epaload.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onEpaLoad, this);
                    }
                    else {
                        var nodeDatas = epaload["epanodeData"];
                        nodeDatas.push(mapNodeData);
                        if (epaload.data) {
                            this.processEpa(mapNodeData, epaload.data);
                        }
                    }
                }
            }
        };
        MapLoader.prototype.processEpa = function (mapNodeData, pro) {
            mapNodeData.object3d.bindAnimation(pro);
            if (this.autoPlayAnimation) {
                if (mapNodeData.object3d.proAnimation) {
                    mapNodeData.object3d.proAnimation.play();
                }
            }
        };
        MapLoader.prototype.onHeightTextureLoad = function (e) {
            var heightImgload = e.loader;
            var nodeDatas = heightImgload["heightNodeDatas"];
            for (var i = 0; i < nodeDatas.length; ++i) {
                var mapNodeData = nodeDatas[i];
                var geometry = mapNodeData.geometry;
                var envHeightGeometry = new egret3d.ElevationGeometry(heightImgload.data, geometry.width, geometry.height, geometry.depth, geometry.segmentsW, geometry.segmentsH);
                var mesh = new egret3d.Mesh(envHeightGeometry, new egret3d.TextureMaterial(heightImgload.data));
                this.processHeightMesh(mapNodeData, mesh);
                this.doLoadEpa(mapNodeData);
            }
            this.processTask(heightImgload);
        };
        MapLoader.prototype.processHeightMesh = function (mapNodeData, mesh) {
            mesh.name = mapNodeData.object3d.name;
            mesh.position = mapNodeData.object3d.position;
            mesh.orientation = mapNodeData.object3d.orientation;
            mesh.scale = mapNodeData.object3d.scale;
            mapNodeData.object3d.swapObject(mesh);
            mapNodeData.object3d = mesh;
            this.processMat(mapNodeData);
        };
        MapLoader.prototype.processMesh = function (mapNodeData, mesh) {
            mesh.name = mapNodeData.object3d.name;
            mesh.position = mapNodeData.object3d.position;
            mesh.orientation = mapNodeData.object3d.orientation;
            mesh.scale = mapNodeData.object3d.scale;
            mapNodeData.object3d.swapObject(mesh);
            mapNodeData.object3d = mesh;
            this.processMat(mapNodeData);
            for (var j = 0; j < mapNodeData.skinClips.length; j++) {
                var eamData = mapNodeData.skinClips[j];
                var path = this._pathRoot + eamData["path"];
                var load = this.findLoader(path);
                if (!load) {
                    load = this.createLoader(path);
                    load["name"] = eamData["name"];
                    var eamnodeDatas = [];
                    eamnodeDatas.push(mapNodeData);
                    load["eamnodeData"] = eamnodeDatas;
                    load["mesh"] = mesh;
                    load.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onEamLoad, this);
                }
                else {
                    var eamnodeDatas = load["eamnodeData"];
                    eamnodeDatas.push(mapNodeData);
                    if (load.data) {
                        var clip = load.data;
                        mesh.animation.skeletonAnimationController.addSkeletonAnimationClip(clip.clone());
                    }
                }
            }
        };
        MapLoader.prototype.onEsmLoad = function (e) {
            var nodeDatas = e.loader["esmnodeData"];
            var mesh = new egret3d.Mesh(e.loader.data, new egret3d.TextureMaterial());
            var cloneMesh = mesh;
            for (var i = 0; i < nodeDatas.length; ++i) {
                var mapNodeData = nodeDatas[i];
                if (cloneMesh) {
                    this.processMesh(mapNodeData, cloneMesh);
                    this.doLoadEpa(mapNodeData);
                    if (i == nodeDatas.length - 1) {
                        break;
                    }
                    cloneMesh = mesh.clone();
                }
            }
            this.processTask(e.loader);
        };
        MapLoader.prototype.onEamLoad = function (e) {
            var nodeDatas = e.loader["eamnodeData"];
            var clip = e.loader.data;
            clip.animationName = e.loader["name"];
            var cloneClip = clip;
            for (var i = 0; i < nodeDatas.length; ++i) {
                var mapNodeData = nodeDatas[i];
                var mesh = mapNodeData.object3d;
                if (cloneClip) {
                    mesh.animation.skeletonAnimationController.addSkeletonAnimationClip(cloneClip);
                    if (i == nodeDatas.length - 1) {
                        break;
                    }
                    cloneClip = clip.clone();
                }
            }
            if (this.autoPlayAnimation) {
                mesh.animation.play(clip.animationName, 1.0, false, false);
            }
            this.processTask(e.loader);
        };
        MapLoader.prototype.onEpaLoad = function (e) {
            var nodeDatas = e.loader["epanodeData"];
            var pa = e.loader.data;
            var clonePa = pa;
            for (var i = 0; i < nodeDatas.length; ++i) {
                var mapNodeData = nodeDatas[i];
                if (clonePa) {
                    this.processEpa(mapNodeData, clonePa);
                    if (i == nodeDatas.length - 1) {
                        break;
                    }
                    clonePa = pa.clone();
                }
            }
            this.processTask(e.loader);
        };
        MapLoader.prototype.onImgLoad = function (e) {
            var load = e.loader;
            var textureDatas = load["textureDatas"];
            var textureData = {};
            var mesh = null;
            var mat = null;
            for (var i = 0; i < textureDatas.length; ++i) {
                textureData = textureDatas[i];
                var mapNodeData = textureData.mapNodeData;
                mesh = mapNodeData.object3d;
                mat = mesh.getMaterial(textureData.matID);
                mat[textureData.type] = load.data;
            }
            this.processTask(load);
        };
        MapLoader.prototype.onImgMethodLoad = function (e) {
            var load = e.loader;
            var methodDatas = load["methodDatas"];
            var methodData = {};
            for (var i = 0; i < methodDatas.length; ++i) {
                methodData = methodDatas[i];
                methodData.method[methodData.textureName] = load.data;
            }
            this.processTask(load);
        };
        MapLoader.prototype.createLoader = function (path) {
            var load = new egret3d.URLLoader(path);
            this.addLoader(load);
            this._taskCount++;
            //console.log("+++" + load.url + "+++" + this._taskCount);
            return load;
        };
        MapLoader.prototype.processTask = function (load) {
            this._taskCount--;
            this.taskCurrent++;
            this._event.eventType = egret3d.LoaderEvent3D.LOADER_PROGRESS;
            this._event.target = this;
            this._event.loader = load;
            this._event.data = load;
            this.dispatchEvent(this._event);
            //console.log("---" + load.url + "---" + this._taskCount);
            if (this._taskCount <= 0) {
                for (var i = 0; i < this._mapXmlParser.nodeList.length; i++) {
                    var mapNodeData = this._mapXmlParser.nodeList[i];
                    if (mapNodeData.object3d instanceof egret3d.ParticleEmitter) {
                        var patEmitter = mapNodeData.object3d;
                        for (var j = 0; j < mapNodeData.childs.length; ++j) {
                            var childData = mapNodeData.childs[j];
                            var childPatEmitter = this.container.findObject3D(childData.name);
                            if (childPatEmitter instanceof egret3d.ParticleEmitter) {
                                patEmitter.addSubEmitter(Number(egret3d.ParticleDataSubEmitterPhase[childData.phase]), childPatEmitter);
                            }
                        }
                    }
                }
                this._event.eventType = egret3d.LoaderEvent3D.LOADER_COMPLETE;
                this._event.target = this;
                if (this.view3d) {
                    for (var i = 0; i < this.huds.length; ++i) {
                        this.view3d.addHUD(this.huds[i]);
                    }
                }
                this.dispatchEvent(this._event);
            }
        };
        MapLoader.prototype.addImaTask = function (name, type, matID, mapNodeData) {
            var load = null;
            var path = this._pathRoot + name;
            var load = this.findLoader(path);
            if (!load) {
                load = this.createLoader(path);
                var textureDatas = [];
                var textureData = {};
                textureData.type = type;
                textureData.matID = matID;
                textureData.mapNodeData = mapNodeData;
                textureDatas.push(textureData);
                load["textureDatas"] = textureDatas;
                load.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onImgLoad, this);
            }
            else {
                var textureDatas = load["textureDatas"];
                var textureData = {};
                textureData.type = type;
                textureData.matID = matID;
                textureData.mapNodeData = mapNodeData;
                textureDatas.push(textureData);
            }
            return load;
        };
        MapLoader.prototype.addMethodImgTask = function (name, method, textureName) {
            var path = this._pathRoot + name;
            var load = this.findLoader(path);
            if (!load) {
                load = this.createLoader(path);
                var methodDatas = [];
                var methodData = {};
                methodData.method = method;
                methodData.textureName = textureName;
                methodDatas.push(methodData);
                load["methodDatas"] = methodDatas;
                load.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onImgMethodLoad, this);
            }
            else {
                var methodDatas = load["methodDatas"];
                var methodData = {};
                methodData.method = method;
                methodData.textureName = textureName;
                methodDatas.push(methodData);
                if (load.data) {
                    methodData.method[methodData.textureName] = load.data;
                }
            }
            return load;
        };
        MapLoader.prototype.processMat = function (mapNodeData) {
            var mesh = mapNodeData.object3d;
            for (var i = 0; i < mapNodeData.materialIDs.length; ++i) {
                var matData = this._mapXmlParser.matDict[mapNodeData.materialIDs[i]];
                if (!matData) {
                    continue;
                }
                var material = mesh.getMaterial(i);
                if (!material) {
                    material = new egret3d.TextureMaterial();
                    mesh.addSubMaterial(i, material);
                }
                var load = null;
                if (matData.diffuseTextureName != "") {
                    load = this.addImaTask(matData.diffuseTextureName, "diffuseTexture", i, mapNodeData);
                    if (load.data) {
                        material.diffuseTexture = load.data;
                    }
                }
                if (matData.normalTextureName != "") {
                    load = this.addImaTask(matData.normalTextureName, "normalTexture", i, mapNodeData);
                    if (load.data) {
                        material.normalTexture = load.data;
                    }
                }
                if (matData.specularTextureName != "") {
                    load = this.addImaTask(matData.specularTextureName, "specularTexture", i, mapNodeData);
                    if (load.data) {
                        material.specularTexture = load.data;
                    }
                }
                material.diffuseColor = matData.diffuseColor;
                material.ambientColor = matData.ambientColor;
                material.specularColor = matData.specularColor;
                material.alpha = matData.alpha;
                material.specularLevel = matData.specularLevel;
                material.gloss = matData.gloss;
                material.castShadow = matData.castShadow;
                material.acceptShadow = matData.acceptShadow;
                material.smooth = matData.smooth;
                material.repeat = matData.repeat;
                material.bothside = matData.bothside;
                material.drawMode = matData.drawMode;
                material.cullMode = matData.cullMode;
                material.blendMode = matData.blendMode;
                material.cutAlpha = matData.cutAlpha;
                material.uvRectangle.copy(matData.uvRectangle);
                this.processMethod(material, matData);
            }
            if (typeof mesh != "ParticleEmitter") {
                mesh.lightGroup = this.lightGroup;
            }
        };
        MapLoader.prototype.processMethod = function (material, matData) {
            var load = null;
            var method = null;
            for (var _i = 0, _a = matData.methods; _i < _a.length; _i++) {
                method = _a[_i];
                var defaultTexture = egret3d.CheckerboardTexture.texture;
                if (method.type == egret3d.MatMethodData.methodType.lightmapMethod) {
                    var lightmapMethod = new egret3d.LightmapMethod(method.usePower);
                    material.diffusePass.addMethod(lightmapMethod);
                    lightmapMethod.lightTexture = defaultTexture;
                    var textureData = method.texturesData[0];
                    load = this.addMethodImgTask(textureData.path, lightmapMethod, textureData.attributeName);
                }
                else if (method.type == egret3d.MatMethodData.methodType.uvRollMethod) {
                    var uvScrollMethod = new egret3d.UVRollMethod();
                    material.diffusePass.addMethod(uvScrollMethod);
                    uvScrollMethod.speedU = method.uSpeed;
                    uvScrollMethod.speedV = method.vSpeed;
                    material.repeat = true;
                    uvScrollMethod.start(true);
                }
                else if (method.type == egret3d.MatMethodData.methodType.mulUvRollMethod) {
                    var uvMethod = new egret3d.MulUVRollMethod();
                    material.diffusePass.addMethod(uvMethod);
                    uvMethod.diffuseTexture1 = defaultTexture;
                    uvMethod.setSpeedU(0, method.uSpeed);
                    uvMethod.setSpeedV(0, method.vSpeed);
                    var textureData = method.texturesData[0];
                    uvMethod.setSpeedU(1, textureData.uSpeed);
                    uvMethod.setSpeedV(1, textureData.vSpeed);
                    load = this.addMethodImgTask(textureData.path, uvMethod, textureData.attributeName);
                    material.repeat = true;
                    uvMethod.start(true);
                }
                else if (method.type == egret3d.MatMethodData.methodType.alphaMaskMethod) {
                    var maskmapMethod = new egret3d.AlphaMaskMethod();
                    material.diffusePass.addMethod(maskmapMethod);
                    maskmapMethod.maskTexture = defaultTexture;
                    var textureData = method.texturesData[0];
                    load = this.addMethodImgTask(textureData.path, maskmapMethod, textureData.attributeName);
                }
                else if (method.type == egret3d.MatMethodData.methodType.streamerMethod) {
                    var streamerMethod = new egret3d.StreamerMethod();
                    material.diffusePass.addMethod(streamerMethod);
                    streamerMethod.steamerTexture = defaultTexture;
                    var textureData = method.texturesData[0];
                    load = this.addMethodImgTask(textureData.path, streamerMethod, textureData.attributeName);
                    streamerMethod.speedU = method.uSpeed;
                    streamerMethod.speedV = method.vSpeed;
                    streamerMethod.start(true);
                }
                else if (method.type == egret3d.MatMethodData.methodType.terrainARGBMethod) {
                    var terrainARGBMethod = new egret3d.TerrainARGBMethod(defaultTexture, defaultTexture, defaultTexture, defaultTexture, defaultTexture);
                    material.diffusePass.addMethod(terrainARGBMethod);
                    var textureData = null;
                    for (var i = 0; i < method.texturesData.length; ++i) {
                        textureData = method.texturesData[i];
                        load = this.addMethodImgTask(textureData.path, terrainARGBMethod, textureData.attributeName);
                        if (i != 0) {
                            terrainARGBMethod.setUVTitling(i - 1, textureData.uvTitlingX, textureData.uvTitlingY);
                        }
                    }
                }
                else if (method.type == egret3d.MatMethodData.methodType.waterWaveMethod) {
                    var waterWaveMethod = new egret3d.WaterWaveMethod();
                    material.diffusePass.addMethod(waterWaveMethod);
                    if (method["deepWaterColor"]) {
                        waterWaveMethod.deepWaterColor = Number(method["deepWaterColor"]);
                    }
                    if (method["shallowWaterColor"]) {
                        waterWaveMethod.shallowWaterColor = Number(method["shallowWaterColor"]);
                    }
                    material.repeat = true;
                }
                else if (method.type == egret3d.MatMethodData.methodType.waterNormalMethod) {
                    var waterNormalMethod = new egret3d.WaterNormalMethod();
                    material.diffusePass.addMethod(waterNormalMethod);
                    waterNormalMethod.normalTextureA = defaultTexture;
                    waterNormalMethod.normalTextureB = defaultTexture;
                    if (method["uScale"] && method["vScale"]) {
                        waterNormalMethod.setUvScale(Number(method["uScale"]), Number(method["vScale"]));
                    }
                    var textureData = null;
                    for (var i = 0; i < method.texturesData.length; ++i) {
                        textureData = method.texturesData[i];
                        waterNormalMethod.setUvSpeed(i, Number(textureData.uSpeed), Number(textureData.vSpeed));
                        load = this.addMethodImgTask(textureData.path, waterNormalMethod, textureData.attributeName);
                    }
                }
            }
        };
        //灯光
        MapLoader.prototype.createLight = function () {
            var mapLightData = null;
            for (var key in this._mapXmlParser.lightDict) {
                mapLightData = this._mapXmlParser.lightDict[key];
                if (mapLightData.type == egret3d.LightType.directlight && this._mapXmlParser.directLight) {
                    var dirLight = new egret3d.DirectLight(mapLightData.direction);
                    dirLight.lightId = Number(mapLightData.id);
                    dirLight.diffuse = mapLightData.diffuseColor;
                    dirLight.ambient = mapLightData.ambientColor;
                    dirLight.halfIntensity = mapLightData.halfIntensity;
                    dirLight.intensity = mapLightData.intensity;
                    this.lightGroup.addLight(dirLight);
                }
                else if (mapLightData.type == egret3d.LightType.pointlight && this._mapXmlParser.pointLight) {
                    var pLight = new egret3d.PointLight(0);
                    pLight.lightId = Number(mapLightData.id);
                    pLight.position = mapLightData.position;
                    pLight.ambient = mapLightData.ambientColor;
                    pLight.diffuse = mapLightData.diffuseColor;
                    pLight.radius = mapLightData.radius;
                    pLight.falloff = mapLightData.falloff;
                    pLight.intensity = mapLightData.intensity;
                    this.lightGroup.addLight(pLight);
                }
            }
        };
        return MapLoader;
    }(egret3d.EventDispatcher));
    egret3d.MapLoader = MapLoader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.MapNodeData
    * @classdesc
    * 节点数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MapNodeData = (function () {
        function MapNodeData() {
            this.type = "";
            this.insID = "";
            this.parent = "";
            this.name = "";
            this.path = "";
            this.fov = 0.0;
            this.clipNear = 0.0;
            this.clipFar = 0.0;
            /**
             * @language zh_CN
             * 对应的材质球id
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.materialIDs = [];
            /**
             * @language zh_CN
             * 拥有的动画剪辑名的列表
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.skinClips = [];
            /**
             * @language zh_CN
             * 拥有的动画剪辑名的列表
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.propertyAnims = [];
            /**
             * @language zh_CN
             * 是否启用公告板模式
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.billboard = false;
            /**
             * @language zh_CN
             * 坐标x
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.x = 0;
            /**
             * @language zh_CN
             * 坐标y
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.y = 0;
            /**
             * @language zh_CN
             * 坐标z
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.z = 0;
            /**
             * @language zh_CN
             * 旋转x分量
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.rx = 0;
            /**
             * @language zh_CN
             * 旋转y分量
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.ry = 0;
            /**
             * @language zh_CN
             * 旋转z分量
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.rz = 0;
            /**
             * @language zh_CN
             * 旋转w分量
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.rw = 0;
            /**
             * @language zh_CN
             * x轴缩放
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.sx = 1;
            /**
             * @language zh_CN
             * y轴缩放
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.sy = 1;
            /**
             * @language zh_CN
             * z轴缩放
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.sz = 1;
            //public texture: string = "";
            //public width: number = 0;
            //public height: number = 0;
            //public depth: number = 0;
            //public segmentsW: number = 0;
            //public segmentsH: number = 0;
            this.geometry = {};
            this.childs = [];
        }
        return MapNodeData;
    }());
    egret3d.MapNodeData = MapNodeData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MapXmlParser = (function () {
        function MapXmlParser(data) {
            /**
            * @language zh_CN
            * 地图配置信息的版本号
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.version = 1;
            /**
             * @language zh_CN
             * 节点列表
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.nodeList = new Array();
            this.hudList = new Array();
            this.matDict = {};
            this.lightDict = {};
            this.directLight = false;
            this.pointLight = false;
            this.textures = [];
            this.taskDict = {};
            var versionList = data.getElementsByTagName("version");
            this.version = Number(versionList[0].textContent);
            var matList = data.getElementsByTagName("mat");
            var nodeList = data.getElementsByTagName("node");
            var environment = data.getElementsByTagName("env");
            var cameraAnimList = data.getElementsByTagName("cameraAnims");
            var hudList = data.getElementsByTagName("hud");
            var textureList = data.getElementsByTagName("texture");
            this.parseEnvironment(environment);
            for (var i = 0; i < matList.length; i++) {
                var matNodeData = this.parseMat(matList[i]);
                if (matNodeData) {
                    this.matDict[matNodeData.id] = matNodeData;
                    this.calculateMatTask(matNodeData);
                }
            }
            for (var i = 0; i < nodeList.length; i++) {
                var mapNodeData = this.parseNode(nodeList[i]);
                if (mapNodeData) {
                    this.nodeList.push(mapNodeData);
                    this.calculateNodeTask(mapNodeData);
                }
            }
            for (var i = 0; i < textureList.length; i++) {
                this.parseTexture(textureList[i]);
            }
            for (var i = 0; i < hudList.length; i++) {
                var hudNodeData = this.parseHud(hudList[i]);
                if (hudNodeData) {
                    this.hudList.push(hudNodeData);
                    this.calculateHudTask(hudNodeData);
                }
            }
            for (var i = 0; i < this.nodeList.length; i++) {
                var mapNodeData = this.nodeList[i];
                if (mapNodeData.type == "Camera3D") {
                    var camera = new egret3d.Camera3D();
                    camera.fieldOfView = mapNodeData.fov;
                    camera.near = mapNodeData.clipNear;
                    camera.far = mapNodeData.clipFar;
                    mapNodeData.object3d = camera;
                }
                else if (mapNodeData.type == "Billboard") {
                    mapNodeData.object3d = new egret3d.Billboard(new egret3d.TextureMaterial(egret3d.CheckerboardTexture.texture));
                }
                else if (mapNodeData.type == "Terrain") {
                    mapNodeData.object3d = new egret3d.Object3D();
                }
                else {
                    mapNodeData.object3d = new egret3d.Object3D();
                }
                mapNodeData.object3d.name = mapNodeData.name;
                mapNodeData.object3d.position = new egret3d.Vector3D(mapNodeData.x, mapNodeData.y, mapNodeData.z);
                mapNodeData.object3d.orientation = new egret3d.Quaternion(mapNodeData.rx, mapNodeData.ry, mapNodeData.rz, mapNodeData.rw);
                mapNodeData.object3d.scale = new egret3d.Vector3D(mapNodeData.sx, mapNodeData.sy, mapNodeData.sz);
            }
            this.processNode();
        }
        MapXmlParser.prototype.parseTexture = function (node) {
            if (node.childNodes.length == 1)
                return null;
            var attr = null;
            var item;
            var i = 0;
            var count = 0;
            for (i = 0, count = node.childNodes.length; i < count; i++) {
                item = node.childNodes[i];
                if (item.nodeName == "#text")
                    continue;
                var data = {};
                for (var j = 0; j < item.attributes.length; ++j) {
                    attr = item.attributes[j];
                    data[attr.name] = attr.value;
                }
                this.textures.push(data);
                this.calculateTextureTask(data);
            }
        };
        MapXmlParser.prototype.parseMethod = function (node) {
            if (node.childNodes.length <= 1)
                return null;
            var list = [];
            var item;
            var nodeName;
            var count = 0;
            var method;
            var attr = null;
            for (var i = 0, count = node.childNodes.length; i < count; i++) {
                item = node.childNodes[i];
                nodeName = item.nodeName;
                if (nodeName == "#text")
                    continue;
                method = new egret3d.MatMethodData();
                method.type = nodeName;
                for (var j = 0; j < item.attributes.length; ++j) {
                    attr = item.attributes[j];
                    var v = typeof method[attr.name];
                    if (v == "string") {
                        method[attr.name] = attr.value;
                    }
                    else if (v == "number") {
                        method[attr.name] = Number(attr.value);
                    }
                    else if (v == "boolean") {
                        method[attr.name] = (attr.value == "true" ? true : false);
                    }
                    else {
                        method[attr.name] = attr.value;
                    }
                }
                for (var j = 0; j < item.childNodes.length; ++j) {
                    var textureItem = item.childNodes[j];
                    if (textureItem.nodeName == "#text") {
                        continue;
                    }
                    var textureData = {};
                    for (var k = 0; k < textureItem.attributes.length; ++k) {
                        attr = textureItem.attributes[k];
                        textureData[attr.name] = attr.value;
                    }
                    method.texturesData.push(textureData);
                }
                list.push(method);
            }
            return list;
        };
        MapXmlParser.prototype.parseMat = function (node) {
            if (node.childNodes.length == 0)
                return null;
            var data = new egret3d.MatSphereData();
            var attr = null;
            for (var i = 0; i < node.attributes.length; ++i) {
                attr = node.attributes[i];
                data[attr.name] = attr.value;
            }
            var item;
            var nodeName;
            var count = 0;
            for (var i = 0, count = node.childNodes.length; i < count; i++) {
                item = node.childNodes[i];
                nodeName = item.nodeName;
                if (nodeName == "#text") {
                    continue;
                }
                if (nodeName == "methods") {
                    data.methods = this.parseMethod(item);
                }
                else if (nodeName == "uvRectangle") {
                    for (var j = 0; j < item.attributes.length; ++j) {
                        data.uvRectangle[item.attributes[j].name] = Number(item.attributes[j].value);
                    }
                }
                else if (nodeName == "blendMode") {
                    data[item.nodeName] = egret3d.BlendMode[item.textContent];
                }
                else {
                    var v = typeof data[item.nodeName];
                    if (v == "string") {
                        data[item.nodeName] = item.textContent;
                    }
                    else if (v == "number") {
                        data[item.nodeName] = Number(item.textContent);
                    }
                    else if (v == "boolean") {
                        data[item.nodeName] = (item.textContent == "true" ? true : false);
                    }
                }
            }
            return data;
        };
        MapXmlParser.prototype.processNode = function () {
            for (var i = 0; i < this.nodeList.length; i++) {
                var mapNodeData0 = this.nodeList[i];
                for (var j = 0; j < this.nodeList.length; j++) {
                    var mapNodeData1 = this.nodeList[j];
                    if (mapNodeData0.parent == mapNodeData1.insID) {
                        mapNodeData1.object3d.addChild(mapNodeData0.object3d);
                        break;
                    }
                }
            }
        };
        MapXmlParser.prototype.parseNode = function (node) {
            if (node.childNodes.length == 1)
                return null;
            var attr = null;
            var data = new egret3d.MapNodeData();
            for (var i = 0; i < node.attributes.length; ++i) {
                attr = node.attributes[i];
                var v = typeof data[attr.name];
                if (v == "number") {
                    data[attr.name] = Number(attr.value);
                }
                else {
                    data[attr.name] = attr.value;
                }
            }
            var item;
            var nodeName;
            var i = 0;
            var count = 0;
            for (i = 0, count = node.childNodes.length; i < count; i++) {
                item = node.childNodes[i];
                nodeName = item.nodeName;
                if (nodeName == "#text") {
                    continue;
                }
                if (nodeName == "pos") {
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        data[attr.nodeName] = Number(attr.value);
                    }
                }
                else if (nodeName == "rot") {
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        data[attr.nodeName] = Number(attr.value);
                    }
                }
                else if (nodeName == "scale") {
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        data[attr.nodeName] = Number(attr.value);
                    }
                }
                else if (nodeName == "mat") {
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        if (attr.nodeName == "id") {
                            data.materialIDs = (attr.value + "").split(",");
                        }
                    }
                }
                else if (nodeName == "skinClip") {
                    var skinClipData = {};
                    data.skinClips.push(skinClipData);
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        skinClipData[attr.nodeName] = attr.value;
                    }
                }
                else if (nodeName == "propertyAnim") {
                    var propertyAnimsData = {};
                    data.propertyAnims.push(propertyAnimsData);
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        propertyAnimsData[attr.nodeName] = attr.value;
                    }
                }
                else if (nodeName == "geometry") {
                    var geo = {};
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        if (attr.name == "type") {
                            geo[attr.name] = attr.value;
                        }
                        else {
                            geo[attr.name] = Number(attr.value);
                        }
                    }
                    data.geometry = geo;
                }
                else if (nodeName == "sub") {
                    var childData = {};
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        childData[attr.name] = attr.value;
                    }
                    data.childs.push(childData);
                }
            }
            ////使外部使用更方便
            //if (data.skinClips == null) {
            //    data.skinClips = [];
            //}
            //if (data.lightIds == null) {
            //    data.lightIds = [];
            //}
            //for (var i: number = 0; i < data.lightIds.length; i++) {
            //    data.lightIds[i] = Number(data.lightIds[i]);
            //}
            //if (data.lightIds.indexOf(0) == -1) {
            //    data.lightIds.push(0);//平行光默认被追加
            //}
            ////
            //if (data.materialIDs == null) {
            //    data.materialIDs = [];
            //}
            //for (var i: number = 0; i < data.materialIDs.length; i++) {
            //    data.materialIDs[i] = Number(data.materialIDs[i]);
            //}
            return data;
        };
        MapXmlParser.prototype.parseEnvironment = function (environment) {
            if (environment.length <= 0) {
                return;
            }
            //灯光全局配置
            var dlOpen;
            var plOpen;
            //this.enableDirectLight = dlOpen;
            //this.enablePointLight = plOpen;
            //解析灯光
            var item;
            var item0;
            var item1;
            var attr = null;
            for (var iii = 0; iii < environment[0].attributes.length; ++iii) {
                attr = environment[0].attributes[iii];
                this[attr.name] = (attr.value == "open");
            }
            for (var i = 0, count = environment.length; i < count; i++) {
                item = environment[i];
                for (var ii = 0; ii < item.childNodes.length; ++ii) {
                    item0 = item.childNodes[ii];
                    if (item0.nodeName == "#text")
                        continue;
                    if (item0.nodeName == "light") {
                        var lightData = new egret3d.MapLightData();
                        for (var iii = 0; iii < item0.attributes.length; ++iii) {
                            attr = item0.attributes[iii];
                            lightData[attr.name] = attr.value;
                        }
                        this.lightDict[lightData.id] = lightData;
                        for (var iii = 0; iii < item0.childNodes.length; ++iii) {
                            item1 = item0.childNodes[iii];
                            if (item1.nodeName == "#text") {
                                continue;
                            }
                            if (item1.nodeName == "direction") {
                                for (var iiii = 0; iiii < item1.attributes.length; ++iiii) {
                                    attr = item1.attributes[iiii];
                                    lightData.direction[attr.name] = Number(attr.value);
                                }
                            }
                            else if (item1.nodeName == "position") {
                                for (var iiii = 0; iiii < item1.attributes.length; ++iiii) {
                                    attr = item1.attributes[iiii];
                                    lightData.position[attr.name] = Number(attr.value);
                                }
                            }
                            else if (item1.nodeName == "type") {
                                lightData.type = egret3d.LightType[item1.textContent];
                            }
                        }
                    }
                    else if (item0.nodeName == "fog") {
                    }
                }
            }
        };
        MapXmlParser.prototype.parseHud = function (node) {
            if (node.childNodes.length == 1)
                return null;
            var attr = null;
            var hudData = new egret3d.HUDData();
            for (var i = 0; i < node.attributes.length; ++i) {
                attr = node.attributes[i];
                if (attr.nodeName == "bothside") {
                    hudData[attr.nodeName] = (attr.value == "true");
                }
                else {
                    hudData[attr.nodeName] = attr.value;
                }
            }
            var item;
            var nodeName;
            var i = 0;
            var count = 0;
            for (i = 0, count = node.childNodes.length; i < count; i++) {
                item = node.childNodes[i];
                nodeName = item.nodeName;
                if (nodeName == "#text") {
                    continue;
                }
                for (var j = 0; j < item.attributes.length; ++j) {
                    attr = item.attributes[j];
                    if (nodeName == "shader") {
                        hudData[attr.nodeName] = attr.value;
                    }
                    else {
                        hudData[attr.nodeName] = Number(attr.value);
                    }
                }
            }
            return hudData;
        };
        MapXmlParser.prototype.calculateMatTask = function (data) {
            if (data.diffuseTextureName != "") {
                this.taskDict[data.diffuseTextureName] = 0;
            }
            if (data.normalTextureName != "") {
                this.taskDict[data.normalTextureName] = 0;
            }
            if (data.specularTextureName != "") {
                this.taskDict[data.specularTextureName] = 0;
            }
            for (var i = 0; i < data.methods.length; ++i) {
                var methodData = data.methods[i];
                for (var j = 0; j < methodData.texturesData.length; ++j) {
                    var texData = methodData.texturesData[j];
                    if (texData.path) {
                        this.taskDict[texData.path] = 0;
                    }
                }
            }
        };
        MapXmlParser.prototype.calculateNodeTask = function (data) {
            if (data.path) {
                this.taskDict[data.path] = 0;
            }
            for (var j = 0; j < data.skinClips.length; j++) {
                var eamData = data.skinClips[j];
                if (eamData.path) {
                    this.taskDict[eamData.path] = 0;
                }
            }
            for (var j = 0; j < data.propertyAnims.length; ++j) {
                var propertyAnimsData = data.propertyAnims[j];
                if (propertyAnimsData.path) {
                    this.taskDict[propertyAnimsData.path] = 0;
                }
            }
        };
        MapXmlParser.prototype.calculateHudTask = function (data) {
            if (data.texture) {
                this.taskDict[data.texture] = 0;
            }
        };
        MapXmlParser.prototype.calculateTextureTask = function (data) {
            if (data.path) {
                this.taskDict[data.path] = 0;
            }
        };
        return MapXmlParser;
    }());
    egret3d.MapXmlParser = MapXmlParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.MaterialMethodData
    * @classdesc
    * 材质球的特效数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MatMethodData = (function () {
        function MatMethodData() {
            this.id = "";
            /**
             * @language zh_CN
             * 特效的类型
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.type = "";
            /**
             * @language zh_CN
             * 是否增强specular的强度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.usePower = false;
            /**
             * @language zh_CN
             * 贴图索引数据（name）
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.texturesData = [];
            /**
             * @language zh_CN
             * u的滚动速度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.uSpeed = 0;
            /**
             * @language zh_CN
             * v的滚动速度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.vSpeed = 0;
        }
        MatMethodData.methodType = {
            lightmapMethod: "lightmapMethod",
            uvRollMethod: "uvRollMethod",
            mulUvRollMethod: "mulUvRollMethod",
            alphaMaskMethod: "alphaMaskMethod",
            streamerMethod: "streamerMethod",
            terrainARGBMethod: "terrainARGBMethod",
            waterWaveMethod: "waterWaveMethod",
            waterNormalMethod: "waterNormalMethod",
            particleUVRoll: "particleUVRoll",
        };
        return MatMethodData;
    }());
    egret3d.MatMethodData = MatMethodData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.MatSphereData
    * @classdesc
    * 材质球的特效数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MatSphereData = (function () {
        function MatSphereData() {
            /**
             * @language zh_CN
             * diffuse贴图的索引（name）
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.id = "";
            /**
             * @language zh_CN
             * diffuse贴图的索引（name）
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.diffuseTextureName = "";
            /**
             * @language zh_CN
             * normal贴图的索引（name）
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.normalTextureName = "";
            /**
             * @language zh_CN
             * specular贴图的索引（name）
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.specularTextureName = "";
            /**
             * @language zh_CN
             * diffuse的颜色，0xffffff格式
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.diffuseColor = 0;
            /**
             * @language zh_CN
             * ambient的颜色，0xffffff格式
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.ambientColor = 0;
            /**
             * @language zh_CN
             * specular的颜色，0xffffff格式
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.specularColor = 0;
            /**
             * @language zh_CN
             * 透明度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.alpha = 0;
            /**
             * @language zh_CN
             * specular增强等级
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.specularLevel = 0;
            /**
             * @language zh_CN
             * 光泽系数
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.gloss = 0;
            /**
             * @language zh_CN
             * ambient的强度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.ambientPower = 0;
            /**
             * @language zh_CN
             * diffuse的强度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.diffusePower = 0;
            /**
             * @language zh_CN
             * normal的强度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.normalPower = 0;
            /**
             * @language zh_CN
             * 是否产生阴影
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.castShadow = false;
            /**
             * @language zh_CN
             * 是否接受阴影
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.acceptShadow = false;
            /**
             * @language zh_CN
             * 是否平滑采样贴图
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.smooth = false;
            /**
             * @language zh_CN
             * 采样贴图的边缘是否重复
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.repeat = false;
            /**
             * @language zh_CN
             * 是否开启双面渲染
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.bothside = false;
            /**
             * @language zh_CN
             * 绘制模式设定
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.drawMode = 0;
            /**
             * @language zh_CN
             * 剔除模式设定
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.cullMode = 0;
            /**
             * @language zh_CN
             * 叠加模式
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.blendMode = 0;
            /**
             * @language zh_CN
             * alpha裁切值
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.cutAlpha = 0.7;
            /**
             * @language zh_CN
             * 材质球拥有的特效
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.methods = [];
            /**
             * @language zh_CN
             * 材质球uv区域
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.uvRectangle = new egret3d.Rectangle(0, 0, 1, 1);
        }
        return MatSphereData;
    }());
    egret3d.MatSphereData = MatSphereData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.MapLightData
    * @classdesc
    * 顶光数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MapLightData = (function () {
        function MapLightData() {
            this.id = "";
            /**
             * @language zh_CN
             * 灯光类型
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.type = 0;
            /**
             * @language zh_CN
             * diffuseColor
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.diffuseColor = 0xffffff;
            /**
             * @language zh_CN
             * ambientColor
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.ambientColor = 0xffffff;
            /**
             * @language zh_CN
             * 强度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.intensity = 1.0;
            /**
             * @language zh_CN
             * 强度的一半
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.halfIntensity = 0.0;
            this.direction = new egret3d.Vector3D(-0.5, -0.6, 0.2);
            this.position = new egret3d.Vector3D();
            /**
             * @language zh_CN
             * 衰减值
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.falloff = 0.0;
            /**
             * @language zh_CN
             * 半径数据
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.radius = 100;
        }
        return MapLightData;
    }());
    egret3d.MapLightData = MapLightData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var HUDData = (function () {
        function HUDData() {
            this.bothside = false;
        }
        return HUDData;
    }());
    egret3d.HUDData = HUDData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParserUtils
    * @classdesc
    * 用 ParserUtils 类 解析所有egret自定义 文件
    * @see egret3d.EventDispatcher
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParserUtils = (function (_super) {
        __extends(ParserUtils, _super);
        function ParserUtils() {
            _super.apply(this, arguments);
            this._event = new egret3d.ParserEvent3D();
        }
        /**
        * @language zh_CN
        * 传入数据流对象，解析出相应的数据对象.
        * 解析dds tga jpg png esm eam eca
        * @param buffer 需要解析的数据流
        * @returns 是否解析成功
        */
        ParserUtils.prototype.parser = function (buffer) {
            var _this = this;
            var bytes = new egret3d.ByteArray(buffer);
            var fileFormatBytes = new egret3d.ByteArray();
            bytes.readBytes(fileFormatBytes, 0, 3);
            bytes.position = 0;
            var fileFormat = 0;
            fileFormat |= fileFormatBytes.readUnsignedByte() << 16;
            fileFormat |= fileFormatBytes.readUnsignedByte() << 8;
            fileFormat |= fileFormatBytes.readUnsignedByte();
            switch (fileFormat) {
                case 0x00444453:
                    this.datas = egret3d.DDSParser.parse(buffer);
                    this.dataFormat = ".dds";
                    this.doLoadComplete();
                    break;
                case 0x00000002:
                case 0x00000010:
                    this.datas = egret3d.TGAParser.parse(buffer);
                    this.dataFormat = ".tga";
                    this.doLoadComplete();
                    break;
                case 0x00FFD8FF:
                    var blob = new Blob([buffer]);
                    this.dataFormat = ".jpg";
                    var img = document.createElement("img");
                    if (window['createObjectURL'] != undefined) {
                        img.src = window['createObjectURL'](blob);
                    }
                    else if (window['URL'] != undefined) {
                        img.src = window['URL'].createObjectURL(blob);
                    }
                    else if (window['webkitURL'] != undefined) {
                        img.src = window['webkitURL'].createObjectURL(blob);
                    }
                    img.onload = function () { return _this.onLoad(img); };
                    break;
                case 0x0089504E:
                    var blob = new Blob([buffer]);
                    this.dataFormat = ".png";
                    var img = document.createElement("img");
                    if (window['createObjectURL'] != undefined) {
                        img.src = window['createObjectURL'](blob);
                    }
                    else if (window['URL'] != undefined) {
                        img.src = window['URL'].createObjectURL(blob);
                    }
                    else if (window['webkitURL'] != undefined) {
                        img.src = window['webkitURL'].createObjectURL(blob);
                    }
                    img.onload = function () { return _this.onLoad(img); };
                    break;
                case 0x0065736D:
                    this.dataFormat = ".esm";
                    this.datas = egret3d.ESMParser.parse(buffer);
                    this.doLoadComplete();
                    break;
                case 0x0065616D:
                    this.dataFormat = ".eam";
                    this.datas = egret3d.EAMParser.parse(buffer);
                    this.doLoadComplete();
                    break;
                case 0x00656361:
                    this.dataFormat = ".eca";
                    this.datas = egret3d.ECAParser.parse(buffer);
                    this.doLoadComplete();
                    break;
                default:
                    return false;
            }
            return true;
        };
        ParserUtils.prototype.onLoad = function (img) {
            this.datas = new egret3d.ImageTexture(img);
            this.doLoadComplete();
        };
        ParserUtils.prototype.doLoadComplete = function () {
            this._event.eventType = egret3d.ParserEvent3D.PARSER_COMPLETE;
            this._event.data = this;
            this._event.parser = this;
            this.dispatchEvent(this._event);
        };
        return ParserUtils;
    }(egret3d.EventDispatcher));
    egret3d.ParserUtils = ParserUtils;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.URLLoader
     * @classdesc
     * URLLoader类
     * 用于加载和解析各类3d资源.
     * DDS, TGA, jpg, png等格式的贴图文件.
     * ESM, EAM, ECA等egret3d独有的模型文件,动作文件,相机动画文件
     * @includeExample loader/URLLoader.ts
     * @see egret3d.EventDispatcher
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var URLLoader = (function (_super) {
        __extends(URLLoader, _super);
        /**
         * @language zh_CN
         * 构造函数
         * @param url 加载数据的地址.如果参数不为空的话.将直接开始加载
         * @param dataformat 以什么方式进行加载.如果为空的话.将通过目标文件的后缀名判断,
         * 如果为空且文件后缀不为内置支持的集中文件类型的话.将以文本格式进行加载解析
         * @version Egret 3.0
         * @platform Web,Native
         */
        function URLLoader(url, dataformat) {
            if (url === void 0) { url = null; }
            if (dataformat === void 0) { dataformat = null; }
            _super.call(this);
            this._event = new egret3d.LoaderEvent3D();
            /**
             * @language zh_CN
             * 控制以哪种方式接收加载的数据.
             * 如果未赋值则通过加载文件的后缀名来判断加载的类型以解析.
             * 如果未赋值且加载的类型并非为内置支持的文件类型.将以文本格式进行加载
             * @version Egret 3.0
             * @platform Web,Native
             */
            this._dataformat = null;
            /**
            * @language zh_CN
            * 加载的地址
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.url = "";
            /**
            * @language zh_CN
            * 加载的地址的上级目录，为了方便获取资源
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.parentUrl = "";
            /**
            * @language zh_CN
            * 当前加载资源的名字
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.resourceName = "";
            /**
            * @language zh_CN
            * 加载的数据.
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.data = null;
            if (url) {
                if (dataformat) {
                    this.dataformat = dataformat;
                }
                this.load(url);
            }
        }
        /**
         * @language en_US
         */
        /**
         * @language zh_CN
         * 加载目标地址的数据
         * @param url 数据地址
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.prototype.load = function (url) {
            var _this = this;
            this.data = null;
            this.url = url;
            if (null == this._dataformat) {
                this._dataformat = URLLoader.DATAFORMAT_TEXT;
                var endPos = this.url.lastIndexOf(".");
                var startPos = this.url.lastIndexOf("/");
                if (this.url.length >= 4)
                    switch (this.url.substr(this.url.length - 4, 4).toLowerCase()) {
                        case ".dds":
                            this._dataformat = URLLoader.DATAFORMAT_DDS;
                            break;
                        case ".tga":
                            this._dataformat = URLLoader.DATAFORMAT_TGA;
                            break;
                        case ".bmp":
                            this._dataformat = URLLoader.DATAFORMAT_BITMAP;
                            break;
                        case ".png":
                            this._dataformat = URLLoader.DATAFORMAT_BITMAP;
                            break;
                        case ".jpg":
                            this._dataformat = URLLoader.DATAFORMAT_BITMAP;
                            break;
                        case "glsl":
                            this._dataformat = URLLoader.DATAFORMAT_TEXT;
                            break;
                        case ".pvr":
                            this._dataformat = URLLoader.DATAFORMAT_PVR;
                            break;
                        case ".esm":
                            this._dataformat = URLLoader.DATAFORMAT_ESM;
                            break;
                        case ".eam":
                            this._dataformat = URLLoader.DATAFORMAT_EAM;
                            break;
                        case ".eca":
                            this._dataformat = URLLoader.DATAFORMAT_ECA;
                            break;
                        case ".epa":
                            this._dataformat = URLLoader.DATAFORMAT_EPA;
                            break;
                    }
            }
            if (this._xhr == null) {
                this._xhr = this.getXHR();
            }
            if (this._xhr == null) {
                alert("Your browser does not support XMLHTTP.");
                return;
            }
            if (this._xhr.readyState > 0) {
                this._xhr.abort();
            }
            this._xhr.open("GET", this.url, true);
            this._xhr.addEventListener("progress", function (e) { return _this.onProgress(e); }, false);
            this._xhr.addEventListener("readystatechange", function (e) { return _this.onReadyStateChange(e); }, false);
            this._xhr.addEventListener("error", function (e) { return _this.onError(e); }, false);
            if (this.dataformat == URLLoader.DATAFORMAT_BITMAP) {
                this._xhr.responseType = "blob";
            }
            else if (this.dataformat != URLLoader.DATAFORMAT_TEXT) {
                this._xhr.responseType = "arraybuffer";
            }
            this._xhr.send();
        };
        Object.defineProperty(URLLoader.prototype, "dataformat", {
            /**
             * @language zh_CN
             * 控制以哪种方式接收加载的数据.
             * 如果未赋值则通过加载文件的后缀名来判断加载的类型以解析.
             * 如果未赋值且加载的类型并非为内置支持的文件类型.将以文本格式进行加载
             * @returns string
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._dataformat;
            },
            /**
             * @language zh_CN
             * 控制以哪种方式接收加载的数据.
             * 如果未赋值则通过加载文件的后缀名来判断加载的类型以解析.
             * 如果未赋值且加载的类型并非为内置支持的文件类型.将以文本格式进行加载
             * @param value
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this._dataformat = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URLLoader.prototype, "bytesLoaded", {
            /**
            * @language zh_CN
            * 已经获取到的字节数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._progressEvent ? this._progressEvent.loaded : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URLLoader.prototype, "bytesTotal", {
            /**
            * @language zh_CN
            * 需要获取的总字节数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._progressEvent ? this._progressEvent.total : 0;
            },
            enumerable: true,
            configurable: true
        });
        URLLoader.prototype.onReadyStateChange = function (event) {
            if (this._xhr.readyState == 4) {
                if (this._xhr.status >= 400 /*|| this._xhr.status == 0*/) {
                    console.log(this.url, "load fail");
                }
                else {
                    this.loadComplete();
                }
            }
        };
        URLLoader.prototype.loadComplete = function () {
            var _this = this;
            switch (this.dataformat) {
                case URLLoader.DATAFORMAT_BINARY:
                    this.data = new egret3d.ByteArray(this._xhr.response);
                    break;
                case URLLoader.DATAFORMAT_SOUND:
                    this.data = this._xhr.responseBody;
                    break;
                case URLLoader.DATAFORMAT_TEXT:
                    this.data = this._xhr.responseText;
                    break;
                case URLLoader.DATAFORMAT_BITMAP:
                    var img = document.createElement("img");
                    if (window['createObjectURL'] != undefined) {
                        img.src = window['createObjectURL'](this._xhr.response);
                    }
                    else if (window['URL'] != undefined) {
                        img.src = window['URL'].createObjectURL(this._xhr.response);
                    }
                    else if (window['webkitURL'] != undefined) {
                        img.src = window['webkitURL'].createObjectURL(this._xhr.response);
                    }
                    img.onload = function () { return _this.onLoad(img); };
                    return;
                case URLLoader.DATAFORMAT_DDS:
                    this.data = egret3d.DDSParser.parse(this._xhr.response);
                    break;
                case URLLoader.DATAFORMAT_TGA:
                    this.data = egret3d.TGAParser.parse(this._xhr.response);
                    break;
                case URLLoader.DATAFORMAT_ESM:
                    var geomtry = egret3d.ESMParser.parse(this._xhr.response);
                    this.data = geomtry;
                    break;
                case URLLoader.DATAFORMAT_EAM:
                    var skeletonAnimationClip = egret3d.EAMParser.parse(this._xhr.response);
                    this.data = skeletonAnimationClip;
                    break;
                case URLLoader.DATAFORMAT_ECA:
                    var cameraAnimationController = egret3d.ECAParser.parse(this._xhr.response);
                    this.data = cameraAnimationController;
                    break;
                case URLLoader.DATAFORMAT_EPA:
                    this.data = egret3d.EPAParser.parse(this._xhr.response);
                    break;
                case URLLoader.DATAFORMAT_PVR:
                    //var pvr:PVR = PVRParser.parse(this._xhr.response);
                    //this._data = pvr;
                    break;
                default:
                    this.data = this._xhr.responseText;
            }
            this.doLoadComplete();
        };
        URLLoader.prototype.onProgress = function (event) {
            this._event.eventType = egret3d.LoaderEvent3D.LOADER_PROGRESS;
            this._event.target = this;
            this._event.loader = this;
            this._progressEvent = event;
            this.dispatchEvent(this._event);
        };
        URLLoader.prototype.onError = function (event) {
            this._event.eventType = egret3d.LoaderEvent3D.LOADER_ERROR;
            this._event.target = this;
            this._event.loader = this;
            this.dispatchEvent(this._event);
            console.log("load error", event);
        };
        URLLoader.prototype.getXHR = function () {
            var xhr = null;
            if (window["XMLHttpRequest"]) {
                xhr = new window["XMLHttpRequest"]();
            }
            else {
                xhr = new ActiveXObject("MSXML2.XMLHTTP");
            }
            return xhr;
        };
        URLLoader.prototype.onLoad = function (img) {
            this.data = new egret3d.ImageTexture(img);
            this.doLoadComplete();
        };
        URLLoader.prototype.doLoadComplete = function () {
            this.resourceName = egret3d.StringUtil.getURLName(this.url);
            this._event.eventType = egret3d.LoaderEvent3D.LOADER_COMPLETE;
            this._event.target = this;
            this._event.loader = this;
            this.dispatchEvent(this._event);
        };
        /**
         * @language zh_CN
         * 以二进制方式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_BINARY = "binary";
        /**
         * @language zh_CN
         * 以文本的方式接收加载的数据
         * 默认方式
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_TEXT = "text";
        /**
         * @language zh_CN
         * 以音频的方式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_SOUND = "sound";
        /**
         * @language zh_CN
         * 以图像的方式接收加载的数据
         * 支持jpg.png.等格式
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_BITMAP = "bitmap";
        /**
         * @language zh_CN
         * 以DDS的方式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_DDS = "dds";
        /**
         * @language zh_CN
         * 以TGA的方式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_TGA = "tga";
        /**
         * @language zh_CN
         * 以ESM格式接收加载的数据
         * Egret3D独有的格式 模型+蒙皮
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_ESM = "esm";
        /**
         * @language zh_CN
         * 以EAM格式接收加载的数据
         * Egret3D独有的格式 动作文件
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_EAM = "eam";
        /**
         * @language zh_CN
         * 以ECA格式接收加载的数据
         * Egret3D独有的格式 相机动画文件
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_ECA = "eca";
        /**
         * @language zh_CN
         * 以EPA格式接收加载的数据
         * Egret3D独有的格式 属性动画文件
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_EPA = "epa";
        /**
         * @private
         * @language zh_CN
         * 以pvr格式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_PVR = "pvr";
        return URLLoader;
    }(egret3d.EventDispatcher));
    egret3d.URLLoader = URLLoader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.MethodBase
    * @classdesc
    * 增加多种渲染效果的方法基类
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MethodBase = (function () {
        function MethodBase() {
            /**
            * @private
            * @language zh_CN
            */
            this.vsShaderList = [];
            /**
            * @private
            * @language zh_CN
            */
            this.fsShaderList = [];
        }
        /**
        * @private
        * @language zh_CN
        */
        MethodBase.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        /**
        * @private
        * @language zh_CN
        */
        MethodBase.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        /**
        * @private
        * @language zh_CN
        */
        MethodBase.prototype.dispose = function () {
        };
        return MethodBase;
    }());
    egret3d.MethodBase = MethodBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.TerrainARGBMethod
    * @classdesc
    * 地形贴图混合渲染方法。
    * 使用一张贴图中的ARGB色来进行4张贴图进行混合。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TerrainARGBMethod = (function (_super) {
        __extends(TerrainARGBMethod, _super);
        /**
        * @language zh_CN
        * 创建地形贴图混合渲染方法
        * @param controlTex 混合贴图
        * @param splat_0 第一张贴图
        * @param splat_1 第二张贴图
        * @param splat_2 第三张贴图
        * @param splat_3 第四张贴图
        * @version Egret 3.0
        * @platform Web,Native
        */
        function TerrainARGBMethod(controlTex, splat_0, splat_1, splat_2, splat_3) {
            _super.call(this);
            this.uvs = new Float32Array(8);
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("terrainRGBA_fragment");
            this.controlTex = controlTex;
            this.splat_0 = splat_0;
            this.splat_1 = splat_1;
            this.splat_2 = splat_2;
            this.splat_3 = splat_3;
            this.uvs[0] = 1.0;
            this.uvs[1] = 1.0;
            this.uvs[2] = 1.0;
            this.uvs[3] = 1.0;
            this.uvs[4] = 1.0;
            this.uvs[5] = 1.0;
            this.uvs[6] = 1.0;
            this.uvs[7] = 1.0;
        }
        /**
        * @language zh_CN
        * 设置 UVTitling。
        * @param index {Number} 图层索引
        * @param x {Number} u 的重复次数
        * @param y {Number} v 的重复次数
        * @version Egret 3.0
        * @platform Web,Native
        */
        TerrainARGBMethod.prototype.setUVTitling = function (index, x, y) {
            this.uvs[index * 2] = x;
            this.uvs[index * 2 + 1] = y;
        };
        Object.defineProperty(TerrainARGBMethod.prototype, "splat_0_Texture", {
            /**
            * @language zh_CN
            * 设置第一张贴图
            * @param texture 贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                this.splat_0 = texture;
                this.materialData.splat_0Tex = texture;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainARGBMethod.prototype, "splat_1_Texture", {
            /**
            * @language zh_CN
            * 设置第二张贴图
            * @param texture 贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                this.splat_1 = texture;
                this.materialData.splat_1Tex = texture;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainARGBMethod.prototype, "splat_2_Texture", {
            /**
            * @language zh_CN
            * 设置第三张贴图
            * @version Egret 3.0
            * @platform Web,Native
            * @param texture 贴图
            */
            set: function (texture) {
                this.splat_2 = texture;
                this.materialData.splat_2Tex = texture;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainARGBMethod.prototype, "splat_3_Texture", {
            /**
            * @language zh_CN
            * 设置第四张贴图
            * @param texture 贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                this.splat_3 = texture;
                this.materialData.splat_3Tex = texture;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainARGBMethod.prototype, "controlTexture", {
            /**
            * @language zh_CN
            * 设置混合贴图
            * @param texture 贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                this.controlTex = texture;
                this.materialData.blendMaskTexture = texture;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        TerrainARGBMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uvs"] = context3DProxy.getUniformLocation(usage.program3D, "uvs");
        };
        /**
        * @language zh_CN
        * @private
        */
        TerrainARGBMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            context3DProxy.uniform1fv(usage["uvs"], this.uvs);
        };
        /**
        * @language zh_CN
        * @private
        */
        TerrainARGBMethod.prototype.dispose = function () {
        };
        return TerrainARGBMethod;
    }(egret3d.MethodBase));
    egret3d.TerrainARGBMethod = TerrainARGBMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.FogMethod
    * @classdesc
    * Exponential Height Fog渲染方法。
    * 实现3种fog类型： line、exp、exp height
    * @version Egret 3.0
    * @platform Web,Native
    */
    var FogMethod = (function (_super) {
        __extends(FogMethod, _super);
        /**
        * @language zh_CN
        * 创建一个雾的渲染方法
        * @param fogType 雾的类型 line/exp/expHeightFog
        * @version Egret 3.0
        * @platform Web,Native
        */
        function FogMethod(fogType) {
            if (fogType === void 0) { fogType = "expHeightFog_fs"; }
            _super.call(this);
            this.uniform_globalFog = new Float32Array(7);
            this._fogColor = 0x0000cc;
            this._globalDensity = 1.0;
            this._fogStartDistance = 1000;
            this._fogDistanceScale = 0.5;
            this._height = 500;
            this._fogAlpha = 1.0;
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] = this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex].push("vertexPos_vs");
            if (fogType == "line") {
                this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment].push("lineFog");
            }
            else if (fogType == "exp") {
                this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment].push("expFog_fs");
            }
            else if (fogType == "expHeightFog_fs") {
                this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment] || [];
                this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment].push("expHeightFog_fs");
            }
            //0.5, 0.6, 0.7
            this.uniform_globalFog[0] = 0.5;
            this.uniform_globalFog[1] = 0.6;
            this.uniform_globalFog[2] = 0.7;
            this.uniform_globalFog[3] = this._globalDensity;
            this.uniform_globalFog[4] = this._fogStartDistance;
            this.uniform_globalFog[5] = this._height;
            this.uniform_globalFog[6] = this._fogAlpha;
        }
        Object.defineProperty(FogMethod.prototype, "fogColor", {
            /**
            * @language zh_CN
            * 获取雾颜色
            * @returns 雾颜色 rgb  0xffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.fogColor;
            },
            /**
            * @language zh_CN
            * 设置雾颜色
            * @param value 雾颜色 rgb  0xffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._fogColor = value;
                this.uniform_globalFog[0] = (this._fogColor >> 16 & 0xff) / 255.0;
                this.uniform_globalFog[1] = (this._fogColor >> 8 & 0xff) / 255.0;
                this.uniform_globalFog[2] = (this._fogColor & 0xff) / 255.0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FogMethod.prototype, "globalDensity", {
            /**
            * @language zh_CN
            * 获取雾的全局浓度
            * @returns number 雾的全局浓度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._globalDensity;
            },
            /**
            * @language zh_CN
            * 设置雾的全局浓度
            * @param value 雾的全局浓度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._globalDensity = value;
                this.uniform_globalFog[3] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FogMethod.prototype, "fogStartDistance", {
            /**
            * @language zh_CN
            * 获取雾的开始距离
            * @returns number 雾的开始距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._fogStartDistance;
            },
            /**
            * @language zh_CN
            * 设置雾的开始距离
            * @param value 雾的开始距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._fogStartDistance = value;
                this.uniform_globalFog[4] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FogMethod.prototype, "fogHeight", {
            /**
            * @language zh_CN
            * 获取雾的高度值
            * @returns number 雾的高度值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._height;
            },
            //public set fogDistanceScale(value: number) {
            //    this._fogDistanceScale = value;
            //    this.uniform_globalFog[5] = value;
            //}
            //public get fogDistanceScale(): number {
            //    return this._fogDistanceScale;
            //}
            /**
            * @language zh_CN
            * 设置雾的高度值
            * @param value 雾的高度值
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._height = value;
                this.uniform_globalFog[5] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FogMethod.prototype, "fogAlpha", {
            /**
            * @language zh_CN
            * 获取雾的Alpha值
            * @returns number 雾的Alpha值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._height;
            },
            /**
            * @language zh_CN
            * 设置雾的Alpha值
            * @param value 雾的Alpha值
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._height = value;
                this.uniform_globalFog[6] = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        FogMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uniform_globalFog"] = context3DProxy.getUniformLocation(usage.program3D, "uniform_globalFog");
        };
        /**
         * @language zh_CN
         * @private
         */
        FogMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            context3DProxy.uniform1fv(usage["uniform_globalFog"], this.uniform_globalFog);
        };
        /**
         * @language zh_CN
         * @private
         */
        FogMethod.prototype.dispose = function () {
        };
        return FogMethod;
    }(egret3d.MethodBase));
    egret3d.FogMethod = FogMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVRollMethod
    * @classdesc
    * 用来实现UV滚动效果的渲染方法
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UVRollMethod = (function (_super) {
        __extends(UVRollMethod, _super);
        /**
        * @private
        * @language zh_CN
        */
        function UVRollMethod() {
            _super.call(this);
            this._uvRoll = new Float32Array(2);
            this._speedU = 0.00005;
            this._speedV = 0.0;
            this._time = 0.0;
            this._start = false;
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("uvRoll_fs");
        }
        Object.defineProperty(UVRollMethod.prototype, "speedU", {
            /**
            * @language zh_CN
            * 获取UV u的滚动速度
            * @returns number u的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._speedU;
            },
            /**
            * @language zh_CN
            * 用来UV u的滚动速度
            * @param value u的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._speedU = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVRollMethod.prototype, "speedV", {
            /**
            * @language zh_CN
            * 获取UV v的滚动速度
            * @returns number v的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._speedV;
            },
            /**
            * @language zh_CN
            * 用来UV v的滚动速度
            * @param value v的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._speedV = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 开始播放uv动画
        * @param rest 如果为ture就是重置播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        UVRollMethod.prototype.start = function (rest) {
            if (rest === void 0) { rest = false; }
            if (rest)
                this._time = 0;
            this._start = true;
        };
        /**
        * @language zh_CN
        * 停止播放uv动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        UVRollMethod.prototype.stop = function () {
            this._start = false;
        };
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        UVRollMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uvRoll"] = context3DProxy.getUniformLocation(usage.program3D, "uvRoll");
        };
        /**
        * @private
        * @language zh_CN
        */
        UVRollMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (this._start) {
                this._time += delay;
                this._uvRoll[0] = this._time * this._speedU;
                this._uvRoll[1] = this._time * this._speedV;
                context3DProxy.uniform1fv(usage["uvRoll"], this._uvRoll);
            }
        };
        return UVRollMethod;
    }(egret3d.MethodBase));
    egret3d.UVRollMethod = UVRollMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVRollMethod
    * @classdesc
    * 用来实现多UV滚动效果的渲染方法
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MulUVRollMethod = (function (_super) {
        __extends(MulUVRollMethod, _super);
        /**
        * @private
        * @language zh_CN
        */
        function MulUVRollMethod() {
            _super.call(this);
            this._uvRoll = new Float32Array(4);
            this._uvSpeed = new Float32Array(4);
            this._time = 0.0;
            this._start = false;
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("mulUvRoll_fs");
            this._uvSpeed[0] = 0.00005;
            this._uvSpeed[1] = 0.0;
            this._uvSpeed[2] = 0.00005;
            this._uvSpeed[3] = 0.0;
        }
        /**
        * @language zh_CN
        * 用来UV u的滚动速度
        * @param value u的滚动速度
        * @version Egret 3.0
        * @platform Web,Native
        */
        MulUVRollMethod.prototype.setSpeedU = function (index, value) {
            this._uvSpeed[index * 2 + 0] = value;
        };
        /**
        * @language zh_CN
        * 获取UV u的滚动速度
        * @returns number u的滚动速度
        * @version Egret 3.0
        * @platform Web,Native
        */
        MulUVRollMethod.prototype.getSpeedU = function (index) {
            return this._uvSpeed[index * 2 + 0];
        };
        /**
        * @language zh_CN
        * 用来UV v的滚动速度
        * @param value v的滚动速度
        * @version Egret 3.0
        * @platform Web,Native
        */
        MulUVRollMethod.prototype.setSpeedV = function (index, value) {
            this._uvSpeed[index * 2 + 1] = value;
        };
        /**
        * @language zh_CN
        * 获取UV v的滚动速度
        * @returns number v的滚动速度
        * @version Egret 3.0
        * @platform Web,Native
        */
        MulUVRollMethod.prototype.getSpeedV = function (index) {
            return this._uvSpeed[index * 2 + 1];
        };
        /**
        * @language zh_CN
        * 开始播放uv动画
        * @param rest 如果为ture就是重置播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        MulUVRollMethod.prototype.start = function (rest) {
            if (rest === void 0) { rest = false; }
            if (rest)
                this._time = 0;
            this._start = true;
        };
        /**
        * @language zh_CN
        * 停止播放uv动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        MulUVRollMethod.prototype.stop = function () {
            this._start = false;
        };
        Object.defineProperty(MulUVRollMethod.prototype, "diffuseTexture1", {
            /**
            * @language zh_CN
            * 获取流动贴图
            * @returns ITexture 流动贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._diffuseTexture1;
            },
            /**
            * @language zh_CN
            * 设置流动贴图
            * @param tex 流动贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (tex) {
                this._diffuseTexture1 = tex;
                this.materialData["diffuseTexture1"] = tex;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        MulUVRollMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["mulUvRoll"] = context3DProxy.getUniformLocation(usage.program3D, "mulUvRoll");
        };
        /**
        * @private
        * @language zh_CN
        */
        MulUVRollMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (this._start) {
                this._time += delay;
                for (var i = 0; i < 4; ++i) {
                    this._uvRoll[i] = this._time * this._uvSpeed[i];
                }
                context3DProxy.uniform1fv(usage["mulUvRoll"], this._uvRoll);
            }
        };
        return MulUVRollMethod;
    }(egret3d.MethodBase));
    egret3d.MulUVRollMethod = MulUVRollMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVSpriteSheetMethod
    * @classdesc
    * 用来实现UV精灵动画的渲染方法 。
    * 一整张贴图中用行列来分割帧动画，然后实现每帧播放。
    * row * col 是总帧数， frameNum是只播放的帧数.
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UVSpriteSheetMethod = (function (_super) {
        __extends(UVSpriteSheetMethod, _super);
        /**
        * @language zh_CN
        * 创建一个UV精灵动画的渲染方法对象
        * @param frameNum  帧数量
        * @param row 行数
        * @param column 列数
        * @param numTime 播放总时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        function UVSpriteSheetMethod(frameNum, row, column, numTime) {
            _super.call(this);
            this._uvSpriteSheet = new Float32Array(4);
            this._uvRectangle = new egret3d.Rectangle();
            this._speed = 0.0;
            this._time = 0.0;
            this._numTime = 0.4;
            this._start = false;
            this._frameNum = 12;
            this._row = 4;
            this._column = 4;
            this._currentFrame = 0;
            this.frameList = [];
            this._change = false;
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("uvSpriteSheet_fs");
            this.frameNum = frameNum;
            this.row = row;
            this.column = column;
            this.numTime = numTime;
        }
        UVSpriteSheetMethod.prototype.caculate = function () {
            this._speed = (this._numTime * 1000) / this._frameNum;
            this._uvRectangle.x = 0.0;
            this._uvRectangle.y = 0.0;
            this._uvRectangle.width = 1.0 / this._row;
            this._uvRectangle.height = 1.0 / this._column;
            this.frameList.length = this._frameNum;
            var rowIndex = 0;
            var columnIndex = 0;
            for (var i = 0; i < this._frameNum; i++) {
                rowIndex = i % this._row;
                columnIndex = Math.floor(i / this._column);
                var rec = new egret3d.Rectangle();
                rec.x = rowIndex * this._uvRectangle.width + this._uvRectangle.x;
                rec.y = columnIndex * this._uvRectangle.height + this._uvRectangle.y;
                rec.width = this._uvRectangle.width;
                rec.height = this._uvRectangle.height;
                this.frameList[i] = rec;
            }
        };
        Object.defineProperty(UVSpriteSheetMethod.prototype, "numTime", {
            /**
            * @language zh_CN
            * 获取动画播放总时间
            * @returns number 播放总时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._numTime;
            },
            /**
            * @language zh_CN
            * 设置动画播放总时间
            * @param value 播放总时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._numTime != value) {
                    this._change = true;
                    this._numTime = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVSpriteSheetMethod.prototype, "frameNum", {
            /**
            * @language zh_CN
            * 获取动画帧数
            * @returns number  动画帧数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._frameNum;
            },
            /**
            * @language zh_CN
            * 设置动画帧数
            * @param value 动画帧数
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._frameNum != value) {
                    this._change = true;
                    this._frameNum = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVSpriteSheetMethod.prototype, "row", {
            /**
            * @language zh_CN
            * 获取动画行数
            * @returns number  动画行数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._row;
            },
            /**
            * @language zh_CN
            * 设置动画行数
            * @param value 动画行数
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._row != value) {
                    this._change = true;
                    this._row = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVSpriteSheetMethod.prototype, "column", {
            /**
            * @language zh_CN
            * 获取动画列数
            * @returns number  动画列数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._column;
            },
            /**
            * @language zh_CN
            * 设置动画列数
            * @param value 动画列数
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._column != value) {
                    this._change = true;
                    this._column = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 开始播放uv精灵动画
        * @param rest 如果为ture就是重置播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        UVSpriteSheetMethod.prototype.start = function (rest) {
            if (rest === void 0) { rest = false; }
            if (rest)
                this._time = 0;
            this._start = true;
            if (this._change)
                this.caculate();
        };
        /**
        * @language zh_CN
        * 停止播放uv精灵动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        UVSpriteSheetMethod.prototype.stop = function () {
            this._start = false;
        };
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        UVSpriteSheetMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uvSpriteSheet"] = context3DProxy.getUniformLocation(usage.program3D, "uvSpriteSheet");
        };
        /**
        * @private
        */
        UVSpriteSheetMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (this._start) {
                this._time += delay;
                if (this._time / this._speed > 1.0) {
                    this._currentFrame++;
                    this._currentFrame = this._currentFrame % this._frameNum;
                    this._time = 0;
                    this._uvSpriteSheet[0] = this.frameList[this._currentFrame].x;
                    this._uvSpriteSheet[1] = this.frameList[this._currentFrame].y;
                    this._uvSpriteSheet[2] = this.frameList[this._currentFrame].width;
                    this._uvSpriteSheet[3] = this.frameList[this._currentFrame].height;
                    context3DProxy.uniform1fv(usage["uvSpriteSheet"], this._uvSpriteSheet);
                }
            }
        };
        return UVSpriteSheetMethod;
    }(egret3d.MethodBase));
    egret3d.UVSpriteSheetMethod = UVSpriteSheetMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.LightmapMethod
    * @classdesc
    * 实现lightmap渲染方法。
    * 在三维软件里实现打好光，然后渲染把场景各表面的光照输出到贴图上。
    * 然后使用模型的第2UV，渲染出Lightmap效果，lightmap贴图需要自己烘焙。
    * @see egret3d.MethodBase
    * @includeExample material/method/LightmapMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var LightmapMethod = (function (_super) {
        __extends(LightmapMethod, _super);
        /**
        * @language zh_CN
        * 创建一个LightmapMethod对象
        * @param useSpecularPower 是否使用高功率，默认参数为true
        * @version Egret 3.0
        * @platform Web,Native
        */
        function LightmapMethod(useSpecularPower) {
            if (useSpecularPower === void 0) { useSpecularPower = true; }
            _super.call(this);
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] = this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex].push("secondaryUV_vs");
            if (useSpecularPower) {
                this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment] || [];
                this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment].push("lightMapSpecularPower_fs");
            }
            else {
                this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment] || [];
                this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment].push("lightMap_fs");
            }
        }
        Object.defineProperty(LightmapMethod.prototype, "lightTexture", {
            /**
            * @language zh_CN
            * 设置lightmap贴图
            * @param texture lightmap贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                this.texture = texture;
                if (this.materialData.lightTexture != this.texture) {
                    this.materialData.lightTexture = this.texture;
                    this.materialData.textureChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        LightmapMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        /**
        * @private
        * @language zh_CN
        */
        LightmapMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        return LightmapMethod;
    }(egret3d.MethodBase));
    egret3d.LightmapMethod = LightmapMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVRollMethod
    * @classdesc
    * 用来实现UV滚动效果的渲染方法
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PlantDistortedMethod = (function (_super) {
        __extends(PlantDistortedMethod, _super);
        /**
        * @private
        * @language zh_CN
        */
        function PlantDistortedMethod() {
            _super.call(this);
            this._speed = new egret3d.Vector3D();
            this._time = 0.0;
            this._windData = new Float32Array(4);
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] = this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex].push("detail_Bending_vs");
        }
        Object.defineProperty(PlantDistortedMethod.prototype, "windDirAndSpeed", {
            get: function () {
                return this._speed;
            },
            set: function (dirAndStr) {
                this._speed = dirAndStr;
                this._windData[1] = dirAndStr.x;
                this._windData[2] = dirAndStr.y;
                this._windData[3] = dirAndStr.z;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        PlantDistortedMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, moodeltransform, camera3D) {
            usage["uniformTime"] = context3DProxy.getUniformLocation(usage.program3D, "uniformTime");
        };
        /**
        * @private
        * @language zh_CN
        */
        PlantDistortedMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            this._time += delay;
            this._windData[0] = this._time;
            context3DProxy.uniform1fv(usage["uniformTime"], this._windData);
        };
        return PlantDistortedMethod;
    }(egret3d.MethodBase));
    egret3d.PlantDistortedMethod = PlantDistortedMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.AlphaMaskMethod
    * @classdesc
    * 实现alpha遮罩渲染方法。
    * 该贴图的r通道被用于赋值到diffuse数据的alpha上面。
    * @see egret3d.MethodBase
    * @includeExample material/method/AlphaMaskMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var AlphaMaskMethod = (function (_super) {
        __extends(AlphaMaskMethod, _super);
        /**
        * @language zh_CN
        * 创建一个AlphaMaskMethod对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function AlphaMaskMethod() {
            _super.call(this);
            this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment].push("alphaMask_fs");
        }
        Object.defineProperty(AlphaMaskMethod.prototype, "maskTexture", {
            /**
            * @language zh_CN
            * 设置maskTexture贴图
            * @param texture maskTexture贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                this.texture = texture;
                this.materialData.maskTexture = this.texture;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        AlphaMaskMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        /**
        * @private
        * @language zh_CN
        */
        AlphaMaskMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        return AlphaMaskMethod;
    }(egret3d.MethodBase));
    egret3d.AlphaMaskMethod = AlphaMaskMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.ColorTransformMethod
    * @classdesc
    * 实现偏色渲染方法。
    * 将最终渲染的argb值按照这个transform进行修正。
    * @see egret3d.MethodBase
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ColorTransformMethod = (function (_super) {
        __extends(ColorTransformMethod, _super);
        /**
        * @language zh_CN
        * 创建一个ColorTransformMethod对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ColorTransformMethod() {
            _super.call(this);
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment].push("colorTransform_fs");
        }
        Object.defineProperty(ColorTransformMethod.prototype, "colorTransform", {
            get: function () {
                return this.materialData.colorTransform;
            },
            /**
            * @language zh_CN
            * 设置transform数据
            * @param trasform ColorTransform
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (trasform) {
                this.materialData.colorTransform = trasform;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        ColorTransformMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uniform_colorTransformVec4"] = context3DProxy.getUniformLocation(usage.program3D, "uniform_colorTransformVec4");
            usage["uniform_colorTransformM44"] = context3DProxy.getUniformLocation(usage.program3D, "uniform_colorTransformM44");
        };
        /**
        * @private
        * @language zh_CN
        */
        ColorTransformMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            context3DProxy.uniform4fv(usage["uniform_colorTransformVec4"], this.colorTransform.vec4);
            context3DProxy.uniformMatrix4fv(usage["uniform_colorTransformM44"], false, this.colorTransform.m44.rawData);
        };
        return ColorTransformMethod;
    }(egret3d.MethodBase));
    egret3d.ColorTransformMethod = ColorTransformMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.ColorGradientsMethod
    * @classdesc
    * 实现颜色渐变叠加
    * @see egret3d.MethodBase
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ColorGradientsMethod = (function (_super) {
        __extends(ColorGradientsMethod, _super);
        /**
        * @language zh_CN
        * 创建一个ColorGradientsMethod对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ColorGradientsMethod() {
            _super.call(this);
            this._posStart = new egret3d.Vector3D();
            this._posEnd = new egret3d.Vector3D();
            this._color = new egret3d.Color();
            this._zeroVector = new egret3d.Vector3D();
            this._helpVector = new egret3d.Vector3D();
            this._helpMatrix = new egret3d.Matrix4_4();
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment].push("colorGradients_fs");
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] = this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex].push("vertexPos_vs");
        }
        ;
        /**
        * @language zh_CN
        * 设置颜色渐变数据
        * @param posStart Vector3D
        * @param posEnd Vector3D
        * @param color Color
        * @version Egret 3.0
        * @platform Web,Native
        */
        ColorGradientsMethod.prototype.setStartData = function (posStart, posEnd, color) {
            this._color.copyFrom(color);
            this._posStart.copyFrom(posStart);
            this._posEnd.copyFrom(posEnd);
            this._posStart.w = 0;
            this._posEnd.w = 0;
        };
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        ColorGradientsMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uniform_colorGradientsSource"] = context3DProxy.getUniformLocation(usage.program3D, "uniform_colorGradientsSource");
        };
        /**
        * @private
        * @language zh_CN
        */
        ColorGradientsMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            this._helpMatrix.identity();
            this._helpMatrix.copyFrom(camera3D.viewMatrix);
            //start
            this._helpMatrix.transformVector(this._posStart, this._helpVector);
            this.materialData.colorGradientsSource[0] = this._helpVector.x;
            this.materialData.colorGradientsSource[1] = this._helpVector.y;
            this.materialData.colorGradientsSource[2] = this._helpVector.z;
            //end
            this._helpMatrix.transformVector(this._posEnd, this._helpVector);
            this.materialData.colorGradientsSource[3] = this._helpVector.x;
            this.materialData.colorGradientsSource[4] = this._helpVector.y;
            this.materialData.colorGradientsSource[5] = this._helpVector.z;
            //color
            this.materialData.colorGradientsSource[6] = this._color.r;
            this.materialData.colorGradientsSource[7] = this._color.g;
            this.materialData.colorGradientsSource[8] = this._color.b;
            this.materialData.colorGradientsSource[9] = this._color.a;
            context3DProxy.uniform1fv(usage["uniform_colorGradientsSource"], this.materialData.colorGradientsSource);
        };
        return ColorGradientsMethod;
    }(egret3d.MethodBase));
    egret3d.ColorGradientsMethod = ColorGradientsMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVRollMethod
    * @classdesc
    * 用来实现UV流光滚动效果的渲染方法
    * @version Egret 3.0
    * @platform Web,Native
    */
    var StreamerMethod = (function (_super) {
        __extends(StreamerMethod, _super);
        /**
        * @private
        * @language zh_CN
        */
        function StreamerMethod() {
            _super.call(this);
            this._uvRoll = new Float32Array(3);
            this._speedU = 0.0001;
            this._speedV = 0.0001;
            this._intensity = 0.9;
            this._time = 0.0;
            this._start = false;
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("uvStreamerRoll_fs");
            this.start();
        }
        Object.defineProperty(StreamerMethod.prototype, "speedU", {
            /**
            * @language zh_CN
            * 获取UV u的滚动速度
            * @returns number u的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._speedU;
            },
            /**
            * @language zh_CN
            * 用来UV u的滚动速度
            * @param value u的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._speedU = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StreamerMethod.prototype, "speedV", {
            /**
            * @language zh_CN
            * 获取UV v的滚动速度
            * @returns number v的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._speedV;
            },
            /**
            * @language zh_CN
            * 用来UV v的滚动速度
            * @param value v的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._speedV = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StreamerMethod.prototype, "steamerTexture", {
            /**
            * @language zh_CN
            * 获取流动贴图
            * @returns ITexture 流动贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._steamerTexture;
            },
            /**
            * @language zh_CN
            * 设置流动贴图
            * @param tex 流动贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (tex) {
                this._steamerTexture = tex;
                this.materialData["streamerTexture"] = tex;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 开始播放uv动画
        * @param rest 如果为ture就是重置播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        StreamerMethod.prototype.start = function (rest) {
            if (rest === void 0) { rest = false; }
            if (rest)
                this._time = 0;
            this._start = true;
        };
        /**
        * @language zh_CN
        * 停止播放uv动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        StreamerMethod.prototype.stop = function () {
            this._start = false;
        };
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        StreamerMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uvRoll"] = context3DProxy.getUniformLocation(usage.program3D, "uvRoll");
        };
        /**
        * @private
        * @language zh_CN
        */
        StreamerMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (this._start) {
                this._time += delay;
                this._uvRoll[0] = this._time * this._speedU;
                this._uvRoll[1] = this._time * this._speedV;
                this._uvRoll[2] = this._intensity;
                context3DProxy.uniform1fv(usage["uvRoll"], this._uvRoll);
            }
        };
        return StreamerMethod;
    }(egret3d.MethodBase));
    egret3d.StreamerMethod = StreamerMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.AlphaMaskMethod
    * @classdesc
    * 实现实时阴影渲染方法
    * @see egret3d.MethodBase
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ShadowMethod = (function (_super) {
        __extends(ShadowMethod, _super);
        function ShadowMethod(material) {
            _super.call(this);
            this.materialData = material.materialData;
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] = this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex].push("shadowMapping_vs");
            this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment].push("shadowMapping_fs");
        }
        Object.defineProperty(ShadowMethod.prototype, "shadowMapTexture", {
            /**
            * @language zh_CN
            * 获取阴影贴图
            * @returns ITexture 阴影贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.shadowMapTexture;
            },
            /**
            * @language zh_CN
            * 设置阴影贴图
            * @param texture 阴影贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                if (this.materialData.shadowMapTexture != texture) {
                    this.materialData.shadowMapTexture = texture;
                    this.materialData.textureChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        */
        ShadowMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            //usage["uniform_ShadowMatrix"] = context3DProxy.getUniformLocation(usage.program3D, "uniform_ShadowMatrix");
        };
        /**
        * @private
        */
        ShadowMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (egret3d.ShadowCast.instance.shadowCamera) {
                context3DProxy.uniformMatrix4fv(usage.uniform_ShadowMatrix.uniformIndex, false, egret3d.ShadowCast.instance.shadowCamera.viewProjectionMatrix.rawData);
            }
            context3DProxy.uniform3fv(usage.uniform_ShadowColor.uniformIndex, this.materialData.shadowColor);
        };
        return ShadowMethod;
    }(egret3d.MethodBase));
    egret3d.ShadowMethod = ShadowMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.CubeMethod
    * @classdesc
    * @see egret3d.MethodBase
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CubeMethod = (function (_super) {
        __extends(CubeMethod, _super);
        /**
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        function CubeMethod() {
            _super.call(this);
            this.vsShaderList[egret3d.ShaderPhaseType.global_vertex] = this.fsShaderList[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.global_vertex].push("cube_vertex");
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("cube_fragment");
        }
        /**
        * @private
        */
        CubeMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        /**
        * @private
        * @language zh_CN
        */
        CubeMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        return CubeMethod;
    }(egret3d.MethodBase));
    egret3d.CubeMethod = CubeMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.ColorMethod
    * @classdesc
    * @see egret3d.MethodBase
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ColorMethod = (function (_super) {
        __extends(ColorMethod, _super);
        /**
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ColorMethod() {
            _super.call(this);
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("color_fragment");
        }
        /**
        * @private
        */
        ColorMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        /**
        * @private
        * @language zh_CN
        */
        ColorMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        return ColorMethod;
    }(egret3d.MethodBase));
    egret3d.ColorMethod = ColorMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVRollMethod
    * @classdesc
    * 用来实现水面顶点波动效果
    * @version Egret 3.0
    * @platform Web,Native
    */
    var WaterWaveMethod = (function (_super) {
        __extends(WaterWaveMethod, _super);
        /**
        * @private
        * @language zh_CN
        */
        function WaterWaveMethod() {
            _super.call(this);
            this._waveVSData = new Float32Array(12);
            this._waveFSData = new Float32Array(8);
            this._time = 0.0;
            this._start = false;
            this._wave_xyz_intensity_0 = new egret3d.Vector3D(120.0, 50.0, 70.0);
            this._wave_xyz_intensity_1 = new egret3d.Vector3D(80.0, 40.0, 80.0);
            this._wave_xyz_speed_0 = new egret3d.Vector3D(0.001, 0.001, -0.001);
            this._wave_xyz_speed_1 = new egret3d.Vector3D(0.001, 0.001, 0.001);
            this.vsShaderList[egret3d.ShaderPhaseType.start_vertex] = this.vsShaderList[egret3d.ShaderPhaseType.start_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.start_vertex].push("wave_vs");
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment].push("wave_fs");
            this.start();
            //---------------
            this._waveVSData[0] = this._wave_xyz_intensity_0.x;
            this._waveVSData[1] = this._wave_xyz_intensity_0.y;
            this._waveVSData[2] = this._wave_xyz_intensity_0.z;
            this._waveVSData[3] = this._wave_xyz_intensity_1.x;
            this._waveVSData[4] = this._wave_xyz_intensity_1.y;
            this._waveVSData[5] = this._wave_xyz_intensity_1.z;
            this._waveVSData[6] = this._wave_xyz_speed_0.x;
            this._waveVSData[7] = this._wave_xyz_speed_0.y;
            this._waveVSData[8] = this._wave_xyz_speed_0.z;
            this._waveVSData[9] = this._wave_xyz_speed_1.x;
            this._waveVSData[10] = this._wave_xyz_speed_1.y;
            this._waveVSData[11] = this._wave_xyz_speed_1.z;
            //0.0/255.0,63.0/255.0,77.0/255.0
            //71.0/255.0,118.0/255.0,138.0/255.0
            this._waveFSData[0] = 0.0 / 255.0;
            this._waveFSData[1] = 63.0 / 255.0;
            this._waveFSData[2] = 77.0 / 255.0;
            this._waveFSData[3] = 1.0;
            this._waveFSData[4] = 71.0 / 255.0;
            this._waveFSData[5] = 118.0 / 255.0;
            this._waveFSData[6] = 138.0 / 255.0;
            this._waveFSData[7] = 1.0;
        }
        Object.defineProperty(WaterWaveMethod.prototype, "deepWaterColor", {
            /**
            * @language zh_CN
            * 获取深水颜色
            * @param color 颜色 a r b g
            */
            get: function () {
                var r = this._waveFSData[0] * 255.0;
                var g = this._waveFSData[1] * 255.0;
                var b = this._waveFSData[2] * 255.0;
                var a = this._waveFSData[3] * 255.0;
                return (a << 24) | (r << 16) | (g << 8) | b;
            },
            /**
            * @language zh_CN
            * 设置深水颜色
            * @param color 颜色 a r b g
            */
            set: function (color) {
                var a = color >> 24 & 0xff;
                var r = color >> 16 & 0xff;
                var g = color >> 8 & 0xff;
                var b = color & 0xff;
                this._waveFSData[0] = r / 255.0;
                this._waveFSData[1] = g / 255.0;
                this._waveFSData[2] = b / 255.0;
                this._waveFSData[3] = a / 255.0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterWaveMethod.prototype, "shallowWaterColor", {
            /**
            * @language zh_CN
            * 获取浅水颜色
            * @param color 颜色 a r b g
            */
            get: function () {
                var r = this._waveFSData[4] * 255.0;
                var g = this._waveFSData[5] * 255.0;
                var b = this._waveFSData[6] * 255.0;
                var a = this._waveFSData[7] * 255.0;
                return (a << 24) | (r << 16) | (g << 8) | b;
            },
            /**
            * @language zh_CN
            * 设置浅水颜色
            * @param color 颜色
            */
            set: function (color) {
                var a = color >> 24 & 0xff;
                var r = color >> 16 & 0xff;
                var g = color >> 8 & 0xff;
                var b = color & 0xff;
                this._waveFSData[4] = r / 255.0;
                this._waveFSData[5] = g / 255.0;
                this._waveFSData[6] = b / 255.0;
                this._waveFSData[7] = a / 255.0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterWaveMethod.prototype, "waveTexture", {
            /**
            * @language zh_CN
            * 水贴图
            * @param texture  水贴图
            */
            set: function (texture) {
                this._waveTexture = texture;
                if (texture) {
                    if (this.materialData["waveTexture"] != this._waveTexture) {
                        this.materialData["waveTexture"] = texture;
                        this.materialData.textureChange = true;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 开始播放uv动画
        * @param rest 如果为ture就是重置播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterWaveMethod.prototype.start = function (rest) {
            if (rest === void 0) { rest = false; }
            if (rest)
                this._time = 0;
            this._start = true;
        };
        /**
        * @language zh_CN
        * 停止播放uv动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterWaveMethod.prototype.stop = function () {
            this._start = false;
        };
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        WaterWaveMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["waveVSData"] = context3DProxy.getUniformLocation(usage.program3D, "waveVSData");
            usage["waveFSData"] = context3DProxy.getUniformLocation(usage.program3D, "waveFSData");
            usage["time"] = context3DProxy.getUniformLocation(usage.program3D, "time");
        };
        /**
        * @private
        * @language zh_CN
        */
        WaterWaveMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (this._start) {
                this._time += delay;
                context3DProxy.uniform3fv(usage["waveVSData"], this._waveVSData);
                context3DProxy.uniform4fv(usage["waveFSData"], this._waveFSData);
                context3DProxy.uniform1f(usage["time"], this._time);
            }
        };
        return WaterWaveMethod;
    }(egret3d.MethodBase));
    egret3d.WaterWaveMethod = WaterWaveMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVRollMethod
    * @classdesc
    * 用来实现水面波光粼粼的效果
    * @version Egret 3.0
    * @platform Web,Native
    */
    var WaterNormalMethod = (function (_super) {
        __extends(WaterNormalMethod, _super);
        /**
        * @private
        * @language zh_CN
        */
        function WaterNormalMethod() {
            _super.call(this);
            this._uvData = new Float32Array(8);
            this._time = 0.0;
            this._start = false;
            this._speedU_0 = new egret3d.Point(-0.000009, 0.0);
            this._speedU_1 = new egret3d.Point(0.00003, 0.0);
            this._distion_intensity = new egret3d.Point(0.05, 0.05);
            this._normal_0_UVScale = 4.0;
            this._normal_1_UVScale = 4.0;
            this.fsShaderList[egret3d.ShaderPhaseType.normal_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.normal_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.normal_fragment].push("waterNormal_fs");
            this.start();
            //---------------
            this._uvData[0] = this._speedU_0.x * 2.5;
            this._uvData[1] = this._speedU_0.y * 2.5;
            this._uvData[2] = this._speedU_1.x * 2.5;
            this._uvData[3] = this._speedU_1.y * 2.5;
            this._uvData[4] = this._distion_intensity.x;
            this._uvData[5] = this._distion_intensity.y;
            this._uvData[6] = this._normal_0_UVScale;
            this._uvData[7] = this._normal_1_UVScale;
        }
        /**
        * @language zh_CN
        * 开始播放uv动画
        * @param rest 如果为ture就是重置播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterNormalMethod.prototype.start = function (rest) {
            if (rest === void 0) { rest = false; }
            if (rest)
                this._time = 0;
            this._start = true;
        };
        /**
        * @language zh_CN
        * 停止播放uv动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterNormalMethod.prototype.stop = function () {
            this._start = false;
        };
        /**
        * @language zh_CN
        * 设置UV 速度
        * @param index 0 或 1
        * @param u
        * @param v
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterNormalMethod.prototype.setUvSpeed = function (index, u, v) {
            switch (index) {
                case 0:
                    this._speedU_0.x = u;
                    this._speedU_0.y = v;
                    this._uvData[0] = this._speedU_0.x * 2.5;
                    this._uvData[1] = this._speedU_0.y * 2.5;
                    break;
                case 1:
                    this._speedU_1.x = u;
                    this._speedU_1.y = v;
                    this._uvData[2] = this._speedU_1.x * 2.5;
                    this._uvData[3] = this._speedU_1.y * 2.5;
                    break;
            }
        };
        /**
        * @language zh_CN
        * 设置UV repat次数
        * @param u
        * @param v
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterNormalMethod.prototype.setUvScale = function (first, second) {
            this._normal_0_UVScale = first;
            this._normal_1_UVScale = second;
            this._uvData[6] = this._normal_0_UVScale;
            this._uvData[7] = this._normal_1_UVScale;
        };
        Object.defineProperty(WaterNormalMethod.prototype, "normalTextureA", {
            /**
             * @language zh_CN
             * 设置lightmap贴图
             * @param texture lightmap贴图
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                this._normalTexture_0 = texture;
                if (this.materialData["normalTextureA"] != this._normalTexture_0) {
                    this.materialData["normalTextureA"] = this._normalTexture_0;
                    this.materialData.textureChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterNormalMethod.prototype, "normalTextureB", {
            /**
             * @language zh_CN
             * 设置lightmap贴图
             * @param texture lightmap贴图
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                this._normalTexture_1 = texture;
                if (this.materialData["normalTextureB"] != this._normalTexture_1) {
                    this.materialData["normalTextureB"] = this._normalTexture_1;
                    this.materialData.textureChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        WaterNormalMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["waterNormalData"] = context3DProxy.getUniformLocation(usage.program3D, "waterNormalData");
            usage["time"] = context3DProxy.getUniformLocation(usage.program3D, "time");
        };
        /**
        * @private
        * @language zh_CN
        */
        WaterNormalMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (this._start) {
                this._time += delay;
                context3DProxy.uniform2fv(usage["waterNormalData"], this._uvData);
                context3DProxy.uniform1f(usage["time"], this._time);
            }
        };
        return WaterNormalMethod;
    }(egret3d.MethodBase));
    egret3d.WaterNormalMethod = WaterNormalMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVRollMethod
    * @classdesc
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EnvironmentMethod = (function (_super) {
        __extends(EnvironmentMethod, _super);
        /**
        * @private
        * @language zh_CN
        */
        function EnvironmentMethod() {
            _super.call(this);
            this.reflectValue = 0.3;
            //this.vsShaderList[ShaderPhaseType.start_vertex] = this.vsShaderList[ShaderPhaseType.start_vertex] || [];
            //this.vsShaderList[ShaderPhaseType.start_vertex].push("environmentDiffuse_vertex");
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment].push("environmentMapping_fragment");
        }
        Object.defineProperty(EnvironmentMethod.prototype, "reflect", {
            /**
             *
             * @returns number
             */
            get: function () {
                return this.reflectValue;
            },
            /**
             * @language zh_CN
             * @param value
             */
            set: function (value) {
                this.reflectValue = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentMethod.prototype, "environmentTexture", {
            /**
             * @language zh_CN
             * @param texture
             */
            set: function (texture) {
                this.texture = texture;
                if (texture) {
                    if (this.materialData["environmentMapTex"] != this.texture) {
                        this.materialData["environmentMapTex"] = texture;
                        this.materialData.textureChange = true;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        EnvironmentMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["reflectValue"] = context3DProxy.getUniformLocation(usage.program3D, "reflectValue");
        };
        /**
        * @private
        * @language zh_CN
        */
        EnvironmentMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            context3DProxy.uniform1f(usage["reflectValue"], this.reflectValue);
        };
        return EnvironmentMethod;
    }(egret3d.MethodBase));
    egret3d.EnvironmentMethod = EnvironmentMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.MethodUsageData
    * @classdesc
    * 方法中需要用到的数据。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PassUsage = (function () {
        function PassUsage() {
            /**
             * @language zh_CN
             */
            this.sampler2DList = new Array();
            /**
             * @language zh_CN
             */
            this.sampler3DList = new Array();
            //----------------------------------------------
            //public vertexShaderRegister: ver;
            this.vertexShader = new egret3d.ShaderBase(egret3d.Shader.vertex);
            this.fragmentShader = new egret3d.ShaderBase(egret3d.Shader.fragment);
            this.maxDirectLight = 0;
            this.maxSpotLight = 0;
            this.maxPointLight = 0;
            this.maxBone = 0;
            this.attributeDiry = true;
        }
        /**
         * @language zh_CN
         */
        PassUsage.prototype.dispose = function () {
        };
        return PassUsage;
    }());
    egret3d.PassUsage = PassUsage;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @class egret3d.MaterialData
     */
    var MaterialData = (function (_super) {
        __extends(MaterialData, _super);
        function MaterialData() {
            _super.apply(this, arguments);
            /**
            * @private
            * @language zh_CN
            * 材质类型数组。
            * @每个材质球可能会有很多种贴图方法，而这个是做为默认支持的材质方法的添加通道。要使用的方法
            * @default MaterialType.DIFFUSE
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.shaderPhaseTypes = {};
            /**
            * @language zh_CN
            * 深度 pass usage data。
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public depthPassUsageData: PassUsage = new PassUsage(); 
            /**
            * @language zh_CN
            * 法线 pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public normalPassUsageData: PassUsage = new PassUsage(); 
            /**
            * @language zh_CN
            * position pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public positionPassUsageData: PassUsage = new PassUsage(); 
            /**
            * @language zh_CN
            * post pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public postPassUsageData: PassUsage = new PassUsage(); 
            /**
            * @language zh_CN
            * 灯光 pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public lightPassUsageData: PassUsage = new PassUsage(); 
            /**
            * @language zh_CN
            * 阴影 pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public shadowPassUsageData: PassUsage = new PassUsage(); 
            /**
            * @language zh_CN
            * 材质球ID。
            * <p> 一个合成材质球，可以多维合成，用于标记 subGeometry 所用的材质方法
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.matID = 0;
            /**
            * @language zh_CN
            * 渲染模式。
            * @default DrawMode.TRIANGLES
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.drawMode = egret3d.DrawMode.TRIANGLES;
            /**
            * @language zh_CN
            * 法线贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.normalTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * matCapTexture。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.matcapTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * 特效贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.specularTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * 灯光贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lightTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * 遮罩贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.maskTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * ao 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.aoTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * 环境贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.environmentTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * mask 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.blendMaskTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * splat_0 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.splat_0Tex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * splat_1 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.splat_1Tex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * splat_2 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.splat_2Tex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * splat_3 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.splat_3Tex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * layer。
            * @default 0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.layer = 0;
            /**
            * @language zh_CN
            * 投射阴影 。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.castShadow = false;
            /**
            * @language zh_CN
            * 接受阴影。
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.acceptShadow = true;
            /**
            * @language zh_CN
            * 阴影颜色
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.shadowColor = new Float32Array([0.5, 0.5, 0.6]);
            /**
            * @language zh_CN
            * 深度测试 。
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.depthTest = true;
            /**
            * @language zh_CN
            * 是否平滑 。
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.smooth = true;
            /**
            * @language zh_CN
            * 混合模式 。
            * @default BlendMode.NORMAL
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.blendMode = egret3d.BlendMode.NORMAL;
            /**
            * @language zh_CN
            * alphaBlending。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.alphaBlending = false;
            /**
            * @language zh_CN
            * ambientColor 值。
            * @default 0x0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.ambientColor = 0x333333;
            /**
            * @language zh_CN
            * diffuseColor 值。
            * @default 0xffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.diffuseColor = 0xffffff;
            /**
            * @language zh_CN
            * specularColor 值。
            * @default 0xffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.specularColor = 0xffffff;
            /**
            * @language zh_CN
            * 材质球的高光强度。
            * @default 8.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.specularLevel = 4.0;
            /**
            * @language zh_CN
            * 材质球的光滑度。
            * @default 8.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.gloss = 20.0;
            /**
            * @language zh_CN
            * cutAlpha 值。
            * @default 0.7
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cutAlpha = 0.7;
            /**
            * @language zh_CN
            * 是否重复。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.repeat = false;
            /**
            * @language zh_CN
            * bothside 值。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.bothside = false;
            /**
            * @language zh_CN
            * alpha 值。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.alpha = 1.0;
            /**
            * @language zh_CN
            * 光照光滑程度，会影响反光的面积，强度。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public roughness: number = 1.0; 
            /**
             * @language zh_CN
             * 反射颜色的强度值，出射光照的出射率。
             * @default 1.0
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.albedo = 0.95;
            /**
            * @language zh_CN
            * 高光亮度的强度值,设置较大的值会让高光部分极亮。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.specularScale = 1.0;
            this.normalScale = 1.0;
            /**
            * @language zh_CN
            * uv 在贴图上的映射区域，值的范围限制在0.0~1.0之间。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.uvRectangle = new egret3d.Rectangle(0, 0, 1, 1);
            /**
            * @language zh_CN
            * ambientPower 值。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public ambientPower: number = 1.0; 
            /**
            * @language zh_CN
            * diffusePower。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public diffusePower: number = 1.0; 
            /**
            * @language zh_CN
            * normalPower 值。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public normalPower: number = 1.0; 
            /**
            * @language zh_CN
            * 材质数据需要变化。
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.materialDataNeedChange = true;
            /**
            * @language zh_CN
            * 纹理变化。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.textureChange = false;
            /**
            * @language zh_CN
            * cullFrontOrBack。
            * @default Egret3DDrive.BACK
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cullFrontOrBack = egret3d.ContextConfig.BACK;
            //data
            /**
             * @language zh_CN
             */
            this.materialSourceData = new Float32Array(20); //20
            /**
             * @language zh_CN
             */
            this.colorGradientsSource = new Float32Array(10); //10 xyz xyz rgba
            /**
            * @language zh_CN
            * 颜色变化信息。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.colorTransform = new egret3d.ColorTransform();
        }
        /**
        * @language zh_CN
        * 克隆方法。
        * @returns {MaterialData}
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialData.prototype.clone = function () {
            var data = new MaterialData();
            //data.depthPassUsageData = this.depthPassUsageData;
            //data.normalPassUsageData = this.normalPassUsageData;
            //data.positionPassUsageData = this.positionPassUsageData;
            //data.postPassUsageData = this.positionPassUsageData;
            //data.lightPassUsageData = this.positionPassUsageData;
            //data.shadowPassUsageData = this.positionPassUsageData;
            //data.textureChange = true;
            //data.textureMethodTypes = this.textureMethodTypes;
            data.drawMode = this.drawMode;
            //data.context3D = this.context3D;
            data.diffuseTexture = this.diffuseTexture;
            //data.specularTex = this.specularTex;
            //data.lightMapTex = this.lightMapTex;
            //data.environmentMapTex = this.environmentMapTex;
            data.shadowMapTexture = this.shadowMapTexture;
            for (var i = 0; i < 3; ++i) {
                data.shadowColor[i] = this.shadowColor[i];
            }
            //data.splat_0Tex = this.splat_0Tex;
            //data.splat_1Tex = this.splat_1Tex;
            //data.splat_2Tex = this.splat_2Tex;
            //data.splat_3Tex = this.splat_3Tex;
            data.layer = this.layer;
            data.castShadow = this.castShadow;
            data.acceptShadow = this.acceptShadow;
            data.depthTest = this.depthTest;
            data.smooth = this.smooth;
            data.blendMode = this.blendMode;
            data.blend_src = this.blend_src;
            data.blend_dest = this.blend_dest;
            data.ambientColor = this.ambientColor;
            data.diffuseColor = this.diffuseColor;
            data.specularColor = this.specularColor;
            data.cutAlpha = this.cutAlpha;
            data.alpha = this.alpha;
            data.specularLevel = this.specularLevel;
            data.gloss = this.gloss;
            data.albedo = this.albedo;
            data.specularScale = this.specularScale;
            data.materialDataNeedChange = this.materialDataNeedChange;
            data.textureChange = true;
            data.cullFrontOrBack = this.cullFrontOrBack;
            data.colorTransform = this.colorTransform;
            //material state
            return data;
        };
        /**
        * @language zh_CN
        * 销毁。
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialData.prototype.dispose = function () {
            //if (this.depthPassUsageData)
            //    this.depthPassUsageData.dispose();
            //if (this.normalPassUsageData)
            //    this.normalPassUsageData.dispose();
            //if (this.normalPassUsageData)
            //    this.normalPassUsageData.dispose();
            //if (this.positionPassUsageData)
            //    this.positionPassUsageData.dispose();
            //if (this.postPassUsageData)
            //    this.postPassUsageData.dispose();
            //if (this.lightPassUsageData)
            //    this.lightPassUsageData.dispose();
            //if (this.shadowPassUsageData)
            //    this.shadowPassUsageData.dispose();
            //if (this.directLightList.length > 0) {
            //    this.directLightList.length = 0;
            //    this.directLightList = null;
            //}
            //if (this.sportLightList.length > 0) {
            //    this.sportLightList.length = 0;
            //    this.sportLightList = null;
            //}
            //if (this.pointLightList.length > 0) {
            //    this.pointLightList.length = 0;
            //    this.pointLightList = null;
            //}
        };
        return MaterialData;
    }(Object));
    egret3d.MaterialData = MaterialData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.MaterialPass
    * @classdesc
    * 材质渲染pass 根据Mesh数据、模型的材质还有灯光数据的不同。
    * 以不同的渲染方法，会组成相应的shader内容，然后渲染出不同的效果。
    * 阶段 shader 灵活动态的 特效组合
    * @see egret3d.Mesh
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MaterialPass = (function () {
        /**
        * @private
        */
        function MaterialPass(materialData) {
            /**
           * @private
           */
            this._passChange = true;
            /**
           * @private
           */
            this._vs_shader_methods = {};
            /**
           * @private
           */
            this._fs_shader_methods = {};
            /**
            * @private
            */
            this.methodList = new Array();
            /**
            * @private
            */
            this.methodDatas = new Array();
            /**
            * @private
            */
            this.vsShaderNames = new Array();
            /**
            * @private
            */
            this.fsShaderNames = new Array();
            /**
            * @private
            */
            this._helpMatrix = new egret3d.Matrix4_4();
            this._materialData = materialData;
        }
        /**
        * @language zh_CN
        * 增加渲染方法
        * @param method 渲染方法
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialPass.prototype.addMethod = function (method) {
            var index = this.methodList.indexOf(method);
            if (index == -1) {
                this.methodList.push(method);
                method.materialData = this._materialData;
                this._passChange = true;
            }
        };
        /**
        * @language zh_CN
        * 移除渲染方法
        * @param method 渲染方法
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialPass.prototype.removeMethod = function (method) {
            var index = this.methodList.indexOf(method);
            if (index != -1) {
                this.methodList.slice(index);
                this._passChange = true;
            }
        };
        MaterialPass.prototype.materialDataChange = function () {
            this._materialData.materialDataNeedChange = true;
        };
        /**
        * @private
        */
        MaterialPass.prototype.passInvalid = function () {
            this._passChange = true;
        };
        /**
       * @language zh_CN
       * 重置纹理。
       * @version Egret 3.0
       * @platform Web,Native
       */
        MaterialPass.prototype.resetTexture = function (context3DProxy) {
            //--------texture----------------
            var sampler2D;
            for (var index in this._passUsage.sampler2DList) {
                sampler2D = this._passUsage.sampler2DList[index];
                if (this._materialData[sampler2D.varName]) {
                    sampler2D.texture = this._materialData[sampler2D.varName];
                }
            }
            var sampler3D;
            for (var index in this._passUsage.sampler3DList) {
                sampler3D = this._passUsage.sampler3DList[index];
                if (this._materialData[sampler3D.varName]) {
                    sampler3D.texture = this._materialData[sampler3D.varName];
                }
            }
            this._materialData.textureChange = false;
        };
        /**
        * @language zh_CN
        * @private
        * 指定shader 添加shader 片段。
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialPass.prototype.addMethodShaders = function (shaderBase, shaders) {
            for (var i = 0; i < shaders.length; i++) {
                shaderBase.addUseShaderName(shaders[i]);
            }
        };
        MaterialPass.prototype.addShaderPhase = function (passType, sourcePhase, targetPhase) {
            var names;
            var phase;
            var tn;
            for (phase in sourcePhase) {
                names = sourcePhase[phase];
                for (var i = 0; i < names.length; i++) {
                    targetPhase[phase] = targetPhase[phase] || [];
                    targetPhase[phase].push(names[i]);
                    tn = egret3d.ShaderPhaseType[phase];
                    var index = this._materialData.shaderPhaseTypes[passType].indexOf(egret3d.ShaderPhaseType[tn]);
                    if (index != -1) {
                        this._materialData.shaderPhaseTypes[passType].splice(index, 1);
                    }
                }
            }
        };
        MaterialPass.prototype.initOthreMethods = function () {
            var shaderPhase;
            var shaderList;
            for (var d = 0; d < this.methodList.length; d++) {
                var method = this.methodList[d];
                for (shaderPhase in method.vsShaderList) {
                    shaderList = method.vsShaderList[shaderPhase];
                    for (var i = 0; i < shaderList.length; i++) {
                        this._vs_shader_methods[shaderPhase] = this._vs_shader_methods[shaderPhase] || [];
                        this._vs_shader_methods[shaderPhase].push(shaderList[i]);
                    }
                }
                for (shaderPhase in method.fsShaderList) {
                    shaderList = method.fsShaderList[shaderPhase];
                    for (var i = 0; i < shaderList.length; i++) {
                        this._fs_shader_methods[shaderPhase] = this._fs_shader_methods[shaderPhase] || [];
                        this._fs_shader_methods[shaderPhase].push(shaderList[i]);
                    }
                }
            }
        };
        /**
        * @language zh_CN
        * @private
        * 初始化 UseMethod。
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialPass.prototype.initUseMethod = function (animation, geom) {
            this._passChange = false;
            var i = 0;
            this._passUsage = new egret3d.PassUsage();
            this._vs_shader_methods = {};
            this._fs_shader_methods = {};
            //pre Phase ---------------------------------------------------
            if (animation) {
                // to add accept animation shader
                if (animation.skeletonAnimationController) {
                    this._passUsage.maxBone = animation.skeletonAnimationController.jointNum * 2;
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("skeleton_vs");
                }
                else if (animation.particleAnimationController) {
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("particle_vs");
                    //to change importent
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.vertex_shaders, this._vs_shader_methods);
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.fragment_shaders, this._fs_shader_methods);
                }
            }
            if (this._materialData.acceptShadow) {
                // to add accept shadow maping shader+
                this._vs_shader_methods[egret3d.ShaderPhaseType.global_vertex] = this._vs_shader_methods[egret3d.ShaderPhaseType.global_vertex] || [];
                //this._vs_shader_methods[ShaderPhaseType.global_vertex].push("particle_vs");
                this._fs_shader_methods[egret3d.ShaderPhaseType.shadow_fragment] = this._fs_shader_methods[egret3d.ShaderPhaseType.shadow_fragment] || [];
            }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.diffuse_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment].push("diffuse_fragment");
            }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.normal_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.normal_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.normal_fragment].push("normalMap_fragment");
            }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.specular_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.specular_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.specular_fragment].push("specularMap_fragment");
            }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.matCap_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.matCap_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.matCap_fragment].push("matCap_TextureMult_fs");
            }
            if (this.lightGroup) {
                this._passUsage.maxDirectLight = this.lightGroup.directLightList.length;
                this._passUsage.maxSpotLight = this.lightGroup.spotLightList.length;
                this._passUsage.maxPointLight = this.lightGroup.pointLightList.length;
                this._vs_shader_methods[egret3d.ShaderPhaseType.local_vertex] = this._vs_shader_methods[egret3d.ShaderPhaseType.local_vertex] || [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.lighting_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.lighting_fragment].push("lightingBase_fs");
                if (this.lightGroup.directLightList.length) {
                    this._passUsage.directLightData = new Float32Array(egret3d.DirectLight.stride * this.lightGroup.directLightList.length);
                    this._vs_shader_methods[egret3d.ShaderPhaseType.local_vertex].push("varyingViewDir_vs");
                    this._fs_shader_methods[egret3d.ShaderPhaseType.lighting_fragment].push("directLight_fragment");
                }
                if (this.lightGroup.spotLightList.length) {
                    this._passUsage.spotLightData = new Float32Array(egret3d.SpotLight.stride * this.lightGroup.spotLightList.length);
                    this._fs_shader_methods[egret3d.ShaderPhaseType.lighting_fragment].push("spotLight_fragment");
                }
                if (this.lightGroup.pointLightList.length) {
                    this._passUsage.pointLightData = new Float32Array(egret3d.PointLight.stride * this.lightGroup.pointLightList.length);
                    this._fs_shader_methods[egret3d.ShaderPhaseType.lighting_fragment].push("pointLight_fragment");
                }
            }
            this.initOthreMethods();
            //pre Phase end ---------------------------------------------------
            var shaderList;
            //---vs---shadering
            this.addMethodShaders(this._passUsage.vertexShader, ["base_vs"]);
            //start Phase
            shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.vertexShader, shaderList);
            else
                this.addMethodShaders(this._passUsage.vertexShader, ["diffuse_vertex"]);
            //local
            shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.local_vertex];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.vertexShader, shaderList);
            //global
            shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.global_vertex];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.vertexShader, shaderList);
            //end
            shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.end_vertex];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.vertexShader, shaderList);
            else
                this.addMethodShaders(this._passUsage.vertexShader, ["end_vs"]);
            //---vs---shadering-------------------------------------------------
            //---fs---shadering
            this.addMethodShaders(this._passUsage.fragmentShader, ["base_fs"]);
            //start
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.start_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            //materialsource
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.materialsource_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            else
                this.addMethodShaders(this._passUsage.fragmentShader, ["materialSource_fs"]);
            //diffuse
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            else
                this.addMethodShaders(this._passUsage.fragmentShader, ["diffuse_fragment"]);
            //normal
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.normal_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            //else
            //    this.addMethodShaders(this._passUsage.fragmentShader, ["normalMap_fragment"]);
            //else
            //    this.addMethodShaders(this._passUsage.fragmentShader, ["specularMap_fragment"]);
            //shadow
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.shadow_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            //lighting
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.lighting_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            //specular
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.specular_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            //matCap
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.matCap_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            //multi_end_fragment
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.multi_end_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            //else 
            //    this.addMethodShaders(this._passUsage.fragmentShader, ["matCap_TextureAdd_fs"]);
            //end
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            else {
                if (animation && animation.particleAnimationController) {
                    this.addMethodShaders(this._passUsage.fragmentShader, ["particle_end_fs"]);
                }
                else {
                    this.addMethodShaders(this._passUsage.fragmentShader, ["end_fs"]);
                }
            }
            //---fs---shadering-------------------------------------------------
        };
        /**
        * @private
        */
        MaterialPass.prototype.upload = function (time, delay, context3DProxy, modeltransform, camera3D, animation, geometry) {
            if (this._passChange && this._passUsage) {
                //delete this._passUsage; 
                egret3d.Context3DProxy.gl.deleteProgram(this._passUsage.program3D.program);
            }
            this._passChange = false;
            this.initUseMethod(animation, geometry);
            this._passUsage.vertexShader.shader = this._passUsage.vertexShader.getShader(this._passUsage);
            this._passUsage.fragmentShader.shader = this._passUsage.fragmentShader.getShader(this._passUsage);
            this._passUsage.program3D = egret3d.ShaderPool.getProgram(this._passUsage.vertexShader.shader.id, this._passUsage.fragmentShader.shader.id);
            for (var property in this._passUsage) {
                if (property.indexOf("uniform") != -1) {
                    if (this._passUsage[property]) {
                        this._passUsage[property].uniformIndex = context3DProxy.getUniformLocation(this._passUsage.program3D, property);
                    }
                }
            }
            var sampler2D;
            for (var index in this._passUsage.sampler2DList) {
                sampler2D = this._passUsage.sampler2DList[index];
                sampler2D.uniformIndex = context3DProxy.getUniformLocation(this._passUsage.program3D, sampler2D.varName);
            }
            var sampler3D;
            for (var index in this._passUsage.sampler3DList) {
                sampler3D = this._passUsage.sampler3DList[index];
                sampler3D.uniformIndex = context3DProxy.getUniformLocation(this._passUsage.program3D, sampler3D.varName);
            }
            if (this.methodList) {
                for (var i = 0; i < this.methodList.length; i++) {
                    this.methodList[i].upload(time, delay, this._passUsage, null, context3DProxy, modeltransform, camera3D);
                }
            }
        };
        /**
        * @private
        */
        MaterialPass.prototype.draw = function (time, delay, context3DProxy, modeltransform, camera3D, subGeometry, animation) {
            if (this._materialData.materialDataNeedChange) {
                //this._materialData.materialDataNeedChange = false;
                this._materialData.materialSourceData[0] = (this._materialData.diffuseColor >> 16 & 0xff) / 255.0;
                this._materialData.materialSourceData[1] = (this._materialData.diffuseColor >> 8 & 0xff) / 255.0;
                this._materialData.materialSourceData[2] = (this._materialData.diffuseColor & 0xff) / 255.0;
                this._materialData.materialSourceData[3] = (this._materialData.ambientColor >> 16 & 0xff) / 255.0;
                this._materialData.materialSourceData[4] = (this._materialData.ambientColor >> 8 & 0xff) / 255.0;
                this._materialData.materialSourceData[5] = (this._materialData.ambientColor & 0xff) / 255.0;
                this._materialData.materialSourceData[6] = (this._materialData.specularColor >> 16 & 0xff) / 255.0;
                this._materialData.materialSourceData[7] = (this._materialData.specularColor >> 8 & 0xff) / 255.0;
                this._materialData.materialSourceData[8] = (this._materialData.specularColor & 0xff) / 255.0;
                this._materialData.materialSourceData[9] = this._materialData.alpha;
                this._materialData.materialSourceData[10] = this._materialData.cutAlpha;
                this._materialData.materialSourceData[11] = this._materialData.gloss;
                this._materialData.materialSourceData[12] = this._materialData.specularLevel;
                this._materialData.materialSourceData[13] = this._materialData.albedo;
                this._materialData.materialSourceData[14] = this._materialData.uvRectangle.x;
                this._materialData.materialSourceData[15] = this._materialData.uvRectangle.y; //保留
                this._materialData.materialSourceData[16] = this._materialData.uvRectangle.width; //保留
                this._materialData.materialSourceData[17] = this._materialData.uvRectangle.height; //保留
                this._materialData.materialSourceData[18] = this._materialData.specularLevel; //保留
                this._materialData.materialSourceData[19] = this._materialData.normalScale; //保留
            }
            if (this._passChange) {
                this.upload(time, delay, context3DProxy, modeltransform, camera3D, animation, subGeometry.geometry);
            }
            context3DProxy.setProgram(this._passUsage.program3D);
            subGeometry.activeState(time, delay, this._passUsage, context3DProxy);
            if (this._materialData.depthTest) {
                context3DProxy.enableDepth();
                context3DProxy.depthFunc(egret3d.ContextConfig.LEQUAL);
            }
            else {
                context3DProxy.disableDepth();
                context3DProxy.depthFunc(egret3d.ContextConfig.LEQUAL);
            }
            context3DProxy.setCulling(this._materialData.cullFrontOrBack);
            if (this._materialData.bothside) {
                context3DProxy.disableCullFace();
            }
            else
                context3DProxy.enableCullFace();
            if (this._materialData.alphaBlending)
                egret3d.Context3DProxy.gl.depthMask(false);
            context3DProxy.enableBlend();
            context3DProxy.setBlendFactors(this._materialData.blend_src, this._materialData.blend_dest);
            if (this._passUsage.uniform_materialSource) {
                context3DProxy.uniform1fv(this._passUsage.uniform_materialSource.uniformIndex, this._materialData.materialSourceData);
            }
            if (this._materialData.textureChange) {
                this.resetTexture(context3DProxy);
            }
            //texture 2D
            var sampler2D;
            for (var index in this._passUsage.sampler2DList) {
                sampler2D = this._passUsage.sampler2DList[index];
                sampler2D.texture = this._materialData[sampler2D.varName];
                if (!sampler2D.texture) {
                    continue;
                }
                sampler2D.texture.upload(context3DProxy);
                context3DProxy.setTexture2DAt(sampler2D.activeTextureIndex, sampler2D.uniformIndex, sampler2D.index, sampler2D.texture.texture2D);
                if (this._materialData.materialDataNeedChange) {
                    var min_filter = (this._materialData.smooth && sampler2D.texture.texture2D.useMipmap) ? egret3d.Context3DProxy.gl.LINEAR_MIPMAP_LINEAR : egret3d.Context3DProxy.gl.LINEAR;
                    var mag_filter = this._materialData.smooth ? egret3d.Context3DProxy.gl.LINEAR : egret3d.Context3DProxy.gl.LINEAR;
                    var wrap_u_filter = this._materialData.repeat ? egret3d.Context3DProxy.gl.REPEAT : egret3d.Context3DProxy.gl.CLAMP_TO_EDGE;
                    var wrap_v_filter = this._materialData.repeat ? egret3d.Context3DProxy.gl.REPEAT : egret3d.Context3DProxy.gl.CLAMP_TO_EDGE;
                    context3DProxy.setTexture2DSamplerState(min_filter, mag_filter, wrap_u_filter, wrap_v_filter);
                    this._materialData.materialDataNeedChange = false;
                }
            }
            var sampler3D;
            for (var index in this._passUsage.sampler3DList) {
                sampler3D = this._passUsage.sampler3DList[index];
                sampler3D.texture = this._materialData[sampler3D.varName];
                if (!sampler3D.texture) {
                    continue;
                }
                sampler3D.texture.upload(context3DProxy);
                context3DProxy.setCubeTextureAt(sampler3D.activeTextureIndex, sampler3D.uniformIndex, sampler3D.index, sampler3D.texture.texture3D);
            }
            var i = 0;
            if (this.lightGroup) {
                for (i = 0; i < this._passUsage.maxDirectLight; i++) {
                    this.lightGroup.directLightList[i].updateLightData(camera3D, i, this._passUsage.directLightData);
                }
                for (i = 0; i < this._passUsage.maxSpotLight; i++) {
                    this.lightGroup.spotLightList[i].updateLightData(camera3D, i, this._passUsage.spotLightData);
                }
                for (i = 0; i < this._passUsage.maxPointLight; i++) {
                    this.lightGroup.pointLightList[i].updateLightData(camera3D, i, this._passUsage.pointLightData);
                }
                if (this._passUsage.uniform_directLightSource)
                    context3DProxy.uniform1fv(this._passUsage.uniform_directLightSource.uniformIndex, this._passUsage.directLightData);
                if (this._passUsage.uniform_sportLightSource)
                    context3DProxy.uniform1fv(this._passUsage.uniform_sportLightSource.uniformIndex, this._passUsage.spotLightData);
                if (this._passUsage.uniform_pointLightSource)
                    context3DProxy.uniform1fv(this._passUsage.uniform_pointLightSource.uniformIndex, this._passUsage.pointLightData);
            }
            if (this._passUsage.uniform_ModelMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_ModelMatrix.uniformIndex, false, modeltransform.rawData);
            }
            if (this._passUsage.uniform_ViewMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_ViewMatrix.uniformIndex, false, camera3D.viewMatrix.rawData);
            }
            if (this._passUsage.uniform_ProjectionMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_ProjectionMatrix.uniformIndex, false, camera3D.projectMatrix.rawData);
            }
            if (this._passUsage.uniform_ModelViewMatrix) {
                this._helpMatrix.identity();
                this._helpMatrix.copyFrom(modeltransform);
                this._helpMatrix.multiply(camera3D.viewMatrix);
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_ModelViewMatrix.uniformIndex, false, this._helpMatrix.rawData);
            }
            if (this._passUsage.uniform_ViewProjectionMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_ViewProjectionMatrix.uniformIndex, false, camera3D.viewProjectionMatrix.rawData);
            }
            if (animation) {
                animation.activeState(time, delay, this._passUsage, subGeometry, context3DProxy, modeltransform, camera3D);
            }
            if (this.methodList) {
                for (var i = 0; i < this.methodList.length; i++) {
                    this.methodList[i].activeState(time, delay, this._passUsage, null, context3DProxy, modeltransform, camera3D);
                }
            }
            if (this._passUsage.uniform_NormalMatrix) {
                this._helpMatrix.identity();
                this._helpMatrix.copyFrom(modeltransform);
                this._helpMatrix.multiply(camera3D.viewMatrix);
                this._helpMatrix.invert();
                this._helpMatrix.transpose();
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_NormalMatrix.uniformIndex, false, this._helpMatrix.rawData);
            }
            if (this._passUsage.uniform_ShadowMatrix) {
            }
            if (this._passUsage.uniform_eyepos) {
                context3DProxy.uniform3f(this._passUsage.uniform_eyepos.uniformIndex, camera3D.x, camera3D.y, camera3D.z);
            }
            if (this._passUsage.uniform_cameraMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_cameraMatrix.uniformIndex, false, camera3D.modelMatrix.rawData);
            }
            context3DProxy.drawElement(this._materialData.drawMode, subGeometry.start, subGeometry.count);
            if (this._materialData.alphaBlending)
                egret3d.Context3DProxy.gl.depthMask(true);
            //this.deactiveState(this._passUsage, context3DProxy);
            subGeometry.deactiveState(this._passUsage, context3DProxy);
        };
        MaterialPass.prototype.deactiveState = function (passUsage, context3DProxy) {
            var sampler2D;
            for (var index in passUsage.sampler2DList) {
                sampler2D = this._passUsage.sampler2DList[index];
                if (!sampler2D.texture) {
                    continue;
                }
                context3DProxy.disableTexture2DAt(sampler2D.activeTextureIndex, sampler2D.uniformIndex, sampler2D.index);
            }
        };
        MaterialPass.prototype.dispose = function () {
        };
        return MaterialPass;
    }());
    egret3d.MaterialPass = MaterialPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ColorPass = (function (_super) {
        __extends(ColorPass, _super);
        function ColorPass(materialData) {
            _super.call(this, materialData);
            this._passID = egret3d.PassType.colorPass;
        }
        /**
       * @language zh_CN
       * @private
       * 初始化 UseMethod。
       * @version Egret 3.0
       * @platform Web,Native
       */
        ColorPass.prototype.initUseMethod = function (animation, geom) {
            _super.prototype.initUseMethod.call(this, animation, geom);
        };
        return ColorPass;
    }(egret3d.MaterialPass));
    egret3d.ColorPass = ColorPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var DiffusePass = (function (_super) {
        __extends(DiffusePass, _super);
        function DiffusePass(materialData) {
            _super.call(this, materialData);
            this._passID = egret3d.PassType.diffusePass;
        }
        /**
        * @language zh_CN
        * @private
        * 初始化 UseMethod。
        * @version Egret 3.0
        * @platform Web,Native
        */
        DiffusePass.prototype.initUseMethod = function (animation, geom) {
            _super.prototype.initUseMethod.call(this, animation, geom);
        };
        return DiffusePass;
    }(egret3d.MaterialPass));
    egret3d.DiffusePass = DiffusePass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ShadowPass = (function (_super) {
        __extends(ShadowPass, _super);
        function ShadowPass(materialData) {
            _super.call(this, materialData);
            this._passID = egret3d.PassType.shadowPass;
        }
        /**
        * @language zh_CN
        * @private
        * 初始化 UseMethod。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ShadowPass.prototype.initUseMethod = function (animation, geom) {
            this._passChange = false;
            var i = 0;
            this._passUsage = new egret3d.PassUsage();
            this._vs_shader_methods = {};
            this._fs_shader_methods = {};
            //pre Phase ---------------------------------------------------
            if (animation) {
                // to add accept animation shader
                if (animation.skeletonAnimationController) {
                    this._passUsage.maxBone = animation.skeletonAnimationController.jointNum * 2;
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("skeletonShadowPass_vs");
                }
                else if (animation.particleAnimationController) {
                }
            }
            else {
                this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("staticShadowPass_vs");
            }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.shadowPass].indexOf(egret3d.ShaderPhaseType.diffuse_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment].push("diffuseShadowPass_fs");
            }
            //this.initOthreMethods();
            //pre Phase end ---------------------------------------------------
            var shaderList;
            //---vs---shadering
            this.addMethodShaders(this._passUsage.vertexShader, ["baseShadowPass_vs"]);
            //start Phase
            shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.vertexShader, shaderList);
            this.addMethodShaders(this._passUsage.vertexShader, ["endShadowPass_vs"]);
            //---vs---shadering-------------------------------------------------
            //---fs---shadering
            this.addMethodShaders(this._passUsage.fragmentShader, ["baseShadowPass_fs"]);
            //diffuse
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            this.addMethodShaders(this._passUsage.fragmentShader, ["endShadowPass_fs"]);
            //---fs---shadering-------------------------------------------------
        };
        return ShadowPass;
    }(egret3d.MaterialPass));
    egret3d.ShadowPass = ShadowPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var CubePass = (function (_super) {
        __extends(CubePass, _super);
        function CubePass(materialData) {
            _super.call(this, materialData);
            this._passID = egret3d.PassType.CubePass;
        }
        /**
        * @language zh_CN
        * @private
        * 初始化 UseMethod。
        * @version Egret 3.0
        * @platform Web,Native
        */
        CubePass.prototype.initUseMethod = function (animation, geom) {
            this._passChange = false;
            // this._materialData.textureMethodTypes.push(TextureMethodType.color);
            var i = 0;
            this._passUsage = new egret3d.PassUsage();
            this._passUsage.vertexShader.shaderType = egret3d.Shader.vertex;
            this._passUsage.fragmentShader.shaderType = egret3d.Shader.fragment;
            //if (this._materialData.textureMethodTypes.indexOf(TextureMethodType.color) != -1) {
            this._passUsage.vertexShader.addUseShaderName("cube_vertex");
            this._passUsage.fragmentShader.addUseShaderName("cube_fragment");
            // }
        };
        return CubePass;
    }(egret3d.MaterialPass));
    egret3d.CubePass = CubePass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var MatCapPass = (function (_super) {
        __extends(MatCapPass, _super);
        function MatCapPass(materialData) {
            _super.call(this, materialData);
            this._passID = egret3d.PassType.matCapPass;
        }
        /**
        * @language zh_CN
        * @private
        * 初始化 UseMethod。
        * @version Egret 3.0
        * @platform Web,Native
        */
        MatCapPass.prototype.initUseMethod = function (animation, geom) {
            this._passChange = false;
            var i = 0;
            this._passUsage = new egret3d.PassUsage();
            this._vs_shader_methods = {};
            this._fs_shader_methods = {};
            //pre Phase ---------------------------------------------------
            if (animation) {
                // to add accept animation shader
                if (animation.skeletonAnimationController) {
                    this._passUsage.maxBone = animation.skeletonAnimationController.jointNum * 2;
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("skeleton_vs");
                }
            }
            // if (this._materialData.shaderPhaseTypes[PassType.matCapPass] && this._materialData.shaderPhaseTypes[PassType.matCapPass].indexOf(ShaderPhaseType.local_vertex) != -1) {
            //this._vs_shader_methods[ShaderPhaseType.local_vertex] = [];
            //this._vs_shader_methods[ShaderPhaseType.local_vertex].push("matCapPass_vs");
            // }
            // if (this._materialData.shaderPhaseTypes[PassType.matCapPass] && this._materialData.shaderPhaseTypes[PassType.matCapPass].indexOf(ShaderPhaseType.diffuse_fragment) != -1) {
            this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment] = [];
            this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment].push("diffuse_fragment");
            this._fs_shader_methods[egret3d.ShaderPhaseType.matCap_fragment] = [];
            this._fs_shader_methods[egret3d.ShaderPhaseType.matCap_fragment].push("matCap_TextureAdd_fs");
            //  }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.matCapPass] && this._materialData.shaderPhaseTypes[egret3d.PassType.matCapPass].indexOf(egret3d.ShaderPhaseType.normal_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.normal_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.normal_fragment].push("normalMap_fragment");
            }
            //------pre----
            //this._fs_shader_methods[ShaderPhaseType.diffuse_fragment].push("matCapPass_fs");
            //this.initOthreMethods();
            //pre Phase end ---------------------------------------------------
            var shaderList;
            //---vs---shadering
            this.addMethodShaders(this._passUsage.vertexShader, ["base_vs", "tangent_vs"]);
            //start Phase
            shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.vertexShader, shaderList);
            else
                this.addMethodShaders(this._passUsage.vertexShader, ["diffuse_vertex"]);
            //local
            shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.local_vertex];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.vertexShader, shaderList);
            this.addMethodShaders(this._passUsage.vertexShader, ["end_vs"]);
            //---vs---shadering-------------------------------------------------
            //---fs---shadering
            this.addMethodShaders(this._passUsage.fragmentShader, ["base_fs"]);
            //materialsource
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.materialsource_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            else
                this.addMethodShaders(this._passUsage.fragmentShader, ["materialSource_fs"]);
            //diffuse
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            //normal
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.normal_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            //matCap
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.matCap_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            this.addMethodShaders(this._passUsage.fragmentShader, ["end_fs"]);
            //---fs---shadering-------------------------------------------------
        };
        return MatCapPass;
    }(egret3d.MaterialPass));
    egret3d.MatCapPass = MatCapPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    (function (PassType) {
        PassType[PassType["diffusePass"] = 0] = "diffusePass";
        PassType[PassType["colorPass"] = 1] = "colorPass";
        PassType[PassType["normalPass"] = 2] = "normalPass";
        PassType[PassType["shadowPass"] = 3] = "shadowPass";
        PassType[PassType["lightPass"] = 4] = "lightPass";
        PassType[PassType["matCapPass"] = 5] = "matCapPass";
        PassType[PassType["depthPass_8"] = 6] = "depthPass_8";
        PassType[PassType["depthPass_32"] = 7] = "depthPass_32";
        PassType[PassType["CubePass"] = 8] = "CubePass";
    })(egret3d.PassType || (egret3d.PassType = {}));
    var PassType = egret3d.PassType;
    var PassUtil = (function () {
        function PassUtil() {
        }
        PassUtil.CreatPass = function (pass, materialData) {
            switch (pass) {
                case PassType.colorPass:
                    materialData.shaderPhaseTypes[PassType.colorPass] = [];
                    return [new egret3d.ColorPass(materialData)];
                case PassType.diffusePass:
                    materialData.shaderPhaseTypes[PassType.diffusePass] = [];
                    return [new egret3d.DiffusePass(materialData)];
                case PassType.shadowPass:
                    materialData.shaderPhaseTypes[PassType.shadowPass] = [];
                    return [new egret3d.ShadowPass(materialData)];
                case PassType.matCapPass:
                    materialData.shaderPhaseTypes[PassType.matCapPass] = [];
                    return [new egret3d.MatCapPass(materialData)];
                case PassType.CubePass:
                    materialData.shaderPhaseTypes[PassType.diffusePass] = [];
                    return [new egret3d.CubePass(materialData)];
            }
            return null;
        };
        PassUtil.PassAuto = [true, true, true, false, false, true, true, true];
        return PassUtil;
    }());
    egret3d.PassUtil = PassUtil;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.MaterialBase
    * @classdesc
    * 材质球共有的基础类型，封装了材质球共有的基础数据设置方法。</p>
    * 不同的渲染通道pass。</p>
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MaterialBase = (function () {
        /**
        * @language zh_CN
        * @class egret3d.MaterialBase
        * @classdesc
        * TerrainMaterial,TextureMaterial 的基类。</p>
        * 材质球共有的基础类型，封装了材质球共有的基础数据设置方法。</p>
        * 不同的渲染通道pass。</p>
        * @version Egret 3.0
        * @platform Web,Native
        */
        function MaterialBase(materialData) {
            if (materialData === void 0) { materialData = null; }
            /**
             * @language zh_CN
             * @private
             * @version Egret 3.0
             * @platform Web,Native
             */
            //public diffusePass: MaterialPass; 
            //public shadowPass: MaterialPass; 
            this.passes = [];
            if (materialData == null) {
                this.setData(new egret3d.MaterialData());
            }
            else
                this.setData(materialData);
        }
        /**
         * @language zh_CN
         * @private
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.setData = function (data) {
            this.materialData = data;
            this.initPass();
            this.blendMode = egret3d.BlendMode.NORMAL;
        };
        /**
         * @language zh_CN
         * @private
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.getData = function () {
            return this.materialData;
        };
        MaterialBase.prototype.initPass = function () {
            //this.passes[PassType.diffusePass] = new ColorPass(this.materialData);
            this.addPass(egret3d.PassType.colorPass);
        };
        Object.defineProperty(MaterialBase.prototype, "lightGroup", {
            /**
             * @language zh_CN
             * 获取材质球接受的灯光组。
             * @return LightGroup 灯光组
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._lightGroup;
            },
            /**
             * @language zh_CN
             * 设置材质 lightGroup 。
             * 设置材质球接受的灯光组。
             * @param lightGroup LightGroup
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (group) {
                this._lightGroup = group;
                if (this.passes[egret3d.PassType.diffusePass] && this.passes[egret3d.PassType.diffusePass].length > 0) {
                    for (var i = 0; i < this.passes[egret3d.PassType.diffusePass].length; i++) {
                        this.passes[egret3d.PassType.diffusePass][i].lightGroup = group;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "diffuseTexture", {
            /**
            * @language zh_CN
            * 返回材质 diffuseTexture。
            * 返回材质球的漫反射贴图。
            * @returns ITexture 漫反射贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.diffuseTexture;
            },
            ///**
            // * @language zh_CN
            // * 设置材质 shadowMapTexture 。
            // * 设置材质球的阴影贴图。
            // * @param texture ITexture
            // * @version Egret 3.0
            // * @platform Web,Native
            // */
            ////public set shadowMapTexture(texture: ITexture) {
            ////    if (texture) {
            ////        this.materialData.shadowMapTexture = texture;
            ////        this.materialData.textureChange = true;
            ////        //if (this.materialData.shaderPhaseTypes.indexOf(ShaderPhaseType.shadow_fragment) == -1) {
            ////        //    this.materialData.shaderPhaseTypes.push(ShaderPhaseType.shadow_fragment);
            ////        //    this.diffusePass.passInvalid();
            ////        //}
            ////    }
            ////}
            ///**
            //* @language zh_CN
            //* 返回材质 shadowMapTexture。
            //* 返回材质球的阴影贴图。
            //* @returns ITexture 阴影贴图
            //* @version Egret 3.0
            //* @platform Web,Native
            //*/
            ////public get shadowMapTexture(): ITexture {
            ////    return this.materialData.shadowMapTexture;
            ////}
            /**
             * @language zh_CN
             * 设置材质 diffuseTexture 。
             * 设置材质球的漫反射贴图。
             * @param texture ITexture
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                if (texture) {
                    this.materialData.diffuseTexture = texture;
                    this.materialData.textureChange = true;
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass] && this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.diffuse_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].push(egret3d.ShaderPhaseType.diffuse_fragment);
                    }
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.shadowPass] && this.materialData.shaderPhaseTypes[egret3d.PassType.shadowPass].indexOf(egret3d.ShaderPhaseType.diffuse_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.shadowPass].push(egret3d.ShaderPhaseType.diffuse_fragment);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "normalTexture", {
            /**
             * @language zh_CN
             * 得到材质球的凹凸法线贴图。
             * @returns ITexture
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.normalTexture;
            },
            /**
             * @language zh_CN
             * 设置材质 normalTexture 。
             * 设置材质球的凹凸法线贴图。
             * @param texture {TextureBase}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                if (texture) {
                    this.materialData.normalTexture = texture;
                    this.materialData.textureChange = true;
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass] && this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.normal_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].push(egret3d.ShaderPhaseType.normal_fragment);
                        this.passInvalid(egret3d.PassType.diffusePass);
                    }
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.matCapPass] && this.materialData.shaderPhaseTypes[egret3d.PassType.matCapPass].indexOf(egret3d.ShaderPhaseType.normal_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.matCapPass].push(egret3d.ShaderPhaseType.normal_fragment);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        MaterialBase.prototype.passInvalid = function (passType) {
            if (this.passes[passType] && this.passes[passType].length > 0) {
                for (var i = 0; i < this.passes[passType].length; i++) {
                    this.passes[passType][i].passInvalid();
                }
            }
        };
        Object.defineProperty(MaterialBase.prototype, "matcapTexture", {
            /**
            * @language zh_CN
            * 得到材质球特殊光效贴图。
            * @returns ITexture
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.normalTexture;
            },
            /**
              * @language zh_CN
              * 设置材质 matcapTexture 。
              * 设置材质球特殊光效算法。
              * @param texture {TextureBase}
              * @version Egret 3.0
              * @platform Web,Native
              */
            set: function (texture) {
                if (texture) {
                    this.materialData.matcapTexture = texture;
                    this.materialData.textureChange = true;
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass] && this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.matCap_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].push(egret3d.ShaderPhaseType.matCap_fragment);
                        this.passInvalid(egret3d.PassType.diffusePass);
                    }
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.matCapPass] && this.materialData.shaderPhaseTypes[egret3d.PassType.matCapPass].indexOf(egret3d.ShaderPhaseType.matCap_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.matCapPass].push(egret3d.ShaderPhaseType.matCap_fragment);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "specularTexture", {
            /**
             * @language zh_CN
             * 得到材质球的高光贴图。
             * @returns ITexture
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.specularTexture;
            },
            /**
             * @language zh_CN
             * 设置材质 specularTexture 。
             * 设置材质球的高光贴图。
             * @param texture {TextureBase}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                if (texture) {
                    this.materialData.specularTexture = texture;
                    this.materialData.textureChange = true;
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass] && this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.specular_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].push(egret3d.ShaderPhaseType.specular_fragment);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "drawMode", {
            /**
            * @language zh_CN
            * 设置模型渲染模式。模型可以以顶点的方式渲染，线框渲染（会需要特定模型），三角形渲染
            * DrawMode.POINTS
            * rawMode.LINES
            * DrawMode.TRIANGLES
            * @default DrawMode.TRIANGLES
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.drawMode;
            },
            /**
            * @language zh_CN
            * 设置模型渲染模式。模型可以以顶点的方式渲染，线框渲染（会需要特定模型），三角形渲染
            * DrawMode.POINTS
            * rawMode.LINES
            * DrawMode.TRIANGLES
            * @default DrawMode.TRIANGLES
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (mode) {
                this.materialData.drawMode = mode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "cutAlpha", {
            /**
            * @language zh_CN
            * 设置模型渲染模式。模型渲染中，带透明贴图的 去除不渲染透明透明部分的阀值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.cutAlpha;
            },
            /**
            * @language zh_CN
            * 设置模型渲染模式。模型渲染中，带透明贴图的 去除不渲染透明透明部分的阀值
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (v) {
                this.materialData.cutAlpha = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "diffuseColor", {
            /**
            * @language zh_CN
            * 获取材质 diffuseColor
            * @returns number 材质 diffuseColor
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.diffuseColor;
            },
            /**
            * @language zh_CN
            * 设置材质 diffuseColor。
            * 设置 16 进制的漫反射颜色
            * @param color {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this.materialData.materialDataNeedChange = true;
                this.materialData.diffuseColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "ambientColor", {
            /**
            * @language zh_CN
            * 获取材质 ambientColor
            * @returns number 材质 ambientColor
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.ambientColor;
            },
            /**
            * @language zh_CN
            * 设置材质 ambientColor。
            * 设置 16 进制的环境光颜色
            * @param color {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this.materialData.materialDataNeedChange = true;
                this.materialData.ambientColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "specularColor", {
            /**
            * @language zh_CN
            * 获取材质 specularColor
            * @returns number 材质 specularColor
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.specularColor;
            },
            /**
            * @language zh_CN
            * 设置材质 specularColor。
            * 设置 16 进制的镜面光反射颜色
            * @param color {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this.materialData.materialDataNeedChange = true;
                this.materialData.specularColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "alpha", {
            /**
             * @language zh_CN
             * 返回材质 alpha 值。
             * 返回 alpha 颜色
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.alpha;
            },
            /**
             * @language zh_CN
             * 设置材质 alpha 值。
             * 设置 材质球的透明度，如果透明度小于1会自动启用 alphablending
             * @param value {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                if (this.materialData.alpha != value) {
                    this.materialData.alpha = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "specularLevel", {
            /**
             * @language zh_CN
             * 返回材质 specularLevel 值。
             * 返回材质 材质球的高光强度
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.specularLevel;
            },
            /**
             * @language zh_CN
             * 设置材质 specularLevel 值。
             * 设置材质球的材质球的高光强度
             * @param value {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                if (this.materialData.specularLevel != value) {
                    this.materialData.specularLevel = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "gloss", {
            /**
             * @language zh_CN
             * 返回材质球的镜面平滑程度值。
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.gloss;
            },
            /**
             * @language zh_CN
             * 设置材质 gloss 值。
             * 设置材质 镜面平滑程度值。
             * @param value {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                if (this.materialData.gloss != value) {
                    this.materialData.gloss = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "uvRectangle", {
            /**
            * @language zh_CN
            * 获取映射贴图UV坐标，区域，用uvRectangle 的方式映射
            * @return rect Rectangle
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.uvRectangle;
            },
            /**
            * @language zh_CN
            * 映射贴图UV坐标，设置此材质要显示使用贴图的区域，用uvRectangle 的方式映射
            * @param rect Rectangle
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (rect) {
                this.materialData.uvRectangle.x = rect.x;
                this.materialData.uvRectangle.y = rect.y;
                this.materialData.uvRectangle.width = rect.width;
                this.materialData.uvRectangle.height = rect.height;
                this.materialData.materialDataNeedChange = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "diffusePass", {
            /**
             * @private
             * @language zh_CN
             * 设置材质 ambientPower 值。
             * 设置材质 环境光颜色的强度 值。
             * @param value {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.passes[egret3d.PassType.diffusePass][0];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         * 设置材质 ambientPower 值。
         * 设置材质 环境光颜色的强度 值。
         * @param value {Number}
         * @version Egret 3.0
         * @platform Web,Native
         */
        //public set ambientPower(value: number) {
        //    if (this.materialData.ambientPower != value) {
        //        this.materialData.ambientPower = value;
        //        this.materialData.materialDataNeedChange = true;
        //    }
        //}
        /**
         * @language zh_CN
         * 返回材质 ambientPower 值。
         * 返回材质 环境光颜色的强度 值。
         * @returns {Number}
         * @version Egret 3.0
         * @platform Web,Native
         */
        //public get ambientPower(): number {
        //    return this.materialData.ambientPower;
        //}
        /**
         * @language zh_CN
         * 设置材质 diffusePower 值。
         * 设置材质 漫反射颜色的强度 值。
         * @param value {Number}
         * @version Egret 3.0
         * @platform Web,Native
         */
        //public set diffusePower(value: number) {
        //    if (this.materialData.diffusePower != value) {
        //        this.materialData.diffusePower = value;
        //        this.materialData.materialDataNeedChange = true;
        //    }
        //}
        /**
         * @language zh_CN
         * 返回材质 diffusePower 值。
         * 返回材质 漫反射颜色的强度 值。
         * @returns {Number}
         * @version Egret 3.0
         * @platform Web,Native
         */
        //public get diffusePower(): number {
        //    return this.materialData.diffusePower;
        //}
        /**
         * @language zh_CN
         * 设置材质 normalPower 值。
         * 设置材质 法线的强度 值。
         * @param value {Number}
         * @version Egret 3.0
         * @platform Web,Native
         */
        //public set normalPower(value: number) {
        //    if (this.materialData.normalPower != value) {
        //        this.materialData.normalPower = value;
        //        this.materialData.materialDataNeedChange = true;
        //    }
        //}
        /**
         * @language zh_CN
         * 返回材质 normalPower 值。
         * 返回材质 法线的强度 值。
         * @returns {Number}
         * @version Egret 3.0
         * @platform Web,Native
         */
        //public get normalPower(): number {
        //    return this.materialData.normalPower;
        //}
        /** m
        * @language zh_CN
        * 返回材质 normalPower 值。
        * 返回材质 法线的强度 值。
        * @returns {Number}
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialBase.prototype.addPass = function (pass) {
            this.passes[pass] = this.passes[egret3d.PassType.shadowPass] || egret3d.PassUtil.CreatPass(pass, this.materialData);
        };
        Object.defineProperty(MaterialBase.prototype, "castShadow", {
            /**
             * @language zh_CN
             * 返回材质 castShadow 值。
             * 返回材质 是否产生阴影 值。
             * @returns {boolean}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.castShadow;
            },
            /**
             * @language zh_CN
             * 设置材质 castShadow 值。
             * 设置材质是否接受阴影，设置了之后必须要给 shadowmaping 的方法。
             * @param value {boolean}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this.materialData.castShadow = value;
                if (value) {
                    this.addPass(egret3d.PassType.shadowPass);
                }
                else {
                    if (this.passes[egret3d.PassType.shadowPass]) {
                        this.disposePass(egret3d.PassType.shadowPass);
                        this.passes[egret3d.PassType.shadowPass] = null;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "acceptShadow", {
            /**
            * @language zh_CN
            * 返回材质 acceptShadow 值。
            * 返回材质是否接受阴影，设置了之后必须要给 shadowmaping 的方法。
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.acceptShadow;
            },
            /**
             * @language zh_CN
             * 设置材质 acceptShadow 值。
             * 设置材质是否是否产生阴影，设置了之后必须要给 shadowmaping 的方法。
             * @param value {boolean}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this.materialData.acceptShadow = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "shadowColor", {
            /**
            * @language zh_CN
            * 返回材质 阴影颜色
            * @returns number 阴影颜色
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                var color = 0;
                color |= this.materialData.shadowColor[0] * 255.0 << 16;
                color |= this.materialData.shadowColor[1] * 255.0 << 8;
                color |= this.materialData.shadowColor[2] * 255.0;
                return color;
            },
            /**
            * @language zh_CN
            * 设置 阴影颜色
            * @param color 0xffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this.materialData.shadowColor[0] = color >> 16 & 0xff / 255.0;
                this.materialData.shadowColor[1] = color >> 8 & 0xff / 255.0;
                this.materialData.shadowColor[2] = color & 0xff / 255.0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "smooth", {
            /**
            * @language zh_CN
            * 返回材质 smooth 值。
            * 返回 材质纹理的采样方式，是否抗锯齿，是否精细显示。的开关
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.smooth;
            },
            /**
             * @language zh_CN
             * 设置材质 smooth 值。
             * 材质纹理的采样方式，是否抗锯齿，是否精细显示。
             * @param value {boolean}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (val) {
                this.materialData.smooth = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "repeat", {
            /**
            * @language zh_CN
            * 返回材质 repeat 值。
            * 返回材质 是否进行纹理重复采样的方式开关。
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.repeat;
            },
            /**
             * @language zh_CN
             * 设置材质 repeat 值。
             * 设置材质 是否进行纹理重复采样的方式开关。
             * @param value {boolean}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (val) {
                this.materialData.repeat = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "bothside", {
            /**
            * @language zh_CN
            * 返回材质 bothside 值。
           * 返回是否显示双面的开关。
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.bothside;
            },
            /**
            * @language zh_CN
            * 设置材质 bothside 值。
            * 设置材质是否显示双面的开关。
            * @param value {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                this.materialData.bothside = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "cullMode", {
            /**
             * @language zh_CN
             * 返回 cull 模式。
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.cullFrontOrBack;
            },
            /**
           * @language zh_CN
           * 设置 cull 模式 正面渲染三角形或者背面渲染三角形。
           * @param value {Number}
           * @version Egret 3.0
           * @platform Web,Native
           */
            set: function (value) {
                this.materialData.cullFrontOrBack = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "blendMode", {
            /**
             * @language zh_CN
             * 设置材质 blendMode 值。
             * 设置材质球的 混合模式可以参照 blendmode 中的值
             * @param value {BlendMode}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this.materialData.blendMode = value;
                switch (value) {
                    //his.materialData.blend_src = ContextConfig.SRC_ALPHA; 透明
                    //this.materialData.blend_dest = ContextConfig.SRC_COLOR;
                    case egret3d.BlendMode.NORMAL:
                        this.materialData.blend_src = egret3d.ContextConfig.ONE;
                        this.materialData.blend_dest = egret3d.ContextConfig.ONE_MINUS_SRC_ALPHA;
                        this.materialData.alphaBlending = false;
                        break;
                    case egret3d.BlendMode.LAYER:
                        this.materialData.blend_src = egret3d.ContextConfig.SRC_ALPHA;
                        this.materialData.blend_dest = egret3d.ContextConfig.ZERO;
                        this.materialData.alphaBlending = true;
                        break;
                    case egret3d.BlendMode.MULTIPLY:
                        this.materialData.blend_src = egret3d.ContextConfig.ZERO;
                        this.materialData.blend_dest = egret3d.ContextConfig.SRC_COLOR;
                        this.materialData.alphaBlending = true;
                        break;
                    case egret3d.BlendMode.ADD:
                        this.materialData.blend_src = egret3d.ContextConfig.SRC_ALPHA;
                        this.materialData.blend_dest = egret3d.ContextConfig.ONE;
                        this.materialData.alphaBlending = true;
                        break;
                    case egret3d.BlendMode.SOFT_ADD:
                        this.materialData.blend_src = egret3d.ContextConfig.SRC_COLOR;
                        this.materialData.blend_dest = egret3d.ContextConfig.ONE;
                        this.materialData.alphaBlending = true;
                        break;
                    case egret3d.BlendMode.ALPHA:
                        this.materialData.blend_src = egret3d.ContextConfig.ONE;
                        this.materialData.blend_dest = egret3d.ContextConfig.ONE_MINUS_SRC_ALPHA;
                        this.materialData.alphaBlending = true;
                        break;
                    case egret3d.BlendMode.SCREEN:
                        this.materialData.blend_src = egret3d.ContextConfig.ONE;
                        this.materialData.blend_dest = egret3d.ContextConfig.ONE_MINUS_SRC_COLOR;
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "pointSize", {
            get: function () {
                return this.materialData.specularLevel;
            },
            set: function (value) {
                if (value == this.materialData.specularLevel) {
                    return;
                }
                this.materialData.specularLevel = value;
                this.materialData.materialDataNeedChange = true;
            },
            enumerable: true,
            configurable: true
        });
        MaterialBase.prototype.disposePass = function (passType) {
            for (var i = 0; i < this.passes[passType].length; i++) {
                this.passes[passType][i].dispose();
            }
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        //public renderDiffusePass(time: number, delay: number, matID: number , context3DProxy: Context3DProxy, modeltransform: Matrix4_4, camera3D: Camera3D, subGeometry: SubGeometry, animtion: IAnimation) {
        //    this.diffusePass.draw(time, delay, context3DProxy, modeltransform, camera3D, subGeometry, animtion);
        //}
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderXRayPass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderOutlinePass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderNormalPass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderDepthPass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderPositionPass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderUVPass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderScendUVPass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderVertexColorPass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderLightingPass = function () {
        };
        return MaterialBase;
    }());
    egret3d.MaterialBase = MaterialBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ColorMaterial = (function (_super) {
        __extends(ColorMaterial, _super);
        function ColorMaterial(color) {
            if (color === void 0) { color = 0xcccccc; }
            _super.call(this);
            this.color = color;
            this.diffuseTexture = egret3d.CheckerboardTexture.texture;
            this.initMatPass();
        }
        ColorMaterial.prototype.initMatPass = function () {
            this.addPass(egret3d.PassType.diffusePass);
            this.diffusePass.addMethod(new egret3d.ColorMethod());
        };
        Object.defineProperty(ColorMaterial.prototype, "color", {
            get: function () {
                return this.materialData.diffuseColor;
            },
            set: function (value) {
                this.materialData.diffuseColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorMaterial.prototype, "alpha", {
            get: function () {
                return this.materialData.alpha;
            },
            set: function (value) {
                this.materialData.alpha = value;
            },
            enumerable: true,
            configurable: true
        });
        return ColorMaterial;
    }(egret3d.MaterialBase));
    egret3d.ColorMaterial = ColorMaterial;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.TextureMaterial
    * @classdesc
    * 纹理材质。
    * 标准的贴图材质球，可以设置三种贴图， diffuse ， normal ， speclar 贴图
    * 材质球中默认不设置纹理，显示的黑白棋盘格
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TextureMaterial = (function (_super) {
        __extends(TextureMaterial, _super);
        /**
         * @language zh_CN
         * 创建一个新的 TextureMaterial 对象。
         * @param texture 用来渲染的贴图，默认会给出一张棋盘格贴图
         * @param materialData 材质数据信息，可以不指定
         * @version Egret 3.0
         * @platform Web,Native
         */
        function TextureMaterial(texture, materialData) {
            if (texture === void 0) { texture = null; }
            if (materialData === void 0) { materialData = null; }
            _super.call(this, materialData);
            if (!texture) {
                this.diffuseTexture = egret3d.CheckerboardTexture.texture;
            }
            else {
                this.diffuseTexture = texture;
            }
            this.initMatPass();
        }
        TextureMaterial.prototype.initMatPass = function () {
            this.addPass(egret3d.PassType.diffusePass);
        };
        /**
         * @language zh_CN
         * 克隆方法。
         * 将材质球克隆一份，公用shader着色器和贴图，不公用参数
         * @returns {TextureMaterial}
         * @version Egret 3.0
         * @platform Web,Native
         */
        TextureMaterial.prototype.clone = function () {
            var mat = new TextureMaterial(this.diffuseTexture, this.materialData.clone());
            return mat;
        };
        return TextureMaterial;
    }(egret3d.MaterialBase));
    egret3d.TextureMaterial = TextureMaterial;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.CubeTextureMaterial
    * @classdesc
    * cube纹理材质。
    * 6张无缝连接的贴图，使一个cube的6个面贴上不同的贴图。
    *
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CubeTextureMaterial = (function (_super) {
        __extends(CubeTextureMaterial, _super);
        /**
         * @language zh_CN
         * 创建一个新的 CubeTextureMaterial 对象。
         * @param texture {CubeTexture}
         * @param materialData {MaterialData}
         * @version Egret 3.0
         * @platform Web,Native
         */
        function CubeTextureMaterial(texture, materialData) {
            if (texture === void 0) { texture = null; }
            if (materialData === void 0) { materialData = null; }
            _super.call(this, materialData);
            this.diffuseTexture = texture;
            this.initMatPass();
        }
        CubeTextureMaterial.prototype.initMatPass = function () {
            this.addPass(egret3d.PassType.diffusePass);
            this.diffusePass.addMethod(new egret3d.CubeMethod());
        };
        /**
         * @language zh_CN
         * 克隆方法。
         * 将材质球克隆一份，公用shader着色器和贴图，不公用参数
         * @returns {TextureMaterial}
         * @version Egret 3.0
         * @platform Web,Native
         */
        CubeTextureMaterial.prototype.clone = function () {
            var mat = new CubeTextureMaterial(this.diffuseTexture, this.materialData.clone());
            return mat;
        };
        return CubeTextureMaterial;
    }(egret3d.MaterialBase));
    egret3d.CubeTextureMaterial = CubeTextureMaterial;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.RenderBase
    * @classdesc
    * 渲染器基类
    */
    var RenderBase = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function RenderBase() {
            ///protected _context3D: Context3DProxy;
            this._renderIndex = 0;
            this.numEntity = 0;
            ///this.camera3D = camera3D;
        }
        RenderBase.prototype.setRenderToTexture = function (width, height, format) {
            if (format === void 0) { format = egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB; }
            this.renderTexture = new egret3d.RenderTexture(width, height, format);
            //this.renderTexture.
        };
        /**
        * @language zh_CN
        * 每帧渲染
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @param context3D 设备上下文
        * @param collect 渲染对象收集器
        * @param camera 渲染时的相机
        */
        RenderBase.prototype.draw = function (time, delay, context3D, collect, camera, backViewPort, shadow) {
            if (backViewPort === void 0) { backViewPort = null; }
            if (shadow === void 0) { shadow = false; }
        };
        return RenderBase;
    }());
    egret3d.RenderBase = RenderBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.MultiRender
    * @classdesc
    * default render
    * 把所有需要渲染的对象，依次进行渲染
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MultiRender = (function (_super) {
        __extends(MultiRender, _super);
        /**
        * @language zh_CN
        * constructor
        */
        function MultiRender(pass) {
            if (pass === void 0) { pass = egret3d.PassType.diffusePass; }
            _super.call(this);
            this._i = 0;
            this._j = 0;
            this._pass = pass;
        }
        /**
        * @language zh_CN
        * 把所有需要渲染的对象，依次进行渲染
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @param context3D 设备上下文
        * @param collect 渲染对象收集器
        * @param camera 渲染时的相机
        */
        MultiRender.prototype.draw = function (time, delay, context3D, collect, camera, backViewPort, shadow) {
            if (backViewPort === void 0) { backViewPort = null; }
            if (shadow === void 0) { shadow = false; }
            this.numEntity = collect.renderList.length;
            if (this.renderTexture) {
                this.renderTexture.upload(context3D);
                context3D.setRenderToTexture(this.renderTexture.texture2D, true, 0);
            }
            var material;
            for (this._renderIndex = 0; this._renderIndex < this.numEntity; this._renderIndex++) {
                this._renderItem = collect.renderList[this._renderIndex];
                if (shadow) {
                    if (!this._renderItem.material.castShadow) {
                        continue;
                    }
                }
                this._renderItem.geometry.activeState(time, delay, egret3d.Egret3DCanvas.context3DProxy, camera);
                for (this._i = 0; this._i < this._renderItem.geometry.subGeometrys.length; this._i++) {
                    var subGeometry = this._renderItem.geometry.subGeometrys[this._i];
                    var matID = subGeometry.matID;
                    material = this._renderItem.multiMaterial[matID];
                    if (material == null)
                        continue;
                    if (material.passes[this._pass]) {
                        for (this._j = material.passes[this._pass].length - 1; this._j >= 0; this._j--) {
                            material.passes[this._pass][this._j].draw(time, delay, context3D, this._renderItem.modelMatrix, camera, subGeometry, this._renderItem.animation);
                        }
                    }
                    else if (egret3d.PassUtil.PassAuto[this._pass]) {
                        for (this._j = material.passes[this._pass].length - 1; this._j >= 0; this._j--) {
                            material.passes[this._pass] = egret3d.PassUtil.CreatPass(this._pass, material.materialData);
                            material.passes[this._pass][this._j].draw(time, delay, context3D, this._renderItem.modelMatrix, camera, subGeometry, this._renderItem.animation);
                        }
                    }
                }
            }
            if (this.renderTexture) {
                context3D.setRenderToBackBuffer();
                if (backViewPort) {
                    context3D.viewPort(backViewPort.x, backViewPort.y, backViewPort.width, backViewPort.height);
                    context3D.setScissorRectangle(backViewPort.x, backViewPort.y, backViewPort.width, backViewPort.height);
                }
            }
        };
        return MultiRender;
    }(egret3d.RenderBase));
    egret3d.MultiRender = MultiRender;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var PostRender = (function (_super) {
        __extends(PostRender, _super);
        function PostRender(vs, fs) {
            _super.call(this);
            this._hud = new egret3d.HUD();
            this._hud.vsShader = vs;
            this._hud.fsShader = fs;
        }
        PostRender.prototype.setRenderToTexture = function (width, height, format) {
            if (format === void 0) { format = egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB; }
            this.renderTexture = new egret3d.RenderTexture(width, height, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB);
        };
        PostRender.prototype.draw = function (time, delay, context3D, collect, camera, backViewPort, posList) {
            if (backViewPort === void 0) { backViewPort = null; }
            this.numEntity = collect.renderList.length;
            if (this.renderTexture) {
                this.renderTexture.upload(context3D);
                context3D.setRenderToTexture(this.renderTexture.texture2D, true, 0);
            }
            //--------render container--------------
            this._hud.viewPort = camera.viewPort;
            this._hud.x = camera.viewPort.x;
            this._hud.y = camera.viewPort.y;
            this._hud.width = camera.viewPort.width;
            this._hud.height = camera.viewPort.height;
            this._hud.diffuseTexture = posList["end"];
            this._hud["colorTexture"] = posList["colorTexture"];
            this._hud.draw(context3D);
            //--------------------------------------
            context3D.setRenderToBackBuffer();
            if (backViewPort) {
                context3D.viewPort(backViewPort.x, backViewPort.y, backViewPort.width, backViewPort.height);
                context3D.setScissorRectangle(backViewPort.x, backViewPort.y, backViewPort.width, backViewPort.height);
            }
        };
        return PostRender;
    }(egret3d.RenderBase));
    egret3d.PostRender = PostRender;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    (function (ValueType) {
        ValueType[ValueType["float"] = 0] = "float";
        ValueType[ValueType["vec2"] = 1] = "vec2";
        ValueType[ValueType["vec3"] = 2] = "vec3";
        ValueType[ValueType["vec4"] = 3] = "vec4";
    })(egret3d.ValueType || (egret3d.ValueType = {}));
    var ValueType = egret3d.ValueType;
    /**
    * @private
    */
    var ValueShape = (function () {
        function ValueShape() {
        }
        ValueShape.prototype.calculate = function (num, valueShape) {
            if (valueShape === void 0) { valueShape = null; }
            new Error("asd");
            return null;
        };
        return ValueShape;
    }());
    egret3d.ValueShape = ValueShape;
    /**
    * @private
    */
    var ConstValueShape = (function (_super) {
        __extends(ConstValueShape, _super);
        function ConstValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.float;
            this.value = 5;
        }
        ConstValueShape.prototype.calculate = function (num) {
            var values = [];
            for (var i = 0; i < num; i++) {
                values.push(this.value);
            }
            return values;
        };
        return ConstValueShape;
    }(ValueShape));
    egret3d.ConstValueShape = ConstValueShape;
    /**
    * @private
    */
    var ConstRandomValueShape = (function (_super) {
        __extends(ConstRandomValueShape, _super);
        function ConstRandomValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.float;
            this.min = 0;
            this.max = 100;
        }
        ConstRandomValueShape.prototype.calculate = function (num) {
            var values = [];
            for (var i = 0; i < num; i++) {
                values.push(this.min + Math.random() * (this.max - this.min));
            }
            return values;
        };
        return ConstRandomValueShape;
    }(ValueShape));
    egret3d.ConstRandomValueShape = ConstRandomValueShape;
    /**
    * @private
    */
    var Vec2ConstValueShape = (function (_super) {
        __extends(Vec2ConstValueShape, _super);
        function Vec2ConstValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec2;
            this.minX = 0;
            this.minY = 0;
        }
        Vec2ConstValueShape.prototype.calculate = function (num) {
            var values = [];
            for (var i = 0; i < num; i++) {
                var p = new egret3d.Point();
                p.x = this.minX;
                p.y = this.minY;
                values.push(p);
            }
            return values;
        };
        return Vec2ConstValueShape;
    }(ValueShape));
    egret3d.Vec2ConstValueShape = Vec2ConstValueShape;
    /**
    * @private
    */
    var Vec2ConstRandomValueShape = (function (_super) {
        __extends(Vec2ConstRandomValueShape, _super);
        function Vec2ConstRandomValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec2;
            this.minX = 0;
            this.minY = 0;
            this.maxX = 100;
            this.maxY = 100;
        }
        Vec2ConstRandomValueShape.prototype.calculate = function (num) {
            var values = [];
            for (var i = 0; i < num; i++) {
                var p = new egret3d.Point();
                p.x = this.minX + Math.random() * (this.maxX - this.minX);
                p.y = this.minY + Math.random() * (this.maxY - this.minY);
                values.push(p);
            }
            return values;
        };
        return Vec2ConstRandomValueShape;
    }(ValueShape));
    egret3d.Vec2ConstRandomValueShape = Vec2ConstRandomValueShape;
    /**
    * @private
    */
    var Vec3ConstValueShape = (function (_super) {
        __extends(Vec3ConstValueShape, _super);
        function Vec3ConstValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.minX = 0;
            this.minY = 0;
            this.minZ = 0;
        }
        Vec3ConstValueShape.prototype.calculate = function (num) {
            var values = [];
            for (var i = 0; i < num; i++) {
                var p = new egret3d.Vector3D();
                p.x = this.minX;
                p.y = this.minY;
                p.z = this.minZ;
                values.push(p);
            }
            return values;
        };
        return Vec3ConstValueShape;
    }(ValueShape));
    egret3d.Vec3ConstValueShape = Vec3ConstValueShape;
    /**
    * @private
    */
    var Vec3ConstRandomValueShape = (function (_super) {
        __extends(Vec3ConstRandomValueShape, _super);
        function Vec3ConstRandomValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.minX = -50;
            this.minY = -50;
            this.minZ = -50;
            this.maxX = 50;
            this.maxY = 50;
            this.maxZ = 50;
        }
        Vec3ConstRandomValueShape.prototype.calculate = function (num) {
            var values = [];
            for (var i = 0; i < num; i++) {
                var p = new egret3d.Vector3D();
                p.x = this.minX + Math.random() * (this.maxX - this.minX);
                p.y = this.minY + Math.random() * (this.maxY - this.minY);
                p.z = this.minZ + Math.random() * (this.maxZ - this.minZ);
                values.push(p);
            }
            return values;
        };
        return Vec3ConstRandomValueShape;
    }(ValueShape));
    egret3d.Vec3ConstRandomValueShape = Vec3ConstRandomValueShape;
    /**
    * @private
    */
    var CubeVector3DValueShape = (function (_super) {
        __extends(CubeVector3DValueShape, _super);
        function CubeVector3DValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.width = 100;
            this.height = 100;
            this.depth = 100;
        }
        /**
        * @language zh_CN
        * @param num
        * @param parameters [width, height, depth]
        * @returns Vector3D[]
        */
        CubeVector3DValueShape.prototype.calculate = function (num) {
            var values = [];
            var val;
            for (var i = 0; i < num; i++) {
                val = new egret3d.Vector3D();
                val.x = Math.random() * this.width - (this.width * 0.5);
                val.y = Math.random() * this.height - (this.height * 0.5);
                val.z = Math.random() * this.depth - (this.depth * 0.5);
                values.push(val);
            }
            return values;
        };
        return CubeVector3DValueShape;
    }(ValueShape));
    egret3d.CubeVector3DValueShape = CubeVector3DValueShape;
    /**
    * @private
    */
    var PlaneValueShape = (function (_super) {
        __extends(PlaneValueShape, _super);
        function PlaneValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.width = 100;
            this.height = 100;
        }
        PlaneValueShape.prototype.calculate = function (num) {
            var values = [];
            var pos;
            for (var i = 0; i < num; i++) {
                pos = new egret3d.Vector3D();
                pos.x = Math.random() * this.width - (this.width * 0.5);
                pos.y = 0;
                pos.z = Math.random() * this.height - (this.height * 0.5);
                values.push(pos);
            }
            return values;
        };
        return PlaneValueShape;
    }(ValueShape));
    egret3d.PlaneValueShape = PlaneValueShape;
    /**
    * @private
    *圆柱体.以Y轴为高 (parameters = [R, height])
    */
    var CylinderValueShape = (function (_super) {
        __extends(CylinderValueShape, _super);
        function CylinderValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.radiusTop = 20;
            this.radiusBottom = 20;
            this.height = 20;
            //目前没写完，只支持Volume和VolumeShell，后面慢慢补充
            this.coneType = egret3d.ParticleConeShapeType.Volume;
        }
        CylinderValueShape.prototype.calculate = function (num) {
            var pos;
            var values = [];
            if (this.radiusBottom == this.radiusTop) {
                this.origPoint = null;
                var angle;
                for (var i = 0; i < num; i++) {
                    pos = new egret3d.Vector3D();
                    angle = Math.random() * 2 * Math.PI;
                    pos.x = Math.sin(angle) * this.radiusBottom;
                    pos.z = Math.cos(angle) * this.radiusBottom;
                    //体积
                    if (this.coneType == egret3d.ParticleConeShapeType.Volume) {
                        var random = Math.random();
                        pos.x *= random;
                        pos.z *= random;
                        pos.y = Math.random() * this.height - this.height * 0.5;
                    }
                    else if (this.coneType == egret3d.ParticleConeShapeType.VolumeShell) {
                        pos.y = Math.random() * this.height - this.height * 0.5;
                    }
                    else if (this.coneType == egret3d.ParticleConeShapeType.Base) {
                        pos.y = this.height * 0.5;
                        var random = Math.random();
                        if (random > 0.5) {
                            pos.y *= -1;
                        }
                        pos.x *= random;
                        pos.z *= random;
                    }
                    else if (this.coneType == egret3d.ParticleConeShapeType.BaseShell) {
                        pos.y = this.height * 0.5;
                        if (Math.random() > 0.5) {
                            pos.y *= -1;
                        }
                    }
                    values.push(pos);
                }
            }
            else {
                this.origPoint = new egret3d.Vector3D(0, 0, 0);
                var awayValue = this.radiusTop * this.height / Math.abs(this.radiusTop - this.radiusBottom);
                this.origPoint.y = -(this.height / 2 + awayValue);
                if (this.radiusTop < this.radiusBottom) {
                    this.origPoint.y *= -1;
                }
                //圆筒中的位置
                var angle;
                var targetR;
                var radiusT_B = Math.abs(this.radiusBottom - this.radiusTop);
                for (var i = 0; i < num; i++) {
                    pos = new egret3d.Vector3D();
                    angle = Math.random() * 2 * Math.PI;
                    pos.y = Math.random() * this.height - this.height * 0.5;
                    targetR = Math.abs(pos.y - this.origPoint.y); //点到原点的y距离
                    if (this.radiusBottom < this.radiusTop) {
                        targetR = radiusT_B * (this.height / 2 + pos.y) / this.height;
                        targetR += this.radiusBottom;
                    }
                    else {
                        targetR = radiusT_B * (this.height / 2 - pos.y) / this.height;
                        targetR += this.radiusBottom;
                    }
                    pos.x = Math.sin(angle) * targetR;
                    pos.z = Math.cos(angle) * targetR;
                    if (this.coneType == egret3d.ParticleConeShapeType.Volume) {
                        var random = Math.random();
                        pos.x *= random;
                        pos.y *= random;
                    }
                    values.push(pos);
                }
            }
            //unity中的圆筒默认是横着放的yz互换
            if (this.origPoint) {
                this.yz_zy(this.origPoint);
            }
            for (var i = 0, count = values.length; i < count; i++) {
                this.yz_zy(values[i]);
            }
            //
            return values;
        };
        CylinderValueShape.prototype.yz_zy = function (v) {
            v.y += this.height / 2;
            v.setTo(v.x, v.z, v.y, v.w);
        };
        //获取从这个桶里面发射的粒子，沿着桶的发射朝向
        CylinderValueShape.prototype.getDirection = function (point, dst) {
            if (dst == null) {
                dst = new egret3d.Vector3D();
            }
            dst.setTo(0, 1, 0);
            if (point == null) {
                return dst;
            }
            if (this.origPoint) {
                dst.copyFrom(point);
                dst.decrementBy(this.origPoint);
                dst.normalize();
                if (this.radiusTop < this.radiusBottom) {
                    dst.x *= -1;
                    dst.y *= -1;
                    dst.z *= -1;
                }
            }
            return dst;
        };
        return CylinderValueShape;
    }(ValueShape));
    egret3d.CylinderValueShape = CylinderValueShape;
    /**
    * @private
    * 线性分布
    */
    var LineValueShape = (function (_super) {
        __extends(LineValueShape, _super);
        function LineValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.points = [new egret3d.Vector3D(), new egret3d.Vector3D(100, 0, 0), new egret3d.Vector3D(100, 200, 0)];
        }
        LineValueShape.prototype.calculate = function (num) {
            if (this.points.length == 1)
                return this.points;
            var values = [];
            var pos;
            var numLen = 0;
            var segment = 0;
            for (var i = 1; i < this.points.length; i++) {
                numLen += egret3d.Vector3D.distance(this.points[i - 1], this.points[i]);
            }
            segment = numLen / num;
            var ntmp = new egret3d.Vector3D();
            var sourceD = 0;
            var nD = 0;
            var len = 0;
            for (var i = 1; i < this.points.length; i++) {
                ntmp.x = this.points[i].x - this.points[i - 1].x;
                ntmp.y = this.points[i].y - this.points[i - 1].y;
                ntmp.z = this.points[i].z - this.points[i - 1].z;
                ntmp.normalize();
                ntmp.scaleBy(segment + len);
                sourceD = egret3d.Vector3D.distance(this.points[i - 1], this.points[i]);
                nD = egret3d.Vector3D.distance(ntmp, this.points[i]);
                if (nD > sourceD) {
                    len += nD;
                }
            }
            return values;
        };
        return LineValueShape;
    }(ValueShape));
    /**
    * @private
    * 球表面分布
    */
    var BallSurfaceValueShape = (function (_super) {
        __extends(BallSurfaceValueShape, _super);
        function BallSurfaceValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
        }
        //parameters = [R]
        BallSurfaceValueShape.prototype.calculate = function (num) {
            var parameters = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                parameters[_i - 1] = arguments[_i];
            }
            var values = [];
            var r = parameters[0][0];
            values = this.getPoints1(num, r);
            return values;
        };
        BallSurfaceValueShape.prototype.getPoints1 = function (num, r) {
            var values = [];
            var x;
            var y;
            var z;
            var s;
            var n;
            for (var i = 0; i < num; i++) {
                x = Math.random() * 2 - 1;
                y = Math.random() * 2 - 1;
                z = Math.random() * 2 - 1;
                s = x * x + y * y + z * z;
                if (s > 1) {
                    i--;
                }
                else {
                    n = Math.sqrt(s);
                    values.push(new egret3d.Vector3D(x / n * r, y / n * r, z / n * r));
                }
            }
            return values;
        };
        BallSurfaceValueShape.prototype.getPoints2 = function (num, r) {
            var values = [];
            for (var i = 0; i < num; i++) {
            }
            return values;
        };
        return BallSurfaceValueShape;
    }(ValueShape));
    /**
    * @private
    * 球内分布
    */
    var BallValueShape = (function (_super) {
        __extends(BallValueShape, _super);
        function BallValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.r = 10;
        }
        //parameters = [R]
        BallValueShape.prototype.calculate = function (num) {
            var values = [];
            values = this.getPoints1(num, this.r);
            return values;
        };
        BallValueShape.prototype.getPoints1 = function (num, r) {
            var values = [];
            var x;
            var y;
            var z;
            var pos;
            var radio = new egret3d.Vector3D(0, 0, 0);
            for (var i = 0; i < num; i++) {
                x = Math.random() * 2 * r - r;
                y = Math.random() * 2 * r - r;
                z = Math.random() * 2 * r - r;
                pos = new egret3d.Vector3D(x, y, z);
                if (egret3d.Vector3D.distance(radio, pos) > r) {
                    i--;
                }
                else {
                    values.push(pos);
                }
            }
            return values;
        };
        return BallValueShape;
    }(ValueShape));
    egret3d.BallValueShape = BallValueShape;
    /**
    * @private
    * 半球内分布
    */
    var HemiBallValueShape = (function (_super) {
        __extends(HemiBallValueShape, _super);
        function HemiBallValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.r = 10;
        }
        //parameters = [R]
        HemiBallValueShape.prototype.calculate = function (num) {
            var values = [];
            values = this.getPoints1(num, this.r);
            return values;
        };
        HemiBallValueShape.prototype.getPoints1 = function (num, r) {
            var values = [];
            var x;
            var y;
            var z;
            var pos;
            var radio = new egret3d.Vector3D(0, 0, 0);
            for (var i = 0; i < num; i++) {
                x = Math.random() * 2 * r - r;
                y = Math.abs(Math.random() * 2 * r - r);
                z = Math.random() * 2 * r - r;
                pos = new egret3d.Vector3D(x, y, z);
                if (egret3d.Vector3D.distance(radio, pos) > r) {
                    i--;
                }
                else {
                    values.push(pos);
                }
            }
            return values;
        };
        return HemiBallValueShape;
    }(ValueShape));
    egret3d.HemiBallValueShape = HemiBallValueShape;
    /**
    * @private
    * 平面圆
    */
    var CircleValueShape = (function (_super) {
        __extends(CircleValueShape, _super);
        function CircleValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
        }
        CircleValueShape.prototype.calculate = function (num) {
            var parameters = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                parameters[_i - 1] = arguments[_i];
            }
            var values;
            var tmpPar = parameters[0];
            var r = tmpPar[0];
            //var time: number = new Date().getTime();
            values = this.createRandomPoint1(num, r); //createRandomPoint1 比 createRandomPoint2 大部分情况下快了15% - 25%, 少数情况下略高于createRandomPoint2
            //console.log('createRandomPoint1 cost time: ', new Date().getTime() - time);
            //time = new Date().getTime();
            //this.createRandomPoint2(num, r);
            //console.log('createRandomPoint2 cost time: ', new Date().getTime() - time);
            return values;
        };
        //非稳定算法.但是因为没有三角函数和开平方的计算.反而在大部分情况下效率会更高
        CircleValueShape.prototype.createRandomPoint1 = function (num, r) {
            var values = [];
            var d = r * 2;
            for (var i = 0; i < num; i++) {
                var x = Math.random() * d - r;
                var z = Math.random() * d - r;
                if ((x * x + z * z) > (r * r)) {
                    i--;
                }
                else {
                    values.push(new egret3d.Vector3D(x, 0, z));
                }
            }
            return values;
        };
        CircleValueShape.prototype.createRandomPoint2 = function (num, r) {
            var values = [];
            var pos;
            var tempR;
            var theta;
            for (var i = 0; i < num; i++) {
                pos = new egret3d.Vector3D();
                tempR = Math.sqrt(Math.random()) * r;
                theta = Math.random() * 360;
                pos.x = tempR * Math.sin(theta);
                pos.z = tempR * Math.cos(theta);
                pos.y = 0;
                values.push(pos);
            }
            return values;
        };
        return CircleValueShape;
    }(ValueShape));
    /**
    * @private
    * 贝塞尔曲线, 以Y为平面, parameters = [p0, p1, p2, p3]
    */
    var BezierCurveValueShape = (function (_super) {
        __extends(BezierCurveValueShape, _super);
        function BezierCurveValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
        }
        BezierCurveValueShape.prototype.calculate = function (num) {
            var parameters = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                parameters[_i - 1] = arguments[_i];
            }
            var values = [];
            //var tmpPar = parameters[0];
            var tmpPar = [];
            tmpPar.push(new egret3d.Vector3D(0, 0, 0));
            tmpPar.push(new egret3d.Vector3D(-200, 1000, 700));
            tmpPar.push(new egret3d.Vector3D(200, -50, 300));
            tmpPar.push(new egret3d.Vector3D(-300, -220, 500));
            var p0 = tmpPar[0];
            var p1 = tmpPar[1];
            var p2 = tmpPar[2];
            var p3 = tmpPar[3];
            var t;
            var yt;
            var x;
            var y;
            var z;
            for (var i = 0; i < num; i++) {
                t = Math.random();
                yt = 1 - t;
                x = p0.x * yt * yt * yt + 3 * p1.x * yt * yt * t + 3 * p2.x * yt * t * t + p3.x * t * t * t;
                y = p0.y * yt * yt * yt + 3 * p1.y * yt * yt * t + 3 * p2.y * yt * t * t + p3.y * t * t * t;
                z = p0.z * yt * yt * yt + 3 * p1.z * yt * yt * t + 3 * p2.z * yt * t * t + p3.z * t * t * t;
                values.push(new egret3d.Vector3D(x, y, z));
            }
            return values;
        };
        return BezierCurveValueShape;
    }(ValueShape));
    /**
    * @private
    */
    var Value = (function () {
        function Value() {
            this.emitter = {};
            //this.emitter[ValueType.constValue] = new ConstValueShape();
            //this.emitter[ValueType.line] = new LineValueShape();
            //this.emitter[ValueType.plane] = new PlaneValueShape();
            //this.emitter[ValueType.cube3D] = new CubeVector3DValueShape();
            //this.emitter[ValueType.sphere] = new BallValueShape();
            //this.emitter[ValueType.sphere_plane] = new BallSurfaceValueShape();
            //this.emitter[ValueType.cylinder] = new CylinderValueShape();
        }
        Value.calculate = function (count, valueShape) {
            return valueShape.calculate(count, valueShape);
        };
        Value.getValues = function (count, valueType, parameters) {
        };
        Value._instance = new Value();
        return Value;
    }());
    egret3d.Value = Value;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ParticleEndNode = (function (_super) {
        __extends(ParticleEndNode, _super);
        function ParticleEndNode() {
            _super.call(this);
            this.name = "ParticleEndNode";
            this.vertex_ShaderName[egret3d.ShaderPhaseType.end_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.end_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.end_vertex].push("particle_end_vs");
        }
        ParticleEndNode.prototype.build = function (geometry, count) {
        };
        return ParticleEndNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleEndNode = ParticleEndNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ParticleTime = (function (_super) {
        __extends(ParticleTime, _super);
        function ParticleTime() {
            _super.call(this);
            this.name = "ParticleSpeedNode";
            this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex].push("particle_bezier");
            this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex].push("particle_time_vs");
            this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment] = this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment] || [];
            this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment].push("particle_time_fs");
            this.fragment_ShaderName[egret3d.ShaderPhaseType.diffuse_fragment] = this.fragment_ShaderName[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fragment_ShaderName[egret3d.ShaderPhaseType.diffuse_fragment].push("particle_diffuse_fragment");
            this.attribute_time = new egret3d.GLSL.VarRegister();
            this.attribute_time.name = "attribute_time";
            this.attribute_time.size = 3;
            this.attributes.push(this.attribute_time);
        }
        /**
        * @language zh_CN
        * 填充粒子生命周期数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleTime.prototype.initNode = function (data) {
            var node = this._node = data;
            var lifeValue = new egret3d.ConstRandomValueShape();
            lifeValue.max = node.max;
            lifeValue.min = node.min;
            this._life = lifeValue;
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleTime.prototype.build = function (geometry, count) {
            this._animationState = this.state;
            var emission = this._animationState.emitter.data.emission;
            var lifeArray = this._life.calculate(count);
            var bornTimeArray;
            if (emission.type == egret3d.ParticleValueType.Const) {
                bornTimeArray = this.createBornTimeConst(count, emission);
            }
            else {
                bornTimeArray = this.createBornTimeBezier(count, emission);
            }
            //排序
            bornTimeArray.sort(function (a, b) {
                return a - b;
            });
            //略去多余的部分
            bornTimeArray.length = count;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var maxLife = 0;
            var bornTime = 0;
            var lifeTime;
            var progress = 0;
            var duration = this._animationState.emitter.data.life.duration;
            for (var i = 0; i < count; ++i) {
                //当前累加的间隔时间就是出生时间
                bornTime = bornTimeArray[i];
                //
                if (this._node.type == egret3d.ParticleValueType.OneBezier || this._node.type == egret3d.ParticleValueType.TwoBezier) {
                    progress = bornTime / duration;
                    progress = progress - Math.floor(progress); //取小数部分
                    lifeTime = this._node.bezier1.calc(progress);
                    if (this._node.type == egret3d.ParticleValueType.TwoBezier) {
                        var random = Math.random();
                        lifeTime *= random;
                        lifeTime += this._node.bezier2.calc(progress) * (1 - random);
                    }
                }
                else {
                    lifeTime = lifeArray[i];
                }
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_time.offsetIndex;
                    geometry.verticesData[index + 0] = bornTime; //出生时间
                    geometry.verticesData[index + 1] = lifeTime; //单次生命周期时间
                    geometry.verticesData[index + 2] = i; //下标
                    maxLife = Math.max(maxLife, lifeTime);
                }
            }
            var loopTime = maxLife;
            if (bornTime > maxLife) {
                loopTime = bornTime;
            }
            //粒子一个完整的周期为最后一个粒子走完周期
            this._animationState.loopTime = loopTime;
        };
        /**
        * private
        * 出生时间创建(const)
        */
        ParticleTime.prototype.createBornTimeConst = function (count, emission) {
            var bornTimeArray = [];
            var speace;
            if (emission.rate <= 0) {
                speace = 60;
            }
            else {
                speace = 1 / emission.rate;
            }
            for (var i = 0; i < count; i++) {
                bornTimeArray.push(i * speace + speace); //i + 1
            }
            //使用bursts对speaceArray进行修正
            if (emission.bursts) {
                bornTimeArray = this.burstParticle(emission.bursts, bornTimeArray, count);
            }
            return bornTimeArray;
        };
        /**
         * private
         * 出生时间创建(bezier);
         */
        ParticleTime.prototype.createBornTimeBezier = function (count, emission) {
            var bornTimeArray = [];
            var data = emission.bezier;
            //采用的算法为：
            //1，将duration划分为每1s10帧，然后获得总帧数totalFrame
            //2，根据totalFrame遍历循环，计算每个frame对应的curveValue数据：particleCount += curveValue/10;
            //3，取出particleCount中的超过整数部分，记为particleCountInt
            //4，根据particleCountInt在这个frame中，插入对应数量的bornTime，平均分配
            //5，particleCount减去particleCountInt获得小数部分
            //6，执行逻辑2
            var PerSecFrame = 10;
            var FrameTime = 1000 / PerSecFrame;
            var duration = this._node.duration * 1000;
            var TotalFrame = Math.ceil(this._node.duration * 1000 / FrameTime);
            var currentTime = 0;
            var rateValue = 0;
            var insertCount = 0;
            var totalInsertCount = 0;
            while (totalInsertCount < count) {
                currentTime += FrameTime;
                rateValue += data.calc((currentTime % duration) / duration) / PerSecFrame;
                if (rateValue >= 1) {
                    insertCount = Math.floor(rateValue);
                    totalInsertCount += insertCount;
                    for (var i = 0; i < insertCount; i++) {
                        bornTimeArray.push((currentTime + i * FrameTime / insertCount) / 1000);
                    }
                    rateValue -= insertCount;
                }
            }
            //使用bursts对speaceArray进行修正
            if (emission.bursts) {
                bornTimeArray = this.burstParticle(emission.bursts, bornTimeArray, count);
            }
            return bornTimeArray;
        };
        /**
        * private
        * 插入粒子爆炸生成
        */
        ParticleTime.prototype.burstParticle = function (bursts, bornTimeArray, count) {
            //sort bursts
            bursts.sort(function (a, b) {
                return a.x - b.x;
            });
            var duration = this._node.duration;
            var burstLife = [];
            var burstPoint;
            for (var i = 0; i < bursts.length; i++) {
                burstPoint = bursts[i];
                for (var k = 0; k < burstPoint.y; k++) {
                    burstLife.push(burstPoint.x);
                }
            }
            var maxTime = bornTimeArray[bornTimeArray.length - 1];
            var loopCount = 1;
            if (this._node.loop) {
                loopCount = Math.ceil(maxTime / this._node.duration);
            }
            for (var i = 0, count = burstLife.length; i < count; i++) {
                var tempTime = burstLife[i];
                for (var btCt = 0; btCt < loopCount; btCt++) {
                    bornTimeArray.push(btCt * duration + tempTime);
                }
            }
            return bornTimeArray;
        };
        Object.defineProperty(ParticleTime.prototype, "offsetIndex", {
            /**
           * @language zh_CN
           * 获取时间节点在geometry的顶点数据中偏移量
           * @return number
           * @version Egret 3.0
           * @platform Web,Native
           */
            get: function () {
                return this.attribute_time.offsetIndex;
            },
            enumerable: true,
            configurable: true
        });
        return ParticleTime;
    }(egret3d.AnimationNode));
    egret3d.ParticleTime = ParticleTime;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticlePosition
    * @classdesc
    * 粒子位置效果节点，刚出生相对于(0,0,0)位置的偏移量
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticlePosition = (function (_super) {
        __extends(ParticlePosition, _super);
        function ParticlePosition() {
            _super.call(this);
            /**
            * @private
            * 计算用的矩阵
            */
            this.rotationMat = new egret3d.Matrix4_4();
            this.name = "ParticlePosition";
            this.attribute_offsetPosition = new egret3d.GLSL.VarRegister();
            this.attribute_offsetPosition.name = "attribute_offsetPosition";
            this.attribute_offsetPosition.size = 3;
            this.attributes.push(this.attribute_offsetPosition);
        }
        /**
        * @language zh_CN
        * 填充粒子发射器形状数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticlePosition.prototype.initNode = function (data, arg) {
            //根据粒子的属性，选择使用相机方式
            var renderMode = arg.renderMode;
            var renderMode_vs;
            if (renderMode == egret3d.ParticleRenderModeType.Billboard) {
                renderMode_vs = "particle_rm_billboard";
            }
            else if (renderMode == egret3d.ParticleRenderModeType.StretchedBillboard) {
                renderMode_vs = "particle_rm_stretched";
            }
            else {
                renderMode_vs = "particle_rm_mesh";
            }
            this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex].push(renderMode_vs);
            //初始化顶点数据
            var node = this._node = data;
            if (node.type == egret3d.ParticleDataShapeType.Point) {
                var pointShape = new egret3d.Vec3ConstValueShape();
                pointShape.minX = 0;
                pointShape.minY = 0;
                pointShape.minZ = 0;
                this._positions = pointShape;
            }
            else if (node.type == egret3d.ParticleDataShapeType.Cube) {
                var cubeShape = new egret3d.CubeVector3DValueShape();
                cubeShape.width = node.cubeW;
                cubeShape.height = node.cubeH;
                cubeShape.depth = node.cubeD;
                this._positions = cubeShape;
            }
            else if (node.type == egret3d.ParticleDataShapeType.Sphere) {
                var sphereShape = new egret3d.BallValueShape();
                sphereShape.r = node.sphereRadius;
                this._positions = sphereShape;
            }
            else if (node.type == egret3d.ParticleDataShapeType.HemiSphere) {
                var hemiShape = new egret3d.HemiBallValueShape();
                hemiShape.r = node.hemiSphereRadius;
                this._positions = hemiShape;
            }
            else if (node.type == egret3d.ParticleDataShapeType.Cone) {
                var coneShape = new egret3d.CylinderValueShape();
                coneShape.radiusTop = node.coneRadiusTop;
                coneShape.radiusBottom = node.coneRadiusBottom;
                if (coneShape.coneType == egret3d.ParticleConeShapeType.BaseShell) {
                    coneShape.height = 0;
                }
                else {
                    coneShape.height = node.coneHeight;
                }
                coneShape.coneType = node.coneType;
                this._positions = coneShape;
            }
        };
        Object.defineProperty(ParticlePosition.prototype, "offsetIndex", {
            /**
            * @language zh_CN
            * 获取位置节点在geometry的顶点数据中偏移量
            * @return number
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.attribute_offsetPosition.offsetIndex;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticlePosition.prototype.build = function (geometry, count) {
            this._animationState = this.state;
            var posArray = this._positions.calculate(count);
            var directionArray = this._animationState.directionArray = [];
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var data = this._animationState.emitter.data;
            var recordPos = new egret3d.Vector3D(); //用于计算方向，缩放后的位置不能用于计算方向
            var coneShape = this._positions;
            for (var i = 0; i < count; ++i) {
                var pos = posArray[i];
                recordPos.copyFrom(pos);
                //缩放______________________________________________________
                pos.multiply(data.property.scale, pos);
                //粒子发射方向
                var dir = new egret3d.Vector3D();
                if (data.shape.randomDirection) {
                    dir.setTo(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
                }
                else {
                    if (this._node.type == egret3d.ParticleDataShapeType.Point) {
                        dir.setTo(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
                    }
                    else if (this._node.type == egret3d.ParticleDataShapeType.Cube) {
                        dir.setTo(0, 0, 1, 1);
                    }
                    else if (this._node.type == egret3d.ParticleDataShapeType.Sphere) {
                        dir.copyFrom(recordPos);
                    }
                    else if (this._node.type == egret3d.ParticleDataShapeType.HemiSphere) {
                        dir.copyFrom(recordPos);
                    }
                    else if (this._node.type == egret3d.ParticleDataShapeType.Cone) {
                        dir = coneShape.getDirection(recordPos, dir);
                    }
                }
                dir.normalize();
                directionArray.push(dir);
                //创建位置
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_offsetPosition.offsetIndex;
                    geometry.verticesData[index + 0] = pos.x;
                    geometry.verticesData[index + 1] = pos.y;
                    geometry.verticesData[index + 2] = pos.z;
                }
            }
        };
        return ParticlePosition;
    }(egret3d.AnimationNode));
    egret3d.ParticlePosition = ParticlePosition;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleRotation
    * @classdesc
    * 粒子旋转效果节点(初始角度，直接加成到了顶点位置上，不会在shader上反映出)
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleRotation = (function (_super) {
        __extends(ParticleRotation, _super);
        function ParticleRotation() {
            _super.call(this);
            this.rotationMat = new egret3d.Matrix4_4();
            this.name = "ParticleRotation";
        }
        /**
        * @language zh_CN
        * 填充粒子初始旋转数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotation.prototype.initNode = function (data) {
            var node = this._node = data;
            this._rotations = new egret3d.ConstRandomValueShape();
            this._rotations.max = node.max;
            this._rotations.min = node.min;
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotation.prototype.build = function (geometry, count) {
            this._animationState = this.state;
            var rotationArray = this._rotations.calculate(count);
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var pos = new egret3d.Vector3D();
            var rot;
            var progress = 0;
            var duration = this._animationState.emitter.data.life.duration;
            var timeOffsetIndex = this._animationState.emitter.timeNode.offsetIndex;
            var particleIndex = 0;
            var timeIndex;
            var bornTime;
            for (var i = 0; i < count; ++i) {
                //
                if (this._node.type == egret3d.ParticleValueType.OneBezier || this._node.type == egret3d.ParticleValueType.TwoBezier) {
                    timeIndex = particleIndex * geometry.vertexAttLength + timeOffsetIndex;
                    bornTime = geometry.verticesData[timeIndex + 0]; //出生时间
                    progress = bornTime / duration;
                    progress = progress - Math.floor(progress); //取小数部分
                    rot = this._node.bezier1.calc(progress);
                    if (this._node.type == egret3d.ParticleValueType.TwoBezier) {
                        var random = Math.random();
                        rot *= random;
                        rot += this._node.bezier2.calc(progress) * (1 - random);
                    }
                }
                else {
                    rot = rotationArray[i];
                }
                this.rotationMat.identity();
                this.rotationMat.rotation(0, 0, rot);
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength;
                    pos.x = geometry.verticesData[index + 0];
                    pos.y = geometry.verticesData[index + 1];
                    pos.z = geometry.verticesData[index + 2];
                    this.rotationMat.transformVector4(pos, pos);
                    geometry.verticesData[index + 0] = pos.x;
                    geometry.verticesData[index + 1] = pos.y;
                    geometry.verticesData[index + 2] = pos.z;
                }
            }
        };
        return ParticleRotation;
    }(egret3d.AnimationNode));
    egret3d.ParticleRotation = ParticleRotation;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * 粒子初始化的尺寸大小
    */
    var ParticleScale = (function (_super) {
        __extends(ParticleScale, _super);
        function ParticleScale() {
            _super.call(this);
            this.name = "ParticleScale";
        }
        /**
        * @language zh_CN
        * 填充粒子尺寸缩放数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleScale.prototype.initNode = function (data) {
            var node = this._node = data;
            this._scale = new egret3d.ConstRandomValueShape();
            this._scale.max = node.max;
            this._scale.min = node.min;
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleScale.prototype.build = function (geometry, count) {
            this._animationState = this.state;
            var scaleArray = this._scale.calculate(count);
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var progress = 0;
            var duration = this._animationState.emitter.data.life.duration;
            var timeOffsetIndex = this._animationState.emitter.timeNode.offsetIndex;
            var particleIndex = 0;
            var timeIndex;
            var bornTime;
            var scale = 0;
            for (var i = 0; i < count; ++i) {
                //
                if (this._node.type == egret3d.ParticleValueType.OneBezier || this._node.type == egret3d.ParticleValueType.TwoBezier) {
                    timeIndex = particleIndex * geometry.vertexAttLength + timeOffsetIndex;
                    bornTime = geometry.verticesData[timeIndex + 0]; //出生时间
                    progress = bornTime / duration;
                    progress = progress - Math.floor(progress); //取小数部分
                    scale = this._node.bezier1.calc(progress);
                    if (this._node.type == egret3d.ParticleValueType.TwoBezier) {
                        var random = Math.random();
                        scale *= random;
                        scale += this._node.bezier2.calc(progress) * (1 - random);
                    }
                }
                else {
                    scale = scaleArray[i];
                }
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength;
                    geometry.verticesData[index + 0] *= scale;
                    geometry.verticesData[index + 1] *= scale;
                    geometry.verticesData[index + 2] *= scale;
                }
            }
        };
        return ParticleScale;
    }(egret3d.AnimationNode));
    egret3d.ParticleScale = ParticleScale;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleStartColor
    * @classdesc
    * 粒子起始颜色，用顶点色实现
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleStartColor = (function (_super) {
        __extends(ParticleStartColor, _super);
        function ParticleStartColor() {
            _super.call(this);
            this.bornTime = 0;
            this.life = 0;
            this.id = 0;
            this.timeIndex = 0;
            this.name = "ParticleStartColor";
        }
        /**
        * @language zh_CN
        * 填充粒子发射器起始颜色
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleStartColor.prototype.initNode = function (data) {
            this._node = data;
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleStartColor.prototype.build = function (geometry, count) {
            this.particleAnimationState = this.state;
            var vertexColorOffset = 3; //前面三个数据是xyz
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var timeOffsetIndex = this.particleAnimationState.emitter.timeNode.offsetIndex;
            var particleIndex = 0;
            var clr1 = new egret3d.Color();
            var clr2 = new egret3d.Color();
            var progress = 0;
            var duration = this.particleAnimationState.emitter.data.life.duration;
            for (var i = 0; i < count; ++i) {
                particleIndex = i * vertices;
                this.timeIndex = particleIndex * geometry.vertexAttLength + timeOffsetIndex;
                this.bornTime = geometry.verticesData[this.timeIndex + 0]; //出生时间
                //this.life = geometry.verticesData[this.timeIndex + 1];              //单次生命周期时间
                //this.id = geometry.verticesData[this.timeIndex + 2];              //下标(i)
                progress = this.bornTime / duration;
                progress = progress - Math.floor(progress); //取小数部分
                this.lerpBirthColor(clr1, clr2, progress);
                clr1.a /= 256;
                clr1.r /= 256;
                clr1.g /= 256;
                clr1.b /= 256;
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + vertexColorOffset;
                    geometry.verticesData[index + 0] = clr1.r;
                    geometry.verticesData[index + 1] = clr1.g;
                    geometry.verticesData[index + 2] = clr1.b;
                    geometry.verticesData[index + 3] = clr1.a;
                }
            }
        };
        /**
        * @private
        * 根据每种出生颜色数据，相应获得一个颜色
        */
        ParticleStartColor.prototype.lerpBirthColor = function (c1, c2, t) {
            if (this._node.colorType == egret3d.ParticleBirthColorType.Const) {
                c1.copyFrom(this._node.colorConst1);
            }
            else if (this._node.colorType == egret3d.ParticleBirthColorType.RandomConst) {
                c1.randomColor(this._node.colorConst1, this._node.colorConst2, true);
            }
            else if (this._node.colorType == egret3d.ParticleBirthColorType.OneGradients) {
                this._node.colorGradients1.lerpColor(t, c1);
            }
            else if (this._node.colorType == egret3d.ParticleBirthColorType.TwoGradients) {
                this._node.colorGradients1.lerpColor(t, c1);
                this._node.colorGradients2.lerpColor(t, c2);
                c1.lerp(c1, c2, 0.5);
            }
        };
        return ParticleStartColor;
    }(egret3d.AnimationNode));
    egret3d.ParticleStartColor = ParticleStartColor;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleFollowNode
    * @classdesc
    * 粒子跟随效果节点
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleFollowNode = (function (_super) {
        __extends(ParticleFollowNode, _super);
        function ParticleFollowNode() {
            _super.call(this);
            this.count = 0;
            this._followRotation = false;
            this._followScale = false;
            this.bornTime = 0;
            this.life = 0;
            this.id = 0;
            this.timeIndex = 0;
            /**
            * @language zh_CN
            * 顶点数据是否需要重新upload
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.geometryDirty = false;
            this.name = "ParticleFollowNode";
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_follow_vs");
            this.attribute_followPosition = new egret3d.GLSL.VarRegister();
            this.attribute_followPosition.name = "attribute_followPosition";
            this.attribute_followPosition.size = 3;
            this.attributes.push(this.attribute_followPosition);
            this.attribute_followRotation = new egret3d.GLSL.VarRegister();
            this.attribute_followRotation.name = "attribute_followRotation";
            this.attribute_followRotation.size = 4;
            this.attributes.push(this.attribute_followRotation);
            this.attribute_followScale = new egret3d.GLSL.VarRegister();
            this.attribute_followScale.name = "attribute_followScale";
            this.attribute_followScale.size = 3;
            this.attributes.push(this.attribute_followScale);
        }
        /**
        * @language zh_CN
        * 填充粒子跟随属性
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleFollowNode.prototype.initNode = function (data) {
            var node = data;
            this._followScale = node.followScale;
            this._followRotation = node.followRotation;
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleFollowNode.prototype.build = function (geometry, count) {
            this.count = count;
            this.particleAnimationState = this.state;
            //先重置成-1，然后每帧检测每个粒子的上一帧的所属出身次数和下一帧的出身次数，判定是否要刷新他的初始位置
            this.lifeCircles = [];
            for (var i = 0; i < this.count; i++) {
                this.lifeCircles[i] = -1;
            }
        };
        /**
        * @language zh_CN
        * @param animTime 动画当前时间（单位为ms）
        * @param delay  这一帧的时间跨度
        * @param geometry 几何对象
        * 顶点数据是否需要重新upload
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleFollowNode.prototype.update = function (animTime, delay, geometry) {
            //保留原来的geometryDirty为true的属性
            this.geometryDirty = this.geometryDirty;
            //非循环的粒子生命周期达上限
            var loop = this.particleAnimationState.emitter.data.life.loop;
            var maxLife = this.particleAnimationState.loopTime + this.particleAnimationState.emitter.data.life.duration;
            if (!loop && (animTime * 0.001 >= maxLife)) {
                return;
            }
            //animTime += delay;
            var index = 0;
            var vertices = geometry.vertexCount / this.count;
            var particleIndex = 0;
            var changed = false;
            var timeOffsetIndex = this.particleAnimationState.emitter.timeNode.offsetIndex;
            var particleTime = animTime * 0.001 - this.particleAnimationState.emitter.data.life.delay;
            //没有跟随对象，使用自己
            var followTarget = this.particleAnimationState.followTarget || this.particleAnimationState.emitter;
            for (var i = 0; i < this.count; ++i) {
                particleIndex = i * vertices;
                this.timeIndex = particleIndex * geometry.vertexAttLength + timeOffsetIndex;
                this.bornTime = geometry.verticesData[this.timeIndex + 0]; //出生时间
                this.life = geometry.verticesData[this.timeIndex + 1]; //单次生命周期时间
                //this.id = geometry.verticesData[this.timeIndex + 2];                //下标(i)
                var curCircleIndex = -1;
                if (particleTime >= this.bornTime) {
                    //粒子超时了，并且不需要继续循环
                    if (particleTime > (this.bornTime + this.life) && !loop)
                        continue;
                    curCircleIndex = Math.floor((particleTime - this.bornTime) / this.particleAnimationState.loopTime);
                    if (curCircleIndex != this.lifeCircles[i]) {
                        this.lifeCircles[i] = curCircleIndex;
                        changed = true;
                        for (var j = 0; j < vertices; ++j) {
                            //position
                            index = particleIndex + j;
                            index = index * geometry.vertexAttLength + this.attribute_followPosition.offsetIndex;
                            if (true) {
                                geometry.verticesData[index + 0] = followTarget.globalPosition.x;
                                geometry.verticesData[index + 1] = followTarget.globalPosition.y;
                                geometry.verticesData[index + 2] = followTarget.globalPosition.z;
                            }
                            //rotation
                            index = particleIndex + j;
                            index = index * geometry.vertexAttLength + this.attribute_followRotation.offsetIndex;
                            if (this._followRotation) {
                                geometry.verticesData[index + 0] = followTarget.globalOrientation.x;
                                geometry.verticesData[index + 1] = followTarget.globalOrientation.y;
                                geometry.verticesData[index + 2] = followTarget.globalOrientation.z;
                                geometry.verticesData[index + 3] = followTarget.globalOrientation.w;
                            }
                            else {
                                geometry.verticesData[index + 0] = 0;
                                geometry.verticesData[index + 1] = 0;
                                geometry.verticesData[index + 2] = 0;
                                geometry.verticesData[index + 3] = 0;
                            }
                            //scale
                            index = particleIndex + j;
                            index = index * geometry.vertexAttLength + this.attribute_followScale.offsetIndex;
                            if (this._followScale) {
                                geometry.verticesData[index + 0] = followTarget.globalScaleX;
                                geometry.verticesData[index + 1] = followTarget.globalScaleY;
                                geometry.verticesData[index + 2] = followTarget.globalScaleZ;
                            }
                            else {
                                geometry.verticesData[index + 0] = 0;
                                geometry.verticesData[index + 1] = 0;
                                geometry.verticesData[index + 2] = 0;
                            }
                        }
                    }
                }
            }
            this.geometryDirty = changed;
        };
        /**
        * @private
        */
        ParticleFollowNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            if (this.geometryDirty) {
                geometry.geometry.upload(context3DProxy);
                this.geometryDirty = false;
            }
        };
        return ParticleFollowNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleFollowNode = ParticleFollowNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleVelocityNode
    * @classdesc
    * 粒子速度节点(根据粒子的出生相对位置，以及是否随机方向获得一个三维向量)
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityNode = (function (_super) {
        __extends(ParticleVelocityNode, _super);
        function ParticleVelocityNode() {
            _super.call(this);
            this.name = "ParticleVelocityNode";
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocity");
            this.attribute_velocity = new egret3d.GLSL.VarRegister();
            this.attribute_velocity.name = "attribute_velocity";
            this.attribute_velocity.size = 3;
            this.attributes.push(this.attribute_velocity);
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityNode.prototype.initNode = function (data) {
            var node = this._node = data;
            if (node.type == egret3d.ParticleValueType.Const || node.type == egret3d.ParticleValueType.RandomConst) {
                this._velocityConstShape = new egret3d.ConstRandomValueShape();
                this._velocityConstShape.max = node.max;
                this._velocityConstShape.min = node.min;
            }
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityNode.prototype.build = function (geometry, count) {
            this._animationState = this.state;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var constList = this._velocityConstShape.calculate(count);
            var directionVector = this._animationState.directionArray;
            var direction = new egret3d.Vector3D();
            //
            var progress = 0;
            var duration = this._animationState.emitter.data.life.duration;
            var timeOffsetIndex = this._animationState.emitter.timeNode.offsetIndex;
            var particleIndex = 0;
            var timeIndex;
            var bornTime;
            var speed;
            for (var i = 0; i < count; ++i) {
                particleIndex = i * vertices;
                //
                if (this._node.type == egret3d.ParticleValueType.OneBezier || this._node.type == egret3d.ParticleValueType.TwoBezier) {
                    timeIndex = particleIndex * geometry.vertexAttLength + timeOffsetIndex;
                    bornTime = geometry.verticesData[timeIndex + 0]; //出生时间
                    progress = bornTime / duration;
                    progress = progress - Math.floor(progress); //取小数部分
                    speed = this._node.bezier1.calc(progress);
                    if (this._node.type == egret3d.ParticleValueType.TwoBezier) {
                        var random = Math.random();
                        speed *= random;
                        speed += this._node.bezier2.calc(progress) * (1 - random);
                    }
                }
                else {
                    speed = constList[i];
                }
                direction.copyFrom(directionVector[i]);
                direction.scaleBy(speed);
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_velocity.offsetIndex;
                    geometry.verticesData[index + 0] = direction.x;
                    geometry.verticesData[index + 1] = direction.y;
                    geometry.verticesData[index + 2] = direction.z;
                }
            }
        };
        return ParticleVelocityNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityNode = ParticleVelocityNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleColorGlobalNode
    * @classdesc
    * 颜色渐变
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleColorGlobalNode = (function (_super) {
        __extends(ParticleColorGlobalNode, _super);
        function ParticleColorGlobalNode() {
            _super.call(this);
            this._colorSegment = new Float32Array(ParticleColorGlobalNode.MaxColor * 2);
            this.name = "ParticleColorGlobalNode";
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_color_vs");
            this.fragment_ShaderName[egret3d.ShaderPhaseType.multi_end_fragment] = this.fragment_ShaderName[egret3d.ShaderPhaseType.multi_end_fragment] || [];
            this.fragment_ShaderName[egret3d.ShaderPhaseType.multi_end_fragment].push("particle_color_fs");
        }
        /**
        * @language zh_CN
        * 填充粒子颜色变化数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleColorGlobalNode.prototype.initNode = function (data) {
            var node = data;
            var count = ParticleColorGlobalNode.MaxColor;
            var gradients = node.data;
            gradients.colors.length = gradients.times.length = count;
            var color;
            for (var i = 0; i < count; i++) {
                color = gradients.colors[i];
                if (color) {
                    //这里采用了压缩方法：rgb三个数值压缩到一个float，a和time压缩放到第二个float
                    //然后在gpu中还原
                    this._colorSegment[i] = this.getGpuColor(color.r, color.g, color.b);
                    this._colorSegment[i + count] = this.getTimeAndAlpha(gradients.times[i], color.a);
                }
                else {
                    this._colorSegment[i] = 0;
                    this._colorSegment[i + count] = 0;
                }
            }
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleColorGlobalNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        */
        ParticleColorGlobalNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            context3DProxy.uniform1fv(usage["uniform_colorTransform"].uniformIndex, this._colorSegment);
        };
        /**
        * 压缩一个颜色值到一个float中
        */
        ParticleColorGlobalNode.prototype.getGpuColor = function (r, g, b) {
            r = this.normalizeChannel(r);
            g = this.normalizeChannel(g);
            b = this.normalizeChannel(b);
            var value = r * 0x100 + g + b / 0x100;
            return value;
        };
        /**
        * @private
        * 将一个颜色通道规范到0-255之间
        */
        ParticleColorGlobalNode.prototype.normalizeChannel = function (value) {
            if (value > 0xff)
                value = 0xff;
            else if (value < 0)
                value = 0;
            value = Math.floor(value);
            return value;
        };
        /**
        * @private
        * 将时间规范到0和0.9999之间
        */
        ParticleColorGlobalNode.prototype.normalizeTime = function (value) {
            //注：value是一个0-1之间的数，而非真实的秒时间
            //所以超过1将为无效会被设定成为一个接近1的数
            if (value >= 1)
                value = 0.9999;
            else if (value < 0)
                value = 0;
            return value;
        };
        /**
        * @private
        * 合并alpha和time到一个float中
        */
        ParticleColorGlobalNode.prototype.getTimeAndAlpha = function (time, a) {
            a = this.normalizeChannel(a);
            time = this.normalizeTime(time);
            return a + time;
        };
        /**
        * @private
        * 最大支持的颜色变化数量
        */
        ParticleColorGlobalNode.MaxColor = 20;
        return ParticleColorGlobalNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleColorGlobalNode = ParticleColorGlobalNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ParticleSizeGlobalNode = (function (_super) {
        __extends(ParticleSizeGlobalNode, _super);
        function ParticleSizeGlobalNode() {
            _super.call(this);
            this.name = "ParticleSizeGlobalNode";
            this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex].push("particle_size_vs");
            //|sa,sc ea,ec|  每个段的形式
        }
        /**
        * @language zh_CN
        * 填充粒子初始旋转数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleSizeGlobalNode.prototype.initNode = function (data) {
            this._node = data;
            this._floatCompressData = this._node.data.sampler();
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleSizeGlobalNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        */
        ParticleSizeGlobalNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            context3DProxy.uniform1fv(usage["uniform_bezierSize"].uniformIndex, this._floatCompressData);
        };
        return ParticleSizeGlobalNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleSizeGlobalNode = ParticleSizeGlobalNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleVelocityOverConstNode
    * @classdesc
    * 粒子速度节点叠加(常量的影响方式)
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityOverConstNode = (function (_super) {
        __extends(ParticleVelocityOverConstNode, _super);
        function ParticleVelocityOverConstNode() {
            _super.call(this);
            this.name = "ParticleVelocityOverConstNode";
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityOverConst");
            this.attribute_velocityOver = new egret3d.GLSL.VarRegister();
            this.attribute_velocityOver.name = "attribute_velocityOverConst";
            this.attribute_velocityOver.size = 3;
            this.attributes.push(this.attribute_velocityOver);
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityOverConstNode.prototype.initNode = function (data) {
            var node = data;
            this._velocityOverShape = new egret3d.Vec3ConstRandomValueShape();
            this._velocityOverShape.maxX = node.velocityOver.max.x;
            this._velocityOverShape.maxY = node.velocityOver.max.y;
            this._velocityOverShape.maxZ = node.velocityOver.max.z;
            this._velocityOverShape.minX = node.velocityOver.min.x;
            this._velocityOverShape.minY = node.velocityOver.min.y;
            this._velocityOverShape.minZ = node.velocityOver.min.z;
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityOverConstNode.prototype.build = function (geometry, count) {
            this.particleAnimationState = this.state;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var data = this._velocityOverShape.calculate(count);
            for (var i = 0; i < count; ++i) {
                var over = data[i];
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_velocityOver.offsetIndex;
                    geometry.verticesData[index + 0] = over.x;
                    geometry.verticesData[index + 1] = over.y;
                    geometry.verticesData[index + 2] = over.z;
                }
            }
        };
        return ParticleVelocityOverConstNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityOverConstNode = ParticleVelocityOverConstNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleVelocityOverOneBezierNode
    * @classdesc
    * 粒子速度叠加节点,贝塞尔曲线获得
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityOverOneBezierNode = (function (_super) {
        __extends(ParticleVelocityOverOneBezierNode, _super);
        function ParticleVelocityOverOneBezierNode() {
            _super.call(this);
            this.name = "ParticleVelocityOverOneBezierNode";
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityOverOneBezierNode.prototype.initNode = function (data) {
            this._node = data;
            this._floatCompressDataX = this._node.velocityOver.xBezier1.trySampler();
            this._floatCompressDataY = this._node.velocityOver.yBezier1.trySampler();
            this._floatCompressDataZ = this._node.velocityOver.zBezier1.trySampler();
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityOverOneBezier");
            if (this._floatCompressDataX) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityOverOneBezierX");
            }
            if (this._floatCompressDataY) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityOverOneBezierY");
            }
            if (this._floatCompressDataZ) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityOverOneBezierZ");
            }
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityOverOneBezierNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        */
        ParticleVelocityOverOneBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            if (this._floatCompressDataX) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverX"].uniformIndex, this._floatCompressDataX);
            }
            if (this._floatCompressDataY) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverY"].uniformIndex, this._floatCompressDataY);
            }
            if (this._floatCompressDataZ) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverZ"].uniformIndex, this._floatCompressDataZ);
            }
        };
        return ParticleVelocityOverOneBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityOverOneBezierNode = ParticleVelocityOverOneBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleVelocityOverTwoBezierNode
    * @classdesc
    * 粒子速度叠加节点,双贝塞尔曲线获得
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityOverTwoBezierNode = (function (_super) {
        __extends(ParticleVelocityOverTwoBezierNode, _super);
        function ParticleVelocityOverTwoBezierNode() {
            _super.call(this);
            this.name = "ParticleVelocityOverTwoBezierNode";
            this.attribute_randomSeed = new egret3d.GLSL.VarRegister();
            this.attribute_randomSeed.name = "attribute_velocityOverRandomSeed";
            this.attribute_randomSeed.size = 1;
            this.attributes.push(this.attribute_randomSeed);
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityOverTwoBezierNode.prototype.initNode = function (data) {
            this._node = data;
            this._floatCompressDataX1 = this._node.velocityOver.xBezier1.trySampler();
            this._floatCompressDataY1 = this._node.velocityOver.yBezier1.trySampler();
            this._floatCompressDataZ1 = this._node.velocityOver.zBezier1.trySampler();
            this._floatCompressDataX2 = this._node.velocityOver.xBezier2.trySampler();
            this._floatCompressDataY2 = this._node.velocityOver.yBezier2.trySampler();
            this._floatCompressDataZ2 = this._node.velocityOver.zBezier2.trySampler();
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityOverTwoBezier");
            if (this._floatCompressDataX1) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityOverTwoBezierX1");
            }
            if (this._floatCompressDataX2) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityOverTwoBezierX2");
            }
            if (this._floatCompressDataY1) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityOverTwoBezierY1");
            }
            if (this._floatCompressDataY2) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityOverTwoBezierY2");
            }
            if (this._floatCompressDataZ1) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityOverTwoBezierZ1");
            }
            if (this._floatCompressDataZ2) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityOverTwoBezierZ2");
            }
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityOverTwoBezierNode.prototype.build = function (geometry, count) {
            this._animationState = this.state;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            for (var i = 0; i < count; ++i) {
                var random = Math.random();
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_randomSeed.offsetIndex;
                    geometry.verticesData[index + 0] = random;
                }
            }
        };
        /**
        * @private
        */
        ParticleVelocityOverTwoBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            if (this._floatCompressDataX1) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverX1"].uniformIndex, this._floatCompressDataX1);
            }
            if (this._floatCompressDataX2) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverX2"].uniformIndex, this._floatCompressDataX2);
            }
            if (this._floatCompressDataY1) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverY1"].uniformIndex, this._floatCompressDataY1);
            }
            if (this._floatCompressDataY2) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverY2"].uniformIndex, this._floatCompressDataY2);
            }
            if (this._floatCompressDataZ1) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverZ1"].uniformIndex, this._floatCompressDataZ1);
            }
            if (this._floatCompressDataZ2) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverZ2"].uniformIndex, this._floatCompressDataZ2);
            }
        };
        return ParticleVelocityOverTwoBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityOverTwoBezierNode = ParticleVelocityOverTwoBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleVelocityForceConstNode(常量部分)
    * @classdesc
    * 粒子加速度效果节点
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityForceConstNode = (function (_super) {
        __extends(ParticleVelocityForceConstNode, _super);
        function ParticleVelocityForceConstNode() {
            _super.call(this);
            this.name = "ParticleVelocityForceConstNode";
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityForceConst");
            this.attribute_accelerationSpeed = new egret3d.GLSL.VarRegister();
            this.attribute_accelerationSpeed.name = "attribute_velocityForceConst";
            this.attribute_accelerationSpeed.size = 3;
            this.attributes.push(this.attribute_accelerationSpeed);
        }
        /**
       * @language zh_CN
       * 填充粒子加速度数据
       * @param data ParticleDataNode 粒子数据来源
       * @version Egret 3.0
       * @platform Web,Native
       */
        ParticleVelocityForceConstNode.prototype.initNode = function (data) {
            this._node = data;
            var node = this._node.velocityForce;
            this._forceData = new egret3d.Vec3ConstRandomValueShape();
            this._forceData.maxX = node.max.x;
            this._forceData.maxY = node.max.y;
            this._forceData.maxZ = node.max.z;
            this._forceData.minX = node.min.x;
            this._forceData.minY = node.min.y;
            this._forceData.minZ = node.min.z;
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityForceConstNode.prototype.build = function (geometry, count) {
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var data = this._forceData.calculate(count);
            for (var i = 0; i < count; ++i) {
                var accSpeed = data[i];
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_accelerationSpeed.offsetIndex;
                    geometry.verticesData[index + 0] = accSpeed.x;
                    geometry.verticesData[index + 1] = accSpeed.y;
                    geometry.verticesData[index + 2] = accSpeed.z;
                }
            }
        };
        return ParticleVelocityForceConstNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityForceConstNode = ParticleVelocityForceConstNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleVelocityForceOneBezierNode
    * @classdesc
    * 粒子加速度叠加节点,贝塞尔曲线获得
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityForceOneBezierNode = (function (_super) {
        __extends(ParticleVelocityForceOneBezierNode, _super);
        function ParticleVelocityForceOneBezierNode() {
            _super.call(this);
            this.name = "ParticleVelocityForceOneBezierNode";
        }
        /**
        * @language zh_CN
        * 填充粒子加速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityForceOneBezierNode.prototype.initNode = function (data) {
            this._node = data;
            this._floatCompressDataX = this._node.velocityForce.xBezier1.trySampler();
            this._floatCompressDataY = this._node.velocityForce.yBezier1.trySampler();
            this._floatCompressDataZ = this._node.velocityForce.zBezier1.trySampler();
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityForceOneBezier");
            if (this._floatCompressDataX) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityForceOneBezierX");
            }
            if (this._floatCompressDataY) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityForceOneBezierY");
            }
            if (this._floatCompressDataZ) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityForceOneBezierZ");
            }
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityForceOneBezierNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        */
        ParticleVelocityForceOneBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            if (this._floatCompressDataX) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceX"].uniformIndex, this._floatCompressDataX);
            }
            if (this._floatCompressDataY) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceY"].uniformIndex, this._floatCompressDataY);
            }
            if (this._floatCompressDataZ) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceZ"].uniformIndex, this._floatCompressDataZ);
            }
        };
        return ParticleVelocityForceOneBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityForceOneBezierNode = ParticleVelocityForceOneBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleVelocityForceTwoBezierNode
    * @classdesc
    * 粒子加速度叠加节点,双贝塞尔曲线获得
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityForceTwoBezierNode = (function (_super) {
        __extends(ParticleVelocityForceTwoBezierNode, _super);
        function ParticleVelocityForceTwoBezierNode() {
            _super.call(this);
            this.name = "ParticleVelocityForceTwoBezierNode";
            this.attribute_randomSeed = new egret3d.GLSL.VarRegister();
            this.attribute_randomSeed.name = "attribute_velocityForceRandomSeed";
            this.attribute_randomSeed.size = 1;
            this.attributes.push(this.attribute_randomSeed);
        }
        /**
        * @language zh_CN
        * 填充粒子加速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityForceTwoBezierNode.prototype.initNode = function (data) {
            this._node = data;
            this._floatCompressDataX1 = this._node.velocityForce.xBezier1.trySampler();
            this._floatCompressDataY1 = this._node.velocityForce.yBezier1.trySampler();
            this._floatCompressDataZ1 = this._node.velocityForce.zBezier1.trySampler();
            this._floatCompressDataX2 = this._node.velocityForce.xBezier2.trySampler();
            this._floatCompressDataY2 = this._node.velocityForce.yBezier2.trySampler();
            this._floatCompressDataZ2 = this._node.velocityForce.zBezier2.trySampler();
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityForceTwoBezier");
            if (this._floatCompressDataX1) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityForceTwoBezierX1");
            }
            if (this._floatCompressDataX2) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityForceTwoBezierX2");
            }
            if (this._floatCompressDataY1) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityForceTwoBezierY1");
            }
            if (this._floatCompressDataY2) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityForceTwoBezierY2");
            }
            if (this._floatCompressDataZ1) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityForceTwoBezierZ1");
            }
            if (this._floatCompressDataZ2) {
                this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityForceTwoBezierZ2");
            }
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityForceTwoBezierNode.prototype.build = function (geometry, count) {
            this._animationState = this.state;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            for (var i = 0; i < count; ++i) {
                var random = Math.random();
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_randomSeed.offsetIndex;
                    geometry.verticesData[index + 0] = random;
                }
            }
        };
        /**
        * @private
        */
        ParticleVelocityForceTwoBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            if (this._floatCompressDataX1) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceX1"].uniformIndex, this._floatCompressDataX1);
            }
            if (this._floatCompressDataX2) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceX2"].uniformIndex, this._floatCompressDataX2);
            }
            if (this._floatCompressDataY1) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceY1"].uniformIndex, this._floatCompressDataY1);
            }
            if (this._floatCompressDataY2) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceY2"].uniformIndex, this._floatCompressDataY2);
            }
            if (this._floatCompressDataZ1) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceZ1"].uniformIndex, this._floatCompressDataZ1);
            }
            if (this._floatCompressDataZ2) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceZ2"].uniformIndex, this._floatCompressDataZ2);
            }
        };
        return ParticleVelocityForceTwoBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityForceTwoBezierNode = ParticleVelocityForceTwoBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleVelocityLimitConstNode
    * @classdesc
    * 粒子速度节点限制(常量的影响方式)
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityLimitConstNode = (function (_super) {
        __extends(ParticleVelocityLimitConstNode, _super);
        function ParticleVelocityLimitConstNode() {
            _super.call(this);
            this.name = "ParticleVelocityLimitConstNode";
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityLimitConst");
            this.attribute_velocityLimit = new egret3d.GLSL.VarRegister();
            this.attribute_velocityLimit.name = "attribute_velocityLimit";
            this.attribute_velocityLimit.size = 1;
            this.attributes.push(this.attribute_velocityLimit);
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityLimitConstNode.prototype.initNode = function (data) {
            var node = data;
            this._velocityLimitShape = new egret3d.ConstRandomValueShape();
            this._velocityLimitShape.max = node.velocityLimit.max;
            this._velocityLimitShape.min = node.velocityLimit.min;
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityLimitConstNode.prototype.build = function (geometry, count) {
            this._animationState = this.state;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var data = this._velocityLimitShape.calculate(count);
            for (var i = 0; i < count; ++i) {
                var limit = data[i];
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_velocityLimit.offsetIndex;
                    geometry.verticesData[index + 0] = limit;
                }
            }
        };
        return ParticleVelocityLimitConstNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityLimitConstNode = ParticleVelocityLimitConstNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleVelocityLimitOneBezierNode
    * @classdesc
    * 粒子速度限制,贝塞尔曲线获得
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityLimitOneBezierNode = (function (_super) {
        __extends(ParticleVelocityLimitOneBezierNode, _super);
        function ParticleVelocityLimitOneBezierNode() {
            _super.call(this);
            this.name = "ParticleVelocityLimitOneBezierNode";
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityLimitOneBezier");
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityLimitOneBezierNode.prototype.initNode = function (data) {
            this._node = data;
            this._floatCompressData = this._node.velocityLimit.bezier1.sampler();
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityLimitOneBezierNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        */
        ParticleVelocityLimitOneBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            context3DProxy.uniform1fv(usage["uniform_velocityLimit"].uniformIndex, this._floatCompressData);
        };
        return ParticleVelocityLimitOneBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityLimitOneBezierNode = ParticleVelocityLimitOneBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleVelocityLimitTwoBezierNode
    * @classdesc
    * 粒子速度限制,贝塞尔曲线获得
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityLimitTwoBezierNode = (function (_super) {
        __extends(ParticleVelocityLimitTwoBezierNode, _super);
        function ParticleVelocityLimitTwoBezierNode() {
            _super.call(this);
            this.name = "ParticleVelocityLimitTwoBezierNode";
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_velocityLimitTwoBezier");
            this.attribute_randomSeed = new egret3d.GLSL.VarRegister();
            this.attribute_randomSeed.name = "attribute_velocityLimitRandomSeed";
            this.attribute_randomSeed.size = 1;
            this.attributes.push(this.attribute_randomSeed);
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityLimitTwoBezierNode.prototype.initNode = function (data) {
            this._node = data;
            this._floatCompressData = this._node.velocityLimit.bezier1.sampler();
            this._floatCompressData2 = this._node.velocityLimit.bezier2.sampler();
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityLimitTwoBezierNode.prototype.build = function (geometry, count) {
            this._animationState = this.state;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            for (var i = 0; i < count; ++i) {
                var random = Math.random();
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_randomSeed.offsetIndex;
                    geometry.verticesData[index + 0] = random;
                }
            }
        };
        /**
        * @private
        */
        ParticleVelocityLimitTwoBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            context3DProxy.uniform1fv(usage["uniform_velocityLimit"].uniformIndex, this._floatCompressData);
            context3DProxy.uniform1fv(usage["uniform_velocityLimit2"].uniformIndex, this._floatCompressData2);
        };
        return ParticleVelocityLimitTwoBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityLimitTwoBezierNode = ParticleVelocityLimitTwoBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * 粒子的旋转角速度，当前实现为Z轴的速度（todo：模型粒子或许需要同时有x/y/z三个方向的角速度）
    */
    var ParticleRotationConstNode = (function (_super) {
        __extends(ParticleRotationConstNode, _super);
        function ParticleRotationConstNode() {
            _super.call(this);
            this.name = "ParticleRotationConstNode";
            this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex].push("particle_rotationConst");
            this.attribute_Rotation = new egret3d.GLSL.VarRegister();
            this.attribute_Rotation.name = "attribute_rotationZ";
            this.attribute_Rotation.size = 1;
            this.attributes.push(this.attribute_Rotation);
        }
        /**
        * @language zh_CN
        * 填充粒子过程旋转数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotationConstNode.prototype.initNode = function (data) {
            var node = data;
            this._rotation = new egret3d.ConstRandomValueShape();
            this._rotation.max = node.max.z;
            this._rotation.min = node.min.z;
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotationConstNode.prototype.build = function (geometry, count) {
            var index = 0;
            var vertices = geometry.vertexCount / count;
            var data = this._rotation.calculate(count);
            for (var i = 0; i < count; ++i) {
                var rot = data[i];
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_Rotation.offsetIndex;
                    geometry.verticesData[index + 0] = rot;
                }
            }
        };
        return ParticleRotationConstNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleRotationConstNode = ParticleRotationConstNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleRotationOneBezierNode
    * @classdesc
    * 粒子z轴旋转角速度（bezier曲线）
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleRotationOneBezierNode = (function (_super) {
        __extends(ParticleRotationOneBezierNode, _super);
        function ParticleRotationOneBezierNode() {
            _super.call(this);
            this.name = "ParticleRotationOneBezierNode";
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_rotationOneBezier");
        }
        /**
        * @language zh_CN
        * 填充粒子旋转角速度
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotationOneBezierNode.prototype.initNode = function (data) {
            this._node = data;
            this._floatCompressData = this._node.bezier1.sampler();
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotationOneBezierNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        */
        ParticleRotationOneBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            context3DProxy.uniform1fv(usage["uniform_rotationBezier"].uniformIndex, this._floatCompressData);
        };
        return ParticleRotationOneBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleRotationOneBezierNode = ParticleRotationOneBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleRotationTwoBezierNode
    * @classdesc
    * 粒子z轴旋转角速度（双bezier曲线）
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleRotationTwoBezierNode = (function (_super) {
        __extends(ParticleRotationTwoBezierNode, _super);
        function ParticleRotationTwoBezierNode() {
            _super.call(this);
            this.name = "ParticleRotationTwoBezierNode";
            this.attribute_randomSeed = new egret3d.GLSL.VarRegister();
            this.attribute_randomSeed.name = "attribute_rotationRandomSeed";
            this.attribute_randomSeed.size = 1;
            this.attributes.push(this.attribute_randomSeed);
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotationTwoBezierNode.prototype.initNode = function (data) {
            this._node = data;
            this._floatCompressData = this._node.bezier1.sampler();
            this._floatCompressData2 = this._node.bezier2.sampler();
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.global_vertex].push("particle_rotationTwoBezier");
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotationTwoBezierNode.prototype.build = function (geometry, count) {
            this._animationState = this.state;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            for (var i = 0; i < count; ++i) {
                var random = Math.random();
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_randomSeed.offsetIndex;
                    geometry.verticesData[index + 0] = random;
                }
            }
        };
        /**
        * @private
        */
        ParticleRotationTwoBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            context3DProxy.uniform1fv(usage["uniform_rotationBezier"].uniformIndex, this._floatCompressData);
            context3DProxy.uniform1fv(usage["uniform_rotationBezier2"].uniformIndex, this._floatCompressData2);
        };
        return ParticleRotationTwoBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleRotationTwoBezierNode = ParticleRotationTwoBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleTextureSheetNode
    * @classdesc
    * uv序列帧
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleTextureSheetNode = (function (_super) {
        __extends(ParticleTextureSheetNode, _super);
        function ParticleTextureSheetNode() {
            _super.call(this);
            this._sheetFloatData = new Float32Array(5);
            this.name = "ParticleTextureSheetNode";
            //
            this.attribute_textureSheetData = new egret3d.GLSL.VarRegister();
            this.attribute_textureSheetData.name = "attribute_textureSheetData";
            this.attribute_textureSheetData.size = 3;
            this.attributes.push(this.attribute_textureSheetData);
            this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex] = this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vertex_ShaderName[egret3d.ShaderPhaseType.local_vertex].push("particle_textureSheet_vs");
        }
        /**
        * @language zh_CN
        * 填充UV滚动
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleTextureSheetNode.prototype.initNode = function (data, args) {
            this._sheetData = args;
            this._sheetFloatData[0] = this._sheetData.tileX;
            this._sheetFloatData[1] = this._sheetData.tileY;
            this._sheetFloatData[2] = this._sheetData.circles;
            if (this._sheetData.whole) {
                this._sheetFloatData[3] = 0;
                this._sheetFloatData[4] = this._sheetData.tileX * this._sheetData.tileY - 1;
            }
            else {
                this._sheetFloatData[3] = 0;
                this._sheetFloatData[4] = this._sheetData.tileY - 1;
            }
            if (this._sheetData.frameType == egret3d.ParticleValueType.Const || this._sheetData.frameType == egret3d.ParticleValueType.RandomConst) {
                this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment] = this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment] || [];
                this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment].push("particle_textureSheetConst");
            }
            else if (this._sheetData.frameType == egret3d.ParticleValueType.OneBezier) {
                this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment] = this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment] || [];
                this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment].push("particle_bezier");
                this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment].push("particle_textureSheetOneBezier");
                this._floatCompressData1 = this._sheetData.bezier1.sampler();
            }
            else if (this._sheetData.frameType == egret3d.ParticleValueType.TwoBezier) {
                this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment] = this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment] || [];
                this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment].push("particle_bezier");
                this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment].push("particle_textureSheetTwoBezier");
                this._floatCompressData1 = this._sheetData.bezier1.sampler();
                this._floatCompressData2 = this._sheetData.bezier2.sampler();
            }
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleTextureSheetNode.prototype.build = function (geometry, count) {
            var frameStart = 0;
            var frameConst = 0;
            var randomSeed = 0;
            //将frameStart放入到顶点数据中
            var index = 0;
            var vertices = geometry.vertexCount / count;
            for (var i = 0; i < count; ++i) {
                //frameStart
                if (this._sheetData.whole) {
                    frameStart = 0;
                }
                else {
                    if (this._sheetData.randomRow) {
                        frameStart = Math.floor(this._sheetData.tileX * Math.random()) * this._sheetData.tileY;
                    }
                    else {
                        frameStart = this._sheetData.row * this._sheetData.tileY;
                    }
                }
                //frame const
                if (this._sheetData.frameType == egret3d.ParticleValueType.Const || egret3d.ParticleValueType.RandomConst) {
                    var frameConst = (this._sheetData.max - this._sheetData.min) * Math.random() + this._sheetData.min;
                    frameConst = Math.floor(frameConst);
                }
                else {
                    frameConst = 0;
                }
                //
                if (this._sheetData.frameType == egret3d.ParticleValueType.TwoBezier) {
                    randomSeed = Math.random();
                }
                else {
                    randomSeed = 1;
                }
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_textureSheetData.offsetIndex;
                    geometry.verticesData[index + 0] = frameStart + 0.001; //修复抖动的问题
                    geometry.verticesData[index + 1] = frameConst;
                    geometry.verticesData[index + 2] = randomSeed;
                }
            }
        };
        /**
        * @private
        */
        ParticleTextureSheetNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            context3DProxy.uniform1fv(usage["uniform_textureSheet"].uniformIndex, this._sheetFloatData);
            if (this._sheetData.frameType == egret3d.ParticleValueType.OneBezier) {
                context3DProxy.uniform1fv(usage["uniform_frameBezier"].uniformIndex, this._floatCompressData1);
            }
            else if (this._sheetData.frameType == egret3d.ParticleValueType.TwoBezier) {
                context3DProxy.uniform1fv(usage["uniform_frameBezier1"].uniformIndex, this._floatCompressData1);
                context3DProxy.uniform1fv(usage["uniform_frameBezier2"].uniformIndex, this._floatCompressData2);
            }
        };
        return ParticleTextureSheetNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleTextureSheetNode = ParticleTextureSheetNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleUVRollNode
    * @classdesc
    * uv滚动
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleUVRollNode = (function (_super) {
        __extends(ParticleUVRollNode, _super);
        function ParticleUVRollNode() {
            _super.call(this);
            this._uvRollData = new Float32Array(2);
            this.name = "ParticleUVRollNode";
            //需要在之前进行设置UV
            this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment] = this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment] || [];
            this.fragment_ShaderName[egret3d.ShaderPhaseType.start_fragment].push("particle_uv_roll_fs");
        }
        /**
        * @language zh_CN
        * 填充UV滚动
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleUVRollNode.prototype.initNode = function (data, args) {
            this._methodData = args;
            this._uvRollData[0] = this._methodData.uSpeed;
            this._uvRollData[1] = this._methodData.vSpeed;
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleUVRollNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        */
        ParticleUVRollNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            context3DProxy.uniform1fv(usage["uniform_particleUVRoll"].uniformIndex, this._uvRollData);
        };
        return ParticleUVRollNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleUVRollNode = ParticleUVRollNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleSubEmitterNode
    * @classdesc
    * 粒子跟随效果节点
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleSubEmitterNode = (function (_super) {
        __extends(ParticleSubEmitterNode, _super);
        function ParticleSubEmitterNode() {
            _super.call(this);
            this._empty = true;
            this.bornTime = 0;
            this.life = 0;
            this.id = 0;
            this.timeIndex = 0;
            this.count = 0;
            this.position = new egret3d.Vector3D();
            this._added = false;
            this._birthPhase = new ParticleSubEmitterNodePhase(egret3d.ParticleDataSubEmitterPhase.BIRTH);
            this._collisionPhase = new ParticleSubEmitterNodePhase(egret3d.ParticleDataSubEmitterPhase.COLLISION);
            this._deathPhase = new ParticleSubEmitterNodePhase(egret3d.ParticleDataSubEmitterPhase.DEATH);
            this.name = "ParticleSubEmitterNode";
        }
        /**
        * @language zh_CN
        * 填充粒子属性
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleSubEmitterNode.prototype.initNode = function (data, parent) {
            if (parent === void 0) { parent = null; }
            this._parent = parent;
        };
        /**
        * @language zh_CN
        * 导入新的子粒子发射
        * @param subEmitter ParticleEmitter 子发射器
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleSubEmitterNode.prototype.importSubEmitter = function (phase, subEmitter) {
            var nodePhase;
            if (phase == egret3d.ParticleDataSubEmitterPhase.BIRTH) {
                nodePhase = this._birthPhase;
            }
            else if (phase == egret3d.ParticleDataSubEmitterPhase.COLLISION) {
                nodePhase = this._collisionPhase;
            }
            else if (phase == egret3d.ParticleDataSubEmitterPhase.DEATH) {
                nodePhase = this._deathPhase;
            }
            if (nodePhase) {
                this._empty = false;
                nodePhase.importSubEmitter(subEmitter);
            }
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleSubEmitterNode.prototype.build = function (geometry, count) {
            this.count = count;
            this._animationState = this.state;
            //先重置成-1，然后每帧检测每个粒子的上一帧的所属出身次数和下一帧的出身次数，判定是否要刷新他的初始位置
            this._lifeCircles = [];
            for (var i = 0; i < this.count; i++) {
                this._lifeCircles[i] = -1;
            }
        };
        /**
        * @language zh_CN
        * @param animTime 动画当前时间（单位为ms）
        * @param delay  这一帧的时间跨度
        * @param geometry 几何对象
        * 顶点数据是否需要重新upload
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleSubEmitterNode.prototype.update = function (animTime, delay, geometry) {
            if (this._empty)
                return;
            //回收已经可以结束的子特效
            this.recycleParticle();
            //非循环的粒子生命周期达上限
            var loop = this._animationState.emitter.data.life.loop;
            var maxLife = this._animationState.loopTime + this._animationState.emitter.data.life.duration;
            if (!loop && (animTime * 0.001 >= maxLife)) {
                return;
            }
            //animTime += delay;
            var index = 0;
            var vertices = geometry.vertexCount / this.count;
            var particleIndex = 0;
            var positionOffsetIndex = this._animationState.emitter.positionNode.offsetIndex;
            var timeOffsetIndex = this._animationState.emitter.timeNode.offsetIndex;
            var particleTime = animTime * 0.001 - this._animationState.emitter.data.life.delay;
            //没有跟随对象，使用自己
            var followTarget = this._animationState.followTarget || this._animationState.emitter;
            for (var i = 0; i < this.count; ++i) {
                particleIndex = i * vertices;
                this.timeIndex = particleIndex * geometry.vertexAttLength + timeOffsetIndex;
                this.bornTime = geometry.verticesData[this.timeIndex + 0]; //出生时间
                this.life = geometry.verticesData[this.timeIndex + 1]; //单次生命周期时间
                //this.id = geometry.verticesData[this.timeIndex + 2];                //下标(i)
                var curCircleIndex = -1;
                if (particleTime >= this.bornTime) {
                    //粒子超时了，并且不需要继续循环
                    if (particleTime > (this.bornTime + this.life) && !loop)
                        continue;
                    curCircleIndex = Math.floor((particleTime - this.bornTime) / this._animationState.loopTime);
                    if (curCircleIndex != this._lifeCircles[i]) {
                        index = particleIndex * geometry.vertexAttLength + positionOffsetIndex;
                        this._lifeCircles[i] = curCircleIndex;
                        //position
                        this.position.x = geometry.verticesData[index + 0];
                        this.position.y = geometry.verticesData[index + 1];
                        this.position.z = geometry.verticesData[index + 2];
                        this.emitParticleAtPhase(this._birthPhase, this.position);
                    }
                }
            }
        };
        ParticleSubEmitterNode.prototype.emitParticleAtPhase = function (phase, pos) {
            var bakEmiter;
            var bakEmitters = phase.playing.getKeys();
            var playingArr;
            var recycleArr;
            var newParticle;
            for (var i = 0, count = bakEmitters.length; i < count; i++) {
                bakEmiter = bakEmitters[i];
                recycleArr = phase.recycle.getValueByKey(bakEmiter);
                playingArr = phase.playing.getValueByKey(bakEmiter);
                newParticle = recycleArr.shift();
                if (newParticle == null) {
                    newParticle = new egret3d.ParticleEmitter(bakEmiter.data, null, bakEmiter.material);
                }
                playingArr.push(newParticle);
                newParticle.play();
                pos.add(bakEmiter.globalPosition);
                newParticle.position = pos;
                this._parent.addChild(newParticle);
            }
        };
        ParticleSubEmitterNode.prototype.recycleParticle = function () {
            this.recycleParticleAtPhase(this._birthPhase);
            this.recycleParticleAtPhase(this._collisionPhase);
            this.recycleParticleAtPhase(this._deathPhase);
        };
        ParticleSubEmitterNode.prototype.recycleParticleAtPhase = function (phaseNode) {
            var bakEmiter;
            var playingArr;
            var recycleArr;
            var tempParticle;
            var j;
            var jCount;
            var bakEmitters = phaseNode.playing.getKeys();
            for (var i = 0, count = bakEmitters.length; i < count; i++) {
                bakEmiter = bakEmitters[i];
                playingArr = phaseNode.playing.getValueByKey(bakEmiter);
                recycleArr = phaseNode.recycle.getValueByKey(bakEmiter);
                for (j = playingArr.length - 1; j >= 0; j--) {
                    tempParticle = playingArr[j];
                    if (tempParticle.loopProgress > 1) {
                        playingArr.splice(j, 1);
                        tempParticle.stop();
                        this._parent.removeChild(tempParticle);
                        recycleArr.push(tempParticle);
                    }
                }
            }
        };
        /**
        * @private
        */
        ParticleSubEmitterNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
        };
        return ParticleSubEmitterNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleSubEmitterNode = ParticleSubEmitterNode;
    var ParticleSubEmitterNodePhase = (function () {
        function ParticleSubEmitterNodePhase(phase) {
            this.playing = new egret3d.DoubleArray();
            this.recycle = new egret3d.DoubleArray();
        }
        ParticleSubEmitterNodePhase.prototype.importSubEmitter = function (subEmitter) {
            if (this.playing.getKeys().indexOf(subEmitter) >= 0)
                return;
            this.playing.put(subEmitter, []);
            this.recycle.put(subEmitter, []);
        };
        return ParticleSubEmitterNodePhase;
    }());
    egret3d.ParticleSubEmitterNodePhase = ParticleSubEmitterNodePhase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.ParticleAnimationState
     * @classdesc
     * 粒子动画状态机
     * @version Egret 3.0
     * @platform Web,Native
     */
    var ParticleAnimationState = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @param name 粒子动画状态名
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ParticleAnimationState(name, emitter) {
            /**
            * @language zh_CN
            * 新增顶点个数总量
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.numberOfVertices = 0;
            /**
            * @language zh_CN
            * 新增顶点的长度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.vertexSizeInBytes = 0;
            /**
            * @language zh_CN
            * 动画状态机顶点着色器文件名列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.vertex_shaders = {};
            /**
            * @language zh_CN
            * 动画状态机片段着色器文件名列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.fragment_shaders = {};
            /**
            * @language zh_CN
            * 粒子走完一轮所需要的总时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.loopTime = 0;
            /**
            * @language zh_CN
            * 是否反转 1.0是反转 0.0是不反转
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.reverse = 1.0; //0.0/1.0
            /**
            * @language zh_CN
            * 跟随的目标
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.followTarget = null;
            this._particleProperty = new Float32Array(22);
            this._particleFsData = new Float32Array(3);
            this._emitter = emitter;
            this.name = name;
            this.animNodes = [];
            this.keyFrames = [];
        }
        Object.defineProperty(ParticleAnimationState.prototype, "emitter", {
            /**
           * @language zh_CN
           * 获取发射器
           * @return ParticleEmitter
           * @version Egret 3.0
           * @platform Web,Native
           */
            get: function () {
                return this._emitter;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 添加动画功能节点
        * 添加继承 animNodeBase 功能节点 例如粒子的 加速度功能节点，匀速功能节点
        * @param node 节点对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimationState.prototype.addNode = function (node) {
            node.state = this;
            this.animNodes.push(node);
        };
        /**
        * @language zh_CN
        * 移除动画功能节点
        * 删除指定的动画功能节点，但是不能动态删除，需要进行 功能重置
        * @param node 节点对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimationState.prototype.removeNode = function (node) {
            var index = this.animNodes.indexOf(node);
            if (index != -1)
                this.animNodes.splice(index, 1);
        };
        /**
       * @language zh_CN
       * 清空分配好的动画节点
       * @param node 节点对象
       * @version Egret 3.0
       * @platform Web,Native
       */
        ParticleAnimationState.prototype.clean = function () {
            this.animNodes.length = 0;
        };
        //private addShaderPhase(shaderPhase: { [shaderPhase: number]: string[] }) {
        //    var names: string[];
        //    var phase: any; 
        //    for (phase in shaderPhase) {
        //        names = <string[]>shaderPhase[phase];
        //        for (var i: number = 0; i < names.length; i++) {
        //            this.vertex_shaders[phase] = this.vertex_shaders[phase] || [];
        //            this.vertex_shaders[phase].push(names[i]);
        //        }
        //    }
        //}
        ParticleAnimationState.prototype.addShaderPhase = function (sourcePhase, targetPhase) {
            var names;
            var phase;
            for (phase in sourcePhase) {
                names = sourcePhase[phase];
                for (var i = 0; i < names.length; i++) {
                    targetPhase[phase] = targetPhase[phase] || [];
                    targetPhase[phase].push(names[i]);
                }
            }
        };
        /**
        * @language zh_CN
        * 计算节点
        * @private
        */
        ParticleAnimationState.prototype.calculate = function (geometry) {
            //this.vertex_shaders[ShaderPhaseType.local_vertex] = [];
            //this.fragment_shaders[ShaderPhaseType.diffuse_fragment] = [];
            for (var i = 0; i < this.animNodes.length; i++) {
                this.addShaderPhase(this.animNodes[i].vertex_ShaderName, this.vertex_shaders);
                this.addShaderPhase(this.animNodes[i].fragment_ShaderName, this.fragment_shaders);
                var offsetIndex = geometry.vertexAttLength;
                for (var j = 0; j < this.animNodes[i].attributes.length; ++j) {
                    if (this.animNodes[i].attributes[j].size > 0) {
                        this.animNodes[i].attributes[j].offsetIndex = offsetIndex;
                        geometry.vertexAttLength += this.animNodes[i].attributes[j].size;
                        geometry.vertexSizeInBytes += this.animNodes[i].attributes[j].size * 4;
                        geometry.subGeometrys[0].preAttList.push(this.animNodes[i].attributes[j]);
                    }
                    offsetIndex = geometry.vertexAttLength;
                }
            }
        };
        /**
        * @language zh_CN
        * @private
        */
        ParticleAnimationState.prototype.fill = function (geometry, maxParticle) {
            for (var i = 0; i < this.animNodes.length; i++) {
                this.animNodes[i].build(geometry, maxParticle);
            }
        };
        /**
        * @language zh_CN
        * @private
        */
        ParticleAnimationState.prototype.update = function (animTime, delay, geometry) {
            for (var i = 0; i < this.animNodes.length; i++) {
                this.animNodes[i].update(animTime, delay, geometry);
            }
        };
        /**
        * @language zh_CN
        * @private
        */
        ParticleAnimationState.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy, camera3D) {
            //var scaleData: Vector3D;
            var rotateData;
            var positionData;
            var data = this._emitter.data;
            if (data.followTarget && this._emitter.followTarget) {
                //scaleData = this._emitter.followTarget.globalScale;
                rotateData = this._emitter.followTarget.globalOrientation;
                positionData = this._emitter.followTarget.globalPosition;
            }
            else {
                //scaleData = this._emitter.globalScale;
                rotateData = this._emitter.globalOrientation;
                positionData = this._emitter.globalPosition;
            }
            //
            this._particleProperty[0] = animTime * 0.001;
            this._particleProperty[1] = data.life.loop ? 1 : 0;
            this._particleProperty[2] = data.followTarget ? 1 : 0;
            this._particleProperty[3] = 1; //scaleData.x;
            this._particleProperty[4] = 1; //scaleData.y;
            this._particleProperty[5] = 1; //scaleData.z;
            this._particleProperty[6] = rotateData.x;
            this._particleProperty[7] = rotateData.y;
            this._particleProperty[8] = rotateData.z;
            this._particleProperty[9] = rotateData.w;
            this._particleProperty[10] = positionData.x;
            this._particleProperty[11] = positionData.y;
            this._particleProperty[12] = positionData.z;
            this._particleProperty[13] = this.loopTime;
            this._particleProperty[14] = data.life.delay;
            this._particleProperty[15] = data.life.duration;
            this._particleProperty[16] = data.property.gravity;
            this._particleProperty[17] = (data.moveSpeed.velocityOver && data.moveSpeed.velocityOver.worldSpace) ? 1 : 0;
            this._particleProperty[18] = (data.moveSpeed.velocityForce && data.moveSpeed.velocityForce.worldSpace) ? 1 : 0;
            this._particleProperty[19] = data.property.cameraScale;
            this._particleProperty[20] = data.property.speedScale;
            this._particleProperty[21] = data.property.lengthScale;
            context3DProxy.uniform1fv(usage["uniform_particleState"].uniformIndex, this._particleProperty);
            this._particleFsData[0] = camera3D.far;
            this._particleFsData[1] = camera3D.near;
            this._particleFsData[2] = (this._emitter.material && this._emitter.material.materialData.blendMode == egret3d.BlendMode.ALPHA) ? 1 : 0;
            context3DProxy.uniform1fv(usage["uniform_particleFsData"].uniformIndex, this._particleFsData);
            for (var i = 0; i < this.animNodes.length; i++) {
                this.animNodes[i].activeState(time, animTime, delay, animDelay, usage, geometry, context3DProxy);
            }
        };
        return ParticleAnimationState;
    }());
    egret3d.ParticleAnimationState = ParticleAnimationState;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ParticleAnimation
    * @classdesc
    * 粒子动画
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleAnimation = (function (_super) {
        __extends(ParticleAnimation, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ParticleAnimation(emitter) {
            _super.call(this);
            /**
            * @language zh_CN
            * 总时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.animTime = 0;
            /**
            * @language zh_CN
            * 帧间隔时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.delay = 0;
            /**
            * @language zh_CN
            * 播放速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.speed = 1;
            /**
            * @language zh_CN
            * 是否在播放
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._play = false;
            this.animStates = [];
            this.particleAnimationState = new egret3d.ParticleAnimationState("particle", emitter);
            this.addAnimState(this.particleAnimationState);
        }
        /**
        * @private
        * @language zh_CN
        * 更新调度
        * @param time 总时间
        * @param delay 帧间隔时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimation.prototype.update = function (time, delay, geometry) {
            if (!this._play) {
                return;
            }
            this.delay = delay;
            this.animTime += this.delay;
            if (this.particleAnimationState)
                this.particleAnimationState.update(this.animTime, this.delay, geometry);
        };
        /**
       * @private
       * @language zh_CN
       * 将骨骼信息更新给GPU
       * @param time 当前时间
       * @param delay 当前帧时间
       * @param usage PassUsage
       * @param geometry 子几何信息
       * @param context3DProxy 上下文信息
       * @param modeltransform 模型矩阵
       * @param camera3D 相机
       * @version Egret 3.0
       * @platform Web,Native
       */
        ParticleAnimation.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (this.particleAnimationState) {
                this.particleAnimationState.activeState(time, this.animTime, delay, this.delay, usage, geometry, context3DProxy, camera3D);
            }
        };
        /**
        * @language zh_CN
        * 播放动画
        * @param animName 动画名
        * @param speed 播放速度
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimation.prototype.play = function (animName, speed, reset, prewarm) {
            if (speed === void 0) { speed = 1; }
            if (reset === void 0) { reset = true; }
            if (prewarm === void 0) { prewarm = true; }
            this._play = true;
            if (reset) {
                this.animTime = 0;
            }
            if (prewarm) {
                this.animTime = this.particleAnimationState.loopTime;
            }
            this.delay = 0;
        };
        /**
        * @language zh_CN
        * 停止播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimation.prototype.stop = function () {
            this._play = false;
        };
        /**
        * @language zh_CN
        * 是否正在播放中
        * @return 是否播放中
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimation.prototype.isPlay = function () {
            return this._play;
        };
        /**
        * @language zh_CN
        * 添加动画状态
        * @return 动画名称列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimation.prototype.addAnimState = function (animState) {
            var has = this.animStates.indexOf(animState);
            if (has == -1)
                this.animStates.push(animState);
        };
        /**
        * @language zh_CN
        * 上传动画状态
        * @return 动画名称列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimation.prototype.removeAnimState = function (animState) {
            var has = this.animStates.indexOf(animState);
            if (has != -1)
                this.animStates.splice(has, 1);
        };
        /**
        * @private
        * @language zh_CN
        * 获取动画列表
        * @return 动画名称列表
        */
        ParticleAnimation.prototype.getAnimList = function () {
            return [];
        };
        /**
        * @private
        * @language zh_CN
        * 获取动画节点
        * @return 动画节点数组
        */
        ParticleAnimation.prototype.getAnimNode = function () {
            return [];
        };
        /**
        * @private
        * @language zh_CN
        * 克隆新的ParticleAnimation对象;
        * @return 新的ParticleAnimation对象
        */
        ParticleAnimation.prototype.clone = function () {
            return null;
        };
        return ParticleAnimation;
    }(egret3d.EventDispatcher));
    egret3d.ParticleAnimation = ParticleAnimation;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * 粒子数据节点类型
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleDataNodeType) {
        //以下类型必须有
        ParticleDataNodeType[ParticleDataNodeType["Property"] = 0] = "Property";
        ParticleDataNodeType[ParticleDataNodeType["Emission"] = 1] = "Emission";
        ParticleDataNodeType[ParticleDataNodeType["Life"] = 2] = "Life";
        ParticleDataNodeType[ParticleDataNodeType["Shape"] = 3] = "Shape";
        ParticleDataNodeType[ParticleDataNodeType["RotationBirth"] = 4] = "RotationBirth";
        ParticleDataNodeType[ParticleDataNodeType["ScaleBirth"] = 5] = "ScaleBirth";
        ParticleDataNodeType[ParticleDataNodeType["Geometry"] = 6] = "Geometry";
        ParticleDataNodeType[ParticleDataNodeType["MoveSpeed"] = 7] = "MoveSpeed";
        //其他挂接节点
        ParticleDataNodeType[ParticleDataNodeType["FollowTarget"] = 8] = "FollowTarget";
        ParticleDataNodeType[ParticleDataNodeType["ScaleBezier"] = 9] = "ScaleBezier";
        ParticleDataNodeType[ParticleDataNodeType["RotationSpeed"] = 10] = "RotationSpeed";
        ParticleDataNodeType[ParticleDataNodeType["ColorOffset"] = 11] = "ColorOffset";
        ParticleDataNodeType[ParticleDataNodeType["TextureSheet"] = 12] = "TextureSheet";
    })(egret3d.ParticleDataNodeType || (egret3d.ParticleDataNodeType = {}));
    var ParticleDataNodeType = egret3d.ParticleDataNodeType;
    /**
    * @language zh_CN
    * 子发射器阶段
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleDataSubEmitterPhase) {
        ParticleDataSubEmitterPhase[ParticleDataSubEmitterPhase["BIRTH"] = 0] = "BIRTH";
        ParticleDataSubEmitterPhase[ParticleDataSubEmitterPhase["COLLISION"] = 1] = "COLLISION";
        ParticleDataSubEmitterPhase[ParticleDataSubEmitterPhase["DEATH"] = 2] = "DEATH";
    })(egret3d.ParticleDataSubEmitterPhase || (egret3d.ParticleDataSubEmitterPhase = {}));
    var ParticleDataSubEmitterPhase = egret3d.ParticleDataSubEmitterPhase;
    /**
    * @language zh_CN
    * 粒子数据类型
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleValueType) {
        ParticleValueType[ParticleValueType["Const"] = 0] = "Const";
        ParticleValueType[ParticleValueType["RandomConst"] = 1] = "RandomConst";
        ParticleValueType[ParticleValueType["OneBezier"] = 2] = "OneBezier";
        ParticleValueType[ParticleValueType["TwoBezier"] = 3] = "TwoBezier";
    })(egret3d.ParticleValueType || (egret3d.ParticleValueType = {}));
    var ParticleValueType = egret3d.ParticleValueType;
    /**
    * @language zh_CN
    * 粒子的几何形状
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleGeometryType) {
        ParticleGeometryType[ParticleGeometryType["External"] = 0] = "External";
        ParticleGeometryType[ParticleGeometryType["Plane"] = 1] = "Plane";
        ParticleGeometryType[ParticleGeometryType["Cube"] = 2] = "Cube";
        ParticleGeometryType[ParticleGeometryType["Sphere"] = 3] = "Sphere";
    })(egret3d.ParticleGeometryType || (egret3d.ParticleGeometryType = {}));
    var ParticleGeometryType = egret3d.ParticleGeometryType;
    /**
    * @language zh_CN
    * 粒子的几何形状
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleRenderModeType) {
        ParticleRenderModeType[ParticleRenderModeType["Billboard"] = 0] = "Billboard";
        ParticleRenderModeType[ParticleRenderModeType["StretchedBillboard"] = 1] = "StretchedBillboard";
        ParticleRenderModeType[ParticleRenderModeType["HorizontalBillboard"] = 2] = "HorizontalBillboard";
        ParticleRenderModeType[ParticleRenderModeType["VerticalBillboard"] = 3] = "VerticalBillboard";
        ParticleRenderModeType[ParticleRenderModeType["Mesh"] = 4] = "Mesh";
    })(egret3d.ParticleRenderModeType || (egret3d.ParticleRenderModeType = {}));
    var ParticleRenderModeType = egret3d.ParticleRenderModeType;
    /**
    * @language zh_CN
    * 粒子出生颜色
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleBirthColorType) {
        ParticleBirthColorType[ParticleBirthColorType["Const"] = 0] = "Const";
        ParticleBirthColorType[ParticleBirthColorType["RandomConst"] = 1] = "RandomConst";
        ParticleBirthColorType[ParticleBirthColorType["OneGradients"] = 2] = "OneGradients";
        ParticleBirthColorType[ParticleBirthColorType["TwoGradients"] = 3] = "TwoGradients";
    })(egret3d.ParticleBirthColorType || (egret3d.ParticleBirthColorType = {}));
    var ParticleBirthColorType = egret3d.ParticleBirthColorType;
    /**
    * @language zh_CN
    * 发射器形状
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleDataShapeType) {
        ParticleDataShapeType[ParticleDataShapeType["Point"] = 0] = "Point";
        ParticleDataShapeType[ParticleDataShapeType["Cube"] = 1] = "Cube";
        ParticleDataShapeType[ParticleDataShapeType["Sphere"] = 2] = "Sphere";
        ParticleDataShapeType[ParticleDataShapeType["HemiSphere"] = 3] = "HemiSphere";
        ParticleDataShapeType[ParticleDataShapeType["Cone"] = 4] = "Cone";
    })(egret3d.ParticleDataShapeType || (egret3d.ParticleDataShapeType = {}));
    var ParticleDataShapeType = egret3d.ParticleDataShapeType;
    /**
    * @language zh_CN
    * 圆筒发射器类型
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleConeShapeType) {
        ParticleConeShapeType[ParticleConeShapeType["Base"] = 0] = "Base";
        ParticleConeShapeType[ParticleConeShapeType["BaseShell"] = 1] = "BaseShell";
        ParticleConeShapeType[ParticleConeShapeType["Volume"] = 2] = "Volume";
        ParticleConeShapeType[ParticleConeShapeType["VolumeShell"] = 3] = "VolumeShell";
    })(egret3d.ParticleConeShapeType || (egret3d.ParticleConeShapeType = {}));
    var ParticleConeShapeType = egret3d.ParticleConeShapeType;
    /**
     * @private
     * @class egret3d.ParticleData
     */
    var ParticleData = (function () {
        /**
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ParticleData() {
            this.property = new ParticleDataProperty();
            this.emission = new ParticleDataEmission();
            this.life = new ParticleDataLife();
            this.shape = new ParticleDataShape();
            this.rotationBirth = new ParticleDataRotationBirth();
            this.scaleBirth = new ParticleDataScaleBirth();
            this.geometry = new ParticleDataGeometry();
            this.moveSpeed = new ParticleDataMoveSpeed();
        }
        ParticleData.prototype.validate = function () {
            this.property.validate();
            this.emission.validate();
            this.life.validate();
            this.shape.validate();
            this.rotationBirth.validate();
            this.scaleBirth.validate();
            this.geometry.validate();
            this.moveSpeed.validate();
            if (this.scaleBezier) {
                this.scaleBezier.validate();
            }
            if (this.rotationSpeed) {
                this.rotationSpeed.validate();
            }
            if (this.colorOffset) {
                this.colorOffset.validate();
            }
            if (this.followTarget) {
                this.followTarget.validate();
            }
            if (this.textureSheet) {
                this.textureSheet.validate();
            }
        };
        ParticleData.prototype.scaleBy = function (value) {
            //
            this.property.bounds.scaleBy(value);
            this.property.gravity *= value;
            this.property.position.scaleBy(value);
            //
            this.shape.cubeW *= value;
            this.shape.cubeH *= value;
            this.shape.cubeD *= value;
            this.shape.sphereRadius *= value;
            this.shape.hemiSphereRadius *= value;
            this.shape.coneHeight *= value;
            this.shape.coneRadiusBottom *= value;
            this.shape.coneRadiusTop *= value;
            //
            this.geometry.planeW *= value;
            this.geometry.planeH *= value;
            this.geometry.cubeW *= value;
            this.geometry.cubeH *= value;
            this.geometry.cubeD *= value;
            this.geometry.sphereRadius *= value;
            //
            this.moveSpeed.max *= value;
            this.moveSpeed.min *= value;
            if (this.moveSpeed.bezier1) {
                this.moveSpeed.bezier1.scaleBy(value);
            }
            if (this.moveSpeed.bezier2) {
                this.moveSpeed.bezier2.scaleBy(value);
            }
            if (this.moveSpeed.velocityOver) {
                this.moveSpeed.velocityOver.scaleBy(value);
            }
            if (this.moveSpeed.velocityLimit) {
                this.moveSpeed.velocityLimit.scaleBy(value);
            }
            if (this.moveSpeed.velocityForce) {
                this.moveSpeed.velocityForce.scaleBy(value);
            }
            //
        };
        ParticleData.SCALE_VALUE = 1;
        return ParticleData;
    }());
    egret3d.ParticleData = ParticleData;
    var ParticleDataNode = (function () {
        function ParticleDataNode(node) {
            this._nodeType = node;
        }
        Object.defineProperty(ParticleDataNode.prototype, "nodeType", {
            get: function () {
                return this._nodeType;
            },
            enumerable: true,
            configurable: true
        });
        return ParticleDataNode;
    }());
    egret3d.ParticleDataNode = ParticleDataNode;
    /**
    * @language zh_CN
    * 粒子的基础属性
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataProperty = (function (_super) {
        __extends(ParticleDataProperty, _super);
        function ParticleDataProperty() {
            _super.call(this, ParticleDataNodeType.Property);
            this.particleCount = 10;
            this.bounds = new egret3d.Vector3D(10, 10, 10);
            //初始颜色
            this.colorType = ParticleBirthColorType.Const;
            this.colorConst1 = new egret3d.Color(255, 255, 255, 255);
            this.colorConst2 = new egret3d.Color(255, 255, 255, 255);
            //重力
            this.gravity = 0;
            //是否预热
            this.prewarm = false;
            this.rotation = new egret3d.Vector3D(0, 0, 0, 1);
            this.scale = new egret3d.Vector3D(1, 1, 1, 1);
            this.position = new egret3d.Vector3D(0, 0, 0, 1);
            //render mode
            this.renderMode = ParticleRenderModeType.Billboard;
            this.cameraScale = 0.0;
            this.speedScale = 0.0;
            this.lengthScale = 1.0;
        }
        ParticleDataProperty.prototype.validate = function () {
            if (this.bounds == null) {
                this.bounds = new egret3d.Vector3D(10, 10, 10);
            }
            if (this.bounds.x < 0) {
                this.bounds.x = 1;
            }
            if (this.bounds.y < 0) {
                this.bounds.y = 1;
            }
            if (this.bounds.z < 0) {
                this.bounds.z = 1;
            }
            if (this.particleCount < 0) {
                this.particleCount = 10;
            }
            if (this.colorConst1 == null) {
                this.colorConst1 = new egret3d.Color(255, 255, 255, 255);
            }
            if (this.colorConst2 == null) {
                this.colorConst2 = new egret3d.Color(255, 255, 255, 255);
            }
            if (this.colorType == ParticleBirthColorType.OneGradients || this.colorType == ParticleBirthColorType.TwoGradients) {
                if (this.colorGradients1 == null) {
                    this.colorGradients1 = new egret3d.ColorGradients();
                }
            }
            if (this.colorType == ParticleBirthColorType.TwoGradients) {
                if (this.colorGradients2 == null) {
                    this.colorGradients2 = new egret3d.ColorGradients();
                }
            }
            if (this.rotation == null) {
                this.rotation = new egret3d.Vector3D(0, 0, 0, 1);
            }
            if (this.scale == null) {
                this.scale = new egret3d.Vector3D(1, 1, 1, 1);
            }
            if (this.position == null) {
                this.rotation = new egret3d.Vector3D(0, 0, 0, 1);
            }
        };
        return ParticleDataProperty;
    }(ParticleDataNode));
    egret3d.ParticleDataProperty = ParticleDataProperty;
    var ParticleDataEmission = (function (_super) {
        __extends(ParticleDataEmission, _super);
        function ParticleDataEmission() {
            _super.call(this, ParticleDataNodeType.Emission);
            this.rate = 10;
            this.type = ParticleValueType.Const;
            this.bezier = new egret3d.BezierData();
        }
        ParticleDataEmission.prototype.validate = function () {
            if (this.rate < 0) {
                this.rate = 0.00001;
            }
            if (this.type == ParticleValueType.OneBezier) {
                if (this.bezier == null) {
                    this.bezier = new egret3d.BezierData();
                }
                this.bezier.validate();
            }
        };
        return ParticleDataEmission;
    }(ParticleDataNode));
    egret3d.ParticleDataEmission = ParticleDataEmission;
    var ParticleDataLife = (function (_super) {
        __extends(ParticleDataLife, _super);
        function ParticleDataLife() {
            _super.call(this, ParticleDataNodeType.Life);
            this.type = ParticleValueType.Const;
            this.max = 0;
            this.min = 0;
            this.duration = 5;
            this.delay = 0;
            this.loop = true;
        }
        ParticleDataLife.prototype.validate = function () {
            //life
            if (this.type == ParticleValueType.Const) {
                this.min = this.max;
            }
            if (this.type == ParticleValueType.RandomConst) {
                if (this.min > this.max) {
                    this.min = this.max;
                }
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
            //delay
            if (this.delay < 0) {
                this.delay = 0;
            }
            //duration
            if (this.duration < 0) {
                this.duration = 5;
            }
        };
        return ParticleDataLife;
    }(ParticleDataNode));
    egret3d.ParticleDataLife = ParticleDataLife;
    var ParticleDataShape = (function (_super) {
        __extends(ParticleDataShape, _super);
        function ParticleDataShape() {
            _super.call(this, ParticleDataNodeType.Shape);
            //粒子分布类型
            this.type = ParticleDataShapeType.Cube;
            this.randomDirection = false;
            //正方体
            this.cubeW = 0;
            this.cubeH = 0;
            this.cubeD = 0;
            //球型
            this.sphereRadius = 10;
            //半球
            this.hemiSphereRadius = 10;
            //圆筒状
            this.coneHeight = 10;
            this.coneRadiusBottom = 2;
            this.coneRadiusTop = 4;
            this.coneType = ParticleConeShapeType.Volume;
        }
        ParticleDataShape.prototype.validate = function () {
            if (this.type == ParticleDataShapeType.Cube) {
                if (this.cubeW < 0) {
                    this.cubeW = 0;
                }
                if (this.cubeH < 0) {
                    this.cubeH = 0;
                }
                if (this.cubeD < 0) {
                    this.cubeD = 0;
                }
            }
            else if (this.type == ParticleDataShapeType.Sphere) {
                if (this.sphereRadius < 0) {
                    this.sphereRadius = 10;
                }
            }
        };
        return ParticleDataShape;
    }(ParticleDataNode));
    egret3d.ParticleDataShape = ParticleDataShape;
    var ParticleDataRotationBirth = (function (_super) {
        __extends(ParticleDataRotationBirth, _super);
        function ParticleDataRotationBirth() {
            _super.call(this, ParticleDataNodeType.RotationBirth);
            //初始角度
            this.type = ParticleValueType.Const;
            this.max = 0;
            this.min = 0;
        }
        ParticleDataRotationBirth.prototype.validate = function () {
            if (this.type == ParticleValueType.Const) {
                this.min = this.max;
            }
            if (this.type == ParticleValueType.RandomConst) {
                if (this.min > this.max) {
                    this.min = this.max;
                }
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
        };
        return ParticleDataRotationBirth;
    }(ParticleDataNode));
    egret3d.ParticleDataRotationBirth = ParticleDataRotationBirth;
    var ParticleDataScaleBirth = (function (_super) {
        __extends(ParticleDataScaleBirth, _super);
        function ParticleDataScaleBirth() {
            _super.call(this, ParticleDataNodeType.ScaleBirth);
            //初始缩放值
            this.type = ParticleValueType.Const;
            this.max = 0;
            this.min = 0;
        }
        ParticleDataScaleBirth.prototype.validate = function () {
            if (this.type == ParticleValueType.Const) {
                this.min = this.max;
            }
            if (this.type == ParticleValueType.RandomConst) {
                if (this.min > this.max) {
                    this.min = this.max;
                }
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
        };
        return ParticleDataScaleBirth;
    }(ParticleDataNode));
    egret3d.ParticleDataScaleBirth = ParticleDataScaleBirth;
    var ParticleDataGeometry = (function (_super) {
        __extends(ParticleDataGeometry, _super);
        function ParticleDataGeometry() {
            _super.call(this, ParticleDataNodeType.Geometry);
            //粒子模型
            this.type = ParticleGeometryType.Plane;
            this.planeW = 10;
            this.planeH = 10;
            this.cubeW = 10;
            this.cubeH = 10;
            this.cubeD = 10;
            this.sphereRadius = 10;
            this.sphereSegW = 6;
            this.sphereSegH = 6;
        }
        ParticleDataGeometry.prototype.validate = function () {
            if (this.type == ParticleGeometryType.External)
                return;
            if (this.type == ParticleGeometryType.Plane) {
                if (this.planeW < 0) {
                    this.planeW = 10;
                }
                if (this.planeH < 0) {
                    this.planeH = 10;
                }
            }
            else if (this.type == ParticleGeometryType.Cube) {
                if (this.cubeW < 0) {
                    this.cubeW = 10;
                }
                if (this.cubeH < 0) {
                    this.cubeH = 10;
                }
                if (this.cubeD < 0) {
                    this.cubeD = 10;
                }
            }
            else if (this.type == ParticleGeometryType.Sphere) {
                if (this.sphereRadius < 0) {
                    this.sphereRadius = 10;
                }
                if (this.sphereSegW < 0) {
                    this.sphereSegW = 4;
                }
                if (this.sphereSegH < 0) {
                    this.sphereSegH = 4;
                }
            }
        };
        return ParticleDataGeometry;
    }(ParticleDataNode));
    egret3d.ParticleDataGeometry = ParticleDataGeometry;
    var ParticleDataMoveSpeed = (function (_super) {
        __extends(ParticleDataMoveSpeed, _super);
        function ParticleDataMoveSpeed() {
            _super.call(this, ParticleDataNodeType.MoveSpeed);
            //初始速度
            this.type = ParticleValueType.Const;
            this.max = 0;
            this.min = 0;
        }
        ParticleDataMoveSpeed.prototype.validate = function () {
            if (this.velocityOver) {
                this.velocityOver.validate();
            }
            if (this.velocityLimit) {
                this.velocityLimit.validate();
            }
            if (this.velocityForce) {
                this.velocityForce.validate();
            }
            if (this.type == ParticleValueType.Const) {
                this.min = this.max;
            }
            if (this.type == ParticleValueType.RandomConst) {
                if (this.min > this.max) {
                    this.min = this.max;
                }
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
        };
        return ParticleDataMoveSpeed;
    }(ParticleDataNode));
    egret3d.ParticleDataMoveSpeed = ParticleDataMoveSpeed;
    var VelocityLimitLifeTimeData = (function () {
        function VelocityLimitLifeTimeData() {
            this.type = ParticleValueType.Const;
            this.max = 0;
            this.min = 0;
            this.bezier1 = new egret3d.BezierData();
            this.bezier2 = new egret3d.BezierData();
        }
        VelocityLimitLifeTimeData.prototype.validate = function () {
            if (this.max < 0) {
                this.max = 0;
            }
            if (this.min > this.max) {
                this.min = this.max;
            }
            if (this.type == ParticleValueType.Const) {
                this.min = this.max;
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
        };
        VelocityLimitLifeTimeData.prototype.scaleBy = function (value) {
            this.min *= value;
            this.max *= value;
            if (this.bezier1) {
                this.bezier1.scaleBy(value);
            }
            if (this.bezier2) {
                this.bezier2.scaleBy(value);
            }
        };
        return VelocityLimitLifeTimeData;
    }());
    egret3d.VelocityLimitLifeTimeData = VelocityLimitLifeTimeData;
    var VelocityOverLifeTimeData = (function () {
        function VelocityOverLifeTimeData() {
            this.type = ParticleValueType.Const;
            this.max = new egret3d.Vector3D();
            this.min = new egret3d.Vector3D();
            this.worldSpace = false;
            this.xBezier1 = new egret3d.BezierData();
            this.yBezier1 = new egret3d.BezierData();
            this.zBezier1 = new egret3d.BezierData();
            this.xBezier2 = new egret3d.BezierData();
            this.yBezier2 = new egret3d.BezierData();
            this.zBezier2 = new egret3d.BezierData();
        }
        VelocityOverLifeTimeData.prototype.validate = function () {
            if (this.max == null) {
                this.max = new egret3d.Vector3D();
            }
            if (this.min == null) {
                this.min = this.max.clone();
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.xBezier1 == null) {
                    this.xBezier1 = new egret3d.BezierData();
                }
                if (this.yBezier1 == null) {
                    this.yBezier1 = new egret3d.BezierData();
                }
                if (this.zBezier1 == null) {
                    this.zBezier1 = new egret3d.BezierData();
                }
                this.xBezier1.validate();
                this.yBezier1.validate();
                this.zBezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.xBezier2 == null) {
                    this.xBezier2 = new egret3d.BezierData();
                }
                if (this.yBezier2 == null) {
                    this.yBezier2 = new egret3d.BezierData();
                }
                if (this.zBezier2 == null) {
                    this.zBezier2 = new egret3d.BezierData();
                }
                this.xBezier2.validate();
                this.yBezier2.validate();
                this.zBezier2.validate();
            }
        };
        VelocityOverLifeTimeData.prototype.scaleBy = function (value) {
            this.min.scaleBy(value);
            this.max.scaleBy(value);
            if (this.xBezier1) {
                this.xBezier1.scaleBy(value);
            }
            if (this.yBezier1) {
                this.yBezier1.scaleBy(value);
            }
            if (this.zBezier1) {
                this.zBezier1.scaleBy(value);
            }
            if (this.xBezier2) {
                this.xBezier2.scaleBy(value);
            }
            if (this.yBezier2) {
                this.yBezier2.scaleBy(value);
            }
            if (this.zBezier2) {
                this.zBezier2.scaleBy(value);
            }
        };
        return VelocityOverLifeTimeData;
    }());
    egret3d.VelocityOverLifeTimeData = VelocityOverLifeTimeData;
    var VelocityForceLifeTimeData = (function () {
        function VelocityForceLifeTimeData() {
            this.type = ParticleValueType.Const;
            this.max = new egret3d.Vector3D();
            this.min = new egret3d.Vector3D();
            this.worldSpace = false;
            this.xBezier1 = new egret3d.BezierData();
            this.yBezier1 = new egret3d.BezierData();
            this.zBezier1 = new egret3d.BezierData();
            this.xBezier2 = new egret3d.BezierData();
            this.yBezier2 = new egret3d.BezierData();
            this.zBezier2 = new egret3d.BezierData();
        }
        VelocityForceLifeTimeData.prototype.validate = function () {
            if (this.max == null) {
                this.max = new egret3d.Vector3D();
            }
            if (this.min == null) {
                this.min = this.max.clone();
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.xBezier1 == null) {
                    this.xBezier1 = new egret3d.BezierData();
                }
                if (this.yBezier1 == null) {
                    this.yBezier1 = new egret3d.BezierData();
                }
                if (this.zBezier1 == null) {
                    this.zBezier1 = new egret3d.BezierData();
                }
                this.xBezier1.validate();
                this.yBezier1.validate();
                this.zBezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.xBezier2 == null) {
                    this.xBezier2 = new egret3d.BezierData();
                }
                if (this.yBezier2 == null) {
                    this.yBezier2 = new egret3d.BezierData();
                }
                if (this.zBezier2 == null) {
                    this.zBezier2 = new egret3d.BezierData();
                }
                this.xBezier2.validate();
                this.yBezier2.validate();
                this.zBezier2.validate();
            }
        };
        VelocityForceLifeTimeData.prototype.scaleBy = function (value) {
            this.min.scaleBy(value);
            this.max.scaleBy(value);
            if (this.xBezier1) {
                this.xBezier1.scaleBy(value);
            }
            if (this.yBezier1) {
                this.yBezier1.scaleBy(value);
            }
            if (this.zBezier1) {
                this.zBezier1.scaleBy(value);
            }
            if (this.xBezier2) {
                this.xBezier2.scaleBy(value);
            }
            if (this.yBezier2) {
                this.yBezier2.scaleBy(value);
            }
            if (this.zBezier2) {
                this.zBezier2.scaleBy(value);
            }
        };
        return VelocityForceLifeTimeData;
    }());
    egret3d.VelocityForceLifeTimeData = VelocityForceLifeTimeData;
    //export class ParticleDataAcceleration extends ParticleDataNode {
    //    //加速度
    //    public max: Vector3D = new Vector3D();
    //    public min: Vector3D = new Vector3D();
    //    public accelerationWorld: boolean = false;
    //    constructor() {
    //        super(ParticleDataNodeType.Acceleration);
    //    }
    //    public validate(): void {
    //        if (this.max == null) {
    //            this.max = new Vector3D();
    //        }
    //        if (this.min == null) {
    //            this.min = new Vector3D();
    //        }
    //        if (this.min.x > this.max.x) {
    //            this.min.x = this.max.x;
    //        }
    //        if (this.min.y > this.max.y) {
    //            this.min.y = this.max.y;
    //        }
    //        if (this.min.z > this.max.z) {
    //            this.min.z = this.max.z;
    //        }
    //    }
    //}
    var ParticleDataScaleBezier = (function (_super) {
        __extends(ParticleDataScaleBezier, _super);
        function ParticleDataScaleBezier() {
            _super.call(this, ParticleDataNodeType.ScaleBezier);
            //粒子缩放贝塞尔曲线
            this.data = new egret3d.BezierData();
        }
        ParticleDataScaleBezier.prototype.validate = function () {
            if (this.data == null) {
                this.data = new egret3d.BezierData();
            }
            this.data.validate();
        };
        return ParticleDataScaleBezier;
    }(ParticleDataNode));
    egret3d.ParticleDataScaleBezier = ParticleDataScaleBezier;
    var ParticleDataRotationSpeed = (function (_super) {
        __extends(ParticleDataRotationSpeed, _super);
        function ParticleDataRotationSpeed() {
            _super.call(this, ParticleDataNodeType.RotationSpeed);
            //角速度
            this.max = new egret3d.Vector3D();
            this.min = new egret3d.Vector3D();
            this.type = ParticleValueType.Const;
            this.bezier1 = new egret3d.BezierData();
            this.bezier2 = new egret3d.BezierData();
        }
        ParticleDataRotationSpeed.prototype.validate = function () {
            if (this.max == null) {
                this.max = new egret3d.Vector3D();
            }
            if (this.min == null) {
                this.min = this.max.clone();
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
        };
        return ParticleDataRotationSpeed;
    }(ParticleDataNode));
    egret3d.ParticleDataRotationSpeed = ParticleDataRotationSpeed;
    var ParticleDataColorOffset = (function (_super) {
        __extends(ParticleDataColorOffset, _super);
        function ParticleDataColorOffset() {
            _super.call(this, ParticleDataNodeType.ColorOffset);
            //粒子颜色变化贝塞尔曲线
            this.data = new egret3d.ColorGradients();
        }
        ParticleDataColorOffset.prototype.validate = function () {
            if (this.data.colors == null) {
                this.data.colors = [];
            }
            if (this.data.times == null) {
                this.data.times = [];
            }
        };
        return ParticleDataColorOffset;
    }(ParticleDataNode));
    egret3d.ParticleDataColorOffset = ParticleDataColorOffset;
    var ParticleDataFollowTarget = (function (_super) {
        __extends(ParticleDataFollowTarget, _super);
        function ParticleDataFollowTarget() {
            _super.call(this, ParticleDataNodeType.FollowTarget);
            //跟随
            this.followRotation = true;
            this.followScale = true;
        }
        ParticleDataFollowTarget.prototype.validate = function () {
        };
        return ParticleDataFollowTarget;
    }(ParticleDataNode));
    egret3d.ParticleDataFollowTarget = ParticleDataFollowTarget;
    var ParticleDataTextureSheet = (function (_super) {
        __extends(ParticleDataTextureSheet, _super);
        /**
        * @language zh_CN
        * constructor
        */
        function ParticleDataTextureSheet() {
            _super.call(this, ParticleDataNodeType.TextureSheet);
            /**
            * @language zh_CN
            * tileX 序列帧划分为多少列
            */
            this.tileX = 1;
            /**
            * @language zh_CN
            * tileY 序列帧划分为多少行
            */
            this.tileY = 1;
            /**
            * @language zh_CN
            * whole 范围是否为全部帧
            */
            this.whole = true;
            /**
            * @language zh_CN
            * frameType 帧控制类型
            */
            this.frameType = ParticleValueType.Const;
            /**
            * @language zh_CN
            * randomRow 是否随机单行
            */
            this.randomRow = false;
            /**
            * @language zh_CN
            * row 指定锁定第几行播放
            */
            this.row = 0;
            /**
            * @language zh_CN
            * min 常量范围最小值
            */
            this.min = 0;
            /**
            * @language zh_CN
            * max 常量范围最大值
            */
            this.max = 0;
            /**
            * @language zh_CN
            * circles 循环播放次数，最小值为1
            */
            this.circles = 1;
            /**
            * @language zh_CN
            * bezier1 第一条贝塞尔曲线
            */
            this.bezier1 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * bezier2 第二条贝塞尔曲线
            */
            this.bezier2 = new egret3d.BezierData();
        }
        ParticleDataTextureSheet.prototype.validate = function () {
            //
            if (this.tileX < 0) {
                this.tileX = 1;
            }
            this.tileX = Math.floor(this.tileX);
            //
            if (this.tileY < 0) {
                this.tileY = 1;
            }
            this.tileY = Math.floor(this.tileY);
            //
            if (this.max < 0) {
                this.max = 0;
            }
            if (this.min > this.max) {
                this.min = this.max;
            }
            //
            if (this.frameType == ParticleValueType.OneBezier || this.frameType == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            //
            if (this.frameType == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
            //
            if (this.circles < 1) {
                this.circles = 1;
            }
        };
        return ParticleDataTextureSheet;
    }(ParticleDataNode));
    egret3d.ParticleDataTextureSheet = ParticleDataTextureSheet;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ParticleXmlParser
     * @classdesc
     * 用 ParticleXmlParser 解析粒子文件
     */
    var ParticleXmlParser = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function ParticleXmlParser() {
            /**
             * @language zh_CN
             * 粒子的版本号
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.version = 1;
        }
        /**
         * @language zh_CN
         * @param xml 粒子特效的数据解析
         * @returns ParticleData
         */
        ParticleXmlParser.prototype.parse = function (text) {
            this._particleData = new egret3d.ParticleData();
            this._xml = egret3d.XMLParser.parse(text);
            this.version = Number(this.getNode(this._xml, "version").textContent);
            //property
            var propertyNode = this.getNode(this._xml, "property");
            this.parseProperty(propertyNode);
            //emission
            var emissionNode = this.getNode(this._xml, "emission");
            this.parseEmission(emissionNode);
            //life
            var life = this.getNode(this._xml, "life");
            this.parseLife(life);
            //shape
            var shape = this.getNode(this._xml, "shape");
            this.parseShape(shape);
            //rotationBirth
            var rotationBirth = this.getNode(this._xml, "rotationBirth");
            this.parseRotationBirth(rotationBirth);
            //scaleBirth
            var scaleBirth = this.getNode(this._xml, "scaleBirth");
            this.parseScaleBirth(scaleBirth);
            //geometry
            var geometry = this.getNode(this._xml, "geometry");
            this.parseGeometry(geometry);
            //moveSpeed
            var moveSpeed = this.getNode(this._xml, "moveSpeed");
            this.parseMoveSpeed(moveSpeed);
            //followTarget
            var followTarget = this.getNode(this._xml, "followTarget");
            this.parseFollowTarget(followTarget);
            //parseBezierNode
            var scaleBezier = this.getNode(this._xml, "scaleBezier");
            this.parseScaleBeizer(scaleBezier);
            //rotationSpeed
            var rotationSpeed = this.getNode(this._xml, "rotationSpeed");
            this.parseRotationSpeed(rotationSpeed);
            //colorOffset
            var colorOffset = this.getNode(this._xml, "colorOffset");
            this.parseColorOffset(colorOffset);
            //material
            var material = this.getNode(this._xml, "mat");
            //textureSheet
            var textureSheet = this.getNode(this._xml, "textureSheet");
            this.parseTextureSheet(textureSheet);
            this._particleData.validate();
            this._particleData.scaleBy(egret3d.ParticleData.SCALE_VALUE);
            return this._particleData;
        };
        /**
         * @private
         * 解析基础属性
         */
        ParticleXmlParser.prototype.parseProperty = function (node) {
            var property = this._particleData.property;
            property.particleCount = Number(this.getNode(node, "particleCount").textContent);
            property.prewarm = this.getNode(node, "prewarm").textContent == "true";
            var bounds = this.getNode(node, "bounds");
            property.bounds = this.parseVector3D(bounds, property.bounds);
            //color
            property.colorType = egret3d.ParticleBirthColorType[this.getNode(node, "colorType").textContent];
            var colorConst1 = this.getNode(node, "colorConst1");
            var colorConst2 = this.getNode(node, "colorConst2");
            var gradients1 = this.getNode(node, "colorGradients1");
            var gradients2 = this.getNode(node, "colorGradients2");
            this.parseColorProperty(property, colorConst1, colorConst2, gradients1, gradients2);
            //gravity
            property.gravity = Number(this.getNode(node, "gravity").textContent);
            //transform
            var transform = this.getNode(node, "transform");
            var rotation = this.getNode(transform, "rotation");
            var scale = this.getNode(transform, "scale");
            var position = this.getNode(transform, "position");
            property.rotation = this.parseVector3D(rotation, property.rotation);
            property.scale = this.parseVector3D(scale, property.scale);
            property.position = this.parseVector3D(position, property.position);
            //render
            var render = this.getNode(node, "render");
            var renderMode = this.getNode(render, "renderMode");
            if (renderMode) {
                property.renderMode = egret3d.ParticleRenderModeType[renderMode.textContent];
            }
            var lengthScale = this.getNode(render, "lengthScale");
            if (lengthScale) {
                property.lengthScale = Number(lengthScale.textContent);
            }
            var cameraScale = this.getNode(render, "cameraScale");
            if (cameraScale) {
                property.cameraScale = Number(cameraScale.textContent);
            }
            var speedScale = this.getNode(render, "speedScale");
            if (speedScale) {
                property.speedScale = Number(speedScale.textContent);
            }
        };
        /**
         * @private
         * 解析颜色属性
         */
        ParticleXmlParser.prototype.parseColorProperty = function (property, c1, c2, cg1, cg2) {
            if (c1) {
                property.colorConst1 = egret3d.Color.createColor(Number(c1.textContent));
            }
            if (c2) {
                property.colorConst2 = egret3d.Color.createColor(Number(c2.textContent));
            }
            if (cg1) {
                var itemList = this.getNodeList(cg1, "item");
                property.colorGradients1 = this.parseGradientsColor(itemList, property.colorGradients1);
            }
            if (cg2) {
                var itemList = this.getNodeList(cg2, "item");
                property.colorGradients2 = this.parseGradientsColor(itemList, property.colorGradients2);
            }
        };
        /**
         * @private
         * 解析发射器数据
         */
        ParticleXmlParser.prototype.parseEmission = function (node) {
            var emission = this._particleData.emission;
            emission.type = egret3d.ParticleValueType[this.getNode(node, "type").textContent];
            emission.rate = Number(this.getNode(node, "rate").textContent);
            var bursts = this.getNode(node, "bursts");
            var item;
            var nodeName;
            var i = 0;
            var count = 0;
            var pt;
            if (bursts) {
                emission.bursts = [];
                var itemList = this.getNodeList(bursts, "item");
                for (i = 0, count = itemList.length; i < count; i++) {
                    item = itemList[i];
                    pt = new egret3d.Point();
                    emission.bursts.push(pt);
                    this.eachAttr(item, function (label, value) {
                        if (label == "time") {
                            pt.x = Number(value);
                        }
                        else if (label == "count") {
                            pt.y = Number(value);
                        }
                    });
                }
            }
            var bezier = this.getNode(node, "bezier");
            if (emission.type == egret3d.ParticleValueType.OneBezier) {
                emission.bezier = this.parseBezierData(bezier);
            }
        };
        /**
         * @private
         * 解析生命周期相关数据
         */
        ParticleXmlParser.prototype.parseLife = function (node) {
            var life = this._particleData.life;
            life.type = egret3d.ParticleValueType[this.getNode(node, "type").textContent];
            life.min = Number(this.getNode(node, "min").textContent);
            life.max = Number(this.getNode(node, "max").textContent);
            life.bezier1 = this.parseBezierData(this.getNode(node, "bezier1"));
            life.bezier2 = this.parseBezierData(this.getNode(node, "bezier2"));
            life.duration = Number(this.getNode(node, "duration").textContent);
            life.delay = Number(this.getNode(node, "delay").textContent);
            life.loop = this.getNode(node, "loop").textContent == "true";
        };
        /**
         * @private
         * 解析发射器的范围类型
         */
        ParticleXmlParser.prototype.parseShape = function (node) {
            var shape = this._particleData.shape;
            shape.type = egret3d.ParticleDataShapeType[this.getNode(node, "type").textContent];
            shape.randomDirection = this.getNode(node, "randomDirection").textContent == "true";
            //cube
            var cube = this.getNode(node, "cube");
            this.eachAttr(cube, function (label, value) {
                if (label == "width") {
                    shape.cubeW = Number(value);
                }
                else if (label == "height") {
                    shape.cubeH = Number(value);
                }
                else if (label == "depth") {
                    shape.cubeD = Number(value);
                }
            });
            //sphere
            var sphereRadius = this.getNode(node, "sphereRadius");
            if (sphereRadius) {
                shape.sphereRadius = Number(sphereRadius.textContent);
            }
            //hemiSphereRadius
            var hemiSphereRadius = this.getNode(node, "hemiSphereRadius");
            if (hemiSphereRadius) {
                shape.hemiSphereRadius = Number(hemiSphereRadius.textContent);
            }
            //cone
            var cone = this.getNode(node, "cone");
            this.eachAttr(cone, function (label, value) {
                if (label == "coneHeight") {
                    shape.coneHeight = Number(value);
                }
                else if (label == "coneRadiusBottom") {
                    shape.coneRadiusBottom = Number(value);
                }
                else if (label == "coneRadiusTop") {
                    shape.coneRadiusTop = Number(value);
                }
                else if (label == "type") {
                    shape.coneType = egret3d.ParticleConeShapeType[value];
                }
            });
        };
        /**
         * @private
         * 解析粒子出生的旋转信息
         */
        ParticleXmlParser.prototype.parseRotationBirth = function (node) {
            var rotationBirth = this._particleData.rotationBirth;
            rotationBirth.type = egret3d.ParticleValueType[this.getNode(node, "type").textContent];
            rotationBirth.min = Number(this.getNode(node, "min").textContent);
            rotationBirth.max = Number(this.getNode(node, "max").textContent);
            rotationBirth.bezier1 = this.parseBezierData(this.getNode(node, "bezier1"));
            rotationBirth.bezier2 = this.parseBezierData(this.getNode(node, "bezier2"));
        };
        /**
         * @private
         * 解析粒子出生的缩放信息
         */
        ParticleXmlParser.prototype.parseScaleBirth = function (node) {
            var scaleBirth = this._particleData.scaleBirth;
            scaleBirth.type = egret3d.ParticleValueType[this.getNode(node, "type").textContent];
            scaleBirth.min = Number(this.getNode(node, "min").textContent);
            scaleBirth.max = Number(this.getNode(node, "max").textContent);
            scaleBirth.bezier1 = this.parseBezierData(this.getNode(node, "bezier1"));
            scaleBirth.bezier2 = this.parseBezierData(this.getNode(node, "bezier2"));
        };
        /**
         * @private
         * 解析粒子的几何形状
         */
        ParticleXmlParser.prototype.parseGeometry = function (node) {
            var geometry = this._particleData.geometry;
            geometry.type = egret3d.ParticleGeometryType[this.getNode(node, "type").textContent];
            var plane = this.getNode(node, "plane");
            this.eachAttr(plane, function (label, value) {
                if (label == "width") {
                    geometry.planeW = Number(value);
                }
                else if (label == "height") {
                    geometry.planeH = Number(value);
                }
            });
            var cube = this.getNode(node, "cube");
            this.eachAttr(cube, function (label, value) {
                if (label == "width") {
                    geometry.cubeW = Number(value);
                }
                else if (label == "height") {
                    geometry.cubeH = Number(value);
                }
                else if (label == "depth") {
                    geometry.cubeD = Number(value);
                }
            });
            var sphere = this.getNode(node, "sphere");
            this.eachAttr(sphere, function (label, value) {
                if (label == "radius") {
                    geometry.sphereRadius = Number(value);
                }
                else if (label == "segmentW") {
                    geometry.sphereSegW = Number(value);
                }
                else if (label == "segmentH") {
                    geometry.sphereSegH = Number(value);
                }
            });
        };
        /**
         * @private
         * 解析粒子速度相关信息
         */
        ParticleXmlParser.prototype.parseMoveSpeed = function (node) {
            var moveSpeed = this._particleData.moveSpeed;
            moveSpeed.type = egret3d.ParticleValueType[this.getNode(node, "type").textContent];
            moveSpeed.min = Number(this.getNode(node, "min").textContent);
            moveSpeed.max = Number(this.getNode(node, "max").textContent);
            moveSpeed.bezier1 = this.parseBezierData(this.getNode(node, "bezier1"));
            moveSpeed.bezier2 = this.parseBezierData(this.getNode(node, "bezier2"));
            var velocityOverNode = this.getNode(node, "velocityOver");
            if (velocityOverNode) {
                var velocityOver = new egret3d.VelocityOverLifeTimeData();
                velocityOver.type = egret3d.ParticleValueType[this.getNode(velocityOverNode, "type").textContent];
                var min = this.getNode(velocityOverNode, "min");
                var max = this.getNode(velocityOverNode, "max");
                velocityOver.min = this.parseVector3D(min, velocityOver.min);
                velocityOver.max = this.parseVector3D(max, velocityOver.max);
                velocityOver.worldSpace = this.getNode(velocityOverNode, "worldSpace").textContent == "true";
                velocityOver.xBezier1 = this.parseBezierData(this.getNode(velocityOverNode, "xBezier1"));
                velocityOver.yBezier1 = this.parseBezierData(this.getNode(velocityOverNode, "yBezier1"));
                velocityOver.zBezier1 = this.parseBezierData(this.getNode(velocityOverNode, "zBezier1"));
                velocityOver.xBezier2 = this.parseBezierData(this.getNode(velocityOverNode, "xBezier2"));
                velocityOver.yBezier2 = this.parseBezierData(this.getNode(velocityOverNode, "yBezier2"));
                velocityOver.zBezier2 = this.parseBezierData(this.getNode(velocityOverNode, "zBezier2"));
                moveSpeed.velocityOver = velocityOver;
            }
            var velocityForceNode = this.getNode(node, "velocityForce");
            if (velocityForceNode) {
                var velocityForce = new egret3d.VelocityForceLifeTimeData();
                velocityForce.type = egret3d.ParticleValueType[this.getNode(velocityForceNode, "type").textContent];
                var min = this.getNode(velocityForceNode, "min");
                var max = this.getNode(velocityForceNode, "max");
                velocityForce.min = this.parseVector3D(min, velocityForce.min);
                velocityForce.max = this.parseVector3D(max, velocityForce.max);
                velocityForce.worldSpace = this.getNode(velocityForceNode, "worldSpace").textContent == "true";
                velocityForce.xBezier1 = this.parseBezierData(this.getNode(velocityForceNode, "xBezier1"));
                velocityForce.yBezier1 = this.parseBezierData(this.getNode(velocityForceNode, "yBezier1"));
                velocityForce.zBezier1 = this.parseBezierData(this.getNode(velocityForceNode, "zBezier1"));
                velocityForce.xBezier2 = this.parseBezierData(this.getNode(velocityForceNode, "xBezier2"));
                velocityForce.yBezier2 = this.parseBezierData(this.getNode(velocityForceNode, "yBezier2"));
                velocityForce.zBezier2 = this.parseBezierData(this.getNode(velocityForceNode, "zBezier2"));
                moveSpeed.velocityForce = velocityForce;
            }
            var velocityLimitNode = this.getNode(node, "velocityLimit");
            if (velocityLimitNode) {
                var velocityLimit = new egret3d.VelocityLimitLifeTimeData();
                velocityLimit.type = egret3d.ParticleValueType[this.getNode(velocityLimitNode, "type").textContent];
                var min = this.getNode(velocityLimitNode, "min");
                var max = this.getNode(velocityLimitNode, "max");
                velocityLimit.min = Number(min.textContent);
                velocityLimit.max = Number(max.textContent);
                velocityLimit.bezier1 = this.parseBezierData(this.getNode(velocityLimitNode, "bezier1"));
                velocityLimit.bezier2 = this.parseBezierData(this.getNode(velocityLimitNode, "bezier2"));
                moveSpeed.velocityLimit = velocityLimit;
            }
        };
        /**
         * @private
         * 解析全局位置or本地位置类型
         */
        ParticleXmlParser.prototype.parseFollowTarget = function (node) {
            if (node == null)
                return;
            var followTarget = this._particleData.followTarget = new egret3d.ParticleDataFollowTarget();
            followTarget.followRotation = this.getNode(node, "followRotation").textContent == "true";
            followTarget.followScale = this.getNode(node, "followScale").textContent == "true";
        };
        /**
         * @private
         * 解析粒子生命过程中缩放变化信息
         */
        ParticleXmlParser.prototype.parseScaleBeizer = function (node) {
            if (node == null)
                return;
            var scaleBesizer = this._particleData.scaleBezier = new egret3d.ParticleDataScaleBezier();
            scaleBesizer.data = this.parseBezierData(this.getNode(node, "bezier"));
        };
        /**
        * @private
        * 解析粒子旋转角速度
        */
        ParticleXmlParser.prototype.parseRotationSpeed = function (node) {
            if (node == null)
                return;
            var rotationSpeed = this._particleData.rotationSpeed = new egret3d.ParticleDataRotationSpeed();
            rotationSpeed.type = egret3d.ParticleValueType[this.getNode(node, "type").textContent];
            var min = this.getNode(node, "min");
            var max = this.getNode(node, "max");
            rotationSpeed.min = this.parseVector3D(min, rotationSpeed.min);
            rotationSpeed.max = this.parseVector3D(max, rotationSpeed.max);
            rotationSpeed.bezier1 = this.parseBezierData(this.getNode(node, "bezier1"));
            rotationSpeed.bezier2 = this.parseBezierData(this.getNode(node, "bezier2"));
        };
        /**
        * @private
        * 解析粒子生命过程中颜色渐变信息
        */
        ParticleXmlParser.prototype.parseColorOffset = function (node) {
            if (node == null)
                return;
            var colorOffset = this._particleData.colorOffset = new egret3d.ParticleDataColorOffset();
            var itemList = this.getNodeList(node, "item");
            colorOffset.data = this.parseGradientsColor(itemList, colorOffset.data);
        };
        /**
        * @private
        * 解析材质球
        */
        ParticleXmlParser.prototype.parseTextureSheet = function (node) {
            if (node == null)
                return null;
            var textureSheet = this._particleData.textureSheet = new egret3d.ParticleDataTextureSheet();
            textureSheet.frameType = egret3d.ParticleValueType[this.getNode(node, "frameType").textContent];
            textureSheet.tileX = Number(this.getNode(node, "tileX").textContent);
            textureSheet.tileY = Number(this.getNode(node, "tileY").textContent);
            textureSheet.whole = this.getNode(node, "whole").textContent == "true";
            textureSheet.row = Number(this.getNode(node, "row").textContent);
            textureSheet.min = Number(this.getNode(node, "min").textContent);
            textureSheet.max = Number(this.getNode(node, "max").textContent);
            textureSheet.circles = Number(this.getNode(node, "circles").textContent);
            textureSheet.bezier1 = this.parseBezierData(this.getNode(node, "bezier1"));
            textureSheet.bezier2 = this.parseBezierData(this.getNode(node, "bezier2"));
            return textureSheet;
        };
        /**
        * @private
        * 解析渐变数据
        */
        ParticleXmlParser.prototype.parseGradientsColor = function (itemList, dst) {
            dst || (dst = new egret3d.ColorGradients);
            var item;
            var i = 0;
            var count = 0;
            var pt;
            var color;
            var time;
            for (i = 0, count = itemList.length; i < count; i++) {
                item = itemList[i];
                this.eachAttr(item, function (label, value) {
                    if (label == "time") {
                        dst.times.push(Number(value));
                    }
                    else if (label == "color") {
                        color = egret3d.Color.createColor(Number(value));
                        dst.colors.push(color);
                    }
                });
            }
            //排序
            var sortTimes = dst.times.slice();
            var sortColors = dst.colors.slice();
            sortTimes.sort(function (a, b) {
                return a - b;
            });
            for (i = 0, count = dst.times.length; i < count; i++) {
                var index = sortTimes.indexOf(dst.times[i]);
                dst.colors[i] = sortColors[index];
            }
            dst.times = sortTimes;
            return dst;
        };
        /**
        * @private
        * 解析一条贝塞尔曲线数据
        */
        ParticleXmlParser.prototype.parseBezierData = function (node) {
            var bzData = new egret3d.BezierData();
            if (node == null)
                return bzData;
            var posList = this.getNodeList(node, "pos");
            var ctrlList = this.getNodeList(node, "ctrl");
            var item;
            var i = 0;
            var count = 0;
            var pt;
            for (i = 0, count = posList.length; i < count; i++) {
                item = posList[i];
                pt = new egret3d.Point();
                bzData.posPoints.push(pt);
                this.eachAttr(item, function (label, value) {
                    if (label == "x") {
                        pt.x = Number(value);
                    }
                    else if (label == "y") {
                        pt.y = Number(value);
                    }
                });
            }
            for (i = 0, count = ctrlList.length; i < count; i++) {
                item = ctrlList[i];
                pt = new egret3d.Point();
                bzData.ctrlPoints.push(pt);
                this.eachAttr(item, function (label, value) {
                    if (label == "x") {
                        pt.x = Number(value);
                    }
                    else if (label == "y") {
                        pt.y = Number(value);
                    }
                });
            }
            return bzData;
        };
        /**
        * @private
        * 解析一个vector3D数据
        */
        ParticleXmlParser.prototype.parseVector3D = function (node, vector) {
            if (vector == null)
                vector = new egret3d.Vector3D();
            this.eachAttr(node, function (label, value) {
                if (label == "x") {
                    vector.x = Number(value);
                }
                else if (label == "y") {
                    vector.y = Number(value);
                }
                else if (label == "z") {
                    vector.z = Number(value);
                }
            });
            return vector;
        };
        /**
        * @private
        * 在obj中，获取name的元素，第一个
        */
        ParticleXmlParser.prototype.getNode = function (obj, name) {
            if (obj == null)
                return null;
            var list = obj.getElementsByTagName(name);
            if (list == null || list.length == 0)
                return null;
            return list[0];
        };
        /**
         * @private
         * 在obj中，获取name的元素列表
         */
        ParticleXmlParser.prototype.getNodeList = function (obj, name) {
            if (obj == null)
                return null;
            var list = obj.getElementsByTagName(name);
            if (list == null || list.length == 0)
                return null;
            return list;
        };
        ParticleXmlParser.prototype.eachAttr = function (item, fun) {
            egret3d.XMLParser.eachXmlAttr(item, fun);
        };
        return ParticleXmlParser;
    }());
    egret3d.ParticleXmlParser = ParticleXmlParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @class egret3d.ParticleEmitter
   * @classdesc
   * 粒子发射器
   * @see egret3d.Mesh
   * @version Egret 3.0
   * @platform Web,Native
   */
    var ParticleEmitter = (function (_super) {
        __extends(ParticleEmitter, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param geo Geometry 几何数据
        * @param data ParticleData 生成粒子的数据来源
        * @param material 粒子的材质
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ParticleEmitter(data, geo, material) {
            if (geo === void 0) { geo = null; }
            if (material === void 0) { material = null; }
            _super.call(this, null, material);
            this._isEmitterDirty = true;
            this._userNodes = [];
            this._data = data;
            this._externalGeometry = geo;
            this.animation = this.particleAnimation = new egret3d.ParticleAnimation(this);
            this.animation.particleAnimationController = this.particleAnimation;
            this._particleState = this.particleAnimation.particleAnimationState;
            this.particleAnimation.emit = this;
            this.buildParticle();
        }
        /**
        * @private
        * 添加子发射器
        */
        ParticleEmitter.prototype.addSubEmitter = function (phase, subEmitter) {
            subEmitter.animation.stop();
            this._subEmitterNode.importSubEmitter(phase, subEmitter);
        };
        /**
        * @language zh_CN
        * @private
        * 重新构建这个粒子
        * @param geo Geometry 几何数据
        * @param data ParticleData 生成粒子的数据来源
        * @param material 粒子的材质
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.buildParticle = function () {
            if (this._externalGeometry == null) {
                this.particleGeometryShape = this.createShape();
            }
            else {
                this.particleGeometryShape = this._externalGeometry;
            }
            this.initialize();
            this.initBoudBox(this._data.property.bounds);
            this._isEmitterDirty = false;
        };
        /**
        * @language zh_CN
        * 根据粒子的配置信息，生成geometry
        * @return Geometry
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.createShape = function () {
            var geo;
            var geomData = this._data.geometry;
            if (geomData.type == egret3d.ParticleGeometryType.Plane) {
                var defaultAxis = egret3d.Vector3D.Z_AXIS;
                if (this._data.property.renderMode == egret3d.ParticleRenderModeType.VerticalBillboard) {
                    defaultAxis = egret3d.Vector3D.Y_AXIS;
                }
                else if (this._data.property.renderMode == egret3d.ParticleRenderModeType.HorizontalBillboard) {
                    defaultAxis = egret3d.Vector3D.Y_AXIS;
                }
                else {
                    defaultAxis = egret3d.Vector3D.Z_AXIS;
                }
                var wCenter = true;
                var hCenter = true;
                if (this._data.property.renderMode == egret3d.ParticleRenderModeType.StretchedBillboard) {
                    //需要偏移一半位置
                    wCenter = false;
                    hCenter = true;
                }
                geo = new egret3d.PlaneGeometry(geomData.planeW, geomData.planeH, 1, 1, 1, 1, defaultAxis, wCenter, hCenter);
            }
            else if (geomData.type == egret3d.ParticleGeometryType.Cube) {
                geo = new egret3d.CubeGeometry(geomData.cubeW, geomData.cubeH, geomData.cubeD);
            }
            else if (geomData.type == egret3d.ParticleGeometryType.Sphere) {
                geo = new egret3d.SphereGeometry(geomData.sphereRadius, geomData.sphereSegW, geomData.sphereSegH);
            }
            return geo;
        };
        Object.defineProperty(ParticleEmitter.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleEmitter.prototype, "timeNode", {
            /**
            * @language zh_CN
            * 获取时间节点
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._timeNode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleEmitter.prototype, "positionNode", {
            /**
            * @language zh_CN
            * 获取位置节点
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._positionNode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleEmitter.prototype, "followTarget", {
            /**
            * @language zh_CN
            * 获取跟随的目标
            * @returns Object3D 跟随的目标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._particleState.followTarget;
            },
            /**
            * @language zh_CN
            * 设置跟随的目标，如果设置了，粒子发射器会跟随目标
            * @param o 粒子发射器会跟随目标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (o) {
                this._particleState.followTarget = o;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 给粒子发射器添加 粒子效果节点
        * @param node 粒子效果节点
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.addAnimNode = function (node) {
            var index = this._userNodes.indexOf(node);
            if (index == -1) {
                this._userNodes.push(node);
                this._isEmitterDirty = true;
            }
        };
        /**
        * @language zh_CN
        * 移除粒子发射器上的效果节点
        * @param node 粒子效果节点
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.removeAnimNode = function (node) {
            var index = this._userNodes.indexOf(node);
            if (index != -1) {
                this._userNodes.slice(index);
                this._isEmitterDirty = true;
            }
        };
        /**
        * @language zh_CN
        * 播放粒子
        * @param prewarm 是否预热
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.play = function (prewarm) {
            if (prewarm === void 0) { prewarm = false; }
            if (prewarm) {
                this.animation.play("", 1.0, false, true);
            }
            else {
                this.animation.play("", 1.0, true, false);
            }
        };
        /**
        * @language zh_CN
        * 结束播放粒子
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.stop = function () {
            this.animation.stop();
        };
        /**
        * @private
        */
        ParticleEmitter.prototype.initialize = function () {
            //clean
            this.particleAnimation.particleAnimationState.clean();
            var count = this._data.property.particleCount;
            this.geometry = new egret3d.Geometry();
            this.geometry.buildDefaultSubGeometry();
            this.geometry.subGeometrys[0].count = count * this.particleGeometryShape.indexData.length;
            //根据 模型形状初始化 
            var vertexIndex = 0;
            var vertexArray = new Array();
            //根据 动画功能节点初始化 着色器 并初始化粒子顶点结构
            this.geometry.vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_COLOR;
            //根据动画节点，预计算顶点信息，长度，字节总量
            this.initMainAnimNode();
            this.initUserAnimNode();
            this.initEndNode();
            this.geometry.verticesData = new Array();
            for (var i = 0; i < count; ++i) {
                for (var j = 0; j < this.particleGeometryShape.vertexCount; ++j) {
                    for (var k = 0; k < this.geometry.vertexAttLength; ++k) {
                        this.geometry.verticesData.push(0);
                    }
                    vertexIndex = i * this.particleGeometryShape.vertexCount + j;
                    vertexArray.length = 0;
                    this.particleGeometryShape.getVertexForIndex(j, this.geometry.vertexFormat, vertexArray);
                    for (var k = 0; k < vertexArray.length; ++k) {
                        this.geometry.verticesData[vertexIndex * this.geometry.vertexAttLength + k] = vertexArray[k];
                    }
                }
            }
            this.geometry.indexData = new Array();
            for (var i = 0; i < count; ++i) {
                for (var j = 0; j < this.particleGeometryShape.indexData.length; ++j) {
                    this.geometry.indexData[i * this.particleGeometryShape.indexData.length + j] = this.particleGeometryShape.indexData[j] + i * this.particleGeometryShape.vertexCount;
                }
            }
            //最后根据节点功能，填充模型
            this.particleAnimation.particleAnimationState.fill(this.geometry, count);
        };
        /**
        * @private
        * 根据ParticleData中的数据初始化
        */
        ParticleEmitter.prototype.initMainAnimNode = function () {
            var nodes = [];
            //time 
            this._timeNode = new egret3d.ParticleTime();
            this._timeNode.initNode(this._data.life);
            nodes.push(this._timeNode);
            //position
            this._positionNode = new egret3d.ParticlePosition();
            this._positionNode.initNode(this._data.shape, this._data.property);
            nodes.push(this._positionNode);
            //speed(依赖于position)
            var speedNode = new egret3d.ParticleVelocityNode();
            speedNode.initNode(this._data.moveSpeed);
            nodes.push(speedNode);
            //subEmitter
            this._subEmitterNode = new egret3d.ParticleSubEmitterNode();
            this._subEmitterNode.initNode(null, this);
            this.particleAnimation.particleAnimationState.addNode(this._subEmitterNode);
            //velocity
            var velocityOver = this._data.moveSpeed.velocityOver;
            if (velocityOver) {
                if (velocityOver.type == egret3d.ParticleValueType.Const || velocityOver.type == egret3d.ParticleValueType.RandomConst) {
                    var overConstNode = new egret3d.ParticleVelocityOverConstNode();
                    overConstNode.initNode(this._data.moveSpeed);
                    nodes.push(overConstNode);
                }
                else if (velocityOver.type == egret3d.ParticleValueType.OneBezier) {
                    var overOneBezierNode = new egret3d.ParticleVelocityOverOneBezierNode();
                    overOneBezierNode.initNode(this._data.moveSpeed);
                    nodes.push(overOneBezierNode);
                }
                else if (velocityOver.type == egret3d.ParticleValueType.TwoBezier) {
                    var overTwoBezierNode = new egret3d.ParticleVelocityOverTwoBezierNode();
                    overTwoBezierNode.initNode(this._data.moveSpeed);
                    nodes.push(overTwoBezierNode);
                }
            }
            var limit = this._data.moveSpeed.velocityLimit;
            if (limit) {
                if (limit.type == egret3d.ParticleValueType.Const || limit.type == egret3d.ParticleValueType.RandomConst) {
                    var limitConstNode = new egret3d.ParticleVelocityLimitConstNode();
                    limitConstNode.initNode(this._data.moveSpeed);
                    nodes.push(limitConstNode);
                }
                else if (limit.type == egret3d.ParticleValueType.OneBezier) {
                    var limitOneBezierNode = new egret3d.ParticleVelocityLimitOneBezierNode();
                    limitOneBezierNode.initNode(this._data.moveSpeed);
                    nodes.push(limitOneBezierNode);
                }
                else if (limit.type == egret3d.ParticleValueType.TwoBezier) {
                    var limitTwoBezierNode = new egret3d.ParticleVelocityLimitTwoBezierNode();
                    limitTwoBezierNode.initNode(this._data.moveSpeed);
                    nodes.push(limitTwoBezierNode);
                }
            }
            var velocityForce = this._data.moveSpeed.velocityForce;
            if (velocityForce) {
                if (velocityForce.type == egret3d.ParticleValueType.Const || velocityForce.type == egret3d.ParticleValueType.RandomConst) {
                    var forceConstNode = new egret3d.ParticleVelocityForceConstNode();
                    forceConstNode.initNode(this._data.moveSpeed);
                    nodes.push(forceConstNode);
                }
                else if (velocityForce.type == egret3d.ParticleValueType.OneBezier) {
                    var forceOneBezierNode = new egret3d.ParticleVelocityForceOneBezierNode();
                    forceOneBezierNode.initNode(this._data.moveSpeed);
                    nodes.push(forceOneBezierNode);
                }
                else if (velocityForce.type == egret3d.ParticleValueType.TwoBezier) {
                    var forceTwoBezierNode = new egret3d.ParticleVelocityForceTwoBezierNode();
                    forceTwoBezierNode.initNode(this._data.moveSpeed);
                    nodes.push(forceTwoBezierNode);
                }
            }
            //rotation
            var rotationNode = new egret3d.ParticleRotation();
            rotationNode.initNode(this._data.rotationBirth);
            nodes.push(rotationNode);
            //scale
            var scaleNode = new egret3d.ParticleScale();
            scaleNode.initNode(this._data.scaleBirth);
            nodes.push(scaleNode);
            //start color
            var colorNode = new egret3d.ParticleStartColor();
            colorNode.initNode(this._data.property);
            nodes.push(colorNode);
            //follow
            if (this._data.followTarget) {
                var particleFollowNode = new egret3d.ParticleFollowNode();
                particleFollowNode.initNode(this._data.followTarget);
                nodes.push(particleFollowNode);
            }
            if (this._data.scaleBezier) {
                var scaleBesizer = new egret3d.ParticleSizeGlobalNode();
                scaleBesizer.initNode(this._data.scaleBezier);
                nodes.push(scaleBesizer);
            }
            if (this._data.rotationSpeed) {
                if (this._data.rotationSpeed.type == egret3d.ParticleValueType.Const || this._data.rotationSpeed.type == egret3d.ParticleValueType.RandomConst) {
                    var rotateConst = new egret3d.ParticleRotationConstNode();
                    rotateConst.initNode(this._data.rotationSpeed);
                    nodes.push(rotateConst);
                }
                else if (this._data.rotationSpeed.type == egret3d.ParticleValueType.OneBezier) {
                    var rotateOneBezier = new egret3d.ParticleRotationOneBezierNode();
                    rotateOneBezier.initNode(this._data.rotationSpeed);
                    nodes.push(rotateOneBezier);
                }
                else if (this._data.rotationSpeed.type == egret3d.ParticleValueType.TwoBezier) {
                    var rotateTwoBezier = new egret3d.ParticleRotationTwoBezierNode();
                    rotateTwoBezier.initNode(this._data.rotationSpeed);
                    nodes.push(rotateTwoBezier);
                }
            }
            if (this._data.colorOffset) {
                var colorOffset = new egret3d.ParticleColorGlobalNode();
                colorOffset.initNode(this._data.colorOffset);
                nodes.push(colorOffset);
            }
            //materialData
            if (this._data.materialData) {
                //uvRoll
                var method;
                for (var _i = 0, _a = this._data.materialData.methods; _i < _a.length; _i++) {
                    method = _a[_i];
                    if (method.type == egret3d.MatMethodData.methodType.lightmapMethod) {
                    }
                    else if (method.type == egret3d.MatMethodData.methodType.uvRollMethod) {
                        var uvNode = new egret3d.ParticleUVRollNode();
                        uvNode.initNode(null, method);
                        nodes.push(uvNode);
                    }
                    else if (method.type == egret3d.MatMethodData.methodType.alphaMaskMethod) {
                    }
                    else if (method.type == egret3d.MatMethodData.methodType.streamerMethod) {
                    }
                }
            }
            //texture sheet
            if (this._data.textureSheet) {
                var textureSheet = new egret3d.ParticleTextureSheetNode();
                textureSheet.initNode(null, this._data.textureSheet);
                nodes.push(textureSheet);
            }
            //
            for (var i = 0, count = nodes.length; i < count; i++) {
                this.particleAnimation.particleAnimationState.addNode(nodes[i]);
            }
        };
        ParticleEmitter.prototype.initUserAnimNode = function () {
            //加入自定义节点
            for (var i = 0; i < this._userNodes.length; i++) {
                this.particleAnimation.particleAnimationState.addNode(this._userNodes[i]);
            }
        };
        ParticleEmitter.prototype.initEndNode = function () {
            //永远是最后一个加入
            var endNode = new egret3d.ParticleEndNode();
            this.particleAnimation.particleAnimationState.addNode(endNode);
            //计算加入动画后，会获取的节点信息，重新计算 geometry 结构
            this.particleAnimation.particleAnimationState.calculate(this.geometry);
        };
        /**
        * @language zh_CN
        * @private
        * 构建包围盒
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.initBoudBox = function (vector) {
            var b = new egret3d.BoundBox(this);
            b.fillBox(new egret3d.Vector3D(-vector.x / 2, -vector.y / 2, -vector.z / 2), new egret3d.Vector3D(vector.x / 2, vector.y / 2, vector.z / 2));
            this.bound = b;
            this.initAABB();
        };
        Object.defineProperty(ParticleEmitter.prototype, "loopProgress", {
            /**
            * @language zh_CN
            * @public
            * 循环完毕的次数，用于检测是否单个循环结束
            * @return number 循环次数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.animation.animTime / this._particleState.loopTime;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.update = function (time, delay, camera) {
            if (this._isEmitterDirty) {
                this.buildParticle();
            }
            _super.prototype.update.call(this, time, delay, camera);
        };
        return ParticleEmitter;
    }(egret3d.Mesh));
    egret3d.ParticleEmitter = ParticleEmitter;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var Scene3D = (function () {
        function Scene3D() {
            this._root = new egret3d.Object3D();
            this._tree = new egret3d.TreeBase(this._root);
        }
        Object.defineProperty(Scene3D.prototype, "root", {
            /**
            * @language zh_CN
            * 返回渲染根节点
            * 返回渲染场景的 scene3D
            * @returns Object3D
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._root;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene3D.prototype, "quad", {
            /**
            * @language zh_CN
            * 返回剖分场景四叉树根信息
            * @returns QuadRoot
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._quad;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 将一个 Object3D 实例添加到 Scene3D 实例中。
        * 将一个 Object3D 实例添加到 Scene3D 实例中。参与scene3D中的显示树优化，并且即时渲染出来
        * @param  child3D {Object3D}
        * @version Egret 3.0
        * @platform Web,Native
        */
        Scene3D.prototype.addChild3D = function (child3D) {
            this._root.addChild(child3D);
            // to do add renderlist tree
        };
        Scene3D.prototype.removeChild3D = function (child3D) {
            this._root.removeChild(child3D);
            // to do add renderlist tree
        };
        Scene3D.prototype.update = function () {
        };
        Scene3D.prototype.infrustumList = function (camera) {
            return this._tree.infrustumList(camera);
        };
        /**
        * @language zh_CN
        * 根据当前场景的节点分布情况，生成四叉树
        * @version Egret 3.0
        * @platform Web,Native
        */
        Scene3D.prototype.createQuadTree = function () {
            this._quad = new egret3d.QuadRoot(8, 128);
            var nodes = new Array();
            this.collectQuadList(nodes, this.root);
            this._quad.createQuadTree(nodes);
        };
        /**
        * @language zh_CN
        * 遍历一个Object3D及其child节点，如果能够进入视锥体，则放入返回的列表中
        * @param  nodes 用于返回Quad元素结果
        * @param  obj   待遍历的对象
        * @returns Array<IQuadNode>
        * @version Egret 3.0
        * @platform Web,Native
        */
        Scene3D.prototype.collectQuadList = function (nodes, obj) {
            nodes = nodes || new Array();
            var mesh;
            if (obj instanceof egret3d.Mesh) {
                mesh = obj;
                if (mesh.aabb) {
                    nodes.push(mesh);
                }
            }
            var child;
            if (obj.childs && obj.childs.length > 0) {
                for (var _i = 0, _a = obj.childs; _i < _a.length; _i++) {
                    child = _a[_i];
                    this.collectQuadList(nodes, child);
                }
            }
            return nodes;
        };
        return Scene3D;
    }());
    egret3d.Scene3D = Scene3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.TreeBase
    * @classdesc
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TreeBase = (function () {
        function TreeBase(object3D) {
            this._searchList = new Array();
            this._root = object3D;
        }
        TreeBase.prototype.infrustumList = function (camera) {
            this._searchList.length = 0;
            return this._searchList;
        };
        return TreeBase;
    }());
    egret3d.TreeBase = TreeBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.ITexture
    * @classdesc
    * 贴图的接口
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ITexture = (function () {
        function ITexture() {
            /**
            * @language zh_CN
            * 贴图是否使用 mipmap , mipmap为一个贴图的LOD层级贴图。例如（1024*1024的贴图，往下就会自动生成 512* 512,256*256,128*128,64*64,32*32,16*16,8*8,4*4,2*2,1*1）
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.useMipmap = true;
            /**
            * @language zh_CN
            * 是否平滑差值
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.smooth = true;
        }
        /**
        * @language zh_CN
        * 上传贴图数据给GPU
        * @param context3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        ITexture.prototype.upload = function (context3D) {
        };
        /**
        * @language zh_CN
        * 强制上传贴图数据给GPU，强制要求贴图更新。
        * 在video 贴图类型需要立即改变显卡中的贴图内存
        * @param context3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        ITexture.prototype.uploadForcing = function (context3D) {
        };
        return ITexture;
    }());
    egret3d.ITexture = ITexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.ImageTexture
    * @classdesc
    * ImageTexture 类为 图像贴图
    *
    * 图像贴图用于封装 HTMLImageElement（网页图像元素）到引擎内部可使用的Texture2D对象, </p>
     * HTMLImageElement 可通过内嵌HTML文件中获取。</p>
    *
     *
    * 示例：
    * 假设html中已有 &lt;img id="t1" src="xxx.png" /&gt;
    * <pre>
    * var img: HTMLImageElement = <HTMLImageElement>document.getElementById("t1");
    * var imageTexture: egret3d.ImageTexture = new egret3d.ImageTexture(img);
     * </pre>
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ImageTexture = (function (_super) {
        __extends(ImageTexture, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param img HTMLImageElement（网页图像元素）
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ImageTexture(img) {
            _super.call(this);
            this.imageData = img;
        }
        Object.defineProperty(ImageTexture.prototype, "width", {
            get: function () {
                return this.imageData.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ImageTexture.prototype, "height", {
            get: function () {
                return this.imageData.height;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 上传贴图数据给GPU
        * @param context3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        ImageTexture.prototype.upload = function (context3D) {
            if (!this.texture2D) {
                this.texture2D = context3D.creatTexture2D();
                this.texture2D.internalFormat = egret3d.InternalFormat.ImageData;
                this.texture2D.imageData = this.imageData;
                this.texture2D.useMipmap = this.useMipmap;
                this.texture2D.smooth = this.smooth;
                this.texture2D.colorFormat = egret3d.ContextConfig.ColorFormat_RGBA8888;
                context3D.upLoadTextureData(0, this.texture2D);
            }
        };
        /**
        * @language zh_CN
        * 强制上传贴图数据给GPU，强制要求贴图更新。
        * 在video 贴图类型需要立即改变显卡中的贴图内存
        * @param context3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        ImageTexture.prototype.uploadForcing = function (context3D) {
            context3D.upLoadTextureData(0, this.texture2D);
        };
        return ImageTexture;
    }(egret3d.ITexture));
    egret3d.ImageTexture = ImageTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.TGATexture
    * @classdesc
    * DDS 贴图模式对象
    * @version Egret 3.0
    * @platform Web,Native
    */
    var DDSTexture = (function (_super) {
        __extends(DDSTexture, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function DDSTexture() {
            _super.call(this);
            this.smooth = true;
        }
        DDSTexture.prototype.upload = function (context3D) {
            if (!this.texture2D) {
                this.texture2D = context3D.creatTexture2D();
                this.texture2D.smooth = this.smooth;
                this.texture2D.internalFormat = this.internalFormat;
                this.texture2D.colorFormat = this.colorFormat;
                this.texture2D.mimapData = this.mimapData;
                if (this.mimapData && this.mimapData.length > 0) {
                    for (var i = 0; i < this.mimapData.length; i++) {
                        context3D.upLoadTextureData(i, this.texture2D);
                    }
                }
                else {
                    context3D.upLoadTextureData(0, this.texture2D);
                }
            }
        };
        DDSTexture.prototype.uploadForcing = function (context3D) {
            context3D.upLoadTextureData(0, this.texture2D);
        };
        return DDSTexture;
    }(egret3d.ITexture));
    egret3d.DDSTexture = DDSTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.TGATexture
    * @classdesc
    * TGA 贴图模式对象
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TGATexture = (function (_super) {
        __extends(TGATexture, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function TGATexture() {
            _super.call(this);
        }
        /**
        * @language zh_CN
        * 上传贴图数据给GPU
        * @param context3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        TGATexture.prototype.upload = function (context3D) {
            if (!this.texture2D) {
                this.texture2D = context3D.creatTexture2D();
                this.texture2D.internalFormat = this.internalFormat;
                this.texture2D.colorFormat = this.colorFormat;
                this.texture2D.mimapData = this.mimapData;
                this.texture2D.smooth = this.smooth;
                this.useMipmap = true;
                if (this.mimapData && this.mimapData.length > 0) {
                    for (var i = 0; i < this.mimapData.length; i++) {
                        context3D.upLoadTextureData(i, this.texture2D);
                    }
                }
                else {
                    context3D.upLoadTextureData(0, this.texture2D);
                }
            }
        };
        /**
        * @language zh_CN
        * 强制上传贴图数据给GPU，强制要求贴图更新。
        * @param context3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        TGATexture.prototype.uploadForcing = function (context3D) {
            context3D.upLoadTextureData(0, this.texture2D);
        };
        return TGATexture;
    }(egret3d.ITexture));
    egret3d.TGATexture = TGATexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var PVRTexture = (function (_super) {
        __extends(PVRTexture, _super);
        function PVRTexture() {
            _super.call(this);
        }
        PVRTexture.prototype.upload = function (context3D) {
        };
        PVRTexture.prototype.uploadForcing = function (context3D) {
        };
        return PVRTexture;
    }(egret3d.ITexture));
    egret3d.PVRTexture = PVRTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @class egret3d.CubeTexture
     * @classdesc
     * CubeTexture 类为天空贴图
     *
     * 天空贴图用于Sky类使用，其内部是将6张HTMLImageElement（网页图片元素）封装到CubeTexture对象，CubeTexture为引擎内部使用对象。</p>
     *
     * 示例：</p>
     * 假设html中已有</p>
     <pre>
     <img id="t1" src="image_front.png" />
     <img id="t2" src="image_back.png" />
     <img id="t3" src="image_left.png" />
     <img id="t4" src="image_right.png" />
     <img id="t5" src="image_up.png" />
     <img id="t6" src="image_down.png" />
     </pre>
     使用示例：</p>
     <pre>
     var cubeTexture: CubeTexture = CubeTexture.createCubeTexture(
     <HTMLImageElement>document.getElementById("t1"),
     <HTMLImageElement>document.getElementById("t2"),
     <HTMLImageElement>document.getElementById("t3"),
     <HTMLImageElement>document.getElementById("t4"),
     <HTMLImageElement>document.getElementById("t5"),
     <HTMLImageElement>document.getElementById("t6")
     );
     </pre>
     * @see egret3d.Sky
     * @version Egret 3.0
     * @platform Web,Native
     */
    var CubeTexture = (function (_super) {
        __extends(CubeTexture, _super);
        /**
         * @language zh_CN
         * 构造函数
         * @param image_front 默认参为null 前部HTMLImageElement图片元素
         * @param image_back 默认参为null 背部HTMLImageElement图片元素
         * @param image_left 默认参为null 左部HTMLImageElement图片元素
         * @param image_right 默认参为null 右部HTMLImageElement图片元素
         * @param image_up 默认参为null 顶部HTMLImageElement图片元素
         * @param image_down 默认参为null 底部HTMLImageElement图片元素
         */
        function CubeTexture(image_front, image_back, image_left, image_right, image_up, image_down) {
            if (image_front === void 0) { image_front = null; }
            if (image_back === void 0) { image_back = null; }
            if (image_left === void 0) { image_left = null; }
            if (image_right === void 0) { image_right = null; }
            if (image_up === void 0) { image_up = null; }
            if (image_down === void 0) { image_down = null; }
            _super.call(this);
            this.image_front = image_front;
            this.image_back = image_back;
            this.image_left = image_left;
            this.image_right = image_right;
            this.image_up = image_up;
            this.image_down = image_down;
        }
        /**
         * @language zh_CN
         * 创建CubuTexture
         * @param image_front 前部HTMLImageElement图片元素
         * @param image_back 背部HTMLImageElement图片元素
         * @param image_left 左部HTMLImageElement图片元素
         * @param image_right 右部HTMLImageElement图片元素
         * @param image_up 顶部HTMLImageElement图片元素
         * @param image_down 底部HTMLImageElement图片元素
         */
        CubeTexture.createCubeTexture = function (image_front, image_back, image_left, image_right, image_up, image_down) {
            var front = new egret3d.Texture2D();
            front.imageData = image_front;
            var back = new egret3d.Texture2D();
            back.imageData = image_back;
            var left = new egret3d.Texture2D();
            left.imageData = image_left;
            var right = new egret3d.Texture2D();
            right.imageData = image_right;
            var up = new egret3d.Texture2D();
            up.imageData = image_up;
            var down = new egret3d.Texture2D();
            down.imageData = image_down;
            var cubeTexture = new CubeTexture(front, back, left, right, up, down);
            return cubeTexture;
        };
        /**
         * @language zh_CN
         * 设置CubuTexture
         * @param cubeTexture 源CubuTexture
         * @param image_front 前部ITexture图片元素
         * @param image_back 背部ITexture图片元素
         * @param image_left 左部ITexture图片元素
         * @param image_right 右部ITexture图片元素
         * @param image_up 顶部ITexture图片元素
         * @param image_down 底部ITexture图片元素
         */
        CubeTexture.setCubeTexture = function (cubeTexture, image_front, image_back, image_left, image_right, image_up, image_down) {
            cubeTexture.image_front = image_front.texture2D;
            cubeTexture.image_back = image_back.texture2D;
            cubeTexture.image_left = image_left.texture2D;
            cubeTexture.image_right = image_right.texture2D;
            cubeTexture.image_up = image_up.texture2D;
            cubeTexture.image_down = image_down.texture2D;
        };
        /**
         * @language zh_CN
         * 上传贴图数据给GPU
         * 更新上传 cube 贴图纹理到GPU 现存中缓存起来
         * @param context3D
         */
        CubeTexture.prototype.upload = function (context3D) {
            if (!this.image_front ||
                !this.image_back ||
                !this.image_left ||
                !this.image_right ||
                !this.image_up ||
                !this.image_down) {
                return;
            }
            if (!this.texture3D) {
                this.texture3D = context3D.creatCubeTexture();
                this.texture3D.border = 0;
                this.texture3D.image_front = this.image_front;
                this.texture3D.image_back = this.image_back;
                this.texture3D.image_left = this.image_left;
                this.texture3D.image_right = this.image_right;
                this.texture3D.image_up = this.image_up;
                this.texture3D.image_down = this.image_down;
                context3D.uploadCubetexture(this.texture3D);
            }
        };
        CubeTexture.prototype.uploadForcing = function (context3D) {
        };
        return CubeTexture;
    }(egret3d.ITexture));
    egret3d.CubeTexture = CubeTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.CheckerboardTexture
    * @classdesc
    * CheckerboardTexture 类为 棋盘格纹理类</p>
    *
    * 棋盘格纹理为黑白间隔色块组成的一张纹理，主要用于判别模型UV的正确性，若某模型UV值不正确，其纹理表现必定乱序不规整。</p>
    * 使用示例:</p>
     <pre>
    var material: egret3d.TextureMaterial = new egret3d.TextureMaterial(egret3d.CheckerboardTexture.texture );
    var mesh: egret3d.Mesh = new egret3d.Mesh(new egret3d.CubeGeometry(), material);
     </pre>
    *
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample texture/CheckerboardTexture.ts
    */
    var CheckerboardTexture = (function (_super) {
        __extends(CheckerboardTexture, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function CheckerboardTexture() {
            _super.call(this);
            this.width = 32;
            this.height = 32;
            this.buildCheckerboard();
        }
        /**
         * @language zh_CN
         * 上传贴图数据给GPU
         * @param context3D
         */
        CheckerboardTexture.prototype.upload = function (context3D) {
            if (!this.texture2D) {
                this.texture2D = context3D.creatTexture2D();
                this.texture2D.border = 0;
                this.texture2D.internalFormat = egret3d.InternalFormat.PixelArray;
                this.texture2D.colorFormat = egret3d.ContextConfig.ColorFormat_RGBA8888;
                this.texture2D.smooth = this.smooth;
                this.texture2D.useMipmap = this.useMipmap;
                this.texture2D.mimapData = new Array();
                this.texture2D.mimapData.push(new egret3d.MipmapData(this._pixelArray, this.width, this.height));
                this.texture2D.useMipmap = false;
                context3D.upLoadTextureData(0, this.texture2D);
            }
        };
        CheckerboardTexture.prototype.buildCheckerboard = function () {
            if (!this._pixelArray) {
                this._pixelArray = new Uint8Array(this.width * this.height * 4);
                var colors = [egret3d.Color.black(), egret3d.Color.white()];
                var colorIndex = 0;
                var blockSize = 4;
                for (var y = 0; y < this.height; y++) {
                    for (var x = 0; x < this.width; x++) {
                        if ((x % blockSize) == 0) {
                            colorIndex = (colorIndex + 1) % 2;
                        }
                        if ((y % blockSize) == 0 && x == 0) {
                            var tmp = colors[0];
                            colors[0] = colors[1];
                            colors[1] = tmp;
                            colorIndex = 0;
                        }
                        this._pixelArray[(y * (this.width * 4) + x * 4) + 0] = colors[colorIndex].r;
                        this._pixelArray[(y * (this.width * 4) + x * 4) + 1] = colors[colorIndex].g;
                        this._pixelArray[(y * (this.width * 4) + x * 4) + 2] = colors[colorIndex].b;
                        this._pixelArray[(y * (this.width * 4) + x * 4) + 3] = colors[colorIndex].a;
                    }
                }
            }
        };
        CheckerboardTexture.prototype.uploadForcing = function (context3D) {
        };
        /**
        * @language zh_CN
        * 公用棋盘格实例对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        CheckerboardTexture.texture = new CheckerboardTexture();
        return CheckerboardTexture;
    }(egret3d.ITexture));
    egret3d.CheckerboardTexture = CheckerboardTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @class egret3d.VideoTexture
     * @classdesc
     * VideoTexture 使用 Video 标签采集 video 视频 </p>
     * VideoTexture 仅且暂时只能在pc上正常使用，移动端需要直接与用户交互才可正常生成播放</p>
     * 需要设置贴图的宽度和高度。必须为2的N次</p>
     * @version Egret 3.0
     * @platform Web,Native
     */
    var VideoTexture = (function (_super) {
        __extends(VideoTexture, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param width 贴图宽度 默认参数 256
        * @param height 贴图高度 默认参数 256
        * @version Egret 3.0
        * @platform Web,Native
        */
        function VideoTexture(width, height) {
            var _this = this;
            if (width === void 0) { width = 256; }
            if (height === void 0) { height = 256; }
            _super.call(this);
            this.canUpdataTexture = false;
            this.width = width;
            this.height = height;
            this.tmpCanvas = document.createElement("canvas");
            this.tmpCanvas.width = width;
            this.tmpCanvas.height = height;
            this.context = this.tmpCanvas.getContext('2d');
            this.video = document.createElement("video");
            this.video.msZoom = true;
            this.video.width = width;
            this.video.height = height;
            this.video.videoWidth = width;
            this.video.videoHeight = height;
            this.video.controls = false;
            this.video.autoplay = true;
            this.video.addEventListener("canplaythrough", function () { return _this.loadReady(); }, true);
            this.tmpCanvas.hidden = true;
        }
        VideoTexture.prototype.loadReady = function () {
            this.canUpdataTexture = true;
        };
        Object.defineProperty(VideoTexture.prototype, "source", {
            /**
            * @language zh_CN
            * 返回 视频链接
            * 视频的链接地址，只要是h5 支持的格式都支持， 例如:ogv,mp4,avi
            * warning chrom need use url = http://127.0.0.1/resource/video/xxx.mp4
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.video.src;
            },
            /*
            * @language zh_CN
            * 设置 视频链接
            * 设置 视频的链接地址，只要是h5 支持的格式都支持， 例如: ogv,mp4,avi
            * warning chrom need use url = http://127.0.0.1/resource/video/xxx.mp4
            * @param src 视频格式的链接地址
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (src) {
                this.video.src = src;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 播放视频
        * 当视频缓冲好之后才能正常播放视频
        * @version Egret 3.0
        * @platform Web,Native
        */
        VideoTexture.prototype.play = function () {
            this.video.play();
        };
        /**
        * @language zh_CN
        * 暂停视频
        * 控制视频的播放暂停状态
        * @version Egret 3.0
        * @platform Web,Native
        */
        VideoTexture.prototype.pause = function () {
            this.video.pause();
        };
        /**
        * @private
        * @language zh_CN
        * 上传贴图数据给GPU
        * 将video的视频数据实时传输到GPU上
        * @param context3D
        */
        VideoTexture.prototype.upload = function (context3D) {
            if (!this.texture2D) {
                this.texture2D = context3D.creatTexture2D();
                this.context.drawImage(this.video, 0, 0, this.width, this.height);
                egret3d.Context3DProxy.gl.pixelStorei(egret3d.Context3DProxy.gl.UNPACK_ALIGNMENT, 1);
                egret3d.Context3DProxy.gl.bindTexture(egret3d.Context3DProxy.gl.TEXTURE_2D, this.texture2D.texture);
                egret3d.Context3DProxy.gl.texImage2D(egret3d.Context3DProxy.gl.TEXTURE_2D, 0, egret3d.Context3DProxy.gl.RGB, egret3d.Context3DProxy.gl.RGB, egret3d.Context3DProxy.gl.UNSIGNED_BYTE, this.tmpCanvas);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_MIN_FILTER, egret3d.Context3DProxy.gl.LINEAR);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_MAG_FILTER, egret3d.Context3DProxy.gl.LINEAR);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_WRAP_S, egret3d.Context3DProxy.gl.CLAMP_TO_EDGE);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_WRAP_T, egret3d.Context3DProxy.gl.CLAMP_TO_EDGE);
            }
            if (this.canUpdataTexture) {
                this.context.drawImage(this.video, 0, 0, this.width, this.height);
                egret3d.Context3DProxy.gl.pixelStorei(egret3d.Context3DProxy.gl.UNPACK_ALIGNMENT, 1);
                egret3d.Context3DProxy.gl.bindTexture(egret3d.Context3DProxy.gl.TEXTURE_2D, this.texture2D.texture);
                egret3d.Context3DProxy.gl.texImage2D(egret3d.Context3DProxy.gl.TEXTURE_2D, 0, egret3d.Context3DProxy.gl.RGB, egret3d.Context3DProxy.gl.RGB, egret3d.Context3DProxy.gl.UNSIGNED_BYTE, this.tmpCanvas);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_MIN_FILTER, egret3d.Context3DProxy.gl.LINEAR);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_MAG_FILTER, egret3d.Context3DProxy.gl.LINEAR);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_WRAP_S, egret3d.Context3DProxy.gl.CLAMP_TO_EDGE);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_WRAP_T, egret3d.Context3DProxy.gl.CLAMP_TO_EDGE);
            }
        };
        /**
        * @private
        */
        VideoTexture.prototype.uploadForcing = function (context3D) {
        };
        return VideoTexture;
    }(egret3d.ITexture));
    egret3d.VideoTexture = VideoTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.RenderTexture
    * @classdesc
    * 渲染到内容到一张贴图
    * @see egret3d.ITexture
    * @version Egret 3.0
    * @platform Web,Native
    */
    var RenderTexture = (function (_super) {
        __extends(RenderTexture, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param width  贴图的宽度 默认参数 默认为512
        * @param height 贴图的高度 默认参数 默认为512
        * @param frameBufferFormat 帧buffer的格式 默认参数 FrameBufferFormat.UNSIGNED_BYTE_RGB
        * @version Egret 3.0
        * @platform Web,Native
        */
        function RenderTexture(width, height, frameBufferFormat) {
            if (width === void 0) { width = 512; }
            if (height === void 0) { height = 512; }
            if (frameBufferFormat === void 0) { frameBufferFormat = egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB; }
            _super.call(this);
            /**
            * @language zh_CN
            * 帧buffer的格式
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.frameBufferFormat = egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB;
            this.useMipmap = false;
            this.width = width;
            this.height = height;
            this.frameBufferFormat = frameBufferFormat;
        }
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        RenderTexture.prototype.upload = function (context3D) {
            if (!this.texture2D) {
                this.texture2D = context3D.createFramebuffer(this.width, this.height, this.frameBufferFormat);
            }
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        RenderTexture.prototype.uploadForcing = function (context3D) {
        };
        return RenderTexture;
    }(egret3d.ITexture));
    egret3d.RenderTexture = RenderTexture;
})(egret3d || (egret3d = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var egret3d;
(function (egret3d) {
    /**
     * Endian 类中包含一些值，它们表示用于表示多字节数字的字节顺序。
     * 字节顺序为 bigEndian（最高有效字节位于最前）或 littleEndian（最低有效字节位于最前）。
     * @class egret3d.Endian
     * @classdesc
     */
    var Endian = (function () {
        function Endian() {
        }
        /**
         * 表示多字节数字的最低有效字节位于字节序列的最前面。
         * 十六进制数字 0x12345678 包含 4 个字节（每个字节包含 2 个十六进制数字）。最高有效字节为 0x12。最低有效字节为 0x78。（对于等效的十进制数字 305419896，最高有效数字是 3，最低有效数字是 6）。
         * @constant {string} egret.Endian.LITTLE_ENDIAN
         */
        Endian.LITTLE_ENDIAN = "littleEndian";
        /**
         * 表示多字节数字的最高有效字节位于字节序列的最前面。
         * 十六进制数字 0x12345678 包含 4 个字节（每个字节包含 2 个十六进制数字）。最高有效字节为 0x12。最低有效字节为 0x78。（对于等效的十进制数字 305419896，最高有效数字是 3，最低有效数字是 6）。
         * @constant {string} egret.Endian.BIG_ENDIAN
         */
        Endian.BIG_ENDIAN = "bigEndian";
        return Endian;
    }());
    egret3d.Endian = Endian;
    /**
     * @class egret.ByteArray
     * @classdesc
     * ByteArray 类提供用于优化读取、写入以及处理二进制数据的方法和属性。
     * 注意：ByteArray 类适用于需要在字节层访问数据的高级 开发人员。
     */
    var ByteArray = (function () {
        /**
        * 创建一个 egret.ByteArray 对象以引用指定的 ArrayBuffer 对象
        * @param buffer {ArrayBuffer} 数据源
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ByteArray(buffer) {
            this.BUFFER_EXT_SIZE = 0; //Buffer expansion size
            this.EOF_byte = -1;
            this.EOF_code_point = -1;
            this._setArrayBuffer(buffer || new ArrayBuffer(this.BUFFER_EXT_SIZE));
            this.endian = Endian.BIG_ENDIAN;
        }
        ByteArray.prototype._setArrayBuffer = function (buffer) {
            this.write_position = buffer.byteLength;
            this.data = new DataView(buffer);
            this._position = 0;
        };
        Object.defineProperty(ByteArray.prototype, "buffer", {
            /**
            * @language zh_CN
            * 获取ArrayBuffer
            * @returns ArrayBuffer
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.data.buffer;
            },
            /**
            * @language zh_CN
            * 设置ArrayBuffer
            * @param value
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.data = new DataView(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ByteArray.prototype, "dataView", {
            /**
            * @language zh_CN
            * 获取dataView
            * @returns DataView
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.data;
            },
            /**
            * @language zh_CN
            * 设置DataView
            * @param value
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.data = value;
                this.write_position = value.byteLength;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         */
        ByteArray.prototype.uncompress = function (type) {
            if (type === void 0) { type = "7z"; }
            //var decoder: nid.LZMA = new nid.LZMA();
            //var tmp: ArrayBuffer = decoder.decode(new Uint8Array(this.data.buffer)).buffer;
            //this.buffer = tmp; 
            //decoder = null;
        };
        Object.defineProperty(ByteArray.prototype, "bufferOffset", {
            /**
            * @language zh_CN
            * 获取buffer的偏移位置
            * @rerurns number 偏移位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.data.byteOffset;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ByteArray.prototype, "position", {
            /**
            * @language zh_CN
            * 将文件指针的当前位置（以字节为单位）移动或返回到 ByteArray 对象中。下一次调用读取方法时将在此位置开始读取，或者下一次调用写入方法时将在此位置开始写入。
            * @rerurns number 当前位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._position;
            },
            /**
            * @language zh_CN
            * 设置文件指针的当前位置
            * @param value 当前位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._position < value) {
                    if (!this.validate(value - this._position)) {
                        return;
                    }
                }
                this._position = value;
                this.write_position = value > this.write_position ? value : this.write_position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ByteArray.prototype, "length", {
            /**
            * @language zh_CN
            * ByteArray 对象的长度（以字节为单位）。
            * 如果将长度设置为大于当前长度的值，则用零填充字节数组的右侧。
            * 如果将长度设置为小于当前长度的值，将会截断该字节数组。
            * @member {number} egret.ByteArray#length
            * @returns number ByteArray的长度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.write_position;
            },
            /**
            * @language zh_CN
            * 设置ByteArray 对象的长度（以字节为单位）。
            * @param value ByteArray对象的长度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.validateBuffer(value, true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ByteArray.prototype, "bytesAvailable", {
            /**
             * 可从字节数组的当前位置到数组末尾读取的数据的字节数。
             * 每次访问 ByteArray 对象时，将 bytesAvailable 属性与读取方法结合使用，以确保读取有效的数据。
             * @member {number} egret.ByteArray#bytesAvailable
             */
            get: function () {
                return this.data.byteLength - this._position;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 清除字节数组的内容，并将 length 和 position 属性重置为 0。
         * @method egret.ByteArray#clear
         */
        ByteArray.prototype.clear = function () {
            //this._position = 0;
            this._setArrayBuffer(new ArrayBuffer(this.BUFFER_EXT_SIZE));
        };
        //public getArray():Uint8Array {
        //    if (this.array == null) {
        //        this.array = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
        //    }
        //    return this.array;
        //}
        /**
         * 从字节流中读取布尔值。读取单个字节，如果字节非零，则返回 true，否则返回 false
         * @returns 如果字节不为零，则返回 true，否则返回 false
         * @method egret.ByteArray#readBoolean
         */
        ByteArray.prototype.readBoolean = function () {
            if (!this.validate(ByteArray.SIZE_OF_BOOLEAN))
                return null;
            return this.data.getUint8(this.position++) != 0;
        };
        /**
         * 从字节流中读取带符号的字节
         * @returns 介于 -128 和 127 之间的整数
         * @method egret.ByteArray#readByte
         */
        ByteArray.prototype.readByte = function () {
            if (!this.validate(ByteArray.SIZE_OF_INT8))
                return null;
            return this.data.getInt8(this.position++);
        };
        /**
         * 从字节流中读取 length 参数指定的数据字节数。从 offset 指定的位置开始，将字节读入 bytes 参数指定的 ByteArray 对象中，并将字节写入目标 ByteArray 中
         * @param bytes 要将数据读入的 ByteArray 对象
         * @param offset bytes 中的偏移（位置），应从该位置写入读取的数据
         * @param length 要读取的字节数。默认值 0 导致读取所有可用的数据
         * @method egret.ByteArray#readBytes
         */
        ByteArray.prototype.readBytes = function (bytes, offset, length) {
            if (offset === void 0) { offset = 0; }
            if (length === void 0) { length = 0; }
            if (length == 0) {
                length = this.bytesAvailable;
            }
            else if (!this.validate(length)) {
                return null;
            }
            if (bytes) {
                bytes.validateBuffer(length);
            }
            else {
                bytes = new ByteArray(new ArrayBuffer(length));
            }
            //This method is expensive
            for (var i = 0; i < length; i++) {
                bytes.data.setUint8(i + offset, this.data.getUint8(this.position++));
            }
        };
        //public get leftBytes():ArrayBuffer {
        //    var begin = this.data.byteOffset + this.position;
        //    var end = this.data.byteLength;
        //    var result = new ArrayBuffer(end - begin);
        //    var resultBytes = new Uint8Array(result);
        //    var sourceBytes = new Uint8Array(this.data.buffer, begin, end - begin);
        //    resultBytes.set(sourceBytes);
        //    return resultBytes.buffer;
        //}
        /**
         * 从字节流中读取一个 IEEE 754 双精度（64 位）浮点数
         * @returns 双精度（64 位）浮点数
         * @method egret.ByteArray#readDouble
         */
        ByteArray.prototype.readDouble = function () {
            if (!this.validate(ByteArray.SIZE_OF_FLOAT64))
                return null;
            var value = this.data.getFloat64(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_FLOAT64;
            return value;
        };
        /**
         * 从字节流中读取一个 IEEE 754 单精度（32 位）浮点数
         * @returns 单精度（32 位）浮点数
         * @method egret.ByteArray#readFloat
         */
        ByteArray.prototype.readFloat = function () {
            if (!this.validate(ByteArray.SIZE_OF_FLOAT32))
                return null;
            var value = this.data.getFloat32(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_FLOAT32;
            return value;
        };
        /**
         * 从字节流中读取一个带符号的 32 位整数
         * @returns 介于 -2147483648 和 2147483647 之间的 32 位带符号整数
         * @method egret.ByteArray#readFloat
         */
        ByteArray.prototype.readInt = function () {
            if (!this.validate(ByteArray.SIZE_OF_INT32))
                return null;
            var value = this.data.getInt32(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_INT32;
            return value;
        };
        //        public readInt64():Int64{
        //            if (!this.validate(ByteArray.SIZE_OF_UINT32)) return null;
        //
        //            var low = this.data.getInt32(this.position, this.endian == Endian.LITTLE_ENDIAN);
        //            this.position += ByteArray.SIZE_OF_INT32;
        //            var high = this.data.getInt32(this.position, this.endian == Endian.LITTLE_ENDIAN);
        //            this.position += ByteArray.SIZE_OF_INT32;
        //            return new Int64(low,high);
        //        }
        /**
         * 使用指定的字符集从字节流中读取指定长度的多字节字符串
         * @param length 要从字节流中读取的字节数
         * @param charSet 表示用于解释字节的字符集的字符串。可能的字符集字符串包括 "shift-jis"、"cn-gb"、"iso-8859-1"”等
         * @returns UTF-8 编码的字符串
         * @method egret.ByteArray#readMultiByte
         */
        //public readMultiByte(length:number, charSet?:string):string {
        //    if (!this.validate(length)) return null;
        //
        //    return "";
        //}
        /**
         * 从字节流中读取一个带符号的 16 位整数
         * @returns 介于 -32768 和 32767 之间的 16 位带符号整数
         * @method egret.ByteArray#readShort
         */
        ByteArray.prototype.readShort = function () {
            if (!this.validate(ByteArray.SIZE_OF_INT16))
                return null;
            var value = this.data.getInt16(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_INT16;
            return value;
        };
        /**
         * 从字节流中读取无符号的字节
         * @returns 介于 0 和 255 之间的 32 位无符号整数
         * @method egret.ByteArray#readUnsignedByte
         */
        ByteArray.prototype.readUnsignedByte = function () {
            if (!this.validate(ByteArray.SIZE_OF_UINT8))
                return null;
            return this.data.getUint8(this.position++);
        };
        /**
         * 从字节流中读取一个无符号的 32 位整数
         * @returns 介于 0 和 4294967295 之间的 32 位无符号整数
         * @method egret.ByteArray#readUnsignedInt
         */
        ByteArray.prototype.readUnsignedInt = function () {
            if (!this.validate(ByteArray.SIZE_OF_UINT32))
                return null;
            var value = this.data.getUint32(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT32;
            return value;
        };
        //public readVariableSizedUnsignedInt():number {
        //    var i:number;
        //    var c:number = this.data.getUint8(this.position++);
        //    if (c != 0xFF) {
        //        i = c << 8;
        //        c = this.data.getUint8(this.position++);
        //        i |= c;
        //    }
        //    else {
        //        c = this.data.getUint8(this.position++);
        //        i = c << 16;
        //        c = this.data.getUint8(this.position++);
        //        i |= c << 8;
        //        c = this.data.getUint8(this.position++);
        //        i |= c;
        //    }
        //    return i;
        //}
        //		public readUnsignedInt64():UInt64{
        //            if (!this.validate(ByteArray.SIZE_OF_UINT32)) return null;
        //
        //            var low = this.data.getUint32(this.position, this.endian == Endian.LITTLE_ENDIAN);
        //            this.position += ByteArray.SIZE_OF_UINT32;
        //            var high = this.data.getUint32(this.position, this.endian == Endian.LITTLE_ENDIAN);
        //            this.position += ByteArray.SIZE_OF_UINT32;
        //			return new UInt64(low,high);
        //        }
        /**
         * 从字节流中读取一个无符号的 16 位整数
         * @returns 介于 0 和 65535 之间的 16 位无符号整数
         * @method egret.ByteArray#readUnsignedShort
         */
        ByteArray.prototype.readUnsignedShort = function () {
            if (!this.validate(ByteArray.SIZE_OF_UINT16))
                return null;
            var value = this.data.getUint16(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT16;
            return value;
        };
        /**
         * 从字节流中读取一个 UTF-8 字符串。假定字符串的前缀是无符号的短整型（以字节表示长度）
         * @returns UTF-8 编码的字符串
         * @method egret.ByteArray#readUTF
         */
        ByteArray.prototype.readUTF = function () {
            if (!this.validate(ByteArray.SIZE_OF_UINT16))
                return null;
            var length = this.data.getUint16(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT16;
            if (length > 0) {
                return this.readUTFBytes(length);
            }
            else {
                return "";
            }
        };
        /**
         * 从字节流中读取一个由 length 参数指定的 UTF-8 字节序列，并返回一个字符串
         * @param length 指明 UTF-8 字节长度的无符号短整型数
         * @returns 由指定长度的 UTF-8 字节组成的字符串
         * @method egret.ByteArray#readUTFBytes
         */
        ByteArray.prototype.readUTFBytes = function (length) {
            if (!this.validate(length))
                return null;
            var bytes = new Uint8Array(this.buffer, this.bufferOffset + this.position, length);
            this.position += length;
            /*var bytes: Uint8Array = new Uint8Array(new ArrayBuffer(length));
             for (var i = 0; i < length; i++) {
             bytes[i] = this.data.getUint8(this.position++);
             }*/
            return this.decodeUTF8(bytes);
        };
        //public readStandardString(length:number):string {
        //    if (!this.validate(length)) return null;
        //
        //    var str:string = "";
        //
        //    for (var i = 0; i < length; i++) {
        //        str += String.fromCharCode(this.data.getUint8(this.position++));
        //    }
        //    return str;
        //}
        //public readStringTillNull(keepEvenByte:boolean = true):string {
        //
        //    var str:string = "";
        //    var num:number = 0;
        //    while (this.bytesAvailable > 0) {
        //        var b:number = this.data.getUint8(this.position++);
        //        num++;
        //        if (b != 0) {
        //            str += String.fromCharCode(b);
        //        } else {
        //            if (keepEvenByte && num % 2 != 0) {
        //                this.position++;
        //            }
        //            break;
        //        }
        //    }
        //    return str;
        //}
        /**
         * 写入布尔值。根据 value 参数写入单个字节。如果为 true，则写入 1，如果为 false，则写入 0
         * @param value 确定写入哪个字节的布尔值。如果该参数为 true，则该方法写入 1；如果该参数为 false，则该方法写入 0
         * @method egret.ByteArray#writeBoolean
         */
        ByteArray.prototype.writeBoolean = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_BOOLEAN);
            this.data.setUint8(this.position++, value ? 1 : 0);
        };
        /**
         * 在字节流中写入一个字节
         * 使用参数的低 8 位。忽略高 24 位
         * @param value 一个 32 位整数。低 8 位将被写入字节流
         * @method egret.ByteArray#writeByte
         */
        ByteArray.prototype.writeByte = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_INT8);
            this.data.setInt8(this.position++, value);
        };
        //public writeUnsignedByte(value:number):void {
        //    this.validateBuffer(ByteArray.SIZE_OF_UINT8);
        //
        //    this.data.setUint8(this.position++, value);
        //}
        /**
         * 将指定字节数组 bytes（起始偏移量为 offset，从零开始的索引）中包含 length 个字节的字节序列写入字节流
         * 如果省略 length 参数，则使用默认长度 0；该方法将从 offset 开始写入整个缓冲区。如果还省略了 offset 参数，则写入整个缓冲区
         * 如果 offset 或 length 超出范围，它们将被锁定到 bytes 数组的开头和结尾
         * @param bytes ByteArray 对象
         * @param offset 从 0 开始的索引，表示在数组中开始写入的位置
         * @param length 一个无符号整数，表示在缓冲区中的写入范围
         * @method egret.ByteArray#writeBytes
         */
        ByteArray.prototype.writeBytes = function (bytes, offset, length) {
            if (offset === void 0) { offset = 0; }
            if (length === void 0) { length = 0; }
            var writeLength;
            if (offset < 0) {
                return;
            }
            if (length < 0) {
                return;
            }
            else if (length == 0) {
                writeLength = bytes.length - offset;
            }
            else {
                writeLength = Math.min(bytes.length - offset, length);
            }
            if (writeLength > 0) {
                this.validateBuffer(writeLength);
                var tmp_data = new DataView(bytes.buffer);
                for (var i = offset; i < writeLength + offset; i++) {
                    this.data.setUint8(this.position++, tmp_data.getUint8(i));
                }
            }
        };
        /**
         * 在字节流中写入一个 IEEE 754 双精度（64 位）浮点数
         * @param value 双精度（64 位）浮点数
         * @method egret.ByteArray#writeDouble
         */
        ByteArray.prototype.writeDouble = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_FLOAT64);
            this.data.setFloat64(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_FLOAT64;
        };
        /**
         * 在字节流中写入一个 IEEE 754 单精度（32 位）浮点数
         * @param value 单精度（32 位）浮点数
         * @method egret.ByteArray#writeFloat
         */
        ByteArray.prototype.writeFloat = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_FLOAT32);
            this.data.setFloat32(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_FLOAT32;
        };
        /**
         * 在字节流中写入一个带符号的 32 位整数
         * @param value 要写入字节流的整数
         * @method egret.ByteArray#writeInt
         */
        ByteArray.prototype.writeInt = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_INT32);
            this.data.setInt32(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_INT32;
        };
        /**
         * 使用指定的字符集将多字节字符串写入字节流
         * @param value 要写入的字符串值
         * @param charSet 表示要使用的字符集的字符串。可能的字符集字符串包括 "shift-jis"、"cn-gb"、"iso-8859-1"”等
         * @method egret.ByteArray#writeMultiByte
         */
        //public writeMultiByte(value:string, charSet:string):void {
        //
        //}
        /**
         * 在字节流中写入一个 16 位整数。使用参数的低 16 位。忽略高 16 位
         * @param value 32 位整数，该整数的低 16 位将被写入字节流
         * @method egret.ByteArray#writeShort
         */
        ByteArray.prototype.writeShort = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_INT16);
            this.data.setInt16(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_INT16;
        };
        //public writeUnsignedShort(value:number):void {
        //    this.validateBuffer(ByteArray.SIZE_OF_UINT16);
        //
        //    this.data.setUint16(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
        //    this.position += ByteArray.SIZE_OF_UINT16;
        //}
        /**
         * 在字节流中写入一个无符号的 32 位整数
         * @param value 要写入字节流的无符号整数
         * @method egret.ByteArray#writeUnsignedInt
         */
        ByteArray.prototype.writeUnsignedInt = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_UINT32);
            this.data.setUint32(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT32;
        };
        /**
         * 将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节
         * @param value 要写入的字符串值
         * @method egret.ByteArray#writeUTF
         */
        ByteArray.prototype.writeUTF = function (value) {
            var utf8bytes = this.encodeUTF8(value);
            var length = utf8bytes.length;
            this.validateBuffer(ByteArray.SIZE_OF_UINT16 + length);
            this.data.setUint16(this.position, length, this.endian === Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT16;
            this._writeUint8Array(utf8bytes, false);
        };
        /**
         * 将 UTF-8 字符串写入字节流。类似于 writeUTF() 方法，但 writeUTFBytes() 不使用 16 位长度的词为字符串添加前缀
         * @param value 要写入的字符串值
         * @method egret.ByteArray#writeUTFBytes
         */
        ByteArray.prototype.writeUTFBytes = function (value) {
            this._writeUint8Array(this.encodeUTF8(value));
        };
        ByteArray.prototype.toString = function () {
            return "[ByteArray] length:" + this.length + ", bytesAvailable:" + this.bytesAvailable;
        };
        /**
         * 将 Uint8Array 写入字节流
         * @param bytes 要写入的Uint8Array
         * @param validateBuffer
         */
        ByteArray.prototype._writeUint8Array = function (bytes, validateBuffer) {
            if (validateBuffer === void 0) { validateBuffer = true; }
            if (validateBuffer) {
                this.validateBuffer(this.position + bytes.length);
            }
            for (var i = 0; i < bytes.length; i++) {
                this.data.setUint8(this.position++, bytes[i]);
            }
        };
        /**
         * @private
         */
        ByteArray.prototype.validate = function (len) {
            //len += this.data.byteOffset;
            if (this.data.byteLength > 0 && this._position + len <= this.data.byteLength) {
                return true;
            }
            else {
            }
        };
        /*********************/
        /*  PRIVATE METHODS   */
        /*********************/
        ByteArray.prototype.validateBuffer = function (len, needReplace) {
            if (needReplace === void 0) { needReplace = false; }
            this.write_position = len > this.write_position ? len : this.write_position;
            len += this._position;
            if (this.data.byteLength < len || needReplace) {
                var tmp = new Uint8Array(new ArrayBuffer(len + this.BUFFER_EXT_SIZE));
                var length = Math.min(this.data.buffer.byteLength, len + this.BUFFER_EXT_SIZE);
                tmp.set(new Uint8Array(this.data.buffer, 0, length));
                this.buffer = tmp.buffer;
            }
        };
        /**
         * UTF-8 Encoding/Decoding
         */
        ByteArray.prototype.encodeUTF8 = function (str) {
            var pos = 0;
            var codePoints = this.stringToCodePoints(str);
            var outputBytes = [];
            while (codePoints.length > pos) {
                var code_point = codePoints[pos++];
                if (this.inRange(code_point, 0xD800, 0xDFFF)) {
                    this.encoderError(code_point);
                }
                else if (this.inRange(code_point, 0x0000, 0x007f)) {
                    outputBytes.push(code_point);
                }
                else {
                    var count, offset;
                    if (this.inRange(code_point, 0x0080, 0x07FF)) {
                        count = 1;
                        offset = 0xC0;
                    }
                    else if (this.inRange(code_point, 0x0800, 0xFFFF)) {
                        count = 2;
                        offset = 0xE0;
                    }
                    else if (this.inRange(code_point, 0x10000, 0x10FFFF)) {
                        count = 3;
                        offset = 0xF0;
                    }
                    outputBytes.push(this.div(code_point, Math.pow(64, count)) + offset);
                    while (count > 0) {
                        var temp = this.div(code_point, Math.pow(64, count - 1));
                        outputBytes.push(0x80 + (temp % 64));
                        count -= 1;
                    }
                }
            }
            return new Uint8Array(outputBytes);
        };
        ByteArray.prototype.decodeUTF8 = function (data) {
            var fatal = false;
            var pos = 0;
            var result = "";
            var code_point;
            var utf8_code_point = 0;
            var utf8_bytes_needed = 0;
            var utf8_bytes_seen = 0;
            var utf8_lower_boundary = 0;
            while (data.length > pos) {
                var _byte = data[pos++];
                if (_byte === this.EOF_byte) {
                    if (utf8_bytes_needed !== 0) {
                        code_point = this.decoderError(fatal);
                    }
                    else {
                        code_point = this.EOF_code_point;
                    }
                }
                else {
                    if (utf8_bytes_needed === 0) {
                        if (this.inRange(_byte, 0x00, 0x7F)) {
                            code_point = _byte;
                        }
                        else {
                            if (this.inRange(_byte, 0xC2, 0xDF)) {
                                utf8_bytes_needed = 1;
                                utf8_lower_boundary = 0x80;
                                utf8_code_point = _byte - 0xC0;
                            }
                            else if (this.inRange(_byte, 0xE0, 0xEF)) {
                                utf8_bytes_needed = 2;
                                utf8_lower_boundary = 0x800;
                                utf8_code_point = _byte - 0xE0;
                            }
                            else if (this.inRange(_byte, 0xF0, 0xF4)) {
                                utf8_bytes_needed = 3;
                                utf8_lower_boundary = 0x10000;
                                utf8_code_point = _byte - 0xF0;
                            }
                            else {
                                this.decoderError(fatal);
                            }
                            utf8_code_point = utf8_code_point * Math.pow(64, utf8_bytes_needed);
                            code_point = null;
                        }
                    }
                    else if (!this.inRange(_byte, 0x80, 0xBF)) {
                        utf8_code_point = 0;
                        utf8_bytes_needed = 0;
                        utf8_bytes_seen = 0;
                        utf8_lower_boundary = 0;
                        pos--;
                        code_point = this.decoderError(fatal, _byte);
                    }
                    else {
                        utf8_bytes_seen += 1;
                        utf8_code_point = utf8_code_point + (_byte - 0x80) * Math.pow(64, utf8_bytes_needed - utf8_bytes_seen);
                        if (utf8_bytes_seen !== utf8_bytes_needed) {
                            code_point = null;
                        }
                        else {
                            var cp = utf8_code_point;
                            var lower_boundary = utf8_lower_boundary;
                            utf8_code_point = 0;
                            utf8_bytes_needed = 0;
                            utf8_bytes_seen = 0;
                            utf8_lower_boundary = 0;
                            if (this.inRange(cp, lower_boundary, 0x10FFFF) && !this.inRange(cp, 0xD800, 0xDFFF)) {
                                code_point = cp;
                            }
                            else {
                                code_point = this.decoderError(fatal, _byte);
                            }
                        }
                    }
                }
                //Decode string
                if (code_point !== null && code_point !== this.EOF_code_point) {
                    if (code_point <= 0xFFFF) {
                        if (code_point > 0)
                            result += String.fromCharCode(code_point);
                    }
                    else {
                        code_point -= 0x10000;
                        result += String.fromCharCode(0xD800 + ((code_point >> 10) & 0x3ff));
                        result += String.fromCharCode(0xDC00 + (code_point & 0x3ff));
                    }
                }
            }
            return result;
        };
        ByteArray.prototype.encoderError = function (code_point) {
            //$error(1026, code_point);
        };
        ByteArray.prototype.decoderError = function (fatal, opt_code_point) {
            if (fatal) {
            }
            return opt_code_point || 0xFFFD;
        };
        ByteArray.prototype.inRange = function (a, min, max) {
            return min <= a && a <= max;
        };
        ByteArray.prototype.div = function (n, d) {
            return Math.floor(n / d);
        };
        ByteArray.prototype.stringToCodePoints = function (string) {
            /** @type {Array.<number>} */
            var cps = [];
            // Based on http://www.w3.org/TR/WebIDL/#idl-DOMString
            var i = 0, n = string.length;
            while (i < string.length) {
                var c = string.charCodeAt(i);
                if (!this.inRange(c, 0xD800, 0xDFFF)) {
                    cps.push(c);
                }
                else if (this.inRange(c, 0xDC00, 0xDFFF)) {
                    cps.push(0xFFFD);
                }
                else {
                    if (i === n - 1) {
                        cps.push(0xFFFD);
                    }
                    else {
                        var d = string.charCodeAt(i + 1);
                        if (this.inRange(d, 0xDC00, 0xDFFF)) {
                            var a = c & 0x3FF;
                            var b = d & 0x3FF;
                            i += 1;
                            cps.push(0x10000 + (a << 10) + b);
                        }
                        else {
                            cps.push(0xFFFD);
                        }
                    }
                }
                i += 1;
            }
            return cps;
        };
        ByteArray.SIZE_OF_BOOLEAN = 1;
        ByteArray.SIZE_OF_INT8 = 1;
        ByteArray.SIZE_OF_INT16 = 2;
        ByteArray.SIZE_OF_INT32 = 4;
        ByteArray.SIZE_OF_UINT8 = 1;
        ByteArray.SIZE_OF_UINT16 = 2;
        ByteArray.SIZE_OF_UINT32 = 4;
        ByteArray.SIZE_OF_FLOAT32 = 4;
        ByteArray.SIZE_OF_FLOAT64 = 8;
        return ByteArray;
    }());
    egret3d.ByteArray = ByteArray;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.Debug
    * @classdesc
    * 调试面板
    */
    var Debug = (function () {
        /**
         * @language zh_CN
         * 构造
         */
        function Debug() {
            this.isDebug = false;
            this._console = document.createElement('console');
            document.body.appendChild(this._console);
            this._console.style.color = "red";
            this._console.style.zIndex = "1000";
            this._console.style.position = "absolute";
            this._console.style.top = "10px";
            this._console.style.left = "10px";
        }
        /**
         * @language zh_CN
         * 输出调试信息
         * @param parameters
         */
        Debug.prototype.trace = function () {
            var parameters = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                parameters[_i - 0] = arguments[_i];
            }
            if (this.isDebug) {
                this.reset();
                var len = parameters.length;
                for (var i = 0; i < len; i++) {
                    this._console.innerHTML += parameters[i] + "</br>";
                }
            }
        };
        /**
         * @language zh_CN
         * 重置显示数据
         */
        Debug.prototype.reset = function () {
            this._console.innerHTML = "";
        };
        Object.defineProperty(Debug, "instance", {
            /**
             * @language zh_CN
             * 取到当前Debug单例对象
             */
            get: function () {
                if (this._instance == null) {
                    this._instance = new Debug();
                }
                return this._instance;
            },
            enumerable: true,
            configurable: true
        });
        Debug._instance = null;
        return Debug;
    }());
    egret3d.Debug = Debug;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @class egret3d.StringUtil
     * @classdesc
     * 字符串处理工具类
     */
    var StringUtil = (function () {
        function StringUtil() {
        }
        /**
         * @language zh_CN
         * @private
         * 解析文件内容(按行解析)
         * @param file
         * @returns 行列表
         */
        StringUtil.parseContent = function (file) {
            var shaderList = new Array();
            var node = "";
            var endChar = ";";
            var index = -1;
            for (var i = 0; i < file.length; ++i) {
                if (file.charAt(i) == "{") {
                    index = node.indexOf("=");
                    if (index < 0) {
                        endChar = "}";
                    }
                }
                if (node == "") {
                    if (file.charAt(i) == " " || file.charAt(i) == "    " || file.charAt(i) == "\t") {
                        continue;
                    }
                }
                node += file.charAt(i);
                if (endChar != "\n") {
                    if (node.indexOf("#extension") >= 0) {
                        endChar = "\n";
                    }
                }
                if (endChar == file.charAt(i)) {
                    if (endChar == "}") {
                        var s_num = 0;
                        var e_num = 0;
                        for (var j = 0; j < node.length; ++j) {
                            if (node.charAt(j) == "{") {
                                s_num++;
                            }
                            else if (node.charAt(j) == "}") {
                                e_num++;
                            }
                        }
                        if (s_num != e_num) {
                            continue;
                        }
                        if (node.indexOf("struct") >= 0) {
                            endChar = ";";
                            continue;
                        }
                    }
                    if (node.length > 0) {
                        shaderList.push(node);
                    }
                    node = "";
                    endChar = ";";
                }
            }
            return shaderList;
        };
        /**
         * @language zh_CN
         * 解析一行的内容 有多少个成员
         * @param line 源内容
         * @returns 成员列表
         */
        StringUtil.parseLines = function (line) {
            var list = new Array();
            var value = "";
            var isE = false;
            for (var i = 0; i < line.length; ++i) {
                if (isE) {
                    if (line.charAt(i) == ";") {
                        isE = false;
                        if (value.length > 0) {
                            list.push(value);
                            value = "";
                        }
                        break;
                    }
                    value += line.charAt(i);
                    continue;
                }
                if (line.charAt(i) != " " && line.charAt(i) != "\t" && line.charAt(i) != "," &&
                    line.charAt(i) != "\r" && line.charAt(i) != "\n" && line.charAt(i) != ":") {
                    if (line.charAt(i) == ";") {
                        if (value.length > 0) {
                            list.push(value);
                            value = "";
                        }
                        break;
                    }
                    else if (line.charAt(i) == "=") {
                        if (value.length > 0) {
                            list.push(value);
                            value = "";
                        }
                        list.push("=");
                        isE = true;
                        continue;
                    }
                    value += line.charAt(i);
                    if (i == line.length - 1 && line != "") {
                        list.push(value);
                        value = "";
                    }
                }
                else {
                    if (value != "") {
                        list.push(value);
                        value = "";
                    }
                }
            }
            return list;
        };
        /**
         * @language zh_CN
         * 是否存在此字符串
         * @param fields 被检测的列表
         * @param str 比较字符串
         * @returns 成功返回true
         */
        StringUtil.hasString = function (fields, str) {
            for (var i = 0; i < fields.length; ++i) {
                if (fields[i] == str) {
                    return i;
                }
            }
            return -1;
        };
        /**
         * @language zh_CN
         * 得到值的内容
         * @param fields 成员列表
         * @returns 值
         */
        StringUtil.getVarName = function (fields) {
            var index = this.hasString(fields, "=");
            if (index >= 0) {
                index -= 1;
                if (index >= 0 && index < fields.length) {
                    return fields[index];
                }
            }
            else {
                index = fields.length - 1;
                if (index >= 0 && index < fields.length) {
                    return fields[index];
                }
            }
            return "";
        };
        /**
         * @language zh_CN
         * 返回变量的值
         * @param fields 变量数据列表
         * @returns 变量的值
         */
        StringUtil.getVarValue = function (fields) {
            var index = this.hasString(fields, "=");
            if (index >= 0) {
                index += 1;
                if (index >= 0 && index < fields.length) {
                    return fields[index];
                }
            }
            return "";
        };
        /**
         * @language zh_CN
         * 返回变量类型
         * @param fields 变量数据列表
         * @returns 变量类型
         */
        StringUtil.getVarType = function (fields) {
            var index = this.hasString(fields, "=");
            if (index >= 0) {
                index -= 2;
                if (index >= 0 && index < fields.length) {
                    return fields[index];
                }
            }
            else {
                index = fields.length - 2;
                if (index >= 0 && index < fields.length) {
                    return fields[index];
                }
            }
            return "";
        };
        /**
         * @language zh_CN
         * 返回变量属性
         * @param fields 变量数据列表
         * @returns 变量属性
         */
        StringUtil.getVarKey = function (fields) {
            var index = this.hasString(fields, "=");
            if (index >= 0) {
                index -= 3;
                if (index >= 0 && index < fields.length) {
                    return fields[index];
                }
            }
            else {
                index = fields.length - 3;
                if (index >= 0 && index < fields.length) {
                    return fields[index];
                }
            }
            return "";
        };
        /**
         * @language zh_CN
         * @private
         * 筛选文件中的指定字符去掉
         * @param file xxx
         * @returns 筛选后的字符
         */
        StringUtil.processShaderFile = function (file) {
            var filterChar = ["\n", "\r"];
            filterChar = [];
            var src = file;
            var dest = src;
            while (true) {
                var pos = src.indexOf("//");
                if (pos < 0) {
                    break;
                }
                var end = src.indexOf("\r\n", pos);
                if (end == -1) {
                    end = src.indexOf("\n", pos);
                }
                var slice_s = src.slice(pos, end);
                src = src.replace(slice_s, "");
                if (src == dest) {
                    break;
                }
                dest = src;
            }
            for (var i = 0; i < filterChar.length; ++i) {
                while (true) {
                    dest = src.replace(filterChar[i], "");
                    if (src == dest) {
                        break;
                    }
                    src = dest;
                }
            }
            return src;
        };
        /**
         * @language zh_CN
         * 解析字符颜色值
         * @param color
         * @returns
         */
        StringUtil.colorRgb = function (color) {
            var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
            var sColor = color.toLowerCase();
            if (sColor && reg.test(sColor)) {
                if (sColor.length === 4) {
                    var sColorNew = "#";
                    for (var i = 1; i < 4; i += 1) {
                        sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
                    }
                    sColor = sColorNew;
                }
                //处理六位的颜色值  
                var sColorChange = [];
                for (var i = 1; i < 7; i += 2) {
                    sColorChange.push(parseInt("0x" + sColor.slice(i, i + 2)));
                }
                return "RGB(" + sColorChange.join(",") + ")";
            }
            else {
                return sColor;
            }
        };
        /**
         * @language zh_CN
         * @private
         * @returns
         */
        StringUtil.getLineType = function (line) {
            var index = line.indexOf("{");
            if (index > 0) {
                var firstStr = line.substr(0, index);
                if (firstStr.indexOf("struct") >= 0) {
                    var s_pos = firstStr.lastIndexOf(" ");
                    s_pos++;
                    var structName = firstStr.substr(s_pos, firstStr.length - s_pos);
                    return ("struct " + structName);
                }
                if (firstStr.indexOf("=") < 0) {
                    var pos = line.indexOf("(");
                    var s_pos = line.lastIndexOf(" ", pos);
                    s_pos++;
                    var func = line.substr(s_pos, pos - s_pos);
                    return ("function " + func);
                }
            }
            return "unknown";
        };
        /**
         * @language zh_CN
         * @private
         * @returns
         */
        StringUtil.processStruct = function (name, structStr, content) {
            var pos = structStr.lastIndexOf("}");
            pos++;
            var end = structStr.lastIndexOf(";");
            var varName = structStr.substr(pos, end - pos);
            var varList = StringUtil.parseLines(varName);
            for (var i = 0; i < varList.length; ++i) {
                var varTmp = StringUtil.getTemper(name + " " + varList[i] + ";");
                if (varTmp)
                    content.addVar(varTmp);
            }
        };
        /**
         * @language zh_CN
         * @private
         * @returns
         */
        StringUtil.getAttribute = function (shaderLine) {
            var tempStr = shaderLine;
            var tmpName;
            var valueType;
            var attribute;
            var tempArray = StringUtil.parseLines(tempStr);
            tmpName = StringUtil.getVarName(tempArray);
            valueType = StringUtil.getVarType(tempArray);
            attribute = new egret3d.GLSL.Attribute(tmpName, valueType);
            attribute.value = StringUtil.getVarValue(tempArray);
            return attribute;
        };
        /**
        * @language zh_CN
        * @private
        * @returns
        */
        StringUtil.getTemper = function (shaderLine) {
            var tempStr = shaderLine;
            var tmpName;
            var valueType;
            var tmpVar;
            var tempArray = StringUtil.parseLines(tempStr);
            tmpName = StringUtil.getVarName(tempArray);
            valueType = StringUtil.getVarType(tempArray);
            tmpVar = new egret3d.GLSL.TmpVar(tmpName, valueType);
            tmpVar.value = StringUtil.getVarValue(tempArray);
            return tmpVar;
        };
        /**
        * @language zh_CN
        * @private
        * @returns
        */
        StringUtil.getVarying = function (shaderLine) {
            var tempStr = shaderLine;
            var varyingName;
            var valueType;
            var varying;
            var tempArray = StringUtil.parseLines(tempStr);
            varyingName = StringUtil.getVarName(tempArray);
            valueType = StringUtil.getVarType(tempArray);
            varying = new egret3d.GLSL.Varying(varyingName, valueType);
            return varying;
        };
        /**
        * @language zh_CN
        * @private
        * @returns
        */
        StringUtil.getUniform = function (shaderLine) {
            var tempStr = shaderLine;
            var uniformName;
            var valueType;
            var uniform;
            var tempArray = StringUtil.parseLines(tempStr);
            uniformName = StringUtil.getVarName(tempArray);
            valueType = StringUtil.getVarType(tempArray);
            uniform = new egret3d.GLSL.Uniform(uniformName, valueType);
            return uniform;
        };
        /**
        * @language zh_CN
        * @private
        * @returns
        */
        StringUtil.getConst = function (shaderLine) {
            var tempStr = shaderLine;
            var constVarName;
            var valueType;
            var varValue;
            var constVar;
            var tempArray = StringUtil.parseLines(tempStr);
            constVarName = StringUtil.getVarName(tempArray);
            valueType = StringUtil.getVarType(tempArray);
            varValue = StringUtil.getVarValue(tempArray);
            constVar = new egret3d.GLSL.ConstVar(constVarName, valueType, varValue);
            return constVar;
        };
        StringUtil.getExtension = function (shaderLine) {
            var start = shaderLine.indexOf("#");
            var end = shaderLine.indexOf(" ");
            var type = shaderLine.substr(start, end);
            var namePosEnd = shaderLine.indexOf(":");
            var name = shaderLine.substr(end, namePosEnd - end);
            name = StringUtil.replaceCharacter(name, [" "], "");
            namePosEnd += 1;
            var value = shaderLine.substr(namePosEnd, shaderLine.length - namePosEnd);
            value = StringUtil.replaceCharacter(value, [" ", ":", "\n", "\r"], "");
            var extension = new egret3d.GLSL.Extension(name);
            extension.value = value;
            return extension;
        };
        /**
        * @language zh_CN
        * @private
        * @returns
        */
        StringUtil.getSampler2D = function (shaderLine) {
            var tempStr = shaderLine;
            var sampler2DName;
            var valueType;
            var sampler2D;
            var tempArray = StringUtil.parseLines(tempStr);
            sampler2DName = StringUtil.getVarName(tempArray);
            sampler2D = new egret3d.GLSL.Sampler2D(sampler2DName);
            return sampler2D;
        };
        /**
        * @language zh_CN
        * @private
        * @returns
        */
        StringUtil.getSampler3D = function (shaderLine) {
            var tempStr = shaderLine;
            var sampler3DName;
            var valueType;
            var sampler3D;
            var tempArray = StringUtil.parseLines(tempStr);
            sampler3DName = StringUtil.getVarName(tempArray);
            sampler3D = new egret3d.GLSL.Sampler3D(sampler3DName);
            return sampler3D;
        };
        /**
        * @language zh_CN
        * @private
        * @returns
        */
        StringUtil.filterCharacter = function (name) {
            var src = name;
            var dest = src;
            for (var i = 0; i < StringUtil._filterChar.length; ++i) {
                while (true) {
                    dest = src.replace(StringUtil._filterChar[i], "");
                    if (src == dest) {
                        break;
                    }
                    src = dest;
                }
            }
            return dest;
        };
        StringUtil.replaceCharacter = function (src, searchValue, replaceValue) {
            var ret = src;
            var isBreak = false;
            while (!isBreak) {
                isBreak = true;
                for (var i = 0; i < searchValue.length; ++i) {
                    if (ret.indexOf(searchValue[i]) >= 0) {
                        isBreak = false;
                        break;
                    }
                }
                for (var i = 0; i < searchValue.length; ++i) {
                    ret = ret.replace(searchValue[i], replaceValue);
                }
            }
            return ret;
        };
        StringUtil.getURLName = function (url) {
            var urlArray = url.split(".");
            urlArray = urlArray[0].split("/");
            return urlArray[urlArray.length - 1];
        };
        /**
         * @language zh_CN
         * @private
         */
        StringUtil._filterChar = [" ", "  ", ";", "\n", "\r", "\t", "\n", "\r", "\t"];
        return StringUtil;
    }());
    egret3d.StringUtil = StringUtil;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var AxisMesh = (function (_super) {
        __extends(AxisMesh, _super);
        function AxisMesh(axisSize) {
            if (axisSize === void 0) { axisSize = 100; }
            _super.call(this);
            this._xMat = new egret3d.ColorMaterial(0xff0000);
            this._xMat.ambientColor = 0xf0f0f0;
            this._yMat = new egret3d.ColorMaterial(0x00ff00);
            this._yMat.ambientColor = 0xf0f0f0;
            this._zMat = new egret3d.ColorMaterial(0x0000ff);
            this._zMat.ambientColor = 0xf0f0f0;
            var geom;
            var lineSize = axisSize / 100;
            geom = new egret3d.CubeGeometry(axisSize, lineSize, lineSize);
            this._lineX = new egret3d.Mesh(geom, this._xMat);
            this.addChild(this._lineX);
            geom = new egret3d.CubeGeometry(lineSize, axisSize, lineSize);
            this._lineY = new egret3d.Mesh(geom, this._yMat);
            this.addChild(this._lineY);
            geom = new egret3d.CubeGeometry(lineSize, lineSize, axisSize);
            this._lineZ = new egret3d.Mesh(geom, this._zMat);
            this.addChild(this._lineZ);
            var boxSize = axisSize / 25;
            var offset = (axisSize - boxSize) / 2;
            geom = new egret3d.CubeGeometry(boxSize, boxSize, boxSize);
            this._boxX = new egret3d.Mesh(geom, this._xMat);
            this._boxX.position = new egret3d.Vector3D(offset, 0, 0);
            this.addChild(this._boxX);
            this._boxY = new egret3d.Mesh(geom, this._yMat);
            this._boxY.position = new egret3d.Vector3D(0, offset, 0);
            this.addChild(this._boxY);
            this._boxZ = new egret3d.Mesh(geom, this._zMat);
            this._boxZ.position = new egret3d.Vector3D(0, 0, offset);
            this.addChild(this._boxZ);
        }
        return AxisMesh;
    }(egret3d.Object3D));
    egret3d.AxisMesh = AxisMesh;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.CameraAnimationController
    * @classdesc
    * 摄像机动画控制器。
    * 每个摄像机动画绑定一个摄像机，控制摄像机的行为
    * 可以更换绑定的摄像机
    * @see egret3d.Camera3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CameraAnimationController = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @param camera 需要一个摄像机对象来创建摄像机动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        function CameraAnimationController(camera) {
            if (camera === void 0) { camera = null; }
            /**
            * @language zh_CN
            * 相机动画每帧数据列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cameraAnimationFrames = [];
            this._playing = false;
            this._playTime = 0;
            this._currentFrameIndex = 0;
            this._loop = true;
            this._smooth = true;
            this._cameraAnimationFrame = new CameraAnimationFrame();
            this._event = new egret3d.Event3D();
            this._quatCurrentFrame = new egret3d.Quaternion();
            this._quatnNextFrame = new egret3d.Quaternion();
            this._quatn = new egret3d.Quaternion();
            this._camera = camera;
            this._cameraAnimationFrame.fov = 45;
            this._cameraAnimationFrame.rotation = new egret3d.Vector3D();
            this._cameraAnimationFrame.translation = new egret3d.Vector3D();
        }
        /**
        * @language zh_CN
        * 绑定动画控制的相机
        * @param camera
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraAnimationController.prototype.bindCamera = function (camera) {
            this._camera = camera;
        };
        /**
        * @language zh_CN
        * 播放相机动画 是否循环
        * @param isLoop 是否循环播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraAnimationController.prototype.play = function (isLoop) {
            if (this.cameraAnimationFrames.length <= 0)
                return;
            this._loop = isLoop;
            this._playTime = 0;
            this._camera.isController = false;
            this._playing = true;
        };
        /**
        * @language zh_CN
        * 停止播放相机动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraAnimationController.prototype.stop = function () {
            this._camera.isController = true;
            this._playing = false;
        };
        /**
        * @private
        * @language zh_CN
        * 数据更新
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraAnimationController.prototype.update = function (time, delay) {
            if (!this._playing)
                return;
            this._playTime += delay * 5;
            var Tnow = this._playTime % ((this.cameraAnimationFrames[this.cameraAnimationFrames.length - 1].time - this.cameraAnimationFrames[0].time) + (160));
            var currentFrameIndex = Math.floor(Tnow / (160)) % this.cameraAnimationFrames.length;
            if (this._currentFrameIndex > currentFrameIndex) {
                if (!this._loop) {
                    this._playing = false;
                    this._camera.isController = true;
                }
                if (this._camera) {
                    this._event.eventType = CameraAnimationController.EVENT_CAMERA_COMPLETE;
                    this._event.target = this;
                    this._camera.dispatchEvent(this._event);
                }
            }
            this._currentFrameIndex = currentFrameIndex;
            var currentFrame = this.cameraAnimationFrames[currentFrameIndex];
            if (this._smooth) {
                var nextFrameIndex = (currentFrameIndex + 1) % this.cameraAnimationFrames.length;
                var nextFrame = this.cameraAnimationFrames[nextFrameIndex];
                var t = (Tnow - currentFrame.time) / Math.abs(nextFrame.time - currentFrame.time);
                ///(v1.x - v0.x) * t + v0.x;
                this._cameraAnimationFrame.fov = (nextFrame.fov - currentFrame.fov) * t + currentFrame.fov;
                this._quatCurrentFrame.fromEulerAngles(currentFrame.rotation.x, currentFrame.rotation.y, currentFrame.rotation.z);
                this._quatnNextFrame.fromEulerAngles(nextFrame.rotation.x, nextFrame.rotation.y, nextFrame.rotation.z);
                this._quatn.lerp(this._quatCurrentFrame, this._quatnNextFrame, t);
                this._quatn.toEulerAngles(this._cameraAnimationFrame.rotation);
                this._cameraAnimationFrame.translation.lerp(currentFrame.translation, nextFrame.translation, t);
            }
            else {
                this._cameraAnimationFrame.fov = currentFrame.fov;
                this._cameraAnimationFrame.rotation.copyFrom(currentFrame.rotation);
                this._cameraAnimationFrame.translation.copyFrom(currentFrame.translation);
            }
            //this._camera.fieldOfView = this._cameraAnimationFrame.fov;
            this._camera.rotation = this._cameraAnimationFrame.rotation;
            this._camera.position = this._cameraAnimationFrame.translation;
        };
        /**
        * @language zh_CN
        * 动画播放完一个周期的事件
        */
        CameraAnimationController.EVENT_CAMERA_COMPLETE = "event_camera_complete";
        return CameraAnimationController;
    }());
    egret3d.CameraAnimationController = CameraAnimationController;
    /**
    * @class egret3d.CameraAnimationFrame
    * @classdesc
    * 摄像机动画每帧数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CameraAnimationFrame = (function () {
        function CameraAnimationFrame() {
        }
        return CameraAnimationFrame;
    }());
    egret3d.CameraAnimationFrame = CameraAnimationFrame;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.CameraAnimationManager
    * @classdesc
    * 摄像机管理器
    * 管理所有摄像机动画
    * @see egret3d.Camera3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CameraManager = (function () {
        /**
        * @language zh_CN
        * 构建一个摄像机管理对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function CameraManager() {
            this.cameras = new Array();
        }
        CameraManager.prototype.addCamera = function (camera) {
            this.cameras.push(camera);
        };
        /**
        * @language zh_CN
        * 更新所有的摄像机
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraManager.prototype.update = function (time, delay) {
            //for (var i: number = 0; i < this.cameras.length; ++i) {
            //    this.cameras[i].update(time, delay, this.cameras[i]);
            //}
        };
        CameraManager.instance = new CameraManager();
        return CameraManager;
    }());
    egret3d.CameraManager = CameraManager;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * 摄像机类型
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (CameraType) {
        /**
        * 透视投影
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraType[CameraType["perspective"] = 0] = "perspective";
        /**
        * 正交投影
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraType[CameraType["orthogonal"] = 1] = "orthogonal";
        /**
        * VR投影
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraType[CameraType["VR"] = 2] = "VR";
    })(egret3d.CameraType || (egret3d.CameraType = {}));
    var CameraType = egret3d.CameraType;
    ;
    /**
    * VR类型
    * @private
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (VRType) {
        /**
        * 左眼
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        VRType[VRType["left"] = 0] = "left";
        /**
        * 右眼
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        VRType[VRType["right"] = 1] = "right";
    })(egret3d.VRType || (egret3d.VRType = {}));
    var VRType = egret3d.VRType;
    ;
    /**
    * @class egret3d.Camera3D
    * @classdesc
    * 相机数据处理，生成3D摄相机。</p>
    * 渲染场景从摄像机视点到缓冲区。</p>
    * 相机分为透视摄像机、正交摄像机、VR摄像机。</p>
    * 默认相机朝向是(0, 0, 1) 头朝向是(0, 1, 0)
    *
    * @see egret3d.Matrix4_4
    * @see egret3d.Object3D
    *
    * @includeExample camera/Camera3D.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Camera3D = (function (_super) {
        __extends(Camera3D, _super);
        /**
         * @language zh_CN
         * constructor
         * @param cameraType 相机类型
         * @version Egret 3.0
         * @platform Web,Native
         */
        function Camera3D(cameraType) {
            if (cameraType === void 0) { cameraType = CameraType.perspective; }
            _super.call(this);
            /**
             * @language zh_CN
             * 相机投影矩阵
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.projectMatrix = new egret3d.Matrix4_4();
            /**
             * @language zh_CN
             * 相机的视椎体，用来检测是否在当前相机可视范围内
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.frustum = new egret3d.Frustum();
            this.viewPort = new egret3d.Rectangle();
            this._viewPort = new egret3d.Rectangle();
            this._scissorRect = new egret3d.Rectangle();
            this._aspectRatio = 1.0;
            this._fovY = 45.0;
            this._near = 1;
            this._far = 10000.0;
            this.temp = new egret3d.Matrix4_4();
            this._lookAtPosition = new egret3d.Vector3D();
            this._up = new egret3d.Vector3D(0, 1, 0);
            this._cameraType = 0;
            this._cameraMatrixChange = false;
            this._viewMatrix = new egret3d.Matrix4_4();
            this._tempQuat = new egret3d.Quaternion();
            this._normalMatrix = new egret3d.Matrix4_4();
            this._unprojection = new egret3d.Matrix4_4();
            this._animation = [];
            this.raw = new Float32Array(16);
            this.v = new egret3d.Vector3D();
            this.p = new egret3d.Vector3D();
            this.cameraType = cameraType;
            egret3d.CameraManager.instance.addCamera(this);
        }
        Object.defineProperty(Camera3D.prototype, "cameraType", {
            /**
             * @language zh_CN
             * 设置相机类型
             * @param cameraType 相机类型
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (cameraType) {
                this._cameraType = cameraType;
                switch (cameraType) {
                    case CameraType.orthogonal:
                        this.projectMatrix.ortho(this._viewPort.width, this._viewPort.height, this._near, this._far);
                        //this.updataOrth();
                        break;
                    case CameraType.perspective:
                        this.projectMatrix.perspective(this._fovY, this._aspectRatio, this._near, this._far);
                        break;
                    case CameraType.VR:
                        this.projectMatrix.perspective(this._fovY, 1.0, this._near, this._far);
                        this.eyeMatrix = this.eyeMatrix || new egret3d.EyesMatrix();
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * 打开VR相机
        * @param cameraType 相机类型
        * @param vrType VR类型
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.tap = function (cameraType, vrType) {
            if (vrType === void 0) { vrType = null; }
            if (cameraType == CameraType.VR) {
                this.eyeMatrix.update(this);
                if (vrType == VRType.left) {
                    this.viewMatrix.copyFrom(this.eyeMatrix.leftEyeMatrix);
                }
                else if (vrType == VRType.right) {
                    this.viewMatrix.copyFrom(this.eyeMatrix.rightEyeMatrix);
                }
                this.viewMatrix.invert();
            }
        };
        Object.defineProperty(Camera3D.prototype, "aspectRatio", {
            /**
            * @language zh_CN
            * 返回相机横纵比
            *
            * @returns number 横纵比
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._aspectRatio;
            },
            /**
            * @language zh_CN
            * 设置相机横纵比
            *
            * @param value 横纵比
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._aspectRatio != value) {
                    this._aspectRatio = value;
                    this.cameraType = this._cameraType;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "fieldOfView", {
            /**
            * @language zh_CN
            * 返回相机fovY
            *
            * @returns number fovY
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._fovY;
            },
            /**
            * @language zh_CN
            * 设置相机fovY
            *
            * @param value fovY
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._fovY != value) {
                    this._fovY = value;
                    this.cameraType = this._cameraType;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "near", {
            /**
            * @language zh_CN
            * 返回相机近截面
            *
            * @returns 近截面
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._near;
            },
            /**
            * @language zh_CN
            * 设置相机近截面
            *
            * @param value 近截面
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._near != value) {
                    this._near = value;
                    this.cameraType = this._cameraType;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "far", {
            /**
            * @language zh_CN
            * 返回相机远截面
            *
            * @returns 远截面
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._far;
            },
            /**
            * @language zh_CN
            * 设置相机远截面
            *
            * @param value 远截面
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._far != value) {
                    this._far = value;
                    this.cameraType = this._cameraType;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "viewProjectionMatrix", {
            /**
            * @language zh_CN
            * 返回相机视图投影矩阵
            *
            * @returns 视图投影矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                this.temp.copyFrom(this.viewMatrix);
                this.temp.multiply(this.projectMatrix);
                return this.temp;
            },
            enumerable: true,
            configurable: true
        });
        ///**
        //* @language zh_CN
        //* 视图noormal矩阵
        //* normal 矩阵用来纠正透视相机影响视图变形，所影响的法线轴变形，一般用 modeviewMatrix 的逆举证的转置矩阵。
        //* @version Egret 3.0
        //* @platform Web,Native
        //*/
        //public get normalMatrix(): Matrix4_4 {
        //    this._normalMatrix.copyFrom(this.viewMatrix);
        //    this._normalMatrix.multiply(this.projectMatrix);
        //    return this._normalMatrix; 
        //}
        /**
         * @private
         * @language zh_CN
         * @param x number
         * @param y number
         * @param width number
         * @param height number
         * @version Egret 3.0
         * @platform Web,Native
         */
        Camera3D.prototype.updateScissorRect = function (x, y, width, height) {
            this._scissorRect.x = x;
            this._scissorRect.y = y;
            this._scissorRect.width = width;
            this._scissorRect.height = height;
        };
        /**
         * @language zh_CN
         * 更新视口
         * @param x number
         * @param y number
         * @param width number
         * @param height number
         * @version Egret 3.0
         * @platform Web,Native
         */
        Camera3D.prototype.updateViewport = function (x, y, width, height) {
            this._viewPort.x = x;
            this._viewPort.y = y;
            this._viewPort.width = width;
            this._viewPort.height = height;
        };
        /**
         * @language zh_CN
         * 当前对象对视位置
         * @param pos 对象的位置
         * @param target 目标的位置
         * @param up 向上的方向
         * @version Egret 3.0
         * @platform Web,Native
         */
        Camera3D.prototype.lookAt = function (pos, target, up) {
            if (up === void 0) { up = egret3d.Vector3D.Y_AXIS; }
            this.position = pos;
            this._lookAtPosition.copyFrom(target);
            this._up.copyFrom(up);
            this._viewMatrix.lookAt(this._pos, this._lookAtPosition, this._up);
            this._viewMatrix.invert();
            var prs = this._viewMatrix.decompose(egret3d.Orientation3D.QUATERNION);
            this._tempQuat.x = prs[1].x;
            this._tempQuat.y = prs[1].y;
            this._tempQuat.z = prs[1].z;
            this._tempQuat.w = prs[1].w;
            this.orientation = this._tempQuat;
        };
        Camera3D.prototype.onUpdateTransform = function () {
            this._viewMatrix.copyFrom(this._modelMatrix3D);
            this._viewMatrix.invert();
        };
        Object.defineProperty(Camera3D.prototype, "viewMatrix", {
            /**
             * @language zh_CN
             *
             * 相机视图矩阵
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._viewMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "lookAtPosition", {
            /**
             * @language zh_CN
             *
             * 相机目标点
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._lookAtPosition;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * 更新正交矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.updataOrth = function () {
            var _projectionHeight = 2000;
            var _yMax = _projectionHeight * .5;
            var _xMax = _yMax * this._aspectRatio;
            var left, right, top, bottom;
            ///return 
            if (this._scissorRect.x == 0 && this._scissorRect.y == 0 && this._scissorRect.width == this._viewPort.width && this._scissorRect.height == this._viewPort.height) {
                /// assume symmetric frustum
                left = -_xMax;
                right = _xMax;
                top = -_yMax;
                bottom = _yMax;
                this.raw[0] = 2 / (_projectionHeight * this._aspectRatio);
                this.raw[5] = 2 / _projectionHeight;
                this.raw[10] = 1 / (this._far - this._near);
                this.raw[14] = this._near / (this._near - this._far);
                this.raw[1] = this.raw[2] = this.raw[3] = this.raw[4] =
                    this.raw[6] = this.raw[7] = this.raw[8] = this.raw[9] =
                        this.raw[11] = this.raw[12] = this.raw[13] = 0;
                this.raw[15] = 1;
            }
            else {
                var xWidth = _xMax * (this._viewPort.width / this._scissorRect.width);
                var yHgt = _yMax * (this._viewPort.height / this._scissorRect.height);
                var center = _xMax * (this._scissorRect.x * 2 - this._viewPort.width) / this._scissorRect.width + _xMax;
                var middle = -_yMax * (this._scissorRect.y * 2 - this._viewPort.height) / this._scissorRect.height - _yMax;
                left = center - xWidth;
                right = center + xWidth;
                top = middle - yHgt;
                bottom = middle + yHgt;
                this.raw[0] = 2 * 1 / (right - left);
                this.raw[5] = -2 * 1 / (top - bottom);
                this.raw[10] = 1 / (this._far - this._near);
                this.raw[12] = (right + left) / (right - left);
                this.raw[13] = (bottom + top) / (bottom - top);
                this.raw[14] = this._near / (this.near - this.far);
                this.raw[1] = this.raw[2] = this.raw[3] = this.raw[4] =
                    this.raw[6] = this.raw[7] = this.raw[8] = this.raw[9] = this.raw[11] = 0;
                this.raw[15] = 1;
            }
            this.projectMatrix.copyRawDataFrom(this.raw);
        };
        /**
         * @language zh_CN
         * 检测对象是否在相机视椎体内
         * @param object 需要体测的对象
         * @returns 成功返回true
         * @version Egret 3.0
         * @platform Web,Native
         */
        Camera3D.prototype.isVisibleToCamera = function (renderItem) {
            //尝试刷新modelMatrix的值，有可能changed为true
            renderItem.modelMatrix;
            return renderItem.bound.inBound(this.frustum);
        };
        /**
         * @language zh_CN
         * 增加相机动画
         * @param name 相机动画名字
         * @param ani 相机动画
         * @version Egret 3.0
         * @platform Web,Native
         */
        Camera3D.prototype.addAnimation = function (name, ani) {
            this._animation[name] = ani;
        };
        /**
        * @language zh_CN
        * 播放某个动画
        * 根据动画名字来播放，指定摄像机，并且控制动画是否循环播放
        * @param name 动画名
        * @param isLoop 是否循环
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.play = function (name, isLoop) {
            if (isLoop === void 0) { isLoop = false; }
            if (this._animation[name]) {
                this._animation[name].bindCamera(this);
                this._animation[name].play(isLoop);
            }
        };
        /**
        * @private
        * @language zh_CN
        * 当前对象数据更新
        * @param camera 当前渲染的摄相机
        * @param time 当前时间
        * @param delay 每帧时间间隔
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.update = function (time, delay, camera) {
            _super.prototype.update.call(this, time, delay, camera);
            for (var key in this._animation) {
                this._animation[key].update(time, delay);
            }
        };
        /**
        * @private
        * @language zh_CN
        * 3维坐标转2维屏幕坐标
        * @param n 3维坐标
        * @param target 2维屏幕坐标 默认为null 为null会返回一个新的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.object3DToScreenRay = function (n, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new egret3d.Vector3D();
            }
            this._halfw = this.viewPort.width * 0.5;
            this._halfh = this.viewPort.height * 0.5;
            target = this.viewMatrix.transformVector(n, target);
            this.project(target, target);
            target.x = this._halfw + target.x * this._halfw;
            target.y = this.viewPort.height - (this._halfh - target.y * this._halfh);
            return target;
        };
        /**
        * @private
        * @language zh_CN
        * 2维屏幕坐标转3维坐标
        * @param n 2维屏幕坐标
        * @param target 3维坐标 默认为null 为null会返回一个新的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.ScreenRayToObject3D = function (n, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new egret3d.Vector3D();
            }
            this._halfw = this.viewPort.width * 0.5;
            this._halfh = this.viewPort.height * 0.5;
            target.x = (n.x - this._halfw) / this._halfw;
            target.y = (this._halfh - (this.viewPort.height - n.y)) / this._halfh;
            this.unproject(target.x, target.y, n.z, target);
            this.modelMatrix.transformVector(target, target);
            return target;
        };
        Camera3D.prototype.unproject = function (nX, nY, sZ, target) {
            target.x = nX;
            target.y = -nY;
            target.z = sZ;
            target.w = 1.0;
            target.x *= sZ;
            target.y *= sZ;
            this._unprojection.copyFrom(this.projectMatrix);
            this._unprojection.invert();
            this._unprojection.transformVector(target, target);
            target.z = sZ;
            return target;
        };
        Camera3D.prototype.project = function (n, target) {
            target = this.projectMatrix.transformVector(n, target);
            target.x = target.x / target.w;
            target.y = -target.y / target.w;
            target.z = n.z;
            return target;
        };
        Camera3D.prototype.onMakeTransform = function () {
            egret3d.MathUtil.CALCULATION_VECTOR3D.x = 1;
            egret3d.MathUtil.CALCULATION_VECTOR3D.y = 1;
            egret3d.MathUtil.CALCULATION_VECTOR3D.z = 1;
            this._modelMatrix3D.makeTransform(this._globalPos, egret3d.MathUtil.CALCULATION_VECTOR3D, this._globalOrientation);
        };
        return Camera3D;
    }(egret3d.Object3D));
    egret3d.Camera3D = Camera3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.QuadAABB
    * @classdesc
    * 用于四叉树的包围盒抽象
    * @version Egret 3.0
    * @platform Web,Native
    */
    var QuadAABB = (function () {
        /**
        * @language zh_CN
        * constructor
        * @version Egret 3.0
        * @platform Web,Native
        */
        function QuadAABB() {
            /**
            * @language zh_CN
            * 最小x位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.minPosX = 0;
            /**
            * @language zh_CN
            * 最小y位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.minPosY = 0;
            /**
            * @language zh_CN
            * 最大x位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.maxPosX = 0;
            /**
            * @language zh_CN
            * 最大y位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.maxPosY = 0;
            /**
            * @language zh_CN
            * 用于记录quad框选批次
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.testID = 0;
            this.points = new Array();
            this.offsetPosition = new egret3d.Vector3D(0, 0, 0, 0);
            this.clear();
        }
        /**
        * @language zh_CN
        * 将该包围盒设定到以中心点(cx,cy)，纵横距离(sideY,sidex)的范围内
        * @param cx         中心x
        * @param cy         中心y
        * @param sidex      横向范围
        * @param sidey      纵向范围
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.setAABox = function (cx, cy, sideX, sideY) {
            this.minPosX = cx - sideX / 2 - QuadAABB.TINY;
            this.maxPosX = cx + sideX / 2 + QuadAABB.TINY;
            this.minPosY = cy - sideY / 2 - QuadAABB.TINY;
            this.maxPosY = cy + sideY / 2 + QuadAABB.TINY;
            this.offsetPosition.setTo(0, 0, 0);
        };
        /**
        * @language zh_CN
        * 设置偏移量
        * @param vec        偏移坐标
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.setOffset = function (vec) {
            this.maxPosX += vec.x - this.offsetPosition.x;
            this.minPosX += vec.x - this.offsetPosition.x;
            this.minPosY += vec.z - this.offsetPosition.z;
            this.maxPosY += vec.z - this.offsetPosition.z;
            this.offsetPosition.copyFrom(vec);
        };
        /**
        * @language zh_CN
        * 设定包含某个范围
        * @param minX         中心x
        * @param minY         中心y
        * @param maxX      横向范围
        * @param maxY      纵向范围
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.setContainRect = function (minX, minY, maxX, maxY) {
            if (this.minPosX > minX)
                this.minPosX = minX;
            if (this.minPosY > minY)
                this.minPosY = minY;
            if (this.maxPosX < maxX)
                this.maxPosX = maxX;
            if (this.maxPosY < maxY)
                this.maxPosY = maxY;
        };
        /**
        * @language zh_CN
        * 重置包围盒
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.clear = function () {
            var huge = 1000000000;
            this.minPosX = this.minPosY = huge;
            this.maxPosX = this.maxPosY = -huge;
            this.points.length = 0;
            this.testID = 0;
            this.offsetPosition.setTo(0, 0, 0);
        };
        /**
        * @language zh_CN
        * 添加一个点
        * @param pos         点坐标
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.addPoint = function (pos) {
            if (this.points.indexOf(pos) == -1) {
                if (pos.x < this.minPosX)
                    this.minPosX = pos.x - QuadAABB.TINY;
                if (pos.x > this.maxPosX)
                    this.maxPosX = pos.x + QuadAABB.TINY;
                if (pos.z < this.minPosY)
                    this.minPosY = pos.z - QuadAABB.TINY;
                if (pos.z > this.maxPosY)
                    this.maxPosY = pos.z + QuadAABB.TINY;
                this.points.push(pos);
            }
        };
        /**
        * @language zh_CN
        * 获得该对象克隆
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.clone = function () {
            var aabb = new QuadAABB();
            aabb.minPosX = this.minPosX;
            aabb.minPosY = this.minPosY;
            aabb.maxPosX = this.maxPosX;
            aabb.maxPosY = this.maxPosY;
            return aabb;
        };
        Object.defineProperty(QuadAABB.prototype, "radius", {
            /**
            * @language zh_CN
            * 获得对角线长
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return Math.sqrt((this.maxPosY - this.minPosY) * (this.maxPosY - this.minPosY) + (this.maxPosX - this.minPosX) * (this.maxPosX - this.minPosX));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuadAABB.prototype, "sideX", {
            /**
            * @language zh_CN
            * 获得宽
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.maxPosX - this.minPosX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuadAABB.prototype, "sideY", {
            /**
            * @language zh_CN
            * 获得高
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.maxPosY - this.minPosY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuadAABB.prototype, "centreX", {
            /**
            * @language zh_CN
            * 获得中心点x
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return (this.maxPosX - this.minPosX) * 0.5 + this.minPosX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuadAABB.prototype, "centreY", {
            /**
            * @language zh_CN
            * 获得中心点y
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return (this.maxPosY - this.minPosY) * 0.5 + this.minPosY;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 与另外一个包围盒碰撞测试
        * @param box        测试的碰撞对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.overlapTest = function (box) {
            return ((this.minPosY >= box.maxPosY) ||
                (this.maxPosY <= box.minPosY) ||
                (this.minPosX >= box.maxPosX) ||
                (this.maxPosX <= box.minPosX)) ? false : true;
        };
        /**
        * @language zh_CN
        * 判定某个点在包围盒内
        * @param box        测试的点
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.isPointInside = function (pos) {
            return ((pos.x >= this.minPosX) &&
                (pos.x <= this.maxPosX) &&
                (pos.z >= this.minPosY) &&
                (pos.z <= this.maxPosY));
        };
        /**
        * @language zh_CN
        * 与一条线段碰撞测试
        * @param p1x        线段起点x
        * @param p1y        线段起点y
        * @param p2x        线段终点x
        * @param p2y        线段终点y
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.isIntersectLineSegment = function (p1x, p1y, p2x, p2y) {
            var isIntersect = false;
            // 直线方程p1-p2
            var A1 = p1y - p2y;
            var B1 = p2x - p1x;
            var C1 = p1x * p2y - p2x * p1y;
            // 与AABox
            var LineIntersectY = (-C1 - A1 * this.minPosX) / B1;
            if (LineIntersectY <= this.maxPosY && LineIntersectY >= this.minPosY)
                isIntersect = true;
            LineIntersectY = (-C1 - A1 * this.maxPosX) / B1;
            if (LineIntersectY <= this.maxPosY && LineIntersectY >= this.minPosY)
                isIntersect = true;
            var LineIntersectX = (-C1 - B1 * this.minPosY) / A1;
            if (LineIntersectX <= this.maxPosX && LineIntersectX >= this.minPosX)
                isIntersect = true;
            LineIntersectX = (-C1 - B1 * this.maxPosY) / A1;
            if (LineIntersectX <= this.maxPosX && LineIntersectX >= this.minPosX)
                isIntersect = true;
            return isIntersect;
        };
        /**
        * @language zh_CN
        * @private
        * 设定一个微小的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.TINY = 0.000001;
        return QuadAABB;
    }());
    egret3d.QuadAABB = QuadAABB;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.QuadTree
    * @classdesc
    * 四叉树
    * @version Egret 3.0
    * @platform Web,Native
    */
    var QuadTree = (function () {
        /**
        * @language zh_CN
        * constructor
        * @version Egret 3.0
        * @platform Web,Native
        */
        function QuadTree() {
            /**
            * @language zh_CN
            * 显示quadtree结构
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.logDeep = 0;
            this._testID = 0;
            this._cells = new Array();
            this._quadNodes = new Array();
            this._cellsToTest = new Array();
            this._aabb = new egret3d.QuadAABB();
        }
        /**
        * @language zh_CN
        * 根据下标获取node对象
        * @param    idx     下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.getQuadNode = function (idx) {
            return this._quadNodes[idx];
        };
        /**
        * @language zh_CN
        * 清理
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.clear = function () {
            this._cells.length = 0;
            this._quadNodes.length = 0;
        };
        /**
        * @language zh_CN
        * 插入一系列node到树中,不build
        * @param    nodes     待初始化的节点列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.initNodes = function (nodes) {
            this.clear();
            var i = 0;
            var count = nodes.length;
            while (i < count) {
                this._quadNodes.push(nodes[i]);
                i++;
            }
        };
        /**
        * @language zh_CN
        * 构建四叉树
        * @param    maxNodesPerCell     一个Cell中最多几个三角
        * @param    minCellSize         一个cell单元最小划分到多小
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.buildQuadTree = function (maxNodesPerCell, minCellSize) {
            this._aabb.clear();
            for (var _i = 0, _a = this._quadNodes; _i < _a.length; _i++) {
                var node = _a[_i];
                if (node.isTriangle) {
                    for (var _b = 0, _c = node.aabb.points; _b < _c.length; _b++) {
                        var vt = _c[_b];
                        this._aabb.addPoint(vt);
                    }
                }
                else {
                    this._aabb.setContainRect(node.aabb.minPosX, node.aabb.minPosY, node.aabb.maxPosX, node.aabb.maxPosY);
                }
            }
            this._cells.length = 0;
            this._rootCell = new egret3d.QuadTreeCell(this._aabb); // 创建根节点
            this._cells.push(this._rootCell);
            var numTriangles = this._quadNodes.length;
            for (var i = 0; i < numTriangles; i++) {
                this._cells[0].nodeIndices[i] = i; // 先把所有的三角面放到根节点上
            }
            var cellsToProcess = new Array();
            cellsToProcess.push(0);
            var iTri;
            var cellIndex;
            var childCell;
            while (cellsToProcess.length != 0) {
                cellIndex = cellsToProcess.pop();
                if (this._cells[cellIndex].nodeIndices.length <= maxNodesPerCell
                    || this._cells[cellIndex].aabb.radius < minCellSize) {
                    continue; // 该cell中还可以放三角面
                }
                for (i = 0; i < egret3d.QuadTreeCell.NUM_CHILDREN; i++) {
                    this._cells[cellIndex].childCellIndices[i] = this._cells.length;
                    cellsToProcess.push(this._cells.length);
                    this._cells.push(new egret3d.QuadTreeCell(this.createAABox(this._cells[cellIndex].aabb, i)));
                    childCell = this._cells[this._cells.length - 1];
                    // 父节点上的三角型往子节点中放
                    numTriangles = this._cells[cellIndex].nodeIndices.length;
                    var pushCount = 0;
                    for (var j = 0; j < numTriangles; j++) {
                        iTri = this._cells[cellIndex].nodeIndices[j];
                        if (this.doesNodeIntersectCell(this._quadNodes[iTri], childCell)) {
                            pushCount++;
                            childCell.nodeIndices.push(iTri);
                        }
                    }
                }
                this._cells[cellIndex].nodeIndices.length = 0;
            }
            //logTree(0);
        };
        /**
        * @language zh_CN
        * 创建子节点的AABox
        * @param    aabb     包围盒
        * @param    id      象限
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.createAABox = function (aabb, id) {
            var centerX = aabb.centreX;
            var centerY = aabb.centreY;
            var dimX = aabb.sideX;
            var dimY = aabb.sideY;
            var result = new egret3d.QuadAABB();
            switch (id) {
                case 0:
                    result.setAABox(centerX + dimX / 4, centerY + dimY / 4, dimX / 2, dimY / 2);
                    break;
                case 1:
                    result.setAABox(centerX - dimX / 4, centerY + dimY / 4, dimX / 2, dimY / 2);
                    break;
                case 2:
                    result.setAABox(centerX - dimX / 4, centerY - dimY / 4, dimX / 2, dimY / 2);
                    break;
                case 3:
                    result.setAABox(centerX + dimX / 4, centerY - dimY / 4, dimX / 2, dimY / 2);
                    break;
                default:
                    result.setAABox(centerX + dimX / 4, centerY - dimY / 4, dimX / 2, dimY / 2);
                    break;
            }
            return result;
        };
        /**
        * @language zh_CN
        * 如果三角型和Cell相交,返回True
        * @param    node     节点
        * @param    cell     四叉树叶子
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.doesNodeIntersectCell = function (node, cell) {
            // boundingbox要重叠
            var box = node.aabb;
            if (!box.overlapTest(cell.aabb)) {
                return false;
            }
            //如果不是三角形，则只需要检测aabb的相交
            if (!node.isTriangle)
                return true;
            var points = box.points;
            var p1 = points[0];
            var p2 = points[1];
            var p3 = points[2];
            if (cell.aabb.isPointInside(p1) ||
                cell.aabb.isPointInside(p2) ||
                cell.aabb.isPointInside(p3)) {
                return true;
            }
            // cell的顶点在三角型中
            var isIntersect = this.pointInTriangle(cell.aabb.minPosX, cell.aabb.minPosY, p1, p2, p3) ||
                this.pointInTriangle(cell.aabb.minPosX, cell.aabb.maxPosY, p1, p2, p3) ||
                this.pointInTriangle(cell.aabb.maxPosX, cell.aabb.maxPosY, p1, p2, p3) ||
                this.pointInTriangle(cell.aabb.maxPosX, cell.aabb.minPosY, p1, p2, p3);
            if (isIntersect)
                return true;
            // 三角形的边是否与AABB的边相交
            isIntersect = cell.aabb.isIntersectLineSegment(p1.x, p1.z, p2.x, p2.z) ||
                cell.aabb.isIntersectLineSegment(p1.x, p1.z, p3.x, p3.z) ||
                cell.aabb.isIntersectLineSegment(p2.x, p2.z, p3.x, p3.z);
            return isIntersect;
        };
        /**
        * @language zh_CN
        * 寻找在某位置上的三角面
        * @param    result     存储节点的数组
        * @param    aabb       包围盒
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.getNodesIntersectingtAABox = function (result, aabb) {
            if (this._cells.length == 0)
                return 0;
            this._cellsToTest.length = 0;
            this._cellsToTest.push(0);
            this.incrementTestCounter();
            var cellIndex, nTris, cell;
            var nodeBox;
            var i = 0;
            while (this._cellsToTest.length != 0) {
                cellIndex = this._cellsToTest.pop();
                cell = this._cells[cellIndex];
                if (!aabb.overlapTest(cell.aabb)) {
                    continue;
                }
                if (cell.isLeaf()) {
                    nTris = cell.nodeIndices.length;
                    for (i = 0; i < nTris; i++) {
                        nodeBox = this.getQuadNode(cell.nodeIndices[i]).aabb;
                        if (nodeBox.testID != this._testID) {
                            nodeBox.testID = this._testID;
                            if (aabb.overlapTest(nodeBox)) {
                                result.push(cell.nodeIndices[i]);
                            }
                        }
                    }
                }
                else {
                    for (i = 0; i < egret3d.QuadTreeCell.NUM_CHILDREN; i++) {
                        this._cellsToTest.push(cell.childCellIndices[i]);
                    }
                }
            }
            return result.length;
        };
        /**
        * @language zh_CN
        * 判断点在三角型中
        * @param    x           指定点坐标x
        * @param    y           指定点坐标y
        * @param    triPi1      三角形顶点1
        * @param    triPi2      三角形顶点2
        * @param    triPi3      三角形顶点3
        * @return   是否包含
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.pointInTriangle = function (x, y, triP1, triP2, triP3) {
            var p1 = triP1;
            var p2 = triP2;
            var p3 = triP3;
            // 直线方程p1-p2
            var A1 = p1.z - p2.z;
            var B1 = p2.x - p1.x;
            var C1 = p1.x * p2.z - p2.x * p1.z;
            // 直线方程p2-p3
            var A2 = p2.z - p3.z;
            var B2 = p3.x - p2.x;
            var C2 = p2.x * p3.z - p3.x * p2.z;
            // 直线方程p3-p1
            var A3 = p3.z - p1.z;
            var B3 = p1.x - p3.x;
            var C3 = p3.x * p1.z - p1.x * p3.z;
            var isInTri = false;
            var D1 = A1 * x + B1 * y + C1;
            var D2 = A2 * x + B2 * y + C2;
            var D3 = A3 * x + B3 * y + C3;
            var Tiny = 0.01;
            if ((D1 >= -Tiny && D2 >= -Tiny && D3 >= -Tiny) || (D1 <= Tiny && D2 <= Tiny && D3 <= Tiny))
                isInTri = true;
            return isInTri;
        };
        /**
        * @language zh_CN
        * 递增批次
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.incrementTestCounter = function () {
            ++this._testID;
            if (this._testID == 0) {
                var numTriangles = this._quadNodes.length;
                for (var i = 0; i < numTriangles; i++) {
                    this._quadNodes[i].aabb.testID = 0;
                }
                this._testID = 1;
            }
        };
        QuadTree.prototype.logTree = function (cellIndex) {
            if (cellIndex < 0)
                return;
            this.logDeep++;
            var cell = this._cells[cellIndex];
            var spaces = "";
            for (var si = 0; si < (this.logDeep - 1); si++)
                spaces += "-|";
            console.log(spaces + "i=" + cellIndex + " " +
                cell.aabb.minPosX.toFixed(2) + " " + cell.aabb.maxPosX.toFixed(2) + " "
                + cell.aabb.minPosY.toFixed(2) + " " + cell.aabb.maxPosY.toFixed(2));
            var i;
            for (i = 0; i < cell.nodeIndices.length; i++) {
                if (cell.nodeIndices[i] >= 0) {
                    var tri = this._quadNodes[cell.nodeIndices[i]];
                    console.log(spaces + " t=" + cell.nodeIndices[i] + " " +
                        tri.aabb.minPosX.toFixed(2) + " " + tri.aabb.maxPosX.toFixed(2) + " "
                        + tri.aabb.minPosY.toFixed(2) + " " + tri.aabb.maxPosY.toFixed(2));
                }
            }
            for (i = 0; i < cell.childCellIndices.length; i++) {
                if (cell.childCellIndices[i] >= 0) {
                    this.logTree(cell.childCellIndices[i]);
                }
            }
            this.logDeep--;
        };
        return QuadTree;
    }());
    egret3d.QuadTree = QuadTree;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.QuadRoot
    * @classdesc
    * 创建四叉树的根对象。当前只能用于管理场景中静态的Object，
    * @version Egret 3.0
    * @platform Web,Native
    */
    var QuadRoot = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param maxNodesPerCell 一个Cell中最多几个节点
        * @param minCellSize 一个cell单元最小划分到多小
        */
        function QuadRoot(maxNodesPerCell, minCellSize) {
            if (maxNodesPerCell === void 0) { maxNodesPerCell = 10; }
            if (minCellSize === void 0) { minCellSize = 500; }
            this._maxNodesPerCell = maxNodesPerCell;
            this._minCellSize = minCellSize;
            this._segBox = new egret3d.QuadAABB;
            this._collisionNodesIdx = new Array();
            this._collisionNodes = new Array();
        }
        /**
        * @language zh_CN
        * 创建并构造四叉树
        * @param nodes 需要插入到四叉树中的节点列表
        */
        QuadRoot.prototype.createQuadTree = function (nodes) {
            this._quadTree = new egret3d.QuadTree();
            this._quadTree.initNodes(nodes);
            this._quadTree.buildQuadTree(this._maxNodesPerCell, this._minCellSize);
        };
        /**
        * @language zh_CN
        * 在设定范围内，框选出一批节点
        * @param minX 框选范围最小x值
        * @param minY 框选范围最小y值
        * @param maxX 框选范围最大x值
        * @param maxY 框选范围最大y值
        * @return Array<IQuadNode>
        */
        QuadRoot.prototype.getNodesByAABB = function (minX, minY, maxX, maxY) {
            // 创建一个射线的boundingbox
            this._segBox.clear();
            this._segBox.maxPosX = maxX;
            this._segBox.maxPosY = maxY;
            this._segBox.minPosX = minX;
            this._segBox.minPosY = minY;
            // 获取Boundingbox中的nodes
            this._collisionNodesIdx.length = 0;
            this._collisionNodes.length = 0;
            var numNodes = this._quadTree.getNodesIntersectingtAABox(this._collisionNodesIdx, this._segBox);
            var quadNode;
            for (var i = 0; i < this._collisionNodesIdx.length; i++) {
                quadNode = this._quadTree.getQuadNode(this._collisionNodesIdx[i]);
                this._collisionNodes.push(quadNode);
            }
            return this._collisionNodes;
        };
        /**
        * @language zh_CN
        * 给定一个三维坐标点，获取节点中最为接近的一个三角形
        * @param point 给定的点
        * @param threshold 设定的阈值，超出这个距离则视为放弃
        * @return Navi3DTriangle
        */
        QuadRoot.prototype.getTriangleAtPoint = function (point, threshold) {
            if (threshold === void 0) { threshold = 5; }
            // 创建一个射线的boundingbox
            this._segBox.clear();
            this._segBox.setAABox(point.x, point.z, 1, 1);
            this._collisionNodesIdx.length = 0;
            this._collisionNodes.length = 0;
            // 获取Boundingbox中的node的ID
            var numTriangles = this._quadTree.getNodesIntersectingtAABox(this._collisionNodesIdx, this._segBox);
            // 检查那个三角与点(x,y)相交
            var minDistance = Number.MAX_VALUE;
            var curDistance = 0;
            var minTriangle;
            var quadNode;
            var triangle;
            var box;
            for (var i = 0; i < this._collisionNodesIdx.length; i++) {
                quadNode = this._quadTree.getQuadNode(this._collisionNodesIdx[i]);
                box = quadNode.aabb;
                if (!egret3d.Navi3DTriangle.pointInsideTriangle(point, box.points[0], box.points[1], box.points[2])) {
                    continue;
                }
                triangle = quadNode;
                curDistance = Math.abs(triangle.plane.distance(point));
                if (curDistance > threshold)
                    continue;
                if (quadNode == null || curDistance <= minDistance) {
                    minTriangle = triangle;
                    minDistance = curDistance;
                }
            }
            return minTriangle;
        };
        return QuadRoot;
    }());
    egret3d.QuadRoot = QuadRoot;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.QuadTreeCell
    * @classdesc
    * 四叉树叶子节点
    * @version Egret 3.0
    * @platform Web,Native
    */
    var QuadTreeCell = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param aabox 该叶子的包围盒
        * @version Egret 3.0
        * @platform Web,Native
        */
        function QuadTreeCell(aabox) {
            this.childCellIndices = new Array();
            this.childCellIndices.length = QuadTreeCell.NUM_CHILDREN;
            this.nodeIndices = new Array();
            this.clear();
            if (aabox) {
                this.aabb = aabox.clone();
            }
            else {
                this.aabb = new egret3d.QuadAABB();
            }
        }
        /**
        * @language zh_CN
        * Indicates if we contain triangles (if not then we should/might have children)
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTreeCell.prototype.isLeaf = function () {
            return this.childCellIndices[0] == -1;
        };
        /**
        * @language zh_CN
        * 重置该叶子
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTreeCell.prototype.clear = function () {
            for (var i = 0; i < QuadTreeCell.NUM_CHILDREN; i++) {
                this.childCellIndices[i] = -1;
            }
            this.nodeIndices.splice(0, this.nodeIndices.length);
        };
        /**
        * @language zh_CN
        * 一个叶子单元最多包含子叶子树4个
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTreeCell.NUM_CHILDREN = 4;
        return QuadTreeCell;
    }());
    egret3d.QuadTreeCell = QuadTreeCell;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.DoubleArray
    * @classdesc
    * 利用2个数组实现键值对的数组
    * @version Egret 3.0
    * @platform Web,Native
    */
    var DoubleArray = (function () {
        /**
        * @language zh_CN
        * constructor
        * @version Egret 3.0
        * @platform Web,Native
        */
        function DoubleArray() {
            /**
            * @language zh_CN
            * 键队列
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._keys = new Array();
            /**
            * @language zh_CN
            * 值队列
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._values = new Array();
        }
        /**
        * @language zh_CN
        * 根据键获得下标
        * @param    key     键
        * @return           下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        DoubleArray.prototype.getIndexByKey = function (key) {
            return this._keys.indexOf(key);
        };
        /**
        * @language zh_CN
        * 根据键获得值
        * @param    key     键
        * @return           值
        * @version Egret 3.0
        * @platform Web,Native
        */
        DoubleArray.prototype.getValueByKey = function (key) {
            var index = this.getIndexByKey(key);
            if (index > -1) {
                return this._values[index];
            }
            return null;
        };
        /**
        * @language zh_CN
        * 放入一个键值对
        * @param    key     键
        * @param    value   值
        * @return           原来的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        DoubleArray.prototype.put = function (key, value) {
            if (key == null)
                return null;
            var old = this.remove(key);
            this._keys.push(key);
            this._values.push(value);
            return old;
        };
        /**
        * @language zh_CN
        * 移除一个键值对
        * @param    key     键
        * @return           移除的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        DoubleArray.prototype.remove = function (key) {
            var index = this._keys.indexOf(key);
            var item;
            if (index > -1) {
                item = this._values[index];
                this._keys.splice(index, 1);
                this._values.splice(index, 1);
            }
            return item;
        };
        /**
        * @language zh_CN
        * 获取值的队列
        * @return          值的队列
        * @version Egret 3.0
        * @platform Web,Native
        */
        DoubleArray.prototype.getValues = function () {
            return this._values;
        };
        /**
        * @language zh_CN
        * 获取键的队列
        * @return          键的队列
        * @version Egret 3.0
        * @platform Web,Native
        */
        DoubleArray.prototype.getKeys = function () {
            return this._keys;
        };
        /**
        * @language zh_CN
        * 重置该哈希表
        * @version Egret 3.0
        * @platform Web,Native
        */
        DoubleArray.prototype.clear = function () {
            this._values.length = 0;
            this._keys.length = 0;
        };
        return DoubleArray;
    }());
    egret3d.DoubleArray = DoubleArray;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.Navi3DAstar
    * @classdesc
    * 用于Navigation Mesh中寻路的A星算法
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Navi3DAstar = (function () {
        /**
        * @language zh_CN
        * constructor
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Navi3DAstar() {
            this._findIndex = 0;
            this._openedList = new Array();
            this._closedList = new Array();
        }
        /**
        * @language zh_CN
        * 开始找寻路径，输入起点终点
        * param navMesh 搜索的mesh对象
        * param startTriangle 开始三角形
        * param endTriangle 结束三角形
        * @returns 是否搜索成功
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DAstar.prototype.findPath = function (navMesh, startTriangle, endTriangle) {
            this._findIndex++;
            this._navMesh = navMesh;
            this._startNode = startTriangle;
            this._endNode = endTriangle;
            this._openedList.length = 0;
            this._closedList.length = 0;
            if (this._startNode && this._endNode) {
                this._startNode.g = 0;
                this._startNode.h = 0;
                this._startNode.f = 0;
                this._startNode.parent = null;
                return this.search();
            }
            return false;
        };
        /**
        * @language zh_CN
        * 搜寻
        * @return 是否搜索成功
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DAstar.prototype.search = function () {
            var node = this._startNode;
            var neibours = new Array();
            var test;
            while (node != this._endNode) {
                neibours = node.getNeibourTriangles(neibours, egret3d.Navi3DMaskType.WalkAble, egret3d.Navi3DMaskType.WalkAble);
                for (var _i = 0, neibours_1 = neibours; _i < neibours_1.length; _i++) {
                    test = neibours_1[_i];
                    if (test.closeId == this._findIndex)
                        continue;
                    if (test == node || !test.walkAble) {
                        continue;
                    }
                    var g = node.g + egret3d.Navi3DPoint.calcDistance(test, node) * test.costMultiplier;
                    var h = egret3d.Navi3DPoint.calcDistance(test, this._endNode);
                    var f = g + h;
                    if (test.openId == this._findIndex) {
                        if (test.f > f) {
                            test.f = f;
                            test.g = g;
                            test.h = h;
                            test.parent = node;
                        }
                    }
                    else {
                        test.f = f;
                        test.g = g;
                        test.h = h;
                        test.parent = node;
                        test.openId = this._findIndex;
                        this._openedList.push(test);
                    }
                }
                node.closeId = this._findIndex;
                this._closedList.push(node);
                if (this._openedList.length == 0) {
                    return false;
                }
                this._openedList.sort(function (a, b) {
                    return a.f - b.f;
                });
                node = (this._openedList.shift());
            }
            this.buildPath();
            return true;
        };
        /**
        * @language zh_CN
        * 回溯路径列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DAstar.prototype.buildPath = function () {
            this._triangleChannel = [];
            var node = this._endNode;
            this._triangleChannel.push(node);
            while (node != this._startNode) {
                node = node.parent;
                this._triangleChannel.unshift(node);
            }
        };
        Object.defineProperty(Navi3DAstar.prototype, "channel", {
            /**
            * @language zh_CN
            * 获取结果数据（三角带）
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._triangleChannel;
            },
            enumerable: true,
            configurable: true
        });
        return Navi3DAstar;
    }());
    egret3d.Navi3DAstar = Navi3DAstar;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Navi3DEdge
    * @classdesc
    * 用于Navigation Mesh中寻路的三角形边的对象
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Navi3DEdge = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param  point0 顶点0
        * @param  point1 顶点1
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Navi3DEdge(point0, point1) {
            this._edgeMask = 0;
            this._edgeSize = 0;
            this._pointA = point0;
            this._pointB = point1;
            if (point0.id >= point1.id) {
                throw new Error("edge point order error!!!");
            }
            this._triangleOwners = new Array();
            this._centerPoint = new egret3d.Vector3D();
            this._edgeMask = egret3d.Navi3DMaskType.WalkAble;
            egret3d.Navi3DPoint.CALC_VECTOR3D1.setTo(point0.x - point1.x, point0.y - point1.y, point0.z - point1.z);
            this._edgeSize = egret3d.Navi3DPoint.CALC_VECTOR3D1.length;
            this._centerPoint.setTo((point0.x + point1.x) / 2, (point0.y + point1.y) / 2, (point0.z + point1.z) / 2);
        }
        Object.defineProperty(Navi3DEdge.prototype, "size", {
            /**
            * @language zh_CN
            * 获得边长
            * @return 长度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._edgeSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Navi3DEdge.prototype, "triangleOwners", {
            /**
            * @language zh_CN
            * 获得所属三角形列表
            * @returns  Array<Navi3DTriangle> 三角形列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._triangleOwners;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Navi3DEdge.prototype, "centerPoint", {
            /**
            * @language zh_CN
            * 获得线段的中间点坐标
            * @returns Vector3D 中间点坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._centerPoint;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 初始化肥胖监测点
        * @param  radius    输入的肥胖检测半径
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DEdge.prototype.initFatPoints = function (radius) {
            this._edgeDirA2B = this._pointB.subtract(this._pointA);
            this._edgeDirA2B.normalize();
            this.fatPointA = this.fatPointA || new egret3d.Navi3DPointFat(this._pointA, this);
            this.fatPointB = this.fatPointB || new egret3d.Navi3DPointFat(this._pointB, this);
            if (this.fatPointA.radius != radius) {
                Navi3DEdge.CALC_FAT_VECTOR.copyFrom(this._edgeDirA2B);
                Navi3DEdge.CALC_FAT_VECTOR.scaleBy(radius);
                Navi3DEdge.CALC_FAT_VECTOR.incrementBy(this._pointA);
                this.fatPointA.copyFrom(Navi3DEdge.CALC_FAT_VECTOR);
                this.fatPointA.radius = radius;
            }
            if (this.fatPointB.radius != radius) {
                Navi3DEdge.CALC_FAT_VECTOR.copyFrom(this._edgeDirA2B);
                Navi3DEdge.CALC_FAT_VECTOR.scaleBy(-radius);
                Navi3DEdge.CALC_FAT_VECTOR.incrementBy(this._pointB);
                this.fatPointB.copyFrom(Navi3DEdge.CALC_FAT_VECTOR);
                this.fatPointB.radius = radius;
            }
        };
        /**
        * @language zh_CN
        * 根据端点获取对应的肥胖检测点
        * @param  pt  端点
        * @returns Navi3DPointFat 肥胖检测点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DEdge.prototype.getFatPoint = function (pt) {
            if (pt == this._pointA)
                return this.fatPointA;
            return this.fatPointB;
        };
        /**
        * @language zh_CN
        * 输入一个端点获取另外一个端点的肥胖检测点
        * @param  pt  端点
        * @returns Navi3DPointFat 肥胖检测点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DEdge.prototype.getAnotherFatPoint = function (pt) {
            if (pt == this._pointA)
                return this.fatPointB;
            return this.fatPointA;
        };
        /**
        * @language zh_CN
        * 输入一个端点获取另外一个端点
        * @param  pt  端点
        * @returns Navi3DPoint 另外一个端点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DEdge.prototype.getAnotherPoint = function (pt) {
            if (pt == this._pointA)
                return this._pointB;
            return this._pointA;
        };
        /**
        * @language zh_CN
        * 判定一个点是否等价于某个端点
        * @param  pt 被判定的点
        * @returns Navi3DPoint 判定结果端点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DEdge.prototype.containsPoint = function (pt) {
            if (egret3d.Navi3DPoint.equalPoint(pt, this._pointA))
                return this._pointA;
            if (egret3d.Navi3DPoint.equalPoint(pt, this._pointB))
                return this._pointB;
            return null;
        };
        /**
        * @language zh_CN
        * 添加所属三角形
        * @param  triangle 所属三角形
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DEdge.prototype.addTriangleOwners = function (triangle) {
            if (triangle.edges.indexOf(this) == -1) {
                throw new Error("the edge is not belong triangle!!!");
            }
            if (this._triangleOwners.indexOf(triangle) == -1) {
                this._triangleOwners.push(triangle);
            }
        };
        /**
        * @language zh_CN
        * 获取和另外一条边的公共端点
        * @param  edge 另外一条边
        * @returns Navi3DPoint 公共边
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DEdge.prototype.getPublicPoint = function (edge) {
            if (this._pointA == edge._pointA || this._pointA == edge._pointB) {
                return this._pointA;
            }
            else if (this._pointB == edge._pointA || this._pointB == edge._pointB) {
                return this._pointB;
            }
            return null;
        };
        /**
        * @language zh_CN
        * 输入一个点获，获取与之等价的一个端点对象
        * @param  p 输入的点
        * @returns Navi3DPoint 等价的端点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DEdge.prototype.getEqualPoint = function (p) {
            if (egret3d.Navi3DPoint.equalPoint(p, this._pointA))
                return this._pointA;
            if (egret3d.Navi3DPoint.equalPoint(p, this._pointB))
                return this._pointB;
            return null;
        };
        Object.defineProperty(Navi3DEdge.prototype, "pointA", {
            /**
            * @language zh_CN
            * 端点A
            * @returns Navi3DPoint 端点A
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pointA;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Navi3DEdge.prototype, "pointB", {
            /**
            * @language zh_CN
            * 端点B
            * @returns Navi3DPoint 端点B
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pointB;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Navi3DEdge.prototype, "walkAble", {
            /**
            * @language zh_CN
            * 记录该边的通过属性
            * @returns boolean 是否可通过
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return (this._edgeMask & egret3d.Navi3DMaskType.WalkAble) == egret3d.Navi3DMaskType.WalkAble;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 测试是否通过
        * @param  value 被测试的值
        * @returns boolean 是否通过
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DEdge.prototype.testMask = function (value) {
            return (this._edgeMask & value) == value;
        };
        /**
        * @language zh_CN
        * 计算用的Vector3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DEdge.CALC_FAT_VECTOR = new egret3d.Vector3D();
        return Navi3DEdge;
    }());
    egret3d.Navi3DEdge = Navi3DEdge;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.Navi3DMaskType
    * @classdesc
    * 枚举出的可通过类型
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Navi3DMaskType = (function () {
        function Navi3DMaskType() {
        }
        /**
       * @language zh_CN
       * 可通过
       * @version Egret 3.0
       * @platform Web,Native
       */
        Navi3DMaskType.WalkAble = 1;
        return Navi3DMaskType;
    }());
    egret3d.Navi3DMaskType = Navi3DMaskType;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.Navi3DPoint2D
    * @classdesc
    * ��2d�ĵ�
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Navi3DPoint2D = (function () {
        /**
        * @language zh_CN
        * constructor
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Navi3DPoint2D() {
        }
        /**
        * @language zh_CN
        * ���õ����õ�ָ��λ��
        * @param X   x����
        * @param Y   y����
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DPoint2D.prototype.setTo = function (X, Y) {
            this.x = X;
            this.y = Y;
        };
        /**
        * @language zh_CN
        * �Ƿ��ĳ��λ�õȼ�
        * @param X   x����
        * @param Y   y����
        * @return �Ƿ�ȼ�
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DPoint2D.prototype.equals = function (X, Y) {
            return X == this.x && Y == this.y;
        };
        /**
        * @language zh_CN
        * �Ƿ��ĳ��λ�õȼ�
        * @param pt   ��
        * @return �Ƿ�ȼ�
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DPoint2D.prototype.equalPoint = function (pt) {
            return this.equals(pt.x, pt.y);
        };
        Object.defineProperty(Navi3DPoint2D.prototype, "length", {
            /**
            * @language zh_CN
            * ��ȡ����
            * @return ����
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * ��¡һ����λ�õ�
        * @return ��¡�ĵ�
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DPoint2D.prototype.clone = function () {
            var point = new Navi3DPoint2D();
            point.setTo(this.x, this.y);
            return point;
        };
        /**
        * @language zh_CN
        * ��׼����������Ϊ1
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DPoint2D.prototype.normalize = function () {
            var size = length;
            if (size == 0)
                return;
            this.setTo(this.x / size, this.y / size);
        };
        return Navi3DPoint2D;
    }());
    egret3d.Navi3DPoint2D = Navi3DPoint2D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Navi3DPoint
    * @classdesc
    * ����ĵ�
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Navi3DPoint = (function (_super) {
        __extends(Navi3DPoint, _super);
        /**
        * @language zh_CN
        * constructor
        * @param    id   ����id
        * @param    X   ����x
        * @param    Y   ����y
        * @param    Z   ����z
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Navi3DPoint(id, X, Y, Z) {
            _super.call(this, X, Y, Z, 0);
            this._pointId = 0;
            this._pointId = id;
        }
        Object.defineProperty(Navi3DPoint.prototype, "id", {
            /**
            * @language zh_CN
            * ��Navi3DMesh�е�Ψһid
            * @returns number Ψһid
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pointId;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * �ж���������λ���Ƿ�ȼ�
        * @param    p1   ����1
        * @param    p2   ����2
        * @returns  boolean �Ƿ�ȼ�
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DPoint.equalPoint = function (p1, p2) {
            return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z) < egret3d.Navi3DFunnel.POWER_EPSILON;
        };
        /**
        * @language zh_CN
        * �������������֮��ľ���
        * @param    p1   ����1
        * @param    p2   ����2
        * @returns number   ����
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DPoint.calcDistance = function (pt1, pt2) {
            Navi3DPoint.CALC_VECTOR3D3.setTo(pt1.x - pt2.x, pt1.y - pt2.y, pt1.z - pt2.z);
            return Navi3DPoint.CALC_VECTOR3D3.length;
        };
        /**
        * @language zh_CN
        * �����õ�Vector3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DPoint.CALC_VECTOR3D1 = new egret3d.Vector3D();
        /**
        * @language zh_CN
        * �����õ�Vector3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DPoint.CALC_VECTOR3D2 = new egret3d.Vector3D();
        /**
        * @language zh_CN
        * �����õ�Vector3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DPoint.CALC_VECTOR3D3 = new egret3d.Vector3D();
        /**
        * @language zh_CN
        * �����õ�Vector3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DPoint.CALC_VECTOR3D4 = new egret3d.Vector3D();
        /**
        * @language zh_CN
        * �����õ�Vector3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DPoint.CALC_VECTOR3D5 = new egret3d.Vector3D();
        return Navi3DPoint;
    }(egret3d.Vector3D));
    egret3d.Navi3DPoint = Navi3DPoint;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.Navi3DPointFat
    * @classdesc
    * 用于网格中的边上，碰撞检测的点
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Navi3DPointFat = (function (_super) {
        __extends(Navi3DPointFat, _super);
        /**
        * @language zh_CN
        * constructor
        * @param    _point   端点
        * @param    _edge   边
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Navi3DPointFat(_point, _edge) {
            _super.call(this, _point.id, 0, 0, 0);
            /**
            * @language zh_CN
            * 与端点的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.radius = 0;
            this._ownerEdge = _edge;
            this._ownerPoint = _point;
        }
        Object.defineProperty(Navi3DPointFat.prototype, "ownerPoint", {
            /**
            * @language zh_CN
            * @returns 隶属于哪个端点
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._ownerPoint;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Navi3DPointFat.prototype, "ownerEdge", {
            /**
            * @language zh_CN
            * @returns 隶属于那条边
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._ownerEdge;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 获得一个当前对象的复制，并且使用value进行位置修正
        * @param    value   缩放系数
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DPointFat.prototype.scalePoint = function (value) {
            if (value === void 0) { value = 0.7; }
            var point = new Navi3DPointFat(this._ownerPoint, this._ownerEdge);
            point.copyFrom(this);
            point.decrementBy(this._ownerPoint);
            point.scaleBy(value);
            point.radius = point.length;
            point.incrementBy(this._ownerPoint);
            return point;
        };
        return Navi3DPointFat;
    }(egret3d.Navi3DPoint));
    egret3d.Navi3DPointFat = Navi3DPointFat;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Navi3DTriangle
    * @classdesc
    * 纯2d的点
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Navi3DTriangle = (function (_super) {
        __extends(Navi3DTriangle, _super);
        /**
        * @language zh_CN
        * constructor
        * @param    Id   ID
        * @param    edgeA   三角形边A
        * @param    edgeB   三角形边B
        * @param    edgeC   三角形边C
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Navi3DTriangle(Id, edgeA, edgeB, edgeC) {
            _super.call(this, 0, 0, 0, 0);
            this._id = 0;
            this._points = new Array();
            this._edges = new Array();
            /**
            * @language zh_CN
            * 相邻三角形
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._neibourTriangles = new egret3d.DoubleArray();
            /**
            * @language zh_CN
            * 点正对的边的关系表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._pointAgainstEdge = new egret3d.DoubleArray();
            /**
            * @language zh_CN
            * 边正对着点的关系表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._edgeAgainstPoint = new egret3d.DoubleArray();
            /**
            * @language zh_CN
            * 通过属性
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._mask = 0;
            /**
            * @language zh_CN
            * f -- astar
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.f = 0;
            /**
            * @language zh_CN
            * g -- astar
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.g = 0;
            /**
            * @language zh_CN
            * h -- astar
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.h = 0;
            /**
            * @language zh_CN
            * costMultiplier
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.costMultiplier = 1.0;
            /**
            * @language zh_CN
            * 开区间ID，标记寻路批次用
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.openId = 0;
            /**
            * @language zh_CN
            * 闭区间ID，标记寻路批次用
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.closeId = 0;
            this._id = Id;
            this._mask = egret3d.Navi3DMaskType.WalkAble;
            this._edges.push(edgeA, edgeB, edgeC);
            var edge;
            for (var _i = 0, _a = this._edges; _i < _a.length; _i++) {
                edge = _a[_i];
                if (this._points.indexOf(edge.pointA) == -1) {
                    this._points.push(edge.pointA);
                }
                if (this._points.indexOf(edge.pointB) == -1) {
                    this._points.push(edge.pointB);
                }
            }
            this.x = (this._points[0].x + this._points[1].x + this._points[2].x) / 3;
            this.y = (this._points[0].y + this._points[1].y + this._points[2].y) / 3;
            this.z = (this._points[0].z + this._points[1].z + this._points[2].z) / 3;
            this._plane = new egret3d.Plane3D();
            this._plane.fromPoints(this._points[0], this._points[1], this._points[2]);
            this._plane.normalize();
            this.genarateAgainstData();
            this.initAABB();
        }
        Object.defineProperty(Navi3DTriangle.prototype, "aabb", {
            get: function () {
                return this._aabbBox;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 初始化包围盒（实现IQuadNode的接口）
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.prototype.initAABB = function () {
            this._aabbBox = new egret3d.QuadAABB();
            //添加节点
            this._aabbBox.addPoint(this._points[0]);
            this._aabbBox.addPoint(this._points[1]);
            this._aabbBox.addPoint(this._points[2]);
        };
        Object.defineProperty(Navi3DTriangle.prototype, "isTriangle", {
            /**
            * @language zh_CN
            * 该quad是否是三角形（实现IQuadNode的接口）
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * @private
        * 构建点正对着的边，以及边正对着的点的哈希表
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.prototype.genarateAgainstData = function () {
            var edge;
            var point;
            for (var _i = 0, _a = this._edges; _i < _a.length; _i++) {
                edge = _a[_i];
                for (var _b = 0, _c = this._points; _b < _c.length; _b++) {
                    point = _c[_b];
                    if (edge.pointA != point && edge.pointB != point) {
                        this._edgeAgainstPoint.put(edge, point);
                        this._pointAgainstEdge.put(point, edge);
                    }
                }
            }
        };
        Object.defineProperty(Navi3DTriangle.prototype, "id", {
            /**
            * @language zh_CN
            * @return 三角形的ID，在Navi3DMesh中的唯一ID
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Navi3DTriangle.prototype, "plane", {
            /**
            * @language zh_CN
            * @return 该三角形所在平面
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._plane;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Navi3DTriangle.prototype, "points", {
            /**
            * @language zh_CN
            * @return 该三角形的三个顶点
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._points;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 加入相邻三角形
        * param edge     公共边
        * param triangle 相邻三角形
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.prototype.addNeibour = function (edge, triangle) {
            if (this._edges.indexOf(edge) >= 0) {
                this._neibourTriangles.put(edge, triangle);
            }
            else {
                throw new Error("the edge is not in triangle!!!");
            }
        };
        /**
        * @language zh_CN
        * 获取相邻三角形列表
        * @param list            用于存储结果
        * @param edgeMask        边的通过属性过滤
        * @param triangleMask    三角形通过属性过滤
        * @returns Array<Navi3DTriangle> 获得到的相邻三角形的队列
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.prototype.getNeibourTriangles = function (list, edgeMask, triangleMask) {
            if (list === void 0) { list = null; }
            if (edgeMask === void 0) { edgeMask = 1; }
            if (triangleMask === void 0) { triangleMask = 1; }
            list = list || new Array();
            list.length = 0;
            var neibour;
            var edge;
            var keys = this._neibourTriangles.getKeys();
            var obj;
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                obj = keys_1[_i];
                edge = obj;
                if (edge.testMask(edgeMask)) {
                    neibour = this._neibourTriangles.getValueByKey(edge);
                    if (neibour.testMask(triangleMask)) {
                        list.push(neibour);
                    }
                }
            }
            return list;
        };
        /**
        * @language zh_CN
        * 使用mask对所有的边进行过滤，获得结果
        * @param list            用于存储结果
        * @param edgeMask        边的通过属性过滤
        * @returns Array<Navi3DEdge> 获得到的边的队列
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.prototype.getEdges = function (list, edgeMask) {
            if (list === void 0) { list = null; }
            if (edgeMask === void 0) { edgeMask = 1; }
            list = list || new Array();
            list.length = 0;
            var edge;
            for (var _i = 0, _a = this._edges; _i < _a.length; _i++) {
                edge = _a[_i];
                if (edge.testMask(edgeMask)) {
                    list.push(edge);
                }
            }
            return list;
        };
        Object.defineProperty(Navi3DTriangle.prototype, "walkAble", {
            /**
            * @language zh_CN
            * 获得通过属性
            * @returns boolean 是否通过
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.testMask(egret3d.Navi3DMaskType.WalkAble);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Navi3DTriangle.prototype, "edges", {
            /**
            * @language zh_CN
            * 该三角形的三条边
            * @returns 该三角形的三条边
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._edges;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 获得通过属性
        * @param value      用于过滤的值
        * @returns boolean 是否通过
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.prototype.testMask = function (value) {
            return (this._mask & value) == value;
        };
        /**
        * @language zh_CN
        * 根据三角形的一边获取另外一个点
        * @param edge      输入边
        * @returns Navi3DPoint 端点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.prototype.getEdgeAgainstPoint = function (edge) {
            return this._edgeAgainstPoint.getValueByKey(edge);
        };
        /**
        * @language zh_CN
        * 根据一个顶点，获取对面的边
        * @param point     输入点
        * @returns Navi3DEdge 边
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.prototype.getPointAgainstEdge = function (point) {
            return this._pointAgainstEdge.getValueByKey(point);
        };
        /**
        * @language zh_CN
        * 稍微快一些的共边检测，需要等到mesh初始化完毕才可以
        * @param triangle  三角形
        * @returns Navi3DEdge 公共边
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.prototype.getPublicEdge = function (triangle) {
            if (triangle && triangle != this) {
                var keys = this._neibourTriangles.getKeys();
                var obj;
                for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
                    obj = keys_2[_i];
                    if (this._neibourTriangles.getValueByKey(obj) == triangle)
                        return obj;
                }
            }
            return null;
        };
        /**
        * @language zh_CN
        * 费时间一些的检测共边
        * @param triangle  三角形
        * @returns Navi3DEdge 公共边
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.prototype.loopPublicEdge = function (triangle) {
            var edgeA;
            var edgeB;
            if (triangle && triangle != this) {
                for (var _i = 0, _a = this._edges; _i < _a.length; _i++) {
                    edgeA = _a[_i];
                    for (var _b = 0, _c = triangle._edges; _b < _c.length; _b++) {
                        edgeB = _c[_b];
                        if (edgeA == edgeB)
                            return edgeA;
                    }
                }
            }
            return null;
        };
        /**
        * @language zh_CN
        * 在三角形内随机一个位置
        * @returns Vector3D 点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.prototype.randomPoint = function () {
            var pt0 = this._points[2].subtract(this._points[0]);
            //			if(Math.random() > 0.5)
            {
                pt0.scaleBy(Math.random());
            }
            pt0.incrementBy(this._points[0]);
            var pt1 = this._points[1].subtract(pt0);
            //			if(Math.random() > 0.5)
            {
                pt1.scaleBy(Math.random());
            }
            pt1.incrementBy(pt0);
            return pt1;
        };
        /**
        * @language zh_CN
        * 判定2d点是否在一个2d的三角形内
        * @param pt0        被判定的点
        * @param pt1        三角形的顶点1
        * @param pt2        三角形的顶点2
        * @param pt3        三角形的顶点3
        * @returns boolean 是否处于三角形内
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.pointInsideTriangle = function (pt, pt0, pt1, pt2) {
            Navi3DTriangle.pp.setTo(pt.x, pt.z);
            Navi3DTriangle.p1.setTo(pt0.x, pt0.z);
            Navi3DTriangle.p2.setTo(pt1.x, pt1.z);
            Navi3DTriangle.p3.setTo(pt2.x, pt2.z);
            return Navi3DTriangle.pointInsideTriangle2d();
        };
        /**
        * @language zh_CN
        * @private
        * @returns boolean 判定2d点是否在一个2d的三角形内
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.pointInsideTriangle2d = function () {
            if (Navi3DTriangle.product2d(Navi3DTriangle.p1, Navi3DTriangle.p2, Navi3DTriangle.p3) >= 0) {
                return (Navi3DTriangle.product2d(Navi3DTriangle.p1, Navi3DTriangle.p2, Navi3DTriangle.pp) >= 0)
                    && (Navi3DTriangle.product2d(Navi3DTriangle.p2, Navi3DTriangle.p3, Navi3DTriangle.pp)) >= 0
                    && (Navi3DTriangle.product2d(Navi3DTriangle.p3, Navi3DTriangle.p1, Navi3DTriangle.pp) >= 0);
            }
            else {
                return (Navi3DTriangle.product2d(Navi3DTriangle.p1, Navi3DTriangle.p2, Navi3DTriangle.pp) <= 0)
                    && (Navi3DTriangle.product2d(Navi3DTriangle.p2, Navi3DTriangle.p3, Navi3DTriangle.pp)) <= 0
                    && (Navi3DTriangle.product2d(Navi3DTriangle.p3, Navi3DTriangle.p1, Navi3DTriangle.pp) <= 0);
            }
        };
        /**
        * @language zh_CN
        * 叉乘计算
        * @param pt1        点1
        * @param pt2        点2
        * @param pt3        点3
        * @returns number 结果值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.product2d = function (p1, p2, p3) {
            var val = (p1.x - p3.x) * (p2.y - p3.y) - (p1.y - p3.y) * (p2.x - p3.x);
            if (val > -0.00001 && val < 0.00001)
                val = 0;
            return val;
        };
        /**
        * @language zh_CN
        * 静态变量2d点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.p1 = new egret3d.Navi3DPoint2D();
        /**
        * @language zh_CN
        * 静态变量2d点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.p2 = new egret3d.Navi3DPoint2D();
        /**
        * @language zh_CN
        * 静态变量2d点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.p3 = new egret3d.Navi3DPoint2D();
        /**
        * @language zh_CN
        * 静态变量2d点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DTriangle.pp = new egret3d.Navi3DPoint2D();
        return Navi3DTriangle;
    }(egret3d.Vector3D));
    egret3d.Navi3DTriangle = Navi3DTriangle;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Navi3DMesh
    * @classdesc
    * 解析寻路网格生成的对象
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Navi3DMesh = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param    pointList   顶点数据列表
        * @param    triangleIndexList   顶点顺序列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Navi3DMesh(pointList, triangleIndexList) {
            this._nav3dPoints = new Array();
            this._nav3dEdges = new Array();
            this._nav3dTriangles = new Array();
            this._edgesDict = new egret3d.DoubleArray();
            this.initPoints(pointList);
            this.initEdgesAndTriangles(triangleIndexList);
            this.createConnections();
            this._nav3dAstar = new egret3d.Navi3DAstar();
            this._nav3dFunnel = new egret3d.Navi3DFunnel();
            this._terrainQuad = new egret3d.QuadRoot(8, 128);
            this._terrainQuad.createQuadTree(this._nav3dTriangles);
        }
        Object.defineProperty(Navi3DMesh.prototype, "edges", {
            /**
            * @language zh_CN
            * 网格中的边列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._nav3dEdges;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Navi3DMesh.prototype, "points", {
            /**
            * @language zh_CN
            * 网格中的点列表
            * @returns  Array<Navi3DPoint> 点列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._nav3dPoints;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Navi3DMesh.prototype, "path", {
            /**
            * @language zh_CN
            * 寻路结果中，3d点位置列表
            * @returns Array<Vector3D> 3d点位置列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Navi3DMesh.prototype, "triangles", {
            /**
            * @language zh_CN
            * 网格中的三角形列表
            * @returns Array<Navi3DTriangle> 三角形列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._nav3dTriangles;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 输入一个点，获取一个能匹配的三角形
        * @param    point   输入的点
        * @param    threshold   结果三角形最大距离阈值
        * @returns   Navi3DTriangle 返回三角形
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DMesh.prototype.getTriangleAtPoint = function (point, threshold) {
            if (threshold === void 0) { threshold = 5; }
            return this._terrainQuad.getTriangleAtPoint(point, threshold);
        };
        /**
        * @language zh_CN
        * 输入起点终点，搜寻路径
        * @param    startPt   起点
        * @param    endPt   终点
        * @param    aiRadius   寻路肥胖半径
        * @returns  boolean  是否成功
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DMesh.prototype.findPath = function (startPt, endPt, aiRadius) {
            if (aiRadius === void 0) { aiRadius = 5; }
            this._path = null;
            this._triangleList = null;
            var startNode = this.getTriangleAtPoint(startPt, 10);
            var endNode = this.getTriangleAtPoint(endPt, 10);
            var success = this._nav3dAstar.findPath(this, startNode, endNode);
            if (success) {
                this._triangleList = this._nav3dAstar.channel;
                success = this._nav3dFunnel.searchPath(this, startPt, endPt, this._triangleList, aiRadius);
                this._path = this._nav3dFunnel.path;
                return success;
            }
            return false;
        };
        /**
        * @language zh_CN
        * 初始化顶点列表
        * @param    pointList   顶点坐标列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DMesh.prototype.initPoints = function (pointList) {
            var point;
            var nevPoint;
            var count = pointList.length;
            for (var i = 0; i < count; i++) {
                point = pointList[i];
                nevPoint = new egret3d.Navi3DPoint(i, point.x, point.y, point.z);
                this._nav3dPoints.push(nevPoint);
            }
        };
        /**
        * @language zh_CN
        * 初始化三角形和边列表
        * @param    triangleIndexList   三角形顶点顺序列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DMesh.prototype.initEdgesAndTriangles = function (triangleIndexList) {
            var indexOrderList;
            var edge0;
            var edge1;
            var edge2;
            var triangle;
            var count = triangleIndexList.length;
            for (var i = 0; i < count; i++) {
                indexOrderList = triangleIndexList[i];
                edge0 = this.tryCreateEdge(indexOrderList[0], indexOrderList[1]);
                edge1 = this.tryCreateEdge(indexOrderList[1], indexOrderList[2]);
                edge2 = this.tryCreateEdge(indexOrderList[2], indexOrderList[0]);
                if (edge0 == null || edge1 == null || edge2 == null)
                    continue;
                triangle = new egret3d.Navi3DTriangle(i, edge0, edge1, edge2);
                this._nav3dTriangles.push(triangle);
            }
        };
        /**
        * @language zh_CN
        * 根据两个点的ID，创建一条边
        * @param    pointAId   点A
        * @param    pointBId   点B
        * @returns  Navi3DEdge  创建的边
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DMesh.prototype.tryCreateEdge = function (pointAId, pointBId) {
            if (pointAId == pointBId) {
                throw new Error("edge point index error!!!");
            }
            if (pointAId > pointBId) {
                var tempId = pointAId;
                pointAId = pointBId;
                pointBId = tempId;
            }
            var edge = this._edgesDict.getValueByKey(pointAId + "_" + pointBId);
            if (edge == null) {
                edge = new egret3d.Navi3DEdge(this._nav3dPoints[pointAId], this._nav3dPoints[pointBId]);
                this._nav3dEdges.push(edge);
                this._edgesDict.put(pointAId + "_" + pointBId, edge);
            }
            return edge;
        };
        /**
        * @language zh_CN
        * 创建关系表
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DMesh.prototype.createConnections = function () {
            var triangleACount = this._nav3dTriangles.length;
            var triangleBCount = this._nav3dTriangles.length;
            var triangleA;
            var triangleB;
            var edge;
            var publicEdge;
            for (var i = 0; i < triangleACount; i++) {
                //边上面记录拥有这条边的三角形
                triangleA = this._nav3dTriangles[i];
                for (var _i = 0, _a = triangleA.edges; _i < _a.length; _i++) {
                    edge = _a[_i];
                    edge.addTriangleOwners(triangleA);
                }
                for (var j = 0; j < triangleBCount; j++) {
                    //三角形相邻关系
                    triangleB = this._nav3dTriangles[j];
                    if (triangleA == triangleB)
                        continue;
                    publicEdge = triangleA.loopPublicEdge(triangleB);
                    if (publicEdge) {
                        triangleA.addNeibour(publicEdge, triangleB);
                        triangleB.addNeibour(publicEdge, triangleA);
                    }
                }
            }
        };
        return Navi3DMesh;
    }());
    egret3d.Navi3DMesh = Navi3DMesh;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.Navi3DFunnel
    * @classdesc
    * 寻找路径的方法
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Navi3DFunnel = (function () {
        /**
        * @language zh_CN
        * constructor
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Navi3DFunnel() {
            /**
            * @language zh_CN
            * 寻路对象的半径
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._aiRadius = 0;
            /**
            * @language zh_CN
            * 公共边数据列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._tempPublicEdgeList = new Array();
            /**
            * @language zh_CN
            * 共面信息
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._tempSamePlaneList = new Array();
            this._router = new egret3d.Navi3DRouter();
        }
        /**
        * @language zh_CN
        * 搜索路径
        * @param mesh   搜索的范围
        * @param startPt   起点
        * @param endPt   终点
        * @param triangleList   三角带
        * @param radius   半径
        * @return 是否寻路成功
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DFunnel.prototype.searchPath = function (mesh, startPt, endPt, triangleList, radius) {
            if (radius === void 0) { radius = 0; }
            if (radius <= 0)
                radius = 1;
            this._aiRadius = radius * 1.5;
            //
            this._navMesh = mesh;
            //起点终点判断
            if (!this.searchEnable(startPt, endPt, triangleList))
                return false;
            this.search(startPt, endPt, triangleList);
            return true;
        };
        Object.defineProperty(Navi3DFunnel.prototype, "path", {
            get: function () {
                return this._result;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 检测是否满足搜索条件
        * @param startPt   起点
        * @param endPt   终点
        * @param triangleList   三角带
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DFunnel.prototype.searchEnable = function (startPt, endPt, triangleList) {
            if (startPt == null || endPt == null || this._navMesh == null || triangleList == null)
                return false;
            if (triangleList[0].plane.classifyPoint(startPt, Navi3DFunnel.EPSILON) != egret3d.PlaneClassification.INTERSECT) {
                return false;
            }
            if (triangleList[triangleList.length - 1].plane.classifyPoint(endPt, Navi3DFunnel.EPSILON) != egret3d.PlaneClassification.INTERSECT) {
                return false;
            }
            return true;
        };
        /**
        * @language zh_CN
        * 执行搜索
        * @param startPt   起点坐标
        * @param endPt   终点坐标
        * @param triangleList   三角带
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DFunnel.prototype.search = function (startPt, endPt, triangleList) {
            this._tempPublicEdgeList.length = 0;
            this._tempSamePlaneList.length = 0;
            var i = 0;
            var crossedEdgeCount = triangleList.length - 1;
            var tr;
            var curEdge;
            var pt;
            var plane;
            var crossPoint;
            for (i = 0; i < crossedEdgeCount; i++) {
                curEdge = triangleList[i].getPublicEdge(triangleList[i + 1]);
                curEdge.crossPoint = null;
                curEdge.initFatPoints(this._aiRadius);
                this._tempPublicEdgeList.push(curEdge);
                tr = triangleList[i];
                plane = tr.plane;
                tr = triangleList[i + 1];
                pt = tr.getEdgeAgainstPoint(curEdge);
                this._tempSamePlaneList.push(plane.classifyPoint(pt, Navi3DFunnel.EPSILON) == egret3d.PlaneClassification.INTERSECT);
            }
            this._router.continuePass(startPt, endPt, this._tempPublicEdgeList[0]);
            crossedEdgeCount = this._tempPublicEdgeList.length;
            var cornerPoint;
            var cornerEdge;
            var continuePass;
            var lastEdge;
            for (i = 0; i < crossedEdgeCount; i++) {
                curEdge = this._tempPublicEdgeList[i];
                tr = triangleList[i + 1];
                lastEdge = i == crossedEdgeCount - 1;
                if (lastEdge) {
                    pt = endPt;
                }
                else {
                    pt = tr.getEdgeAgainstPoint(curEdge);
                }
                continuePass = this._router.passEdge(curEdge, this._tempPublicEdgeList[i + 1], pt, lastEdge);
                if (!continuePass) {
                    cornerPoint = this._router.cornerPoint;
                    cornerEdge = this._router.cornerEdge;
                    i = this._tempPublicEdgeList.indexOf(cornerEdge);
                    this._router.continuePass(cornerPoint, endPt, this._tempPublicEdgeList[i + 1]);
                }
            }
            this.pushAllPathPoint2(startPt, endPt);
            if (this._result.length >= 3) {
                this.optimusTerminusFat();
                this.optimusByRadius();
            }
        };
        /**
        * @language zh_CN
        * 将端点换成肥胖检测点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DFunnel.prototype.optimusTerminusFat = function () {
            var startFat;
            var endFat;
            var pt;
            pt = this._result[1];
            if (pt instanceof egret3d.Navi3DPointFat) {
                startFat = pt;
            }
            pt = this._result[this._result.length - 2];
            if (pt instanceof egret3d.Navi3DPointFat) {
                endFat = pt;
            }
            if (startFat) {
                this._result[1] = startFat.scalePoint();
            }
            if (endFat && startFat != endFat) {
                this._result[this._result.length - 2] = endFat.scalePoint();
            }
        };
        /**
        * @language zh_CN
        * 将穿越的公共边数据里的通过点加入到结果队列中
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DFunnel.prototype.pushAllPathPoint2 = function (startPt, endPt) {
            var crossedEdgeCount = this._tempPublicEdgeList.length;
            var curEdge;
            var curEdgeJ;
            this._result = new Array();
            this._result.push(startPt);
            var fromPoint = startPt;
            var toPoint;
            var fatPoint;
            var crossPoint;
            for (var i = 0; i < crossedEdgeCount; i++) {
                curEdge = this._tempPublicEdgeList[i];
                fatPoint = null;
                if (curEdge.crossPoint) {
                    fatPoint = this.getFatPoint(curEdge, curEdge.crossPoint);
                    if (fatPoint) {
                        this._result.push(fatPoint);
                    }
                    else {
                        this._result.push(curEdge.crossPoint);
                    }
                    fromPoint = curEdge.crossPoint;
                }
                else {
                    curEdgeJ = null;
                    toPoint = null;
                    //找到下一个点
                    for (var j = i + 1; j < crossedEdgeCount; j++) {
                        curEdgeJ = this._tempPublicEdgeList[j];
                        toPoint = curEdgeJ.crossPoint;
                        if (toPoint) {
                            break;
                        }
                    }
                    if (toPoint == null) {
                        toPoint = endPt;
                    }
                    fatPoint = this.getFatPoint(curEdge, toPoint);
                    if (fatPoint) {
                        this._result.push(fatPoint);
                    }
                    else {
                        Navi3DFunnel.CROSS_TEST_DIRECTION.setTo(toPoint.x - fromPoint.x, 0, toPoint.z - fromPoint.z);
                        crossPoint = this._router.calcCrossEdge(curEdge, fromPoint, Navi3DFunnel.CROSS_TEST_DIRECTION);
                        this._result.push(crossPoint);
                    }
                }
            }
            this._result.push(endPt);
        };
        /**
        * @language zh_CN
        * 优化通过的点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DFunnel.prototype.optimusByRadius = function () {
            var optimusResult = new Array();
            optimusResult.length = this._result.length;
            var count = this._result.length - 2;
            var pt0;
            var pt1;
            var pt2;
            var fatPt0;
            var fatPt1;
            var fatPt2;
            var edgePt0;
            var edgePt1;
            var edgePt2;
            var centerEdge;
            var checkEnable;
            var optimusPoint;
            var i;
            for (i = 0; i < count; i++) {
                edgePt0 = edgePt1 = edgePt2 = null;
                fatPt0 = fatPt1 = fatPt2 = null;
                checkEnable = false;
                optimusPoint = null;
                pt0 = this._result[i];
                pt1 = this._result[i + 1];
                pt2 = this._result[i + 2];
                if (pt0 instanceof egret3d.Navi3DPointFat) {
                    fatPt0 = pt0;
                }
                if (pt1 instanceof egret3d.Navi3DPointFat) {
                    fatPt1 = pt1;
                }
                if (pt2 instanceof egret3d.Navi3DPointFat) {
                    fatPt2 = pt2;
                }
                if (fatPt0) {
                    edgePt0 = fatPt0.ownerPoint;
                }
                if (fatPt1) {
                    edgePt1 = fatPt1.ownerPoint;
                }
                if (fatPt2) {
                    edgePt2 = fatPt2.ownerPoint;
                }
                if (edgePt0 && edgePt1 && edgePt0 == edgePt1 && edgePt1 != edgePt2) {
                    checkEnable = true;
                }
                if (edgePt2 && edgePt1 && edgePt2 == edgePt1 && edgePt0 != edgePt1) {
                    checkEnable = true;
                }
                if (checkEnable) {
                    Navi3DFunnel.CROSS_TEST_DIRECTION.copyFrom(pt0);
                    Navi3DFunnel.CROSS_TEST_DIRECTION.decrementBy(pt2);
                    centerEdge = fatPt1.ownerEdge;
                    checkEnable = this._router.hasCrossPoint(centerEdge.pointA, centerEdge.pointB, pt2, Navi3DFunnel.CROSS_TEST_DIRECTION);
                    if (checkEnable) {
                        optimusPoint = this._router.calcCrossPointOut(edgePt1, pt1, pt2, Navi3DFunnel.CROSS_TEST_DIRECTION);
                    }
                    if (optimusPoint) {
                        optimusResult[i + 1] = optimusPoint;
                    }
                }
            }
        };
        /**
        * @language zh_CN
        * 对某个边获取肥胖监测点
        * @param target 输入的坐标点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DFunnel.prototype.getFatPoint = function (edge, target) {
            if (edge == null)
                return null;
            var fatPoint;
            if (target instanceof egret3d.Navi3DPointFat) {
                fatPoint = target;
            }
            var edgePoint;
            if (fatPoint) {
                edgePoint = fatPoint.ownerPoint;
            }
            else {
                edgePoint = edge.getEqualPoint(target);
            }
            if (edgePoint == null)
                return null;
            fatPoint = edge.getFatPoint(edgePoint);
            return fatPoint;
        };
        /**
        * @language zh_CN
        * 误差值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DFunnel.EPSILON = 5;
        /**
        * @language zh_CN
        * 误差值的平方
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DFunnel.POWER_EPSILON = Navi3DFunnel.EPSILON * Navi3DFunnel.EPSILON;
        /**
        * @language zh_CN
        * 计算用的Vector3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DFunnel.CROSS_TEST_DIRECTION = new egret3d.Vector3D();
        return Navi3DFunnel;
    }());
    egret3d.Navi3DFunnel = Navi3DFunnel;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.Navi3DRouter
    * @classdesc
    * 纯2d的点
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Navi3DRouter = (function () {
        /**
        * @language zh_CN
        * constructor
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Navi3DRouter() {
        }
        /**
        * @language zh_CN
        * 设定继续通过
        * @param fromPt     起点
        * @param endPt      终点
        * @param fromEdge   上一次的边
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.prototype.continuePass = function (fromPt, endPt, fromEdge) {
            this.resetData();
            this.curPoint = fromPt;
            this.endPoint = endPt;
            this.cornerEdge = fromEdge;
        };
        /**
        * @language zh_CN
        * 继续通过
        * @param commonEdge          公共边
        * @param nextCommonEdge      下一个公共边
        * @param targetPoint         目标点
        * @param lastEdge            是否为最后一个边
        * @returns boolean 是否通过
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.prototype.passEdge = function (commonEdge, nextCommonEdge, targetPoint, lastEdge) {
            if (this.rayA == null || this.rayB == null) {
                this.rayA = Navi3DRouter.RAY_1;
                this.rayB = Navi3DRouter.RAY_2;
                this.rayAPoint = commonEdge.pointA;
                this.rayBPoint = commonEdge.pointB;
                this.rayA.setTo(this.rayAPoint.x - this.curPoint.x, 0, this.rayAPoint.z - this.curPoint.z);
                this.rayB.setTo(this.rayBPoint.x - this.curPoint.x, 0, this.rayBPoint.z - this.curPoint.z);
            }
            if (lastEdge) {
                return this.checkEndPoint(targetPoint);
            }
            Navi3DRouter.TEST_RAY.setTo(targetPoint.x - this.curPoint.x, 0, targetPoint.z - this.curPoint.z);
            if (this.isPointAtCenter(Navi3DRouter.TEST_RAY, this.rayA, this.rayB)) {
                if (!this.hasCrossPoint(nextCommonEdge.pointA, nextCommonEdge.pointB, this.rayAPoint, this.rayA)) {
                    this.rayA.copyFrom(Navi3DRouter.TEST_RAY);
                    if (targetPoint instanceof egret3d.Navi3DPoint) {
                        this.rayAPoint = targetPoint;
                    }
                    else {
                        this.rayAPoint = null;
                    }
                }
                else {
                    this.rayB.copyFrom(Navi3DRouter.TEST_RAY);
                    if (targetPoint instanceof egret3d.Navi3DPoint) {
                        this.rayBPoint = targetPoint;
                    }
                    else {
                        this.rayBPoint = null;
                    }
                }
                var anotherPoint = nextCommonEdge.getAnotherPoint(targetPoint);
                Navi3DRouter.TEST_RAY.setTo(anotherPoint.x - this.curPoint.x, 0, anotherPoint.z - this.curPoint.z);
                if (anotherPoint == this.rayAPoint || anotherPoint == this.rayBPoint || this.isPointAtCenter(Navi3DRouter.TEST_RAY, this.rayA, this.rayB)) {
                    this.cornerEdge = nextCommonEdge;
                }
            }
            else {
                var needReturn;
                Navi3DRouter.TEST_RAY_1.copyFrom(nextCommonEdge.pointA);
                Navi3DRouter.TEST_RAY_1.decrementBy(this.curPoint);
                Navi3DRouter.TEST_RAY_2.copyFrom(nextCommonEdge.pointB);
                Navi3DRouter.TEST_RAY_2.decrementBy(this.curPoint);
                Navi3DRouter.TEST_RAY_1.y = 0;
                Navi3DRouter.TEST_RAY_2.y = 0;
                if (this.isPointAtCenter(this.rayA, Navi3DRouter.TEST_RAY_1, Navi3DRouter.TEST_RAY_2)
                    || this.isPointAtCenter(this.rayB, Navi3DRouter.TEST_RAY_1, Navi3DRouter.TEST_RAY_2)) {
                    needReturn = false;
                }
                else {
                    needReturn = true;
                }
                if (needReturn) {
                    if (this.isPointAtCenter(this.rayA, Navi3DRouter.TEST_RAY, this.rayB)) {
                        this.cornerPoint = this.rayAPoint;
                    }
                    else {
                        this.cornerPoint = this.rayBPoint;
                    }
                    this.cornerEdge.crossPoint = this.cornerPoint;
                    return false;
                }
            }
            return true;
        };
        /**
        * @language zh_CN
        * @private
        * 通过边的时候，发现为抵达终点的处理函数
        * @param targetPoint          终点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.prototype.checkEndPoint = function (targetPoint) {
            Navi3DRouter.TEST_RAY.setTo(targetPoint.x - this.curPoint.x, 0, targetPoint.z - this.curPoint.z);
            if (this.isPointAtCenter(Navi3DRouter.TEST_RAY, this.rayA, this.rayB)) {
            }
            else {
                if (this.isPointAtCenter(this.rayA, Navi3DRouter.TEST_RAY, this.rayB)) {
                    this.cornerPoint = this.rayAPoint;
                }
                else {
                    this.cornerPoint = this.rayBPoint;
                }
                this.cornerEdge.crossPoint = this.cornerPoint;
                return false;
            }
            return true;
        };
        /**
        * @language zh_CN
        * 计算射线与线段的两个fatPoint之间交点
        * @param _edge          线段
        * @param linePoint      射线起点
        * @param lineDirection  射线方向
        * @returns     Vector3D          交点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.prototype.calcCrossEdge = function (_edge, linePoint, lineDirection) {
            return this.calcCrossPoint(_edge.fatPointA, _edge.fatPointB, linePoint, lineDirection);
        };
        /**
        * @language zh_CN
        * 计算射线与线段的交点
        * @param _edge          线段
        * @param linePoint      射线起点
        * @param lineDirection  射线方向
        * @returns Vector3D 交点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.prototype.calcCrossPoint = function (segmentPt1, segmentPt2, linePoint, lineDirection) {
            Navi3DRouter.CALC_CROSS_POINT.copyFrom(segmentPt2);
            Navi3DRouter.CALC_CROSS_POINT.decrementBy(segmentPt1);
            var scale = ((segmentPt1.z - linePoint.z) * lineDirection.x - (segmentPt1.x - linePoint.x) * lineDirection.z) /
                (Navi3DRouter.CALC_CROSS_POINT.x * lineDirection.z - lineDirection.x * Navi3DRouter.CALC_CROSS_POINT.z);
            if (scale > 1) {
                scale = 1;
            }
            else if (scale < 0) {
                scale = 0;
            }
            Navi3DRouter.CALC_CROSS_POINT.scaleBy(scale);
            Navi3DRouter.CALC_CROSS_POINT.incrementBy(segmentPt1);
            return Navi3DRouter.CALC_CROSS_POINT.clone();
        };
        /**
        * @language zh_CN
        * 计算射线与线段交点，如果不在线段里面，则返回null
        * @param segmentPt1      线段1端
        * @param segmentPt2      线段另一端
        * @param linePoint       射线起点
        * @param lineDirection   射线方向
        * @return Vector3D 交点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.prototype.calcCrossPointOut = function (segmentPt1, segmentPt2, linePoint, lineDirection) {
            Navi3DRouter.CALC_CROSS_POINT.copyFrom(segmentPt2);
            Navi3DRouter.CALC_CROSS_POINT.decrementBy(segmentPt1);
            var scale = ((segmentPt1.z - linePoint.z) * lineDirection.x - (segmentPt1.x - linePoint.x) * lineDirection.z) /
                (Navi3DRouter.CALC_CROSS_POINT.x * lineDirection.z - lineDirection.x * Navi3DRouter.CALC_CROSS_POINT.z);
            if (scale <= 1 && scale >= 0) {
                return null;
            }
            Navi3DRouter.CALC_CROSS_POINT.scaleBy(scale);
            Navi3DRouter.CALC_CROSS_POINT.incrementBy(segmentPt1);
            return Navi3DRouter.CALC_CROSS_POINT.clone();
        };
        /**
        * @language zh_CN
        * 判定计算射线与线段是否有交点
        * @param segmentPt1      线段1端
        * @param segmentPt2      线段另一端
        * @param linePoint       射线起点
        * @param lineDirection   射线方向
        * @returns boolean 是否有交点
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.prototype.hasCrossPoint = function (segmentPt1, segmentPt2, linePoint, lineDirection) {
            Navi3DRouter.CALC_CROSS_TEST.copyFrom(segmentPt2);
            Navi3DRouter.CALC_CROSS_TEST.decrementBy(segmentPt1);
            var scale = ((segmentPt1.z - linePoint.z) * lineDirection.x - (segmentPt1.x - linePoint.x) * lineDirection.z) /
                (Navi3DRouter.CALC_CROSS_TEST.x * lineDirection.z - lineDirection.x * Navi3DRouter.CALC_CROSS_TEST.z);
            return scale <= 1 && scale >= 0;
        };
        /**
        * @language zh_CN
        * @private
        * 判定一个点是否在两个射线的夹角内侧
        * @param point        点
        * @param vectorA      射线A
        * @param vectorB      射线B
        * @returns boolean 是在内侧
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.prototype.isPointAtCenter = function (point, vectorA, vectorB) {
            var cp1 = vectorA.crossProduct(point);
            if (cp1.length == 0 && point.length < vectorA.length) {
                return true;
            }
            var cp2 = vectorB.crossProduct(point);
            if (cp2.length == 0 && point.length < vectorB.length) {
                return true;
            }
            cp1.normalize();
            cp2.normalize();
            cp1.incrementBy(cp2);
            return cp1.length < 0.01;
        };
        /**
        * @language zh_CN
        * 重置该router
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.prototype.resetData = function () {
            this.cornerEdge = null;
            this.cornerPoint = null;
            this.curPoint = null;
            this.rayA = this.rayB = null;
            this.rayAPoint = this.rayBPoint = null;
            Navi3DRouter.RAY_1.setTo(0, 0, 0);
            Navi3DRouter.RAY_2.setTo(0, 0, 0);
        };
        /**
        * @language zh_CN
        * 静态变量射线1
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.RAY_1 = new egret3d.Vector3D();
        /**
        * @language zh_CN
        * 静态变量射线2
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.RAY_2 = new egret3d.Vector3D();
        /**
        * @language zh_CN
        * 计算用射线
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.TEST_RAY = new egret3d.Vector3D();
        /**
        * @language zh_CN
        * 计算用射线1
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.TEST_RAY_1 = new egret3d.Vector3D();
        /**
        * @language zh_CN
        * 计算用射线2
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.TEST_RAY_2 = new egret3d.Vector3D();
        /**
        * @language zh_CN
        * 计算用的Vector3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.CALC_CROSS_POINT = new egret3d.Vector3D();
        /**
        * @language zh_CN
        * 计算用的Vector3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Navi3DRouter.CALC_CROSS_TEST = new egret3d.Vector3D();
        return Navi3DRouter;
    }());
    egret3d.Navi3DRouter = Navi3DRouter;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.HUD
    * @classdesc
    * HUD直接渲染在屏幕上的一张贴图</p>
    * 可直接指定2维坐标，贴图的宽度和高度。</p>
    * 其底层渲染也是由4个顶点构成，顶点数据结构有位置信息和uv信息。</p>
    * 其所有的HUD对象的顶点信息数据都是共用的。</p>
    * @version Egret 3.0
    * @platform Web,Native
    */
    var HUD = (function () {
        /**
        * @language zh_CN
        * 创建一个HUD对象
        * @param x 屏幕x坐标 默认值 0
        * @param y 屏幕y坐标 默认值 0
        * @param width hud宽度 默认值 100
        * @param height hud高度 默认值 100
        * @version Egret 3.0
        * @platform Web,Native
        */
        function HUD(x, y, width, height) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (width === void 0) { width = 100; }
            if (height === void 0) { height = 100; }
            this._rectangle = new egret3d.Rectangle();
            this._transformMatrix = new egret3d.Matrix4_4();
            this._change = false;
            this._rotation = new egret3d.Vector3D();
            this._scale = new egret3d.Vector3D(1, 1, 1);
            this._position = new egret3d.Vector3D();
            this._transformComponents = [];
            this._changeTexture = false;
            this._vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_UV0;
            this._uv_scale = new Float32Array(2);
            /**
            * @language zh_CN
            * 名字
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.name = "";
            /**
            * @language zh_CN
            * 显示双面的开关。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.bothside = false;
            /**
            * @language zh_CN
            * cull模式。 正面可见ContextConfig.BACK 背面可见ContextConfig.FRONT
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cullMode = egret3d.ContextConfig.BACK;
            /**
            * @language zh_CN
            * 是否可见
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.visible = true;
            this.vsShader = "hud_vs";
            this.fsShader = "hud_V_fs";
            this._passUsage = new egret3d.PassUsage();
            this._attList = new Array();
            this._transformComponents.push(this._position);
            this._transformComponents.push(this._rotation);
            this._transformComponents.push(this._scale);
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this._uv_scale[0] = 1.0;
            this._uv_scale[1] = 1.0;
        }
        Object.defineProperty(HUD.prototype, "diffuseTexture", {
            /**
            * @language zh_CN
            * 返回HUD的漫反射贴图。
            * @returns ITexture 漫反射贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._diffuseTexture;
            },
            /**
             * @language zh_CN
             * 设置HUD的漫反射贴图。
             * @param texture ITexture
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                this._changeTexture = true;
                this._diffuseTexture = texture;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "x", {
            /**
            * @language zh_CN
            * 得到x坐标
            * @returns number x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rectangle.x;
            },
            /**
            * @language zh_CN
            * 设置x坐标
            * @param value x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._change = true;
                this._rectangle.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "y", {
            /**
            * @language zh_CN
            * 得到y坐标
            * @returns number y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rectangle.y;
            },
            /**
            * @language zh_CN
            * 设置y坐标
            * @param value y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._change = true;
                this._rectangle.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "width", {
            /**
            * @language zh_CN
            *  得到HUD的宽度
            * @returns number HUD的宽度宽
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rectangle.width;
            },
            /**
            * @language zh_CN
            * 设置HUD的宽度
            * @param value HUD宽
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._change = true;
                this._rectangle.width = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "height", {
            /**
            * @language zh_CN
            * 得到HUD的高度
            * @returns number HUD的高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rectangle.height;
            },
            /**
            * @language zh_CN
            * 设置HUD的高度
            * @param value HUD高
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._change = true;
                this._rectangle.height = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "rotationX", {
            /**
            * @language zh_CN
            * 返回x旋转
            * @returns x旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rotation.x;
            },
            /**
            * @language zh_CN
            * 设置x轴旋转。</p>
            * @param value x轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._change = true;
                if (this._rotation.x == value)
                    return;
                this._rotation.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "rotationY", {
            /**
            * @language zh_CN
            * 返回y旋转
            * @returns y旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rotation.y;
            },
            /**
            * @language zh_CN
            * 设置y轴旋转。</p>
            * @param value y轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._change = true;
                if (this._rotation.y == value)
                    return;
                this._rotation.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "rotationZ", {
            /**
            * @language zh_CN
            * 返回z旋转
            * @returns z旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rotation.z;
            },
            /**
            * @language zh_CN
            * 设置z轴旋转。</p>
            * @param value z轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._change = true;
                if (this._rotation.z == value)
                    return;
                this._rotation.z = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "viewPort", {
            /**
            * @private
            */
            set: function (viewPort) {
                this._viewPort = viewPort;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "uScale", {
            /**
            * @private
            */
            get: function () {
                return this._uv_scale[0];
            },
            /**
            * @private
            */
            set: function (u) {
                //this._change = true;
                this._uv_scale[0] = u;
                if (this._uv_scale[0] > 1.0) {
                    this._uv_scale[0] = 1.0;
                }
                if (this._uv_scale[0] < 0.0) {
                    this._uv_scale[0] = 0.0;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "vScale", {
            /**
            * @private
            */
            get: function () {
                return this._uv_scale[1];
            },
            /**
            * @private
            */
            set: function (v) {
                //this._change = true;
                this._uv_scale[1] = v;
                if (this._uv_scale[1] > 1.0) {
                    this._uv_scale[1] = 1.0;
                }
                if (this._uv_scale[1] < 0.0) {
                    this._uv_scale[1] = 0.0;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "transformMatrix", {
            /**
            * @private
            */
            get: function () {
                if (!this._viewPort) {
                    return this._transformMatrix;
                }
                if (this._change) {
                    //this._scale.x = this._rectangle.width / this._viewPort.width * 2.0;
                    //this._scale.y = this._rectangle.height / this._viewPort.height * 2.0;
                    //this._position.x = -(this._viewPort.width - (this._rectangle.x + this._viewPort.x + this._rectangle.width / 2) * 2.0) * (1 / this._viewPort.width);
                    //this._position.y = (this._viewPort.height - (this._rectangle.y + this._viewPort.y + this._rectangle.height / 2) * 2.0) * (1 / this._viewPort.height);;
                    this._scale.x = this._rectangle.width / this._viewPort.width;
                    this._scale.y = this._rectangle.height / this._viewPort.height;
                    this._position.x = egret3d.MathUtil.ScreenToPosition(this._rectangle.x, this._rectangle.width, this._viewPort.width);
                    this._position.y = -egret3d.MathUtil.ScreenToPosition(this._rectangle.y, this._rectangle.height, this._viewPort.height);
                    this._transformMatrix.recompose(this._transformComponents);
                    this._change = false;
                }
                return this._transformMatrix;
            },
            enumerable: true,
            configurable: true
        });
        HUD.prototype.updateTexture = function (context) {
            var sampler2D;
            for (var index in this._passUsage.sampler2DList) {
                sampler2D = this._passUsage.sampler2DList[index];
                sampler2D.uniformIndex = context.getUniformLocation(this._passUsage.program3D, sampler2D.varName);
                sampler2D.texture = this[sampler2D.varName];
            }
            this._changeTexture = false;
        };
        /**
        * @private
        */
        HUD.prototype.upload = function (context) {
            if (!this._vertexBuffer3D) {
                this._vertexBuffer3D = context.creatVertexBuffer(HUD.singleQuadData);
            }
            if (!this._indexBuffer3D) {
                this._indexBuffer3D = context.creatIndexBuffer(HUD.singleQuadIndex);
            }
            this._passUsage.vertexShader.shaderType = egret3d.Shader.vertex;
            this._passUsage.fragmentShader.shaderType = egret3d.Shader.fragment;
            this._passUsage.vertexShader.addUseShaderName(this.vsShader);
            this._passUsage.fragmentShader.addUseShaderName(this.fsShader);
            //this._passUsage.vertexShader.addUseShaderName("hud_vs");
            //this._passUsage.fragmentShader.addUseShaderName("hud_fs");
            this._passUsage.vertexShader.shader = this._passUsage.vertexShader.getShader(this._passUsage);
            this._passUsage.fragmentShader.shader = this._passUsage.fragmentShader.getShader(this._passUsage);
            this._passUsage.program3D = egret3d.ShaderPool.getProgram(this._passUsage.vertexShader.shader.id, this._passUsage.fragmentShader.shader.id);
            for (var property in this._passUsage) {
                if (property.indexOf("uniform") != -1) {
                    if (this._passUsage[property]) {
                        this._passUsage[property].uniformIndex = context.getUniformLocation(this._passUsage.program3D, property);
                    }
                }
            }
            this._attList.length = 0;
            var offset = 0;
            if (this._passUsage.attribute_position) {
                if (!this._passUsage.attribute_position.uniformIndex) {
                    this._passUsage.attribute_position.uniformIndex = context.getShaderAttribLocation(this._passUsage.program3D, this._passUsage.attribute_position.varName);
                }
                this._attList.push(this._passUsage.attribute_position);
                this._passUsage.attribute_position.size = egret3d.Geometry.positionSize;
                this._passUsage.attribute_position.dataType = egret3d.ContextConfig.FLOAT;
                this._passUsage.attribute_position.normalized = false;
                this._passUsage.attribute_position.stride = HUD.vertexBytes;
                this._passUsage.attribute_position.offset = offset;
                offset += egret3d.Geometry.positionSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this._passUsage.attribute_uv0) {
                if (!this._passUsage.attribute_uv0.uniformIndex) {
                    this._passUsage.attribute_uv0.uniformIndex = context.getShaderAttribLocation(this._passUsage.program3D, this._passUsage.attribute_uv0.varName);
                }
                this._attList.push(this._passUsage.attribute_uv0);
                this._passUsage.attribute_uv0.size = egret3d.Geometry.uvSize;
                this._passUsage.attribute_uv0.dataType = egret3d.ContextConfig.FLOAT;
                this._passUsage.attribute_uv0.normalized = false;
                this._passUsage.attribute_uv0.stride = HUD.vertexBytes;
                this._passUsage.attribute_uv0.offset = offset;
                offset += egret3d.Geometry.uvSize * Float32Array.BYTES_PER_ELEMENT;
            }
            this._passUsage["uv_scale"] = context.getUniformLocation(this._passUsage.program3D, "uv_scale");
        };
        /**
        * @private
        */
        HUD.prototype.draw = function (contextProxy) {
            if (!this.visible) {
                return;
            }
            if (!this._passUsage.program3D) {
                this.upload(contextProxy);
            }
            contextProxy.setProgram(this._passUsage.program3D);
            contextProxy.bindVertexBuffer(this._vertexBuffer3D);
            contextProxy.bindIndexBuffer(this._indexBuffer3D);
            contextProxy.activeVertexFormat(this._vertexFormat);
            for (var i = 0; i < this._attList.length; ++i) {
                contextProxy.vertexAttribPointer(this._attList[i].uniformIndex, this._attList[i].size, this._attList[i].dataType, this._attList[i].normalized, this._attList[i].stride, this._attList[i].offset);
            }
            if (this._changeTexture) {
                this.updateTexture(contextProxy);
            }
            //texture 2D
            var sampler2D;
            for (var index in this._passUsage.sampler2DList) {
                sampler2D = this._passUsage.sampler2DList[index];
                if (!sampler2D.texture) {
                    continue;
                }
                sampler2D.texture.upload(contextProxy);
                contextProxy.setTexture2DAt(sampler2D.activeTextureIndex, sampler2D.uniformIndex, sampler2D.index, sampler2D.texture.texture2D);
            }
            if (this._passUsage.uniform_ViewProjectionMatrix) {
                contextProxy.uniformMatrix4fv(this._passUsage.uniform_ViewProjectionMatrix.uniformIndex, false, this.transformMatrix.rawData);
            }
            if (this._passUsage["uv_scale"] && this._passUsage["uv_scale"] != -1) {
                contextProxy.uniform2f(this._passUsage["uv_scale"], this._uv_scale[0], this._uv_scale[1]);
            }
            contextProxy.setCulling(this.cullMode);
            if (this.bothside) {
                contextProxy.disableCullFace();
            }
            else
                contextProxy.enableCullFace();
            contextProxy.enableBlend();
            contextProxy.setBlendFactors(egret3d.ContextConfig.SRC_ALPHA, egret3d.ContextConfig.ONE_MINUS_SRC_ALPHA);
            contextProxy.drawElement(egret3d.DrawMode.TRIANGLES, 0, 6);
            contextProxy.clear(egret3d.ContextConfig.DEPTH_BUFFER_BIT);
            //for (var i: number = 0; i < this._attList.length; ++i) {
            //    if (this._attList[i].uniformIndex >= 0)
            //        context.clearVaPointer(this._attList[i].uniformIndex);
            //}
            //for (var index in this._passUsage.sampler2DList) {
            //    sampler2D = this._passUsage.sampler2DList[index];
            //    if (!sampler2D.texture) {
            //        continue;
            //    }
            //    context.disableTexture2DAt(sampler2D.activeTextureIndex, sampler2D.uniformIndex, sampler2D.index );
            //}
        };
        HUD.singleQuadData = [
            -1.0, -1.0, 0.0, 0.0, 1.0,
            1.0, -1.0, 0.0, 1.0, 1.0,
            1.0, 1.0, 0.0, 1.0, 0.0,
            -1.0, 1.0, 0.0, 0.0, 0.0
        ];
        HUD.singleQuadIndex = [0, 1, 2, 0, 2, 3];
        HUD.vertexBytes = 20;
        return HUD;
    }());
    egret3d.HUD = HUD;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @class egret3d.View3D
     * @classdesc
     * 渲染视图。</p>
     * view3D 是整个3D引擎的渲染视口，可以控制渲染窗口的大小，渲染的方式。</p>
     * 可以设置不同的相机 Camera3D。</p>
     * 交换不同的场景元素 Scene3D 。</p>
     * 当前的View3D中会有一个Scene3D的节点和一个Camera3D来进行场景中的渲染。
     * 整个渲染的主循环通过 update  。</p>
     * Engre3DCanvas 中的View3D列表会主动调用View3D的update,加入了Engre3DCanvas中的View3D列表后不需要使用者update
     * @includeExample View3D.ts
     * @see egret3d.Camera3D
     * @see egret3d.Scene3D
     * @see egret3d.Egret3DCanvas
     * @version Egret 3.0
     * @platform Web,Native
     */
    var View3D = (function () {
        /**
        * @language zh_CN
        * 构建一个view3d对象
        * @param x 视口的屏幕x坐标
        * @param y 视口的屏幕y坐标
        * @param width 视口的屏幕宽度
        * @param height 视口的屏幕高度
        * @param camera 摄像机 默认参数为null，会在内部新建一个CameraType.perspective 类型的Camera3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        function View3D(x, y, width, height, camera) {
            if (camera === void 0) { camera = null; }
            this._viewPort = new egret3d.Rectangle();
            this._scene = new egret3d.Scene3D();
            this._scissorRect = new egret3d.Rectangle();
            this._viewMatrix = new egret3d.Matrix4_4();
            this._backColor = new egret3d.Vector3D(0.3, 0.3, 0.6, 1.0);
            this._cleanParmerts = egret3d.Context3DProxy.gl.COLOR_BUFFER_BIT | egret3d.Context3DProxy.gl.DEPTH_BUFFER_BIT;
            this._sizeDiry = false;
            this._huds = new Array();
            this._postList = [];
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.a = 0;
            this._entityCollect = new egret3d.EntityCollect();
            this._entityCollect.root = this._scene;
            this._render = new egret3d.MultiRender(egret3d.PassType.diffusePass);
            this._camera = camera || new egret3d.Camera3D(egret3d.CameraType.perspective);
            this._camera.name = "MainCamera";
            this._scene.addChild3D(this._camera);
            this._viewPort.x = x;
            this._viewPort.y = y;
            this._viewPort.width = width;
            this._viewPort.height = height;
            this._camera.aspectRatio = this._viewPort.width / this._viewPort.height;
            this._camera.updateViewport(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
        }
        Object.defineProperty(View3D.prototype, "render", {
            get: function () {
                return this._render;
            },
            set: function (render) {
                this._render = render;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "post", {
            set: function (list) {
                this._postList = list;
                if (list.length > 0) {
                    this._postProcessing = this._postProcessing || new egret3d.PostProcessing();
                    this._postHUD = this._postHUD || new egret3d.HUD(0, 0, 512, 512);
                    this._postHUD.fsShader = "hud_H_fs";
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 设置是否清除背景缓冲颜色 和 深度
        * @param cleanColor 是否清除背景缓冲颜色
        * @param cleanDepth 是否清除背景缓冲深度
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.blender = function (cleanColor, cleanDepth) {
            this._cleanParmerts = (cleanColor ? egret3d.Context3DProxy.gl.COLOR_BUFFER_BIT : 0) | (cleanDepth ? egret3d.Context3DProxy.gl.DEPTH_BUFFER_BIT : 0);
        };
        Object.defineProperty(View3D.prototype, "backColor", {
            /**
            * @language zh_CN
            * 获取view3d背景颜色
            * @returns number 颜色值 a r g b
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return (this._backColor.w * 255 << 24) | (this._backColor.x * 255 << 16) | (this._backColor.y * 255 << 8) | (this._backColor.z * 255);
            },
            /**
            * @language zh_CN
            * 设置view3d背景颜色
            * @param value  颜色值 a r g b
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._backColor.w = (value >> 24 & 0xff) / 255;
                this._backColor.x = (value >> 16 & 0xff) / 255;
                this._backColor.y = (value >> 8 & 0xff) / 255;
                this._backColor.z = (value & 0xff) / 255;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "backImage", {
            get: function () {
                return this._backImg.diffuseTexture;
            },
            set: function (tex) {
                if (tex) {
                    this._backImg = this._backImg || new egret3d.HUD();
                    this._backImg.diffuseTexture = tex;
                    this._backImg.x = this.x;
                    this._backImg.y = this.y;
                    this._backImg.width = this.width;
                    this._backImg.height = this.height;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "camera3D", {
            /**
            * @language zh_CN
            * 获取View3d中的渲染摄像机
            * @returns Camera3D 当前View3D的摄像机
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._camera;
            },
            /**
            * @language zh_CN
            * 设置View3d中的渲染摄像机
            * @param value 当前View3D的摄像机
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._camera = value;
                this._camera.aspectRatio = this._viewPort.width / this._viewPort.height;
                this._camera.updateViewport(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "scene", {
            /**
            * @language zh_CN
            * 获取View3d中的场景对象
            * @returns Scene3D 场景对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._scene;
            },
            /**
            * @language zh_CN
            * 设置View3d中的场景对象
            * @param sc 当前View3D的场景对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (sc) {
                this._scene = sc;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "x", {
            /**
            * @language zh_CN
            * 获得当前视口的屏幕x坐标
            * @returns number 视口的屏幕x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._viewPort.x;
            },
            /**
            * @language zh_CN
            * 设置当前视口的屏幕x坐标
            * @param x 视口的屏幕x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._viewPort.x = value;
                this._camera.updateViewport(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
                if (this._backImg) {
                    this._backImg.x = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "y", {
            /**
            * @language zh_CN
            * 获得当前视口的屏幕y坐标
            * @returns number 视口的屏幕y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._viewPort.y;
            },
            /**
            * @language zh_CN
            * 设置当前视口的屏幕y坐标
            * @param y 视口的屏幕y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._viewPort.y = value;
                this._camera.updateViewport(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
                if (this._backImg) {
                    this._backImg.y = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "width", {
            /**
            * @language zh_CN
            * 获取视口的屏幕宽度
            * @returns number 视口的屏幕宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._viewPort.width;
            },
            /**
            * @language zh_CN
            * 设置视口的屏幕宽度
            * @param width 视口的屏幕宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._viewPort.width = value;
                this._camera.aspectRatio = this._viewPort.width / this._viewPort.height;
                this._camera.updateViewport(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
                if (this._backImg) {
                    this._backImg.width = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "height", {
            /**
            * @language zh_CN
            * 获取视口的屏幕高度
            * @returns number 视口的屏幕高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._viewPort.height;
            },
            /**
            * @language zh_CN
            * 设置视口的屏幕高度
            * @param width 视口的屏幕高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._viewPort.height = value;
                this._camera.aspectRatio = this._viewPort.width / this._viewPort.height;
                this._camera.updateViewport(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
                if (this._backImg) {
                    this._backImg.height = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "viewPort", {
            /**
            * @language zh_CN
            * 获取视口数据 x y width height
            * @returns Rectangle 视口数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._viewPort;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "entityCollect", {
            /**
            * @private
            * @language zh_CN
            * 获取View3D的数据收集对象
            * @returns EntityCollect 数据收集对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._entityCollect;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 添加一个Object3D对象进场景根节点
        * @param child3d Object3D需要添加的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.addChild3D = function (child3d) {
            this._scene.addChild3D(child3d);
        };
        /**
        * @language zh_CN
        * 从场景根节点中移除一个Object3D对象
        * @param child3d 需要移除的Object3D对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.removeChild3D = function (child3d) {
            this._scene.removeChild3D(child3d);
        };
        /**
        * @language zh_CN
        * 检测x y 是否在当前视口内
        * @param x  x 坐标。
        * @param y  y 坐标。
        */
        View3D.prototype.inView3D = function (x, y) {
            return this._viewPort.inner(x, y);
        };
        /**
        * @language zh_CN
        * 添加 HUD 到渲染列表中
        * @param hud 需要增加的HUD
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.addHUD = function (hud) {
            if (this._huds.indexOf(hud) == -1) {
                hud.viewPort = this._viewPort;
                this._huds.push(hud);
            }
        };
        /**
        * @language zh_CN
        * 查找HUD
        * @param name hud 名字
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.findHud = function (name) {
            for (var i = 0; i < this._huds.length; ++i) {
                if (this._huds[i].name == name) {
                    return this._huds[i];
                }
            }
            return null;
        };
        /**
        * @language zh_CN
        * 在渲染列表中删除一个HUD
        * @param hud 需要删除的HUD
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.delHUD = function (hud) {
            var index = this._huds.indexOf(hud);
            if (index >= 0 && index < this._huds.length) {
                this._huds.splice(index, 1);
            }
        };
        View3D.prototype.update = function (time, delay) {
            this._camera.viewPort = this._viewPort;
            this._entityCollect.update(this._camera);
            //------------------
            this.updateObject3D(this._scene.root, time, delay);
            //this._numberEntity = this._entityCollect.renderList.length;
            //for (this._index = 0; this._index < this._numberEntity; this._index++) {
            //    this._renderItem = this._entityCollect.renderList[this._index];
            //    this._renderItem.update(time, delay, this._camera);
            //}
            //------------------
            //this._render.update(time, delay, this._entityCollect, this._camera);
            egret3d.Egret3DCanvas.context3DProxy.viewPort(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
            egret3d.Egret3DCanvas.context3DProxy.setScissorRectangle(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
            if (egret3d.ShadowCast.instance.shadowRender[0]) {
                egret3d.MathUtil.CALCULATION_QUATERNION.fromEulerAngles(0, this.a++, 0);
                var v = new egret3d.Vector3D(0, -1, -1);
                egret3d.MathUtil.CALCULATION_QUATERNION.transformVector(v, egret3d.ShadowCast.instance.dir);
                egret3d.ShadowCast.instance.shadowRender[0].draw(time, delay, egret3d.Egret3DCanvas.context3DProxy, this._entityCollect, egret3d.ShadowCast.instance.shadowCamera, this._viewPort, true);
            }
            if (this._cleanParmerts & egret3d.Context3DProxy.gl.COLOR_BUFFER_BIT) {
                egret3d.Egret3DCanvas.context3DProxy.clearColor(this._backColor.x, this._backColor.y, this._backColor.z, this._backColor.w);
            }
            egret3d.Egret3DCanvas.context3DProxy.clear(this._cleanParmerts);
            if (this._backImg) {
                this._backImg.draw(egret3d.Egret3DCanvas.context3DProxy);
            }
            if (this._postList.length > 0) {
                this._postProcessing.postItem = this._postList;
                this._postProcessing.drawFrameBuffer(time, delay, egret3d.Egret3DCanvas.context3DProxy, this._entityCollect, this._camera, this._viewPort);
                this._postHUD.diffuseTexture = this._postProcessing.endTexture;
                //this._postHUD.viewPort = this._viewPort ;
                this._postHUD.draw(egret3d.Egret3DCanvas.context3DProxy);
            }
            else {
                this._render.draw(time, delay, egret3d.Egret3DCanvas.context3DProxy, this._entityCollect, this._camera, this._viewPort);
            }
            for (var i = 0; i < this._huds.length; ++i) {
                this._huds[i].draw(egret3d.Egret3DCanvas.context3DProxy);
            }
        };
        View3D.prototype.updateObject3D = function (object3d, time, delay) {
            if (object3d) {
                object3d.update(time, delay, this.camera3D);
                for (var i = 0; i < object3d.childs.length; ++i) {
                    this.updateObject3D(object3d.childs[i], time, delay);
                }
            }
        };
        /**
        * @language zh_CN
        * 请求全屏
        */
        View3D.requestFullScreen = function () {
            var dom = document.documentElement;
            if (dom.requestFullscreen) {
                dom.requestFullscreen();
            }
            else if (dom.webkitRequestFullScreen) {
                dom.webkitRequestFullScreen();
            }
        };
        /**
        * @language zh_CN
        * 退出全屏
        */
        View3D.exitFullscreen = function () {
            var de = document;
            if (de.exitFullscreen) {
                de.exitFullscreen();
            }
            else if (de.webkitCancelFullScreen) {
                de.webkitCancelFullScreen();
            }
        };
        return View3D;
    }());
    egret3d.View3D = View3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @class egret3d.View3D
     * @classdesc
     * VRView3D 会把场景渲染成两个视口。
     * 两个视口是由不同的摄像机渲染出来的结果，也相当由左右眼。
     * @see egret3d.Camera3D
     * @see egret3d.Scene3D
     * @see egret3d.Egret3DCanvas
     * @version Egret 3.0
     * @platform Web,Native
     */
    var VRView3D = (function (_super) {
        __extends(VRView3D, _super);
        /**
        * @language zh_CN
        * 构建一个view3d对象
        * @param x 视口的屏幕x坐标
        * @param y 视口的屏幕y坐标
        * @param width 视口的屏幕宽度
        * @param height 视口的屏幕高度
        * @version Egret 3.0
        * @platform Web,Native
        */
        function VRView3D(x, y, width, height) {
            _super.call(this, x, y, width, height, new egret3d.Camera3D(egret3d.CameraType.VR));
            this.leftViewPort = new egret3d.Rectangle();
            this.rightViewPort = new egret3d.Rectangle();
            this.updateViewport();
        }
        VRView3D.prototype.updateViewport = function () {
            this.leftViewPort.x = this._viewPort.x;
            this.leftViewPort.y = this._viewPort.y;
            this.leftViewPort.width = this._viewPort.width / 2;
            this.leftViewPort.height = this._viewPort.height;
            this.rightViewPort.x = this._viewPort.x + this.leftViewPort.width;
            this.rightViewPort.y = this._viewPort.y;
            this.rightViewPort.width = this.leftViewPort.width;
            this.rightViewPort.height = this.leftViewPort.height;
        };
        Object.defineProperty(VRView3D.prototype, "x", {
            /**
            * @language zh_CN
            * 设置当前视口的屏幕x坐标
            * @param x 视口的屏幕x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._viewPort.x = value;
                this.updateViewport();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VRView3D.prototype, "y", {
            /**
            * @language zh_CN
            * 设置当前视口的屏幕y坐标
            * @param y 视口的屏幕y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._viewPort.y = value;
                this.updateViewport();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VRView3D.prototype, "width", {
            /**
            * @language zh_CN
            * 设置视口的屏幕宽度
            * @param width 视口的屏幕宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._viewPort.width = value;
                this._camera.aspectRatio = this._viewPort.width / this._viewPort.height;
                this.updateViewport();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VRView3D.prototype, "height", {
            /**
            * @language zh_CN
            * 设置视口的屏幕高度
            * @param width 视口的屏幕高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._viewPort.height = value;
                this._camera.aspectRatio = this._viewPort.width / this._viewPort.height;
                this.updateViewport();
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        VRView3D.prototype.update = function (time, delay) {
            this._entityCollect.update(this._camera);
            //  this._render.update(time, delay, this._entityCollect, this._camera);
            //------------------
            this._numberEntity = this._entityCollect.renderList.length;
            for (this._index = 0; this._index < this._numberEntity; this._index++) {
                this._entityCollect.renderList[this._index].update(time, delay, this._camera);
            }
            //------------------
            var viewPort = this.leftViewPort;
            this._camera.viewPort = viewPort;
            this._camera.tap(egret3d.CameraType.VR, egret3d.VRType.left);
            egret3d.Egret3DCanvas.context3DProxy.viewPort(viewPort.x, viewPort.y, viewPort.width, viewPort.height);
            egret3d.Egret3DCanvas.context3DProxy.setScissorRectangle(viewPort.x, viewPort.y, viewPort.width, viewPort.height);
            if (this._cleanParmerts & egret3d.Context3DProxy.gl.COLOR_BUFFER_BIT) {
                egret3d.Egret3DCanvas.context3DProxy.clearColor(this._backColor.x, this._backColor.y, this._backColor.z, this._backColor.w);
            }
            egret3d.Egret3DCanvas.context3DProxy.clear(this._cleanParmerts);
            this._render.draw(time, delay, egret3d.Egret3DCanvas.context3DProxy, this._entityCollect, this._camera);
            viewPort = this.rightViewPort;
            this._camera.viewPort = viewPort;
            this._camera.tap(egret3d.CameraType.VR, egret3d.VRType.right);
            egret3d.Egret3DCanvas.context3DProxy.viewPort(viewPort.x, viewPort.y, viewPort.width, viewPort.height);
            egret3d.Egret3DCanvas.context3DProxy.setScissorRectangle(viewPort.x, viewPort.y, viewPort.width, viewPort.height);
            if (this._cleanParmerts & egret3d.Context3DProxy.gl.COLOR_BUFFER_BIT) {
                egret3d.Egret3DCanvas.context3DProxy.clearColor(this._backColor.x, this._backColor.y, this._backColor.z, this._backColor.w);
            }
            egret3d.Egret3DCanvas.context3DProxy.clear(this._cleanParmerts);
            this._render.draw(time, delay, egret3d.Egret3DCanvas.context3DProxy, this._entityCollect, this._camera);
        };
        Object.defineProperty(VRView3D.prototype, "eyeDistance", {
            /**
            * @language zh_CN
            * 获取两只眼睛之间的距离
            * @returns number 眼睛之间的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._camera.eyeMatrix.eyeSpace;
            },
            /**
            * @language zh_CN
            * 设置两只眼睛之间的距离
            * @param eyeDis  两只眼睛之间的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (eyeDis) {
                this._camera.eyeMatrix.eyeSpace = eyeDis;
            },
            enumerable: true,
            configurable: true
        });
        return VRView3D;
    }(egret3d.View3D));
    egret3d.VRView3D = VRView3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Egret3DCanvas
    * @classdesc
    * 3dCanvas 是一个3d渲染画布 它继承EventDispatcher 可以监听部分事件。
    * 如：Event3D.ENTER_FRAME 每帧响应回调事件
    * 一个3d渲染画布里面有多个view3d ，
    * 多个view3d进行渲染
    * @includeExample Egret3DCanvas.ts
    * @see egret3d.EventDispatcher
    * @see egret3d.View3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Egret3DCanvas = (function (_super) {
        __extends(Egret3DCanvas, _super);
        /**
        * @language zh_CN
        * 构造一个Egret3DCanvas对象
        * @param blend2D 暂时未使用，默认参数为false
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Egret3DCanvas(blend2D) {
            if (blend2D === void 0) { blend2D = false; }
            _super.call(this);
            /**
            * @private
            */
            this.canvas3DRectangle = new egret3d.Rectangle();
            this._view3DS = new Array();
            this.sizeDiry = true;
            this._time = 0;
            this._delay = 0;
            this._timeDate = null;
            /**
            * @language zh_CN
            * Egret3DCanvas X 偏移
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.offsetX = 0;
            /**
            * @language zh_CN
            * Egret3DCanvas Y 偏移
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.offsetY = 0;
            egret3d.ShaderUtil.instance.load();
            this._envetManager = new egret3d.EventManager(this);
            this.canvas = document.createElement("canvas");
            this.canvas.style.position = "absolute";
            this.canvas.style.zIndex = "-1";
            if (document.getElementsByClassName("egret-player").length > 0) {
                document.getElementsByClassName("egret-player")[0].appendChild(this.canvas);
            }
            else {
                document.body.appendChild(this.canvas);
            }
            this.canvas.id = "egret3D";
            this.canvas.oncontextmenu = function () {
                return false;
            };
            Egret3DCanvas.context3DProxy = new egret3d.Context3DProxy();
            egret3d.Context3DProxy.gl = this.canvas.getContext("experimental-webgl");
            if (!egret3d.Context3DProxy.gl)
                egret3d.Context3DProxy.gl = this.canvas.getContext("webgl");
            if (!egret3d.Context3DProxy.gl)
                alert("you drivers not suport webgl");
            Egret3DCanvas.context3DProxy.register();
            console.log("this.context3D ==>", egret3d.Context3DProxy.gl);
            egret3d.Input.canvas = this;
            this.initEvent();
        }
        Egret3DCanvas.prototype.initEvent = function () {
            this._enterFrameEvent3D = new egret3d.Event3D(egret3d.Event3D.ENTER_FRAME);
            this._enterFrameEvent3D.target = this;
        };
        Object.defineProperty(Egret3DCanvas.prototype, "x", {
            /**
            * @language zh_CN
            * 获取 Egret3DCanvas 的x坐标
            * @returns number 返回x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.canvas3DRectangle.x;
            },
            /**
            * @language zh_CN
            * 设置 Egret3DCanvas 的x坐标
            * @param x x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this.canvas3DRectangle.x != value)
                    this.resize(value, this.canvas3DRectangle.y, this.canvas3DRectangle.width, this.canvas3DRectangle.height);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Egret3DCanvas.prototype, "y", {
            /**
            * @language zh_CN
            * 获取 Egret3DCanvas 的y坐标
            * @returns number 返回y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.canvas3DRectangle.y;
            },
            /**
            * @language zh_CN
            * 设置 Egret3DCanvas 的y坐标
            * @param y y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this.canvas3DRectangle.y != value)
                    this.resize(this.canvas3DRectangle.x, value, this.canvas3DRectangle.width, this.canvas3DRectangle.height);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Egret3DCanvas.prototype, "width", {
            /**
            * @language zh_CN
            * 获取 Egret3DCanvas 的宽度
            * @returns number 返回Egret3DCanvas 的宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.canvas3DRectangle.width;
            },
            /**
            * @language zh_CN
            * 设置 Egret3DCanvas 的宽度
            * @param value Egret3DCanvas 的宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this.canvas3DRectangle.width != value)
                    this.resize(this.canvas3DRectangle.x, this.canvas3DRectangle.y, value, this.canvas3DRectangle.height);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Egret3DCanvas.prototype, "height", {
            /**
            * @language zh_CN
            * 获取 Egret3DCanvas 的高度
            * @returns number 返回Egret3DCanvas 的高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.canvas3DRectangle.height;
            },
            /**
            * @language zh_CN
            * 设置 Egret3DCanvas 的高度
            * @param value Egret3DCanvas 的高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this.canvas3DRectangle.height != value)
                    this.resize(this.canvas3DRectangle.x, this.canvas3DRectangle.y, this.canvas3DRectangle.width, value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Egret3DCanvas.prototype, "view3Ds", {
            /**
            * @language zh_CN
            * 获取 Egret3DCanvas 所有的view3d
            * @returns Array<View3D> 返回Egret3DCanvas view3ds列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._view3DS;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * Egret3DCanvas 中 增加一个view3d
        * @param view3D 增加的渲染视口
        * @version Egret 3.0
        * @platform Web,Native
        */
        Egret3DCanvas.prototype.addView3D = function (view3D) {
            var index = this._view3DS.indexOf(view3D);
            if (index == -1)
                this._view3DS.push(view3D);
        };
        /**
        * @language zh_CN
        * Egret3DCanvas 中 移除一个view3d
        * @param view3D 移除的渲染视口
        * @version Egret 3.0
        * @platform Web,Native
        */
        Egret3DCanvas.prototype.removeView3D = function (view3D) {
            var index = this._view3DS.indexOf(view3D);
            if (index != -1)
                this._view3DS.splice(index);
        };
        /**
        * @language zh_CN
        * Egret3DCanvas 开始启动
        * @version Egret 3.0
        * @platform Web,Native
        */
        Egret3DCanvas.prototype.start = function () {
            this.update(0);
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        Egret3DCanvas.prototype.update = function (delay) {
            var _this = this;
            this._timeDate = new Date();
            this._delay = this._timeDate.getTime() - this._time;
            this._time = this._timeDate.getTime();
            this._enterFrameEvent3D.time += this._time;
            this._enterFrameEvent3D.delay = this._delay;
            this.dispatchEvent(this._enterFrameEvent3D);
            //Context3DProxy.gl.enable(ContextConfig.BLEND);
            //Context3DProxy.gl.enable(ContextConfig.CULL_FACE);
            //Context3DProxy.gl.enable(Context3DProxy.gl.SCISSOR_TEST);
            Egret3DCanvas.context3DProxy.enableBlend();
            Egret3DCanvas.context3DProxy.enableCullFace();
            egret3d.Context3DProxy.gl.enable(egret3d.Context3DProxy.gl.SCISSOR_TEST);
            Egret3DCanvas.context3DProxy.viewPort(this.canvas3DRectangle.x, this.canvas3DRectangle.y, this.canvas3DRectangle.width, this.canvas3DRectangle.height);
            Egret3DCanvas.context3DProxy.setScissorRectangle(this.canvas3DRectangle.x, this.canvas3DRectangle.y, this.canvas3DRectangle.width, this.canvas3DRectangle.height);
            egret3d.CameraManager.instance.update(this._time, this._delay);
            for (var i = 0; i < this._view3DS.length; i++) {
                this._view3DS[i].update(this._time, this._delay);
            }
            requestAnimationFrame(function (delay) { return _this.update(delay); });
        };
        /**
        * @language zh_CN
        * 初始化,并创建显示区域的后台缓冲大小。
        * @param GPU_CONFIG
        * @param canvasRec
        * @event call
        */
        Egret3DCanvas.prototype.resize = function (x, y, width, height) {
            this.canvas3DRectangle.x = x;
            this.canvas3DRectangle.y = y;
            this.canvas3DRectangle.width = width;
            this.canvas3DRectangle.height = height;
            egret3d.ContextConfig.canvasRectangle = this.canvas3DRectangle;
            this.canvas.style.left = this.canvas3DRectangle.x.toString() + "px";
            this.canvas.style.top = this.canvas3DRectangle.y.toString() + "px";
            this.canvas.width = this.canvas3DRectangle.width;
            this.canvas.height = this.canvas3DRectangle.height;
        };
        return Egret3DCanvas;
    }(egret3d.EventDispatcher));
    egret3d.Egret3DCanvas = Egret3DCanvas;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var MainPass = (function () {
        function MainPass() {
            this._debugHud = new egret3d.HUD();
            this.mainPassRender = new egret3d.MultiRender(egret3d.PassType.diffusePass);
            this.mainPassRender.setRenderToTexture(2048, 2048, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB);
            this._debugHud.fsShader = "hud_H_fs";
            this._debugHud.x = 512;
            this._debugHud.y = 0;
            this._debugHud.width = 256;
            this._debugHud.height = 256;
        }
        MainPass.prototype.drawTexture = function (time, delay, context3D, collect, camera, backViewPort, posList) {
            this.mainPassRender.draw(time, delay, context3D, collect, camera, backViewPort);
            //this._debugHud.viewPort = camera.viewPort;
            //this._debugHud.diffuseTexture = this.mainPassRender.renderTexture;
            //this._debugHud.draw(context3D);
            posList["mainPass"] = this.mainPassRender.renderTexture;
            posList["end"] = this.mainPassRender.renderTexture;
            posList["colorTexture"] = this.mainPassRender.renderTexture;
        };
        return MainPass;
    }());
    egret3d.MainPass = MainPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var BloomPass = (function () {
        function BloomPass() {
            this._debugHud = new egret3d.HUD();
            this.postRender = new egret3d.PostRender("hud_vs", "bloom_fs");
            this.postRender.setRenderToTexture(256, 256, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB);
            this.gaussPass = new egret3d.GaussPass();
            this._debugHud.fsShader = "hud_H_fs";
            this._debugHud.x = 512 + 256;
            this._debugHud.y = 0;
            this._debugHud.width = 128;
            this._debugHud.height = 128;
        }
        BloomPass.prototype.drawTexture = function (time, delay, context3D, collect, camera, backViewPort, posList) {
            //this._debugHud.viewPort = camera.viewPort;
            //this._debugHud.diffuseTexture = posList["colorTexture"];
            //this._debugHud.draw(context3D);
            this.postRender.draw(time, delay, context3D, collect, camera, backViewPort, posList);
            posList["bloomPass"] = this.postRender.renderTexture;
            posList["end"] = this.postRender.renderTexture;
            this.gaussPass.drawTexture(time, delay, context3D, collect, camera, backViewPort, posList);
        };
        return BloomPass;
    }());
    egret3d.BloomPass = BloomPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var GaussPass = (function () {
        function GaussPass() {
            this._debugHud = new egret3d.HUD();
            this._h_postRender = new egret3d.PostRender("hud_vs", "gaussian_H_fs");
            this._h_postRender.setRenderToTexture(2048, 2048, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB);
            this._v_postRender = new egret3d.PostRender("hud_vs", "gaussian_V_fs"); //"gaussian_V_fs");
            this._v_postRender.setRenderToTexture(2048, 2048, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB);
            this._debugHud.fsShader = "hud_H_fs";
            this._debugHud.x = 512 + 256;
            this._debugHud.y = 0;
            this._debugHud.width = 128;
            this._debugHud.height = 128;
        }
        GaussPass.prototype.drawTexture = function (time, delay, context3D, collect, camera, backViewPort, posList) {
            this._h_postRender.draw(time, delay, context3D, collect, camera, backViewPort, posList);
            posList["end"] = this._h_postRender.renderTexture;
            this._v_postRender.draw(time, delay, context3D, collect, camera, backViewPort, posList);
            posList["end"] = this._v_postRender.renderTexture;
            posList["bloomPass"] = this._v_postRender.renderTexture;
            //this._debugHud.viewPort = camera.viewPort;
            //this._debugHud.diffuseTexture = this._v_postRender.renderTexture;
            //this._debugHud.draw(context3D);
        };
        return GaussPass;
    }());
    egret3d.GaussPass = GaussPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var PostProcessing = (function () {
        function PostProcessing() {
            this.posTex = {};
            this.postItem = [];
            this.postRender = new egret3d.MultiRender(egret3d.PassType.diffusePass);
            this.postRender.setRenderToTexture(1024, 1024, egret3d.FrameBufferFormat.FLOAT_RGB);
            this.endTexture = this.posTex["end"] = this.postRender.renderTexture;
        }
        PostProcessing.prototype.drawFrameBuffer = function (time, delay, context3D, collect, camera, backViewPort) {
            if (backViewPort === void 0) { backViewPort = null; }
            for (var i = 0; i < this.postItem.length; i++) {
                this.postItem[i].drawTexture(time, delay, context3D, collect, camera, backViewPort, this.posTex);
                this.endTexture = this.posTex["end"];
            }
        };
        return PostProcessing;
    }());
    egret3d.PostProcessing = PostProcessing;
})(egret3d || (egret3d = {}));
