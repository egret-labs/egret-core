var nid;
(function (nid) {
    /**
     * @private
     * LZMA Decoder
     * @author Nidin Vinayakan | nidinthb@gmail.com
     */
    var LZMAConfig = (function () {
        function LZMAConfig() {
        }
        LZMAConfig.INIT_PROBS = function (p) {
            for (var i = 0; i < p.length; i++) {
                p[i] = this.PROB_INIT_VAL;
            }
        };
        LZMAConfig.BitTreeReverseDecode = function (probs, numBits, rc, offset) {
            if (offset === void 0) { offset = 0; }
            var m = 1;
            var symbol = 0;
            for (var i = 0; i < numBits; i++) {
                var bit = rc.decodeBit(probs, offset + m);
                m <<= 1;
                m += bit;
                symbol |= (bit << i);
            }
            return symbol;
        };
        LZMAConfig.LZMA_DIC_MIN = (1 << 12);
        LZMAConfig.LZMA_RES_ERROR = 0;
        LZMAConfig.LZMA_RES_FINISHED_WITH_MARKER = 1;
        LZMAConfig.LZMA_RES_FINISHED_WITHOUT_MARKER = 2;
        LZMAConfig.kNumBitModelTotalBits = 11;
        LZMAConfig.kNumMoveBits = 5;
        LZMAConfig.PROB_INIT_VAL = ((1 << LZMAConfig.kNumBitModelTotalBits) / 2); //1024
        LZMAConfig.kNumPosBitsMax = 4;
        LZMAConfig.kNumStates = 12;
        LZMAConfig.kNumLenToPosStates = 4;
        LZMAConfig.kNumAlignBits = 4;
        LZMAConfig.kStartPosModelIndex = 4;
        LZMAConfig.kEndPosModelIndex = 14;
        LZMAConfig.kNumFullDistances = (1 << (LZMAConfig.kEndPosModelIndex >>> 1));
        LZMAConfig.kMatchMinLen = 2;
        return LZMAConfig;
    }());
    nid.LZMAConfig = LZMAConfig;
})(nid || (nid = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var egret3d;
(function (egret3d) {
    /**
     * @language en_US
     * The Endian class contains values that denote the byte order used to represent multibyte numbers.
     * The byte order is either bigEndian (most significant byte first) or littleEndian (least significant byte first).
     * @version Egret 2.4
     * @platform Web,Native
     */
    /**
     * @language zh_CN
     * Endian 类中包含一些值，它们表示用于表示多字节数字的字节顺序。
     * 字节顺序为 bigEndian（最高有效字节位于最前）或 littleEndian（最低有效字节位于最前）。
     * @version Egret 2.4
     * @platform Web,Native
     */
    var Endian = (function () {
        function Endian() {
        }
        /**
         * @language en_US
         * Indicates the least significant byte of the multibyte number appears first in the sequence of bytes.
         * The hexadecimal number 0x12345678 has 4 bytes (2 hexadecimal digits per byte). The most significant byte is 0x12. The least significant byte is 0x78. (For the equivalent decimal number, 305419896, the most significant digit is 3, and the least significant digit is 6).
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 表示多字节数字的最低有效字节位于字节序列的最前面。
         * 十六进制数字 0x12345678 包含 4 个字节（每个字节包含 2 个十六进制数字）。最高有效字节为 0x12。最低有效字节为 0x78。（对于等效的十进制数字 305419896，最高有效数字是 3，最低有效数字是 6）。
         * @version Egret 2.4
         * @platform Web,Native
         */
        Endian.LITTLE_ENDIAN = "littleEndian";
        /**
         * @language en_US
         * Indicates the most significant byte of the multibyte number appears first in the sequence of bytes.
         * The hexadecimal number 0x12345678 has 4 bytes (2 hexadecimal digits per byte).  The most significant byte is 0x12. The least significant byte is 0x78. (For the equivalent decimal number, 305419896, the most significant digit is 3, and the least significant digit is 6).
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 表示多字节数字的最高有效字节位于字节序列的最前面。
         * 十六进制数字 0x12345678 包含 4 个字节（每个字节包含 2 个十六进制数字）。最高有效字节为 0x12。最低有效字节为 0x78。（对于等效的十进制数字 305419896，最高有效数字是 3，最低有效数字是 6）。
         * @version Egret 2.4
         * @platform Web,Native
         */
        Endian.BIG_ENDIAN = "bigEndian";
        return Endian;
    }());
    egret3d.Endian = Endian;
    /**
     * @language en_US
     * The ByteArray class provides methods and attributes for optimized reading and writing as well as dealing with binary data.
     * Note: The ByteArray class is applied to the advanced developers who need to access data at the byte layer.
     * @version Egret 2.4
     * @platform Web,Native
     * @includeExample egret/utils/ByteArray.ts
     */
    /**
     * @language zh_CN
     * ByteArray 类提供用于优化读取、写入以及处理二进制数据的方法和属性。
     * 注意：ByteArray 类适用于需要在字节层访问数据的高级开发人员。
     * @version Egret 2.4
     * @platform Web,Native
     * @includeExample egret/utils/ByteArray.ts
     */
    var ByteArray = (function () {
        /**
         * 构造函数
         * @param buffer {ArrayBuffer} 二进制数据,可以为空
         * @version Egret 2.4
         * @platform Web,Native
         */
        function ByteArray(buffer) {
            /**
             * @private
             */
            this.BUFFER_EXT_SIZE = 0; //Buffer expansion size
            /**
             * @private
             */
            this.EOF_byte = -1;
            /**
             * @private
             */
            this.EOF_code_point = -1;
            this._setArrayBuffer(buffer || new ArrayBuffer(this.BUFFER_EXT_SIZE));
            this.endian = Endian.BIG_ENDIAN;
        }
        /**
         * @private
         * @param buffer
         */
        ByteArray.prototype._setArrayBuffer = function (buffer) {
            this.write_position = buffer.byteLength;
            this.data = new DataView(buffer);
            this._position = 0;
        };
        /**
         * @private
         * @deprecated
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.setArrayBuffer = function (buffer) {
        };
        Object.defineProperty(ByteArray.prototype, "buffer", {
            /**
             * 获取buffer
             * @returns {ArrayBuffer} 二进制数据
             * @version Egret 2.4
             * @platform Web,Native
             */
            get: function () {
                return this.data.buffer;
            },
            /**
              * 设置buffer
              * @param value {ArrayBuffer} 二进制数据
              * @version Egret 2.4
              * @platform Web,Native
              */
            set: function (value) {
                this.data = new DataView(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ByteArray.prototype, "dataView", {
            /**
             * @private
             * @version Egret 2.4
             * @platform Web,Native
             */
            get: function () {
                return this.data;
            },
            /**
             * @private
             */
            set: function (value) {
                this.data = value;
                this.write_position = value.byteLength;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ByteArray.prototype, "bufferOffset", {
            /**
             * @private
             */
            get: function () {
                return this.data.byteOffset;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ByteArray.prototype, "position", {
            /**
             * @language en_US
             * The current position of the file pointer (in bytes) to move or return to the ByteArray object. The next time you start reading reading method call in this position, or will start writing in this position next time call a write method.
             * @version Egret 2.4
             * @platform Web,Native
             */
            /**
             * @language zh_CN
             * 获取当前文件指针位置
             * @returns {number} 以字节为单位的位置信息
             * @version Egret 2.4
             * @platform Web,Native
             */
            get: function () {
                return this._position;
            },
            /**
             * @language zh_CN
             * 设置当前文件指针位置
             * @param value {number} 以字节为单位的位置信息
             * @version Egret 2.4
             * @platform Web,Native
             */
            set: function (value) {
                //if (this._position < value) {
                //    if (!this.validate(value - this._position)) {
                //        return;
                //    }
                //}
                this._position = value;
                this.write_position = value > this.write_position ? value : this.write_position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ByteArray.prototype, "length", {
            /**
             * @language en_US
             * The length of the ByteArray object (in bytes).
                      * If the length is set to be larger than the current length, the right-side zero padding byte array.
                      * If the length is set smaller than the current length, the byte array is truncated.
             * @version Egret 2.4
             * @platform Web,Native
             */
            /**
            * @language zh_CN
            * 获取 ByteArray 对象的长度。
            * @returns {number} 以字节为单位的长度信息
            * @version Egret 2.4
            * @platform Web,Native
            */
            get: function () {
                return this.write_position;
            },
            /**
           * @language zh_CN
           * 设置 ByteArray 对象的长度。
           * 如果将长度设置为大于当前长度的值，则用零填充字节数组的右侧。
           * 如果将长度设置为小于当前长度的值，将会截断该字节数组。
           * @param value {number} 以字节为单位的长度信息
           * @version Egret 2.4
           * @platform Web,Native
           */
            set: function (value) {
                this.write_position = value;
                var tmp = new Uint8Array(new ArrayBuffer(value));
                var byteLength = this.data.buffer.byteLength;
                if (byteLength > value) {
                    this._position = value;
                }
                var length = Math.min(byteLength, value);
                tmp.set(new Uint8Array(this.data.buffer, 0, length));
                this.buffer = tmp.buffer;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ByteArray.prototype, "bytesAvailable", {
            /**
             * @language en_US
             * The number of bytes that can be read from the current position of the byte array to the end of the array data.
             * When you access a ByteArray object, the bytesAvailable property in conjunction with the read methods each use to make sure you are reading valid data.
             * @version Egret 2.4
             * @platform Web,Native
             */
            /**
             * @language zh_CN
             * 可从字节数组的当前位置到数组末尾读取的数据的字节数。
             * 每次访问 ByteArray 对象时，将 bytesAvailable 属性与读取方法结合使用，以确保读取有效的数据。
             * @param value {number} 以字节为单位的长度信息
             * @version Egret 2.4
             * @platform Web,Native
             */
            get: function () {
                return this.data.byteLength - this._position;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language en_US
         * Clears the contents of the byte array and resets the length and position properties to 0.
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 清除字节数组的内容，并将 length 和 position 属性重置为 0。
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.clear = function () {
            this._setArrayBuffer(new ArrayBuffer(this.BUFFER_EXT_SIZE));
        };
        /**
         * @language en_US
         * Read a Boolean value from the byte stream. Read a simple byte. If the byte is non-zero, it returns true; otherwise, it returns false.
         * @return If the byte is non-zero, it returns true; otherwise, it returns false.
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 从字节流中读取布尔值。读取单个字节，如果字节非零，则返回 true，否则返回 false
         * @returns 如果字节不为零，则返回 true，否则返回 false
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.readBoolean = function () {
            if (!this.validate(ByteArray.SIZE_OF_BOOLEAN))
                return null;
            return this.data.getUint8(this.position++) != 0;
        };
        /**
         * @language en_US
         * Read signed bytes from the byte stream.
         * @return An integer ranging from -128 to 127
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 从字节流中读取带符号的字节
         * @returns {number} 介于 -128 和 127 之间的整数
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.readByte = function () {
            if (!this.validate(ByteArray.SIZE_OF_INT8))
                return null;
            return this.data.getInt8(this.position++);
        };
        /**
         * @language en_US
         * Read data byte number specified by the length parameter from the byte stream. Starting from the position specified by offset, read bytes into the ByteArray object specified by the bytes parameter, and write bytes into the target ByteArray
         * @param bytes ByteArray object that data is read into
         * @param offset Offset (position) in bytes. Read data should be written from this position
         * @param length Byte number to be read Default value 0 indicates reading all available data
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 从字节流中读取 length 参数指定的数据字节数。从 offset 指定的位置开始，将字节读入 bytes 参数指定的 ByteArray 对象中，并将字节写入目标 ByteArray 中
         * @param bytes {ByteArray} 要将数据读入的 ByteArray 对象
         * @param offset {number} bytes 中的偏移（位置），应从该位置写入读取的数据
         * @param length {number} 要读取的字节数。默认值 0 导致读取所有可用的数据
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.readBytes = function (bytes, offset, length) {
            if (offset === void 0) { offset = 0; }
            if (length === void 0) { length = 0; }
            if (length == 0) {
                length = this.bytesAvailable;
            }
            else if (!this.validate(length)) {
                return null;
            }
            if (bytes) {
                bytes.validateBuffer(offset + length);
            }
            else {
                bytes = new ByteArray(new ArrayBuffer(offset + length));
            }
            //This method is expensive
            //for (var i = 0; i < length; i++) {
            //    bytes.data.setUint8(i + offset, this.data.getUint8(this.position++));
            //}
            var dst = new Uint8Array(bytes.buffer);
            var src = new Uint8Array(this.data.buffer, this.position, length);
            dst.set(src, bytes.position);
            this.position += length;
        };
        /**
         * @language en_US
         * Read an IEEE 754 double-precision (64 bit) floating point number from the byte stream
         * @return Double-precision (64 bit) floating point number
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 从字节流中读取一个 IEEE 754 双精度（64 位）浮点数
         * @returns {number} 双精度（64 位）浮点数
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.readDouble = function () {
            if (!this.validate(ByteArray.SIZE_OF_FLOAT64))
                return null;
            var value = this.data.getFloat64(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_FLOAT64;
            return value;
        };
        /**
        * @language zh_CN
        * 解压 压缩字节流 按类型划分
        * @version Egret 2.4
        * @platform Web,Native
        */
        ByteArray.prototype.uncompress = function (type) {
            if (type === void 0) { type = "7z"; }
            var lzma = new nid.LZMA();
            var tmp = lzma.decode(new Uint8Array(this.data.buffer)).buffer;
            this.buffer = tmp;
        };
        /**
        * @language zh_CN
        * 按7z的方式压缩字节
        * @version Egret 2.4
        * @platform Web,Native
        */
        ByteArray.prototype.compress = function (type) {
            if (type === void 0) { type = "7z"; }
            var decoder = new nid.LZMA();
            var tmp = nid.LZMAHelper.encode(this.data.buffer);
            this.buffer = tmp;
        };
        /**
         * @language en_US
         * Read an IEEE 754 single-precision (32 bit) floating point number from the byte stream
         * @return Single-precision (32 bit) floating point number
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 从字节流中读取一个 IEEE 754 单精度（32 位）浮点数
         * @returns {number} 单精度（32 位）浮点数
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.readFloat = function () {
            if (!this.validate(ByteArray.SIZE_OF_FLOAT32))
                return null;
            var value = this.data.getFloat32(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_FLOAT32;
            return value;
        };
        /**
         * @language en_US
         * Read a 32-bit signed integer from the byte stream.
         * @returns A 32-bit signed integer ranging from -2147483648 to 2147483647
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 从字节流中读取一个带符号的 32 位整数
         * @returns {number} 介于 -2147483648 和 2147483647 之间的 32 位带符号整数
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.readInt = function () {
            if (!this.validate(ByteArray.SIZE_OF_INT32))
                return null;
            var value = this.data.getInt32(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_INT32;
            return value;
        };
        ///**
        // * 使用指定的字符集从字节流中读取指定长度的多字节字符串
        // * @param length 要从字节流中读取的字节数
        // * @param charSet 表示用于解释字节的字符集的字符串。可能的字符集字符串包括 "shift-jis"、"cn-gb"、"iso-8859-1"”等
        // * @return UTF-8 编码的字符串
        // * @method egret.ByteArray#readMultiByte
        // */
        //public readMultiByte(length:number, charSet?:string):string {
        //    if (!this.validate(length)) return null;
        //
        //    return "";
        //}
        /**
         * @language en_US
         * Read a 16-bit signed integer from the byte stream.
         * @returns A 16-bit signed integer ranging from -32768 to 32767
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 从字节流中读取一个带符号的 16 位整数
         * @returns {number} 介于 -32768 和 32767 之间的 16 位带符号整数
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.readShort = function () {
            if (!this.validate(ByteArray.SIZE_OF_INT16))
                return null;
            var value = this.data.getInt16(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_INT16;
            return value;
        };
        /**
         * @language en_US
         * Read unsigned bytes from the byte stream.
         * @returns A 32-bit unsigned integer ranging from 0 to 255
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 从字节流中读取无符号的字节
         * @returns {number} 介于 0 和 255 之间的 32 位无符号整数
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.readUnsignedByte = function () {
            if (!this.validate(ByteArray.SIZE_OF_UINT8))
                return null;
            return this.data.getUint8(this.position++);
        };
        /**
         * @language en_US
         * Read a 32-bit unsigned integer from the byte stream.
         * @return A 32-bit unsigned integer ranging from 0 to 4294967295
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 从字节流中读取一个无符号的 32 位整数
         * @returns {number} 介于 0 和 4294967295 之间的 32 位无符号整数
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.readUnsignedInt = function () {
            if (!this.validate(ByteArray.SIZE_OF_UINT32))
                return null;
            var value = this.data.getUint32(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT32;
            return value;
        };
        /**
         * @language en_US
         * Read a 16-bit unsigned integer from the byte stream.
         * @return A 16-bit unsigned integer ranging from 0 to 65535
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 从字节流中读取一个无符号的 16 位整数
         * @returns {number} 介于 0 和 65535 之间的 16 位无符号整数
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.readUnsignedShort = function () {
            if (!this.validate(ByteArray.SIZE_OF_UINT16))
                return null;
            var value = this.data.getUint16(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT16;
            return value;
        };
        /**
         * @language en_US
         * Read a UTF-8 character string from the byte stream Assume that the prefix of the character string is a short unsigned integer (use byte to express length)
         * @return UTF-8 character string
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 从字节流中读取一个 UTF-8 字符串。假定字符串的前缀是无符号的短整型（以字节表示长度）
         * @returns {string} UTF-8 编码的字符串
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.readUTF = function () {
            if (!this.validate(ByteArray.SIZE_OF_UINT16))
                return null;
            var length = this.data.getUint16(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT16;
            if (length > 0) {
                return this.readUTFBytes(length);
            }
            else {
                return "";
            }
        };
        /**
         * @language en_US
         * Read a UTF-8 byte sequence specified by the length parameter from the byte stream, and then return a character string
         * @param Specify a short unsigned integer of the UTF-8 byte length
         * @return A character string consists of UTF-8 bytes of the specified length
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 从字节流中读取一个由 length 参数指定的 UTF-8 字节序列，并返回一个字符串
         * @param length {number} 指明 UTF-8 字节长度的无符号短整型数
         * @returns {number} 由指定长度的 UTF-8 字节组成的字符串
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.readUTFBytes = function (length) {
            if (!this.validate(length))
                return null;
            var bytes = new Uint8Array(this.buffer, this.bufferOffset + this.position, length);
            this.position += length;
            /*var bytes: Uint8Array = new Uint8Array(new ArrayBuffer(length));
             for (var i = 0; i < length; i++) {
             bytes[i] = this.data.getUint8(this.position++);
             }*/
            return this.decodeUTF8(bytes);
        };
        /**
         * @language en_US
         * Write a Boolean value. A single byte is written according to the value parameter. If the value is true, write 1; if the value is false, write 0.
         * @param value A Boolean value determining which byte is written. If the value is true, write 1; if the value is false, write 0.
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 写入布尔值。根据 value 参数写入单个字节。如果为 true，则写入 1，如果为 false，则写入 0
         * @param value {boolean} 确定写入哪个字节的布尔值。如果该参数为 true，则该方法写入 1；如果该参数为 false，则该方法写入 0
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.writeBoolean = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_BOOLEAN);
            this.data.setUint8(this.position++, value ? 1 : 0);
        };
        /**
         * @language en_US
         * Write a byte into the byte stream
         * The low 8 bits of the parameter are used. The high 24 bits are ignored.
         * @param value A 32-bit integer. The low 8 bits will be written into the byte stream
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 在字节流中写入一个字节
         * 使用参数的低 8 位。忽略高 24 位
         * @param value {number} 一个 32 位整数。低 8 位将被写入字节流
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.writeByte = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_INT8);
            this.data.setInt8(this.position++, value);
        };
        /**
         * @language zh_CN
         * 在字节流中写入一个字节
         * 使用参数的低 8 位。忽略高 24 位
         * @param value {number} 一个 32 位整数。低 8 位将被写入字节流
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.writeUnsignedByte = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_UINT8);
            this.data.setUint8(this.position++, value);
        };
        /**
         * @language en_US
         * Write the byte sequence that includes length bytes in the specified byte array, bytes, (starting at the byte specified by offset, using a zero-based index), into the byte stream
         * If the length parameter is omitted, the default length value 0 is used and the entire buffer starting at offset is written. If the offset parameter is also omitted, the entire buffer is written
         * If the offset or length parameter is out of range, they are clamped to the beginning and end of the bytes array.
         * @param bytes ByteArray Object
         * @param offset A zero-based index specifying the position into the array to begin writing
         * @param length An unsigned integer specifying how far into the buffer to write
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 将指定字节数组 bytes（起始偏移量为 offset，从零开始的索引）中包含 length 个字节的字节序列写入字节流
         * 如果省略 length 参数，则使用默认长度 0；该方法将从 offset 开始写入整个缓冲区。如果还省略了 offset 参数，则写入整个缓冲区
         * 如果 offset 或 length 超出范围，它们将被锁定到 bytes 数组的开头和结尾
         * @param bytes {ByteArray} ByteArray 对象
         * @param offset {number} 从 0 开始的索引，表示在数组中开始写入的位置
         * @param length {number} 一个无符号整数，表示在缓冲区中的写入范围
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.writeBytes = function (bytes, offset, length) {
            if (offset === void 0) { offset = 0; }
            if (length === void 0) { length = 0; }
            var writeLength;
            if (offset < 0) {
                return;
            }
            if (length < 0) {
                return;
            }
            else if (length == 0) {
                writeLength = bytes.length - offset;
            }
            else {
                writeLength = Math.min(bytes.length - offset, length);
            }
            if (writeLength > 0) {
                this.validateBuffer(writeLength);
                var dst = new Uint8Array(this.buffer);
                var src = new Uint8Array(bytes.buffer, offset, writeLength);
                dst.set(src, this.position);
                this.position += writeLength;
            }
        };
        /**
         * @language en_US
         * Write an IEEE 754 double-precision (64 bit) floating point number into the byte stream
         * @param value Double-precision (64 bit) floating point number
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 在字节流中写入一个 IEEE 754 双精度（64 位）浮点数
         * @param value {number} 双精度（64 位）浮点数
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.writeDouble = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_FLOAT64);
            this.data.setFloat64(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_FLOAT64;
        };
        /**
         * @language en_US
         * Write an IEEE 754 single-precision (32 bit) floating point number into the byte stream
         * @param value Single-precision (32 bit) floating point number
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 在字节流中写入一个 IEEE 754 单精度（32 位）浮点数
         * @param value {number} 单精度（32 位）浮点数
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.writeFloat = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_FLOAT32);
            this.data.setFloat32(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_FLOAT32;
        };
        /**
         * @language en_US
         * Write a 32-bit signed integer into the byte stream
         * @param value An integer to be written into the byte stream
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 在字节流中写入一个带符号的 32 位整数
         * @param value {number} 要写入字节流的整数
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.writeInt = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_INT32);
            this.data.setInt32(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_INT32;
        };
        /**
         * @language en_US
         * Write a 16-bit integer into the byte stream. The low 16 bits of the parameter are used. The high 16 bits are ignored.
         * @param value A 32-bit integer. Its low 16 bits will be written into the byte stream
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 在字节流中写入一个 16 位整数。使用参数的低 16 位。忽略高 16 位
         * @param value {number} 32 位整数，该整数的低 16 位将被写入字节流
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.writeShort = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_INT16);
            this.data.setInt16(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_INT16;
        };
        /**
         * @language en_US
         * Write a 32-bit unsigned integer into the byte stream
         * @param value An unsigned integer to be written into the byte stream
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 在字节流中写入一个无符号的 32 位整数
         * @param value {number} 要写入字节流的无符号整数
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.writeUnsignedInt = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_UINT32);
            this.data.setUint32(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT32;
        };
        /**
         * @language en_US
         * Write a 16-bit unsigned integer into the byte stream
         * @param value An unsigned integer to be written into the byte stream
         * @version Egret 2.5
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 在字节流中写入一个无符号的 16 位整数
         * @param value {number} 要写入字节流的无符号整数
         * @version Egret 2.5
         * @platform Web,Native
         */
        ByteArray.prototype.writeUnsignedShort = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_UINT16);
            this.data.setUint16(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT16;
        };
        /**
         * @language en_US
         * Write a UTF-8 string into the byte stream. The length of the UTF-8 string in bytes is written first, as a 16-bit integer, followed by the bytes representing the characters of the string
         * @param value Character string value to be written
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节
         * @param value {string} 要写入的字符串值
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.writeUTF = function (value) {
            var utf8bytes = this.encodeUTF8(value);
            var length = utf8bytes.length;
            this.validateBuffer(ByteArray.SIZE_OF_UINT16 + length);
            this.data.setUint16(this.position, length, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT16;
            this._writeUint8Array(utf8bytes, false);
        };
        /**
         * @language en_US
         * Write a UTF-8 string into the byte stream. Similar to the writeUTF() method, but the writeUTFBytes() method does not prefix the string with a 16-bit length word
         * @param value Character string value to be written
         * @version Egret 2.4
         * @platform Web,Native
         */
        /**
         * @language zh_CN
         * 将 UTF-8 字符串写入字节流。类似于 writeUTF() 方法，但 writeUTFBytes() 不使用 16 位长度的词为字符串添加前缀
         * @param value {string} 要写入的字符串值
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.writeUTFBytes = function (value) {
            this._writeUint8Array(this.encodeUTF8(value));
        };
        /**
         * 返回格式化字符串信息，包含ByteArray的长度信息和bytesAvailable信息
         * @returns {string} 格式化字符串
         * @version Egret 2.4
         * @platform Web,Native
         */
        ByteArray.prototype.toString = function () {
            return "[ByteArray] length:" + this.length + ", bytesAvailable:" + this.bytesAvailable;
        };
        /**
         * @private
         * 将 Uint8Array 写入字节流
         * @param bytes {Uint8Array} 要写入的Uint8Array
         * @param validateBuffer
         */
        ByteArray.prototype._writeUint8Array = function (bytes, validateBuffer) {
            if (validateBuffer === void 0) { validateBuffer = true; }
            if (validateBuffer) {
                this.validateBuffer(this.position + bytes.length);
            }
            var dst = new Uint8Array(this.buffer);
            dst.set(bytes, this.position);
            this.position += bytes.length;
        };
        /**
         * @private
         * @param len
         * @returns
         * @version Egret 2.4
         * @platform Web,Native
         * @private
         */
        ByteArray.prototype.validate = function (len) {
            //len += this.data.byteOffset;
            if (this.data.byteLength > 0 && this._position + len <= this.data.byteLength) {
                return true;
            }
            else {
            }
        };
        /**********************/
        /*  PRIVATE METHODS   */
        /**********************/
        /**
         * @private
         * @param len
         * @param needReplace
         */
        ByteArray.prototype.validateBuffer = function (len, needReplace) {
            if (needReplace === void 0) { needReplace = false; }
            this.write_position = len > this.write_position ? len : this.write_position;
            len += this._position;
            // 如果当前缓冲数据不足 需要扩大缓冲区
            if (this.data.byteLength < len || needReplace) {
                var dst = new Uint8Array(new ArrayBuffer(len + this.BUFFER_EXT_SIZE));
                var length = Math.min(this.data.buffer.byteLength, len + this.BUFFER_EXT_SIZE);
                var src = new Uint8Array(this.data.buffer, 0, length);
                dst.set(src);
                this.buffer = dst.buffer;
            }
        };
        /**
         * @private
         * UTF-8 Encoding/Decoding
         */
        ByteArray.prototype.encodeUTF8 = function (str) {
            var pos = 0;
            var codePoints = this.stringToCodePoints(str);
            var outputBytes = [];
            while (codePoints.length > pos) {
                var code_point = codePoints[pos++];
                if (this.inRange(code_point, 0xD800, 0xDFFF)) {
                    this.encoderError(code_point);
                }
                else if (this.inRange(code_point, 0x0000, 0x007f)) {
                    outputBytes.push(code_point);
                }
                else {
                    var count, offset;
                    if (this.inRange(code_point, 0x0080, 0x07FF)) {
                        count = 1;
                        offset = 0xC0;
                    }
                    else if (this.inRange(code_point, 0x0800, 0xFFFF)) {
                        count = 2;
                        offset = 0xE0;
                    }
                    else if (this.inRange(code_point, 0x10000, 0x10FFFF)) {
                        count = 3;
                        offset = 0xF0;
                    }
                    outputBytes.push(this.div(code_point, Math.pow(64, count)) + offset);
                    while (count > 0) {
                        var temp = this.div(code_point, Math.pow(64, count - 1));
                        outputBytes.push(0x80 + (temp % 64));
                        count -= 1;
                    }
                }
            }
            return new Uint8Array(outputBytes);
        };
        /**
         * @private
         *
         * @param data
         * @returns
         */
        ByteArray.prototype.decodeUTF8 = function (data) {
            var fatal = false;
            var pos = 0;
            var result = "";
            var code_point;
            var utf8_code_point = 0;
            var utf8_bytes_needed = 0;
            var utf8_bytes_seen = 0;
            var utf8_lower_boundary = 0;
            while (data.length > pos) {
                var _byte = data[pos++];
                if (_byte == this.EOF_byte) {
                    if (utf8_bytes_needed != 0) {
                        code_point = this.decoderError(fatal);
                    }
                    else {
                        code_point = this.EOF_code_point;
                    }
                }
                else {
                    if (utf8_bytes_needed == 0) {
                        if (this.inRange(_byte, 0x00, 0x7F)) {
                            code_point = _byte;
                        }
                        else {
                            if (this.inRange(_byte, 0xC2, 0xDF)) {
                                utf8_bytes_needed = 1;
                                utf8_lower_boundary = 0x80;
                                utf8_code_point = _byte - 0xC0;
                            }
                            else if (this.inRange(_byte, 0xE0, 0xEF)) {
                                utf8_bytes_needed = 2;
                                utf8_lower_boundary = 0x800;
                                utf8_code_point = _byte - 0xE0;
                            }
                            else if (this.inRange(_byte, 0xF0, 0xF4)) {
                                utf8_bytes_needed = 3;
                                utf8_lower_boundary = 0x10000;
                                utf8_code_point = _byte - 0xF0;
                            }
                            else {
                                this.decoderError(fatal);
                            }
                            utf8_code_point = utf8_code_point * Math.pow(64, utf8_bytes_needed);
                            code_point = null;
                        }
                    }
                    else if (!this.inRange(_byte, 0x80, 0xBF)) {
                        utf8_code_point = 0;
                        utf8_bytes_needed = 0;
                        utf8_bytes_seen = 0;
                        utf8_lower_boundary = 0;
                        pos--;
                        code_point = this.decoderError(fatal, _byte);
                    }
                    else {
                        utf8_bytes_seen += 1;
                        utf8_code_point = utf8_code_point + (_byte - 0x80) * Math.pow(64, utf8_bytes_needed - utf8_bytes_seen);
                        if (utf8_bytes_seen !== utf8_bytes_needed) {
                            code_point = null;
                        }
                        else {
                            var cp = utf8_code_point;
                            var lower_boundary = utf8_lower_boundary;
                            utf8_code_point = 0;
                            utf8_bytes_needed = 0;
                            utf8_bytes_seen = 0;
                            utf8_lower_boundary = 0;
                            if (this.inRange(cp, lower_boundary, 0x10FFFF) && !this.inRange(cp, 0xD800, 0xDFFF)) {
                                code_point = cp;
                            }
                            else {
                                code_point = this.decoderError(fatal, _byte);
                            }
                        }
                    }
                }
                //Decode string
                if (code_point !== null && code_point !== this.EOF_code_point) {
                    if (code_point <= 0xFFFF) {
                        if (code_point > 0)
                            result += String.fromCharCode(code_point);
                    }
                    else {
                        code_point -= 0x10000;
                        result += String.fromCharCode(0xD800 + ((code_point >> 10) & 0x3ff));
                        result += String.fromCharCode(0xDC00 + (code_point & 0x3ff));
                    }
                }
            }
            return result;
        };
        /**
         * @private
         *
         * @param code_point
         */
        ByteArray.prototype.encoderError = function (code_point) {
            //egret.$error(1026, code_point);
        };
        /**
         * @private
         *
         * @param fatal
         * @param opt_code_point
         * @returns
         */
        ByteArray.prototype.decoderError = function (fatal, opt_code_point) {
            if (fatal) {
            }
            return opt_code_point || 0xFFFD;
        };
        /**
         * @private
         *
         * @param a
         * @param min
         * @param max
         */
        ByteArray.prototype.inRange = function (a, min, max) {
            return min <= a && a <= max;
        };
        /**
         * @private
         *
         * @param n
         * @param d
         */
        ByteArray.prototype.div = function (n, d) {
            return Math.floor(n / d);
        };
        /**
         * @private
         *
         * @param string
         */
        ByteArray.prototype.stringToCodePoints = function (string) {
            /** @type {Array.<number>} */
            var cps = [];
            // Based on http://www.w3.org/TR/WebIDL/#idl-DOMString
            var i = 0, n = string.length;
            while (i < string.length) {
                var c = string.charCodeAt(i);
                if (!this.inRange(c, 0xD800, 0xDFFF)) {
                    cps.push(c);
                }
                else if (this.inRange(c, 0xDC00, 0xDFFF)) {
                    cps.push(0xFFFD);
                }
                else {
                    if (i == n - 1) {
                        cps.push(0xFFFD);
                    }
                    else {
                        var d = string.charCodeAt(i + 1);
                        if (this.inRange(d, 0xDC00, 0xDFFF)) {
                            var a = c & 0x3FF;
                            var b = d & 0x3FF;
                            i += 1;
                            cps.push(0x10000 + (a << 10) + b);
                        }
                        else {
                            cps.push(0xFFFD);
                        }
                    }
                }
                i += 1;
            }
            return cps;
        };
        /**
         * @private
         */
        ByteArray.SIZE_OF_BOOLEAN = 1;
        /**
         * @private
         */
        ByteArray.SIZE_OF_INT8 = 1;
        /**
         * @private
         */
        ByteArray.SIZE_OF_INT16 = 2;
        /**
         * @private
         */
        ByteArray.SIZE_OF_INT32 = 4;
        /**
         * @private
         */
        ByteArray.SIZE_OF_UINT8 = 1;
        /**
         * @private
         */
        ByteArray.SIZE_OF_UINT16 = 2;
        /**
         * @private
         */
        ByteArray.SIZE_OF_UINT32 = 4;
        /**
         * @private
         */
        ByteArray.SIZE_OF_FLOAT32 = 4;
        /**
         * @private
         */
        ByteArray.SIZE_OF_FLOAT64 = 8;
        return ByteArray;
    }());
    egret3d.ByteArray = ByteArray;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.BooleanArray
    * @classdesc
    * 合并24个bool到一个float32中
    * @version Egret 3.0
    * @platform Web,Native
    */
    var BooleanArray = (function () {
        /**
        * @language zh_CN
        * constructor
        * @version Egret 3.0
        * @platform Web,Native
        */
        function BooleanArray() {
            //...一共可以有24个，用的时候加
            this._dirty = true;
            this._makeResult = 0;
            /**
            * @language zh_CN
            * 值队列
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._values = [];
            this._values = [];
            this._values.length = BooleanArray.MAX_COUNT;
        }
        /**
       * @language zh_CN
       * 在指定的位置s设置bool值
       * @param index 指定下标
       * @param value 需要设置的bool值
       * @version Egret 3.0
       * @platform Web,Native
       */
        BooleanArray.prototype.setBoolean = function (index, value) {
            if (index >= BooleanArray.MAX_COUNT)
                throw Error("BooleanArray MAX_COUNT：" + BooleanArray.MAX_COUNT);
            if (this._values[index] != value) {
                this._values[index] = value;
                this._dirty = true;
            }
        };
        /**
        * @language zh_CN
        * 在指定的位置获取bool值
        * @param index 指定下标
        * @returns bool值
        * @version Egret 3.0
        * @platform Web,Native
        */
        BooleanArray.prototype.getBoolean = function (index) {
            if (index >= BooleanArray.MAX_COUNT)
                return false;
            return this._values[index];
        };
        Object.defineProperty(BooleanArray.prototype, "dirty", {
            /**
            * @language zh_CN
            * 是否需要重新计算
            * @returns bool值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._dirty;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 强制设置需要计算
        * @version Egret 3.0
        * @platform Web,Native
        */
        BooleanArray.prototype.forceDirty = function () {
            this._dirty = true;
        };
        Object.defineProperty(BooleanArray.prototype, "makeResult", {
            /**
            * @language zh_CN
            * 获取压缩后的值
            * @returns number 压缩的结果
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._dirty) {
                    this.make();
                }
                return this._makeResult;
            },
            enumerable: true,
            configurable: true
        });
        BooleanArray.prototype.make = function () {
            this._makeResult = 0;
            for (var i = 0, count = BooleanArray.MAX_COUNT; i < count; i++) {
                if (this._values[i]) {
                    this._makeResult += 1 << i;
                }
            }
            this._dirty = false;
            return this._makeResult;
        };
        /**
        * @language zh_CN
        * 重置该列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        BooleanArray.prototype.clear = function () {
            this._dirty = true;
            this._makeResult = 0;
            this._values.length = 0;
        };
        BooleanArray.FLAG_0 = 0;
        BooleanArray.FLAG_1 = 1;
        BooleanArray.FLAG_2 = 2;
        BooleanArray.FLAG_3 = 3;
        BooleanArray.FLAG_4 = 4;
        BooleanArray.FLAG_5 = 5;
        BooleanArray.FLAG_6 = 6;
        BooleanArray.FLAG_7 = 7;
        BooleanArray.FLAG_8 = 8;
        BooleanArray.FLAG_9 = 9;
        BooleanArray.FLAG_10 = 10;
        BooleanArray.MAX_COUNT = 24;
        return BooleanArray;
    }());
    egret3d.BooleanArray = BooleanArray;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.Debug
    * @classdesc
    * 调试面板
    */
    var Debug = (function () {
        /**
         * @language zh_CN
         * 构造
         */
        function Debug() {
            this.isDebug = false;
            this._console = document.createElement('console');
            document.body.appendChild(this._console);
            this._console.style.color = "red";
            this._console.style.zIndex = "1000";
            this._console.style.position = "absolute";
            this._console.style.top = "10px";
            this._console.style.left = "10px";
        }
        /**
         * @language zh_CN
         * 输出调试信息
         * @param parameters
         */
        Debug.prototype.trace = function () {
            var parameters = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                parameters[_i - 0] = arguments[_i];
            }
            if (this.isDebug) {
                this.reset();
                var len = parameters.length;
                for (var i = 0; i < len; i++) {
                    this._console.innerHTML += parameters[i] + "</br>";
                }
            }
        };
        /**
         * @language zh_CN
         * 重置显示数据
         */
        Debug.prototype.reset = function () {
            this._console.innerHTML = "";
        };
        Object.defineProperty(Debug, "instance", {
            /**
             * @language zh_CN
             * 取到当前Debug单例对象
             */
            get: function () {
                if (this._instance == null) {
                    this._instance = new Debug();
                }
                return this._instance;
            },
            enumerable: true,
            configurable: true
        });
        Debug._instance = null;
        return Debug;
    }());
    egret3d.Debug = Debug;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @class egret3d.StringUtil
     * @classdesc
     * 字符串处理工具类
     */
    var StringUtil = (function () {
        function StringUtil() {
        }
        /**
         * @language zh_CN
         * @private
         * 解析文件内容(按行解析)
         * @param file
         * @returns 行列表
         */
        StringUtil.parseContent = function (file) {
            var shaderList = new Array();
            var node = "";
            var endChar = ";";
            var index = -1;
            for (var i = 0; i < file.length; ++i) {
                if (file.charAt(i) == "{") {
                    index = node.indexOf("=");
                    if (index < 0) {
                        endChar = "}";
                    }
                }
                if (node == "") {
                    if (file.charAt(i) == " " || file.charAt(i) == "    " || file.charAt(i) == "\t") {
                        continue;
                    }
                }
                node += file.charAt(i);
                if (endChar != "\n") {
                    if (node.indexOf("#extension") >= 0) {
                        endChar = "\n";
                    }
                    else if (node.indexOf("#define") >= 0) {
                        endChar = "\n";
                    }
                }
                if (endChar == file.charAt(i)) {
                    if (endChar == "}") {
                        var s_num = 0;
                        var e_num = 0;
                        for (var j = 0; j < node.length; ++j) {
                            if (node.charAt(j) == "{") {
                                s_num++;
                            }
                            else if (node.charAt(j) == "}") {
                                e_num++;
                            }
                        }
                        if (s_num != e_num) {
                            continue;
                        }
                        if (node.indexOf("struct") >= 0) {
                            endChar = ";";
                            continue;
                        }
                    }
                    if (node.length > 0) {
                        shaderList.push(node);
                    }
                    node = "";
                    endChar = ";";
                }
            }
            return shaderList;
        };
        /**
         * @language zh_CN
         * 解析一行的内容 有多少个成员
         * @param line 源内容
         * @returns 成员列表
         */
        StringUtil.parseLines = function (line) {
            var list = new Array();
            var value = "";
            var isE = false;
            for (var i = 0; i < line.length; ++i) {
                if (isE) {
                    if (line.charAt(i) == ";") {
                        isE = false;
                        if (value.length > 0) {
                            list.push(value);
                            value = "";
                        }
                        break;
                    }
                    value += line.charAt(i);
                    continue;
                }
                if (line.charAt(i) != " " && line.charAt(i) != "\t" && line.charAt(i) != "," &&
                    line.charAt(i) != "\r" && line.charAt(i) != "\n" && line.charAt(i) != ":") {
                    if (line.charAt(i) == ";") {
                        if (value.length > 0) {
                            list.push(value);
                            value = "";
                        }
                        break;
                    }
                    else if (line.charAt(i) == "=") {
                        if (value.length > 0) {
                            list.push(value);
                            value = "";
                        }
                        list.push("=");
                        isE = true;
                        continue;
                    }
                    value += line.charAt(i);
                    if (i == line.length - 1 && line != "") {
                        list.push(value);
                        value = "";
                    }
                }
                else {
                    if (value != "") {
                        list.push(value);
                        value = "";
                    }
                }
            }
            return list;
        };
        /**
         * @language zh_CN
         * 是否存在此字符串
         * @param fields 被检测的列表
         * @param str 比较字符串
         * @returns 成功返回true
         */
        StringUtil.hasString = function (fields, str) {
            for (var i = 0; i < fields.length; ++i) {
                if (fields[i] == str) {
                    return i;
                }
            }
            return -1;
        };
        /**
         * @language zh_CN
         * 得到值的内容
         * @param fields 成员列表
         * @returns 值
         */
        StringUtil.getVarName = function (fields) {
            var index = this.hasString(fields, "=");
            if (index >= 0) {
                index -= 1;
                if (index >= 0 && index < fields.length) {
                    return fields[index];
                }
            }
            else {
                index = fields.length - 1;
                if (index >= 0 && index < fields.length) {
                    return fields[index];
                }
            }
            return "";
        };
        /**
         * @language zh_CN
         * 返回变量的值
         * @param fields 变量数据列表
         * @returns 变量的值
         */
        StringUtil.getVarValue = function (fields) {
            var index = this.hasString(fields, "=");
            if (index >= 0) {
                index += 1;
                if (index >= 0 && index < fields.length) {
                    return fields[index];
                }
            }
            return "";
        };
        /**
         * @language zh_CN
         * 返回变量类型
         * @param fields 变量数据列表
         * @returns 变量类型
         */
        StringUtil.getVarType = function (fields) {
            var index = this.hasString(fields, "=");
            if (index >= 0) {
                index -= 2;
                if (index >= 0 && index < fields.length) {
                    return fields[index];
                }
            }
            else {
                index = fields.length - 2;
                if (index >= 0 && index < fields.length) {
                    return fields[index];
                }
            }
            return "";
        };
        /**
         * @language zh_CN
         * 返回变量属性
         * @param fields 变量数据列表
         * @returns 变量属性
         */
        StringUtil.getVarKey = function (fields) {
            var index = this.hasString(fields, "=");
            if (index >= 0) {
                index -= 3;
                if (index >= 0 && index < fields.length) {
                    return fields[index];
                }
            }
            else {
                index = fields.length - 3;
                if (index >= 0 && index < fields.length) {
                    return fields[index];
                }
                else {
                    return fields[0];
                }
            }
            return "";
        };
        /**
         * @language zh_CN
         * @private
         * 筛选文件中的指定字符去掉
         * @param file xxx
         * @returns 筛选后的字符
         */
        StringUtil.processShaderFile = function (file) {
            var filterChar = ["\n", "\r"];
            filterChar = [];
            var src = file;
            var dest = src;
            while (true) {
                var pos = src.indexOf("//");
                if (pos < 0) {
                    break;
                }
                var end = src.indexOf("\r\n", pos);
                if (end == -1) {
                    end = src.indexOf("\n", pos);
                }
                var slice_s = src.slice(pos, end);
                src = src.replace(slice_s, "");
                if (src == dest) {
                    break;
                }
                dest = src;
            }
            for (var i = 0; i < filterChar.length; ++i) {
                while (true) {
                    dest = src.replace(filterChar[i], "");
                    if (src == dest) {
                        break;
                    }
                    src = dest;
                }
            }
            return src;
        };
        /**
         * @language zh_CN
         * 解析字符颜色值
         * @param color
         * @returns
         */
        StringUtil.colorRgb = function (color) {
            var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
            var sColor = color.toLowerCase();
            if (sColor && reg.test(sColor)) {
                if (sColor.length === 4) {
                    var sColorNew = "#";
                    for (var i = 1; i < 4; i += 1) {
                        sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
                    }
                    sColor = sColorNew;
                }
                //处理六位的颜色值  
                var sColorChange = [];
                for (var i = 1; i < 7; i += 2) {
                    sColorChange.push(parseInt("0x" + sColor.slice(i, i + 2)));
                }
                return "RGB(" + sColorChange.join(",") + ")";
            }
            else {
                return sColor;
            }
        };
        /**
         * @language zh_CN
         * @private
         * @returns
         */
        StringUtil.getLineType = function (line) {
            var index = line.indexOf("{");
            if (index > 0) {
                var firstStr = line.substr(0, index);
                if (firstStr.indexOf("struct") >= 0) {
                    var s_pos = firstStr.lastIndexOf(" ");
                    s_pos++;
                    var structName = firstStr.substr(s_pos, firstStr.length - s_pos);
                    return ("struct " + structName);
                }
                if (firstStr.indexOf("=") < 0) {
                    var pos = line.indexOf("(");
                    var s_pos = line.lastIndexOf(" ", pos);
                    s_pos++;
                    var func = line.substr(s_pos, pos - s_pos);
                    return ("function " + func);
                }
            }
            return "unknown";
        };
        /**
         * @language zh_CN
         * @private
         * @returns
         */
        StringUtil.processStruct = function (name, structStr, content) {
            var pos = structStr.lastIndexOf("}");
            pos++;
            var end = structStr.lastIndexOf(";");
            var varName = structStr.substr(pos, end - pos);
            var varList = StringUtil.parseLines(varName);
            for (var i = 0; i < varList.length; ++i) {
                var varTmp = StringUtil.getTemper(name + " " + varList[i] + ";");
                if (varTmp)
                    content.addVar(varTmp);
            }
        };
        /**
         * @language zh_CN
         * @private
         * @returns
         */
        StringUtil.getAttribute = function (shaderLine) {
            var tempStr = shaderLine;
            var tmpName;
            var valueType;
            var attribute;
            var tempArray = StringUtil.parseLines(tempStr);
            tmpName = StringUtil.getVarName(tempArray);
            valueType = StringUtil.getVarType(tempArray);
            attribute = new egret3d.GLSL.Attribute(tmpName, valueType);
            attribute.value = StringUtil.getVarValue(tempArray);
            return attribute;
        };
        /**
        * @language zh_CN
        * @private
        * @returns
        */
        StringUtil.getTemper = function (shaderLine) {
            var tempStr = shaderLine;
            var tmpName;
            var valueType;
            var tmpVar;
            var tempArray = StringUtil.parseLines(tempStr);
            tmpName = StringUtil.getVarName(tempArray);
            valueType = StringUtil.getVarType(tempArray);
            tmpVar = new egret3d.GLSL.TmpVar(tmpName, valueType);
            tmpVar.value = StringUtil.getVarValue(tempArray);
            return tmpVar;
        };
        /**
        * @language zh_CN
        * @private
        * @returns
        */
        StringUtil.getVarying = function (shaderLine) {
            var tempStr = shaderLine;
            var varyingName;
            var valueType;
            var varying;
            var tempArray = StringUtil.parseLines(tempStr);
            varyingName = StringUtil.getVarName(tempArray);
            valueType = StringUtil.getVarType(tempArray);
            varying = new egret3d.GLSL.Varying(varyingName, valueType);
            return varying;
        };
        /**
        * @language zh_CN
        * @private
        * @returns
        */
        StringUtil.getUniform = function (shaderLine) {
            var tempStr = shaderLine;
            var uniformName;
            var valueType;
            var uniform;
            var tempArray = StringUtil.parseLines(tempStr);
            uniformName = StringUtil.getVarName(tempArray);
            valueType = StringUtil.getVarType(tempArray);
            uniform = new egret3d.GLSL.Uniform(uniformName, valueType);
            return uniform;
        };
        /**
        * @language zh_CN
        * @private
        * @returns
        */
        StringUtil.getConst = function (shaderLine) {
            var tempStr = shaderLine;
            var constVarName;
            var valueType;
            var varValue;
            var constVar;
            var tempArray = StringUtil.parseLines(tempStr);
            constVarName = StringUtil.getVarName(tempArray);
            valueType = StringUtil.getVarType(tempArray);
            varValue = StringUtil.getVarValue(tempArray);
            constVar = new egret3d.GLSL.ConstVar(constVarName, valueType, varValue);
            return constVar;
        };
        StringUtil.getExtension = function (shaderLine) {
            var start = shaderLine.indexOf("#");
            var end = shaderLine.indexOf(" ");
            var type = shaderLine.substr(start, end);
            var namePosEnd = shaderLine.indexOf(":");
            var name = shaderLine.substr(end, namePosEnd - end);
            name = StringUtil.replaceCharacter(name, [" "], "");
            namePosEnd += 1;
            var value = shaderLine.substr(namePosEnd, shaderLine.length - namePosEnd);
            value = StringUtil.replaceCharacter(value, [" ", ":", "\n", "\r"], "");
            var extension = new egret3d.GLSL.Extension(name);
            extension.value = value;
            return extension;
        };
        StringUtil.getDefine = function (shaderLine) {
            //var start: number = shaderLine.indexOf("#");
            //var end: number = shaderLine.indexOf(" ");
            //var type: string = shaderLine.substr(start, end);
            var tempStr = shaderLine;
            var name = "";
            var value = "";
            var tmpVar;
            var tempArray = StringUtil.parseLines(tempStr);
            name = tempArray[1];
            if (tempArray.length >= 3) {
                value = tempArray[2];
            }
            tmpVar = new egret3d.GLSL.DefineVar(name, value);
            return tmpVar;
        };
        /**
        * @language zh_CN
        * @private
        * @returns
        */
        StringUtil.getSampler2D = function (shaderLine) {
            var tempStr = shaderLine;
            var sampler2DName;
            var valueType;
            var sampler2D;
            var tempArray = StringUtil.parseLines(tempStr);
            sampler2DName = StringUtil.getVarName(tempArray);
            sampler2D = new egret3d.GLSL.Sampler2D(sampler2DName);
            return sampler2D;
        };
        /**
        * @language zh_CN
        * @private
        * @returns
        */
        StringUtil.getSampler3D = function (shaderLine) {
            var tempStr = shaderLine;
            var sampler3DName;
            var valueType;
            var sampler3D;
            var tempArray = StringUtil.parseLines(tempStr);
            sampler3DName = StringUtil.getVarName(tempArray);
            sampler3D = new egret3d.GLSL.Sampler3D(sampler3DName);
            return sampler3D;
        };
        /**
        * @language zh_CN
        * @private
        * @returns
        */
        StringUtil.filterCharacter = function (name) {
            var src = name;
            var dest = src;
            for (var i = 0; i < StringUtil._filterChar.length; ++i) {
                while (true) {
                    dest = src.replace(StringUtil._filterChar[i], "");
                    if (src == dest) {
                        break;
                    }
                    src = dest;
                }
            }
            return dest;
        };
        StringUtil.replaceCharacter = function (src, searchValue, replaceValue) {
            var ret = src;
            var isBreak = false;
            while (!isBreak) {
                isBreak = true;
                for (var i = 0; i < searchValue.length; ++i) {
                    if (ret.indexOf(searchValue[i]) >= 0) {
                        isBreak = false;
                        break;
                    }
                }
                for (var i = 0; i < searchValue.length; ++i) {
                    ret = ret.replace(searchValue[i], replaceValue);
                }
            }
            return ret;
        };
        StringUtil.getURLName = function (url) {
            var urlArray = url.split(".");
            urlArray = urlArray[0].split("/");
            return urlArray[urlArray.length - 1];
        };
        StringUtil.getFileFormat = function (url) {
            var endPos = url.lastIndexOf(".");
            endPos++;
            var startPos = url.lastIndexOf("/");
            var fileFormat = url.substr(endPos, url.length - endPos);
            fileFormat = fileFormat.toLowerCase();
            return fileFormat;
        };
        StringUtil.getPath = function (url) {
            var s_pos = url.lastIndexOf("/");
            s_pos++;
            return url.substr(0, s_pos);
        };
        StringUtil.ab2str = function (byte, block) {
            if (block === void 0) { block = 65535; }
            //  return String.fromCharCode.apply(null, new Uint8Array(buf));
            var str = "";
            var oldPos = byte.position;
            var length = block;
            while (byte.position < byte.length) {
                length = block;
                if (byte.length - byte.position < length) {
                    length = byte.length - byte.position;
                }
                str += byte.readUTFBytes(length);
            }
            byte.position = oldPos;
            return str;
        };
        StringUtil.str2ab = function (str) {
            var byte = new egret3d.ByteArray();
            byte.writeUTFBytes(str);
            return byte;
        };
        /**
         * @language zh_CN
         * @private
         */
        StringUtil._filterChar = [" ", "  ", ";", "\n", "\r", "\t", "\n", "\r", "\t"];
        return StringUtil;
    }());
    egret3d.StringUtil = StringUtil;
})(egret3d || (egret3d = {}));
var nid;
(function (nid) {
    /*
    * @private
    */
    var MEMORY = (function () {
        function MEMORY() {
        }
        MEMORY.allocateUint8 = function (len) {
            MEMORY.u8 = new Uint8Array(len);
        };
        MEMORY.allocateUint16 = function (len) {
            MEMORY.u16 = new Uint16Array(len);
        };
        MEMORY.allocateUint32 = function (len) {
            MEMORY.u32 = new Uint32Array(len);
        };
        MEMORY.reset = function () {
            MEMORY.u8Index = 0;
            MEMORY.u16Index = 0;
            MEMORY.u32Index = 0;
        };
        MEMORY.getUint8 = function () {
            if (!MEMORY.u8) {
                MEMORY.allocateUint8(10);
            }
            return MEMORY.u8Index++;
        };
        MEMORY.getUint16 = function () {
            if (!MEMORY.u16) {
                MEMORY.allocateUint16(24);
            }
            return MEMORY.u16Index++;
        };
        MEMORY.getUint32 = function () {
            if (!MEMORY.u32) {
                MEMORY.allocateUint32(10);
            }
            return MEMORY.u32Index++;
        };
        MEMORY.u8Index = 0;
        MEMORY.u16Index = 0;
        MEMORY.u32Index = 0;
        return MEMORY;
    }());
    nid.MEMORY = MEMORY;
})(nid || (nid = {}));
var nid;
(function (nid) {
    /**
     * @private
     * LZMA Decoder
     * @author Nidin Vinayakan | nidinthb@gmail.com
     */
    //import MEMORY = nid.MEMORY;
    var LzmaDecoder = (function () {
        function LzmaDecoder() {
            this.posSlotDecoder = nid.BitTreeDecoder.constructArray(6, nid.LZMAConfig.kNumLenToPosStates); //6
            this.alignDecoder = new nid.BitTreeDecoder(nid.LZMAConfig.kNumAlignBits);
            this.posDecoders = new Uint16Array(1 + nid.LZMAConfig.kNumFullDistances - nid.LZMAConfig.kEndPosModelIndex);
            this.isMatch = new Uint16Array(nid.LZMAConfig.kNumStates << nid.LZMAConfig.kNumPosBitsMax);
            this.isRep = new Uint16Array(nid.LZMAConfig.kNumStates);
            this.isRepG0 = new Uint16Array(nid.LZMAConfig.kNumStates);
            this.isRepG1 = new Uint16Array(nid.LZMAConfig.kNumStates);
            this.isRepG2 = new Uint16Array(nid.LZMAConfig.kNumStates);
            this.isRep0Long = new Uint16Array(nid.LZMAConfig.kNumStates << nid.LZMAConfig.kNumPosBitsMax);
            this.lenDecoder = new nid.LenDecoder();
            this.repLenDecoder = new nid.LenDecoder();
            this.rangeDec = new nid.RangeDecoder();
            this.outWindow = new nid.OutWindow();
        }
        LzmaDecoder.prototype.init = function () {
            nid.MEMORY.reset();
            this.loc1 = nid.MEMORY.getUint32() | 0;
            this.loc2 = nid.MEMORY.getUint32() | 0;
            this.matchBitI = nid.MEMORY.getUint16() | 0;
            this.matchByteI = nid.MEMORY.getUint16() | 0;
            this.bitI = nid.MEMORY.getUint16() | 0;
            this.symbolI = nid.MEMORY.getUint16() | 0;
            this.prevByteI = nid.MEMORY.getUint16() | 0;
            this.litStateI = nid.MEMORY.getUint16() | 0;
            this.initLiterals();
            this.initDist();
            nid.LZMAConfig.INIT_PROBS(this.isMatch);
            nid.LZMAConfig.INIT_PROBS(this.isRep);
            nid.LZMAConfig.INIT_PROBS(this.isRepG0);
            nid.LZMAConfig.INIT_PROBS(this.isRepG1);
            nid.LZMAConfig.INIT_PROBS(this.isRepG2);
            nid.LZMAConfig.INIT_PROBS(this.isRep0Long);
            this.lenDecoder.init();
            this.repLenDecoder.init();
        };
        LzmaDecoder.prototype.create = function () {
            this.outWindow.create(this.dictSize);
            this.createLiterals();
        };
        //Private
        LzmaDecoder.prototype.createLiterals = function () {
            this.litProbs = new Uint16Array(0x300 << (this.lc + this.lp));
        };
        LzmaDecoder.prototype.initLiterals = function () {
            var num = 0x300 << (this.lc + this.lp); //UInt32
            for (var i = 0; i < num; i++) {
                this.litProbs[i] = nid.LZMAConfig.PROB_INIT_VAL;
            }
        };
        LzmaDecoder.prototype.decodeLiteral = function (state, rep0) {
            nid.MEMORY.u16[this.prevByteI] = 0; //unsigned byte
            if (!this.outWindow.isEmpty())
                nid.MEMORY.u16[this.prevByteI] = this.outWindow.getByte(1);
            nid.MEMORY.u16[this.symbolI] = 1;
            nid.MEMORY.u16[this.litStateI] = ((this.outWindow.totalPos & ((1 << this.lp) - 1)) << this.lc) + (nid.MEMORY.u16[this.prevByteI] >>> (8 - this.lc));
            var probsOffset = (0x300 * nid.MEMORY.u16[this.litStateI]) | 0;
            if (state >= 7) {
                nid.MEMORY.u16[this.matchByteI] = this.outWindow.getByte(rep0 + 1);
                do {
                    nid.MEMORY.u16[this.matchBitI] = (nid.MEMORY.u16[this.matchByteI] >>> 7) & 1;
                    nid.MEMORY.u16[this.matchByteI] <<= 1;
                    nid.MEMORY.u16[this.bitI] = this.rangeDec.decodeBit(this.litProbs, probsOffset + ((1 + nid.MEMORY.u16[this.matchBitI]) << 8) + nid.MEMORY.u16[this.symbolI]);
                    nid.MEMORY.u16[this.symbolI] = (nid.MEMORY.u16[this.symbolI] << 1) | nid.MEMORY.u16[this.bitI];
                    if (nid.MEMORY.u16[this.matchBitI] != nid.MEMORY.u16[this.bitI])
                        break;
                } while (nid.MEMORY.u16[this.symbolI] < 0x100);
            }
            while (nid.MEMORY.u16[this.symbolI] < 0x100) {
                nid.MEMORY.u16[this.symbolI] = (nid.MEMORY.u16[this.symbolI] << 1) | this.rangeDec.decodeBit(this.litProbs, probsOffset + nid.MEMORY.u16[this.symbolI]);
            }
            this.outWindow.putByte(nid.MEMORY.u16[this.symbolI] - 0x100);
        };
        LzmaDecoder.prototype.decodeDistance = function (len) {
            var lenState = len; //unsigned byte
            if (lenState > nid.LZMAConfig.kNumLenToPosStates - 1)
                lenState = nid.LZMAConfig.kNumLenToPosStates - 1;
            var posSlot = this.posSlotDecoder[lenState].decode(this.rangeDec); //unsigned byte
            if (posSlot < 4)
                return posSlot;
            var numDirectBits = ((posSlot >>> 1) - 1); //unsigned byte
            nid.MEMORY.u32[this.loc1] = ((2 | (posSlot & 1)) << numDirectBits); //UInt32
            if (posSlot < nid.LZMAConfig.kEndPosModelIndex) {
                nid.MEMORY.u32[this.loc1] += nid.LZMAConfig.BitTreeReverseDecode(this.posDecoders, numDirectBits, this.rangeDec, nid.MEMORY.u32[this.loc1] - posSlot);
            }
            else {
                nid.MEMORY.u32[this.loc1] += this.rangeDec.decodeDirectBits(numDirectBits - nid.LZMAConfig.kNumAlignBits) << nid.LZMAConfig.kNumAlignBits;
                nid.MEMORY.u32[this.loc1] += this.alignDecoder.reverseDecode(this.rangeDec);
            }
            return nid.MEMORY.u32[this.loc1];
        };
        LzmaDecoder.prototype.initDist = function () {
            for (var i = 0; i < nid.LZMAConfig.kNumLenToPosStates; i++) {
                this.posSlotDecoder[i].init();
            }
            this.alignDecoder.init();
            nid.LZMAConfig.INIT_PROBS(this.posDecoders);
        };
        LzmaDecoder.prototype.decodeProperties = function (properties) {
            var prop = new Uint8Array(4);
            prop[0] = properties[0];
            if (prop[0] >= (9 * 5 * 5)) {
                throw "Incorrect LZMA properties";
            }
            prop[1] = prop[0] % 9;
            prop[0] /= 9;
            prop[2] = prop[0] / 5;
            prop[3] = prop[0] % 5;
            this.lc = prop[1];
            this.pb = prop[2];
            this.lp = prop[3];
            this.dictSizeInProperties = 0;
            for (var i = 0; i < 4; i++) {
                this.dictSizeInProperties |= properties[i + 1] << (8 * i);
            }
            this.dictSize = this.dictSizeInProperties;
            if (this.dictSize < nid.LZMAConfig.LZMA_DIC_MIN) {
                this.dictSize = nid.LZMAConfig.LZMA_DIC_MIN;
            }
        };
        LzmaDecoder.prototype.updateState_Literal = function (state) {
            if (state < 4)
                return 0;
            else if (state < 10)
                return state - 3;
            else
                return state - 6;
        };
        LzmaDecoder.prototype.updateState_ShortRep = function (state) { return state < 7 ? 9 : 11; };
        LzmaDecoder.prototype.updateState_Rep = function (state) { return state < 7 ? 8 : 11; };
        LzmaDecoder.prototype.updateState_Match = function (state) { return state < 7 ? 7 : 10; };
        LzmaDecoder.prototype.decode = function (unpackSizeDefined, unpackSize) {
            this.init();
            this.rangeDec.init();
            if (unpackSizeDefined) {
                this.outWindow.outStream = new Uint8Array(new ArrayBuffer(unpackSize));
            }
            var rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0; //UInt32
            var state = 0; //unsigned byte
            for (;;) {
                if (unpackSizeDefined && unpackSize == 0 && !this.markerIsMandatory) {
                    if (this.rangeDec.isFinishedOK()) {
                        return nid.LZMAConfig.LZMA_RES_FINISHED_WITHOUT_MARKER;
                    }
                }
                var posState = this.outWindow.totalPos & ((1 << this.pb) - 1);
                if (this.rangeDec.decodeBit(this.isMatch, (state << nid.LZMAConfig.kNumPosBitsMax) + posState) == 0) {
                    if (unpackSizeDefined && unpackSize == 0) {
                        return nid.LZMAConfig.LZMA_RES_ERROR;
                    }
                    this.decodeLiteral(state, rep0);
                    state = this.updateState_Literal(state);
                    unpackSize--;
                    continue;
                }
                var len;
                if (this.rangeDec.decodeBit(this.isRep, state) != 0) {
                    if (unpackSizeDefined && unpackSize == 0) {
                        return nid.LZMAConfig.LZMA_RES_ERROR;
                    }
                    if (this.outWindow.isEmpty()) {
                        return nid.LZMAConfig.LZMA_RES_ERROR;
                    }
                    if (this.rangeDec.decodeBit(this.isRepG0, state) == 0) {
                        if (this.rangeDec.decodeBit(this.isRep0Long, (state << nid.LZMAConfig.kNumPosBitsMax) + posState) == 0) {
                            state = this.updateState_ShortRep(state);
                            this.outWindow.putByte(this.outWindow.getByte(rep0 + 1));
                            unpackSize--;
                            continue;
                        }
                    }
                    else {
                        var dist;
                        if (this.rangeDec.decodeBit(this.isRepG1, state) == 0) {
                            dist = rep1;
                        }
                        else {
                            if (this.rangeDec.decodeBit(this.isRepG2, state) == 0) {
                                dist = rep2;
                            }
                            else {
                                dist = rep3;
                                rep3 = rep2;
                            }
                            rep2 = rep1;
                        }
                        rep1 = rep0;
                        rep0 = dist;
                    }
                    len = this.repLenDecoder.decode(this.rangeDec, posState);
                    state = this.updateState_Rep(state);
                }
                else {
                    rep3 = rep2;
                    rep2 = rep1;
                    rep1 = rep0;
                    len = this.lenDecoder.decode(this.rangeDec, posState);
                    state = this.updateState_Match(state);
                    rep0 = this.decodeDistance(len);
                    if (rep0 == 0xFFFFFFFF) {
                        return this.rangeDec.isFinishedOK() ?
                            nid.LZMAConfig.LZMA_RES_FINISHED_WITH_MARKER :
                            nid.LZMAConfig.LZMA_RES_ERROR;
                    }
                    if (unpackSizeDefined && unpackSize == 0) {
                        return nid.LZMAConfig.LZMA_RES_ERROR;
                    }
                    if (rep0 >= this.dictSize || !this.outWindow.checkDistance(rep0)) {
                        return nid.LZMAConfig.LZMA_RES_ERROR;
                    }
                }
                len += nid.LZMAConfig.kMatchMinLen;
                var isError = false;
                if (unpackSizeDefined && unpackSize < len) {
                    len = unpackSize;
                    isError = true;
                }
                this.outWindow.copyMatch(rep0 + 1, len);
                unpackSize -= len;
                if (isError) {
                    return nid.LZMAConfig.LZMA_RES_ERROR;
                }
            }
        };
        return LzmaDecoder;
    }());
    nid.LzmaDecoder = LzmaDecoder;
})(nid || (nid = {}));
var nid;
(function (nid) {
    "use strict";
    /**
     * @private
     * LZMA Decoder
     * @author Nidin Vinayakan | nidinthb@gmail.com
     */
    var LZMA = (function () {
        function LZMA() {
            this.decoder = new nid.LzmaDecoder();
        }
        LZMA.prototype.decode = function (data) {
            this.data = data;
            //var header:Uint8Array = data.readUint8Array(13);
            var header = new Uint8Array(13);
            var i; //int
            for (i = 0; i < 13; i++) {
                header[i] = data[i];
            }
            this.decoder.decodeProperties(header);
            //console.log("lc="+this.decoder.lc+", lp="+this.decoder.lp+", pb="+this.decoder.pb);
            //console.log("Dictionary Size in properties = "+this.decoder.dictSizeInProperties);
            //console.log("Dictionary Size for decoding  = "+this.decoder.dictSize);
            //return this.ucdata;
            var unpackSize = 0; //UInt64
            var unpackSizeDefined = false;
            for (i = 0; i < 8; i++) {
                var b = header[5 + i];
                if (b != 0xFF) {
                    unpackSizeDefined = true;
                }
                unpackSize |= b << (8 * i);
            }
            this.decoder.markerIsMandatory = !unpackSizeDefined;
            if (unpackSizeDefined) {
                console.log("Uncompressed Size : " + unpackSize + " bytes");
            }
            else {
                console.log("End marker is expected");
            }
            this.decoder.rangeDec.inStream = data;
            this.decoder.create();
            // we support the streams that have uncompressed size and marker.
            var res = this.decoder.decode(unpackSizeDefined, unpackSize); //int
            //console.log("Read    ", this.decoder.rangeDec.in_pos);
            //console.log("Written ", this.decoder.outWindow.out_pos);
            if (res == nid.LZMAConfig.LZMA_RES_ERROR) {
                throw "LZMA decoding error";
            }
            else if (res == nid.LZMAConfig.LZMA_RES_FINISHED_WITHOUT_MARKER) {
            }
            else if (res == nid.LZMAConfig.LZMA_RES_FINISHED_WITH_MARKER) {
                if (unpackSizeDefined) {
                    if (this.decoder.outWindow.out_pos != unpackSize) {
                        throw "Finished with end marker before than specified size";
                    }
                }
            }
            else {
                throw "Internal Error";
            }
            if (this.decoder.rangeDec.corrupted) {
                console.log("Warning: LZMA stream is corrupted");
            }
            return this.decoder.outWindow.outStream;
        };
        return LZMA;
    }());
    nid.LZMA = LZMA;
})(nid || (nid = {}));
var nid;
(function (nid) {
    /**
     * @private
     * LZMA Decoder
     * @author Nidin Vinayakan | nidinthb@gmail.com
     */
    var OutWindow = (function () {
        function OutWindow() {
            this.out_pos = 0;
        }
        OutWindow.prototype.create = function (dictSize) {
            this.buf = new Uint8Array(dictSize);
            this.pos = 0;
            this.size = dictSize;
            this.isFull = false;
            this.totalPos = 0;
        };
        OutWindow.prototype.putByte = function (b) {
            this.totalPos++;
            this.buf[this.pos++] = b;
            if (this.pos == this.size) {
                this.pos = 0;
                this.isFull = true;
            }
            this.outStream[this.out_pos++] = b;
        };
        OutWindow.prototype.getByte = function (dist) {
            return this.buf[dist <= this.pos ? this.pos - dist : this.size - dist + this.pos];
        };
        OutWindow.prototype.copyMatch = function (dist, len) {
            for (; len > 0; len--) {
                this.putByte(this.getByte(dist));
            }
        };
        OutWindow.prototype.checkDistance = function (dist) {
            return dist <= this.pos || this.isFull;
        };
        OutWindow.prototype.isEmpty = function () {
            return this.pos == 0 && !this.isFull;
        };
        return OutWindow;
    }());
    nid.OutWindow = OutWindow;
})(nid || (nid = {}));
var nid;
(function (nid) {
    /**
     * @private
     * LZMA Decoder
     * @author Nidin Vinayakan | nidinthb@gmail.com
     */
    //import MEMORY = nid.MEMORY;
    var RangeDecoder = (function () {
        function RangeDecoder() {
            this.rangeI = 0;
            this.codeI = 1;
            this.loc1 = 2;
            this.loc2 = 3;
            this.in_pos = 13;
        }
        RangeDecoder.prototype.isFinishedOK = function () {
            return this.U32[this.codeI] == 0;
        };
        RangeDecoder.prototype.init = function () {
            this.U32 = new Uint32Array(4);
            this.U16 = new Uint16Array(4);
            this.corrupted = false;
            if (this.inStream[this.in_pos++] != 0) {
                this.corrupted = true;
            }
            this.U32[this.rangeI] = 0xFFFFFFFF;
            this.U32[this.codeI] = 0;
            for (var i = 0; i < 4; i++) {
                this.U32[this.codeI] = (this.U32[this.codeI] << 8) | this.inStream[this.in_pos++];
            }
            if (this.U32[this.codeI] == this.U32[this.rangeI]) {
                this.corrupted = true;
            }
        };
        RangeDecoder.prototype.normalize = function () {
            if (this.U32[this.rangeI] < RangeDecoder.kTopValue) {
                this.U32[this.rangeI] <<= 8;
                this.U32[this.codeI] = (this.U32[this.codeI] << 8) | this.inStream[this.in_pos++];
            }
        };
        RangeDecoder.prototype.decodeDirectBits = function (numBits) {
            this.U32[this.loc1] = 0; //UInt32
            do {
                this.U32[this.rangeI] >>>= 1;
                this.U32[this.codeI] -= this.U32[this.rangeI];
                this.U32[this.loc2] = 0 - (this.U32[this.codeI] >>> 31);
                this.U32[this.codeI] += this.U32[this.rangeI] & this.U32[this.loc2];
                if (this.U32[this.codeI] == this.U32[this.rangeI]) {
                    this.corrupted = true;
                }
                this.normalize();
                this.U32[this.loc1] <<= 1;
                this.U32[this.loc1] += this.U32[this.loc2] + 1;
            } while (--numBits);
            return this.U32[this.loc1];
        };
        RangeDecoder.prototype.decodeBit = function (prob, index) {
            this.U16[0] = prob[index];
            //bound
            this.U32[2] = (this.U32[0] >>> 11) * this.U16[0];
            //var symbol:number;
            if (this.U32[1] < this.U32[2]) {
                this.U16[0] += ((1 << 11) - this.U16[0]) >>> 5;
                this.U32[0] = this.U32[2];
                this.U16[1] = 0;
            }
            else {
                //v -= v >>> LZMA.kNumMoveBits;
                this.U16[0] -= this.U16[0] >>> 5;
                this.U32[1] -= this.U32[2];
                this.U32[0] -= this.U32[2];
                this.U16[1] = 1;
            }
            prob[index] = this.U16[0];
            //this.normalize();
            if (this.U32[0] < 16777216) {
                this.U32[0] <<= 8;
                this.U32[1] = (this.U32[1] << 8) | this.inStream[this.in_pos++];
            }
            return this.U16[1];
        };
        RangeDecoder.kTopValue = (1 << 24);
        return RangeDecoder;
    }());
    nid.RangeDecoder = RangeDecoder;
})(nid || (nid = {}));
var nid;
(function (nid) {
    /**
    * @private
     * LZMA Decoder
     * @author Nidin Vinayakan | nidinthb@gmail.com
     */
    var BitTreeDecoder = (function () {
        function BitTreeDecoder(numBits) {
            this.numBits = numBits;
            this.probs = new Uint16Array(1 << this.numBits);
        }
        BitTreeDecoder.prototype.init = function () {
            nid.LZMAConfig.INIT_PROBS(this.probs);
        };
        BitTreeDecoder.prototype.decode = function (rc) {
            var m = 1; //Uint16
            for (var i = 0; i < this.numBits; i++)
                m = (m << 1) + rc.decodeBit(this.probs, m);
            return m - (1 << this.numBits);
        };
        BitTreeDecoder.prototype.reverseDecode = function (rc) {
            return nid.LZMAConfig.BitTreeReverseDecode(this.probs, this.numBits, rc);
        };
        BitTreeDecoder.constructArray = function (numBits, len) {
            var vec = [];
            for (var i = 0; i < len; i++) {
                vec[i] = new BitTreeDecoder(numBits);
            }
            return vec;
        };
        return BitTreeDecoder;
    }());
    nid.BitTreeDecoder = BitTreeDecoder;
})(nid || (nid = {}));
var nid;
(function (nid) {
    /**
     * @private
     * LZMA Decoder
     * @author Nidin Vinayakan | nidinthb@gmail.com
     */
    var LenDecoder = (function () {
        function LenDecoder() {
            this.lowCoder = nid.BitTreeDecoder.constructArray(3, 1 << nid.LZMAConfig.kNumPosBitsMax);
            this.midCoder = nid.BitTreeDecoder.constructArray(3, 1 << nid.LZMAConfig.kNumPosBitsMax);
            this.highCoder = new nid.BitTreeDecoder(8);
        }
        LenDecoder.prototype.init = function () {
            this.choice = [nid.LZMAConfig.PROB_INIT_VAL, nid.LZMAConfig.PROB_INIT_VAL];
            this.highCoder.init();
            for (var i = 0; i < (1 << nid.LZMAConfig.kNumPosBitsMax); i++) {
                this.lowCoder[i].init();
                this.midCoder[i].init();
            }
        };
        LenDecoder.prototype.decode = function (rc, posState) {
            if (rc.decodeBit(this.choice, 0) == 0) {
                return this.lowCoder[posState].decode(rc);
            }
            if (rc.decodeBit(this.choice, 1) == 0) {
                return 8 + this.midCoder[posState].decode(rc);
            }
            return 16 + this.highCoder.decode(rc);
        };
        return LenDecoder;
    }());
    nid.LenDecoder = LenDecoder;
})(nid || (nid = {}));
var nid;
(function (nid) {
    "use strict";
    /*
    * @private
    */
    var LZMAWorker = (function () {
        function LZMAWorker() {
            this.command = null;
            var _this = this;
            this.decoder = new nid.LZMA();
            addEventListener('message', function (e) {
                if (_this.command == null) {
                    _this.command = e.data;
                }
                else if (_this.command['job'] == 1) {
                    _this.command = null;
                }
                else if (_this.command['job'] == 2) {
                    _this.decode(e.data);
                }
            }, false);
        }
        LZMAWorker.prototype.decode = function (data) {
            this.time = Date.now();
            var result = this.decoder.decode(new Uint8Array(data));
            this.command['time'] = Date.now() - this.time;
            postMessage(this.command);
            postMessage(result.buffer, [result.buffer]);
        };
        LZMAWorker.ENCODE = 1;
        LZMAWorker.DECODE = 2;
        return LZMAWorker;
    }());
    nid.LZMAWorker = LZMAWorker;
})(nid || (nid = {}));
/*
* @private
*/
new nid.LZMAWorker();
var nid;
(function (nid) {
    //import LZMA = nid.LZMA;
    /*
    * @private
    */
    var LZMAHelper = (function () {
        function LZMAHelper() {
        }
        LZMAHelper.init = function () {
            var command = 0;
            //LZMAHelper.decoderAsync.onmessage = function(e){
            //    if(command == 0){
            //        command = e.data;
            //    }else if(command == LZMAHelper.ENCODE){
            //        command = 0;//encode not implemented
            //    }else if(command == LZMAHelper.DECODE){
            //        command = 0;
            //        LZMAHelper.callback(e.data);
            //        LZMAHelper.callback = null;
            //    }
            //}
        };
        LZMAHelper.encode = function (data) {
            return null;
        };
        LZMAHelper.decode = function (data) {
            return LZMAHelper.decoder.decode(new Uint8Array(data)).buffer;
        };
        LZMAHelper.encodeAsync = function (data, _callback) {
            //��ʱû֧�� ѹ��
        };
        LZMAHelper.decodeAsync = function (data, _callback) {
            if (LZMAHelper.callback == null) {
                LZMAHelper.callback = _callback;
            }
            else {
                console.log('Warning! Another LZMA decoding is running...');
            }
        };
        LZMAHelper.decoder = new nid.LZMA();
        LZMAHelper.ENCODE = 1;
        LZMAHelper.DECODE = 2;
        return LZMAHelper;
    }());
    nid.LZMAHelper = LZMAHelper;
})(nid || (nid = {}));
nid.LZMAHelper.init();
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var Egret3DLog = (function () {
        function Egret3DLog() {
        }
        Egret3DLog.outError = function (message) {
            console.log("Error:" + message);
        };
        Egret3DLog.outWarn = function (message) {
            console.log("Warning:" + message);
        };
        Egret3DLog.outDebug = function (message) {
            if (egret3d.Egret3DEngine.instance.debug) {
                console.log("Debug:" + message);
            }
        };
        return Egret3DLog;
    }());
    egret3d.Egret3DLog = Egret3DLog;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    (function (TextureMethodType) {
        TextureMethodType[TextureMethodType["diffuse"] = 0] = "diffuse";
        TextureMethodType[TextureMethodType["normal"] = 1] = "normal";
        TextureMethodType[TextureMethodType["specular"] = 2] = "specular";
        TextureMethodType[TextureMethodType["color"] = 3] = "color";
        TextureMethodType[TextureMethodType["shadow"] = 4] = "shadow";
    })(egret3d.TextureMethodType || (egret3d.TextureMethodType = {}));
    var TextureMethodType = egret3d.TextureMethodType;
    /**
    * @private
    */
    (function (ShaderPhaseType) {
        ShaderPhaseType[ShaderPhaseType["utils_vertex"] = 0] = "utils_vertex";
        ShaderPhaseType[ShaderPhaseType["base_vertex"] = 1] = "base_vertex";
        ShaderPhaseType[ShaderPhaseType["start_vertex"] = 2] = "start_vertex";
        ShaderPhaseType[ShaderPhaseType["local_vertex"] = 3] = "local_vertex";
        ShaderPhaseType[ShaderPhaseType["global_vertex"] = 4] = "global_vertex";
        ShaderPhaseType[ShaderPhaseType["end_vertex"] = 5] = "end_vertex";
        ShaderPhaseType[ShaderPhaseType["utils_fragment"] = 6] = "utils_fragment";
        ShaderPhaseType[ShaderPhaseType["base_fragment"] = 7] = "base_fragment";
        ShaderPhaseType[ShaderPhaseType["start_fragment"] = 8] = "start_fragment";
        ShaderPhaseType[ShaderPhaseType["materialsource_fragment"] = 9] = "materialsource_fragment";
        ShaderPhaseType[ShaderPhaseType["diffuse_fragment"] = 10] = "diffuse_fragment";
        ShaderPhaseType[ShaderPhaseType["normal_fragment"] = 11] = "normal_fragment";
        ShaderPhaseType[ShaderPhaseType["matCap_fragment"] = 12] = "matCap_fragment";
        ShaderPhaseType[ShaderPhaseType["specular_fragment"] = 13] = "specular_fragment";
        ShaderPhaseType[ShaderPhaseType["shadow_fragment"] = 14] = "shadow_fragment";
        ShaderPhaseType[ShaderPhaseType["lighting_fragment"] = 15] = "lighting_fragment";
        ShaderPhaseType[ShaderPhaseType["multi_end_fragment"] = 16] = "multi_end_fragment";
        ShaderPhaseType[ShaderPhaseType["end_fragment"] = 17] = "end_fragment";
    })(egret3d.ShaderPhaseType || (egret3d.ShaderPhaseType = {}));
    var ShaderPhaseType = egret3d.ShaderPhaseType;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
* @private
*/
    (function (UniformType) {
        UniformType[UniformType["uniform1f"] = 0] = "uniform1f";
        UniformType[UniformType["uniform1fv"] = 1] = "uniform1fv";
        UniformType[UniformType["uniform1i"] = 2] = "uniform1i";
        UniformType[UniformType["uniform1iv"] = 3] = "uniform1iv";
        UniformType[UniformType["uniform2f"] = 4] = "uniform2f";
        UniformType[UniformType["uniform2fv"] = 5] = "uniform2fv";
        UniformType[UniformType["uniform2i"] = 6] = "uniform2i";
        UniformType[UniformType["uniform2iv"] = 7] = "uniform2iv";
        UniformType[UniformType["uniform3f"] = 8] = "uniform3f";
        UniformType[UniformType["uniform3fv"] = 9] = "uniform3fv";
        UniformType[UniformType["uniform3i"] = 10] = "uniform3i";
        UniformType[UniformType["uniform3iv"] = 11] = "uniform3iv";
        UniformType[UniformType["uniform4f"] = 12] = "uniform4f";
        UniformType[UniformType["uniform4fv"] = 13] = "uniform4fv";
        UniformType[UniformType["uniform4i"] = 14] = "uniform4i";
        UniformType[UniformType["uniform4iv"] = 15] = "uniform4iv";
        UniformType[UniformType["uniformMatrix2fv"] = 16] = "uniformMatrix2fv";
        UniformType[UniformType["uniformMatrix3fv"] = 17] = "uniformMatrix3fv";
        UniformType[UniformType["uniformMatrix4fv"] = 18] = "uniformMatrix4fv";
    })(egret3d.UniformType || (egret3d.UniformType = {}));
    var UniformType = egret3d.UniformType;
    /**
    * @private
    */
    (function (InternalFormat) {
        InternalFormat[InternalFormat["PixelArray"] = 0] = "PixelArray";
        InternalFormat[InternalFormat["CompressData"] = 1] = "CompressData";
        InternalFormat[InternalFormat["ImageData"] = 2] = "ImageData";
    })(egret3d.InternalFormat || (egret3d.InternalFormat = {}));
    var InternalFormat = egret3d.InternalFormat;
    ;
    /**
    * @private
    */
    //export class ColorFormat {
    //    ColorFormat_RGBA8888
    //} 
    /**
    * @private
    */
    (function (FrameBufferType) {
        FrameBufferType[FrameBufferType["shadowFrameBufrfer"] = 0] = "shadowFrameBufrfer";
        FrameBufferType[FrameBufferType["defaultFrameBuffer"] = 1] = "defaultFrameBuffer";
        FrameBufferType[FrameBufferType["positionFrameBuffer"] = 2] = "positionFrameBuffer";
        FrameBufferType[FrameBufferType["normalFrameBuffer"] = 3] = "normalFrameBuffer";
        FrameBufferType[FrameBufferType["specularFrameBuffer"] = 4] = "specularFrameBuffer";
        FrameBufferType[FrameBufferType["leftEyeFrameBuffer"] = 5] = "leftEyeFrameBuffer";
        FrameBufferType[FrameBufferType["rightEyeFrameBuffer"] = 6] = "rightEyeFrameBuffer";
        FrameBufferType[FrameBufferType["nextFrameBuffer"] = 7] = "nextFrameBuffer";
    })(egret3d.FrameBufferType || (egret3d.FrameBufferType = {}));
    var FrameBufferType = egret3d.FrameBufferType;
    /**
    * @private
    */
    (function (FrameBufferFormat) {
        FrameBufferFormat[FrameBufferFormat["FLOAT_RGB"] = 0] = "FLOAT_RGB";
        FrameBufferFormat[FrameBufferFormat["FLOAT_RGBA"] = 1] = "FLOAT_RGBA";
        FrameBufferFormat[FrameBufferFormat["UNSIGNED_BYTE_RGB"] = 2] = "UNSIGNED_BYTE_RGB";
        FrameBufferFormat[FrameBufferFormat["UNSIGNED_BYTE_RGBA"] = 3] = "UNSIGNED_BYTE_RGBA";
    })(egret3d.FrameBufferFormat || (egret3d.FrameBufferFormat = {}));
    var FrameBufferFormat = egret3d.FrameBufferFormat;
    /**
    * @language zh_CN
    * 渲染混合模式</p>
    * BlendMode 类中的一个值，用于指定要使用的混合模式。 内部绘制位图的方法有两种。</p>
    * 如果启用了混合模式或外部剪辑遮罩，则将通过向矢量渲染器添加有位图填充的正方形来绘制位图。</p>
    * 如果尝试将此属性设置为无效值，运行时会将此值设置为 BlendMode.NORMAL。</p>
    * blendMode 属性影响显示对象的每个像素。</p>
    * 每个像素都由三种原色（红色、绿色和蓝色）组成，每种原色的值介于 0x00 和 0xFF 之间。</p>
    * 将影片剪辑中一个像素的每种原色与背景中像素的对应颜色进行比较。</p>
    * 下表将对 blendMode 设置进行说明。BlendMode 类定义可使用的字符串值。</p>
    * 表中的插图显示应用于交叠于显示对象</p>
    * (1) 之上的圆形显示对象 (2) 的 blendMode 值。</p>
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (BlendMode) {
        /**
        * @language zh_CN
        * 将显示对象的每个像素的 Alpha 值应用于背景。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["ALPHA"] = 0] = "ALPHA";
        /**
        * @language zh_CN
        * 强制为该显示对象创建一个透明度组。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["LAYER"] = 1] = "LAYER";
        /**
        * @language zh_CN
        * 该显示对象出现在背景前面。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["NORMAL"] = 2] = "NORMAL";
        /**
        * @language zh_CN
        * 将显示对象的原色值与背景颜色的原色值相乘，然后除以 0xFF 进行标准化，从而得到较暗的颜色。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["MULTIPLY"] = 3] = "MULTIPLY";
        /**
        * @language zh_CN
        * 将显示对象的原色值添加到它的背景颜色中，上限值为 0xFF。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["ADD"] = 4] = "ADD";
        /**
        * @language zh_CN
        * 从背景颜色的值中减去显示对象原色的值，下限值为 0。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["SUB"] = 5] = "SUB";
        /**
        * @language zh_CN
        * 将显示对象颜色的补色（反色）与背景颜色的补色相除。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["DIV"] = 6] = "DIV";
        /**
        * @language zh_CN
        * 将显示对象颜色的补色（反色）与背景颜色的补色相乘，会产生漂白效果。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["SCREEN"] = 7] = "SCREEN";
        /**
        * @language zh_CN
        * 将显示对象的原色值添加到它的背景颜色中(较ADD稍微暗一些)，上限值为 0xFF。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["SOFT_ADD"] = 8] = "SOFT_ADD";
    })(egret3d.BlendMode || (egret3d.BlendMode = {}));
    var BlendMode = egret3d.BlendMode;
    /**
    * @private
    * @class egret3d.ContextSamplerType
    * @classdesc
    * 贴图采样类型
    */
    var ContextSamplerType = (function () {
        function ContextSamplerType() {
        }
        return ContextSamplerType;
    }());
    egret3d.ContextSamplerType = ContextSamplerType;
    /**
    * @class egret3d.DrawMode
    * @classdesc
    * 渲染模式。
    * LINES 线框显示模式。
    * POINTS 点显示模式。
    * TRIANGLES 三角形显示模式。
    * LINE_STRIP 连接线显示模式。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var DrawMode = (function () {
        function DrawMode() {
        }
        return DrawMode;
    }());
    egret3d.DrawMode = DrawMode;
    /**
    * @class egret3d.ContextConfig
    * @classdesc
    *
    * 一些渲染状态，裁剪模式和数据类型的一些常量值。
    * 对应WebGLRenderingContext中的常量值。
    *
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ContextConfig = (function () {
        function ContextConfig() {
        }
        /**
        * @private
        */
        ContextConfig.Direct3D_Opengl_Auto = "Direct3D_Opengl_Auto";
        /**
        * @private
        */
        ContextConfig.Direct3D_9_0 = "Direct3D_9_0";
        /**
        * @private
        */
        ContextConfig.Direct3D_10_0 = "Direct3D_10_0";
        /**
        * @private
        */
        ContextConfig.Direct3D_11_0 = "Direct3D_11_0";
        /**
        * @private
        */
        ContextConfig.OpenGLES_2_0 = "OpenGLES_2_0";
        /**
        * @private
        */
        ContextConfig.OpenGLES_3_0 = "OpenGLES_3_0";
        /**
        * @private
        */
        ContextConfig.OpenGL = "OpenGL";
        /**
        * @private
        */
        ContextConfig.ColorFormat_DXT1_RGB = 0;
        /**
        * @private
        */
        ContextConfig.ColorFormat_DXT1_RGBA = 0;
        /**
        * @private
        */
        ContextConfig.ColorFormat_DXT3_RGBA = 0;
        /**
        * @private
        */
        ContextConfig.ColorFormat_DXT5_RGBA = 0;
        return ContextConfig;
    }());
    egret3d.ContextConfig = ContextConfig;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.UV
     * @classdesc
     * UV类，用来存储模型顶点uv数据
     *
     * @see egret3d.GeometryData
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var UV = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function UV(u, v) {
            if (u === void 0) { u = 0; }
            if (v === void 0) { v = 0; }
            /**
            * @language zh_CN
            * u
            */
            this.u = 0;
            /**
            * @language zh_CN
            * v
            */
            this.v = 0;
            this.u = u;
            this.v = v;
        }
        return UV;
    }());
    egret3d.UV = UV;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Point
    * @classdesc
    * Point 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
    * @includeExample geom/Point.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Point = (function () {
        /**
         * @language en_US
         * Creates a new point. If you pass no parameters to this method, a point is
         * created at(0,0).
         *
         * @param x The horizontal coordinate.
         * @param y The vertical coordinate.
         */
        /**
         * @language zh_CN
         * 创建一个Point实例
         * @param x x坐标 默认为0
         * @param y y坐标 默认为0
         * @version Egret 3.0
         * @platform Web,Native
         */
        function Point(x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            this.x = x;
            this.y = y;
        }
        Object.defineProperty(Point.prototype, "length", {
            /**
             * @language en_US
             * The length of the line segment from(0,0) to this point.
             * @returns length
                    * @version Egret 3.0
            * @platform Web,Native
             */
            /**
             * @language zh_CN
             * 返回从(0, 0)到(x, y)的距离
             * @returns number 当前2维向量的长度
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language en_US
         * Adds the coordinates of another point to the coordinates of this point to
         * create a new point.
         *
         * @param v The point to be added.
         * @returns The new point.
         */
        /**
         * @language zh_CN
         * 当前Point加上v Point，结果返回新的实例
         * @param v
         * @version Egret 3.0
         * @platform Web,Native
         */
        Point.prototype.add = function (v) {
            return new Point(this.x + v.x, this.y + v.y);
        };
        /**
        * @language zh_CN
        * 当前Point自生加上v Point
        * @param v
        * @version Egret 3.0
        * @platform Web,Native
        */
        Point.prototype.incrementBy = function (v) {
            this.x += v.x;
            this.y += v.y;
        };
        /**
        * @language zh_CN
        * 重新赋值Point实例
        * @param x x坐标 默认为0
        * @param y y坐标 默认为0
        * @version Egret 3.0
        * @platform Web,Native
        */
        Point.prototype.setTo = function (x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            this.x += x;
            this.y += y;
        };
        /**
         * @language en_US
         * Creates a copy of this Point object.
         *
         * @returns The new Point object.
         */
        /**
         * @language zh_CN
         * 克隆Point
         * @returns  Point 返回克隆后的Point
         * @version Egret 3.0
         * @platform Web,Native
         */
        Point.prototype.clone = function () {
            return new Point(this.x, this.y);
        };
        /**
         * @language zh_CN
         * 复制源Point的值
         * @param sourcePoint 数据源
         * @version Egret 3.0
         * @platform Web,Native
         */
        Point.prototype.copyFrom = function (sourcePoint) {
            this.x = sourcePoint.x;
            this.y = sourcePoint.y;
        };
        /**
         * @language en_US
         * Determines whether two points are equal. Two points are equal if they have
         * the same <i>x</i> and <i>y</i> values.
         *
         * @param toCompare The point to be compared.
         * @returns A value of <code>true</code> if the object is equal to this Point
         *         object; <code>false</code> if it is not equal.
         */
        /**
         * @language zh_CN
         * 比较两个Point是否全等
         * @param toCompare 被比较的Point
         * @returns boolean 全等返回true
         * @version Egret 3.0
         * @platform Web,Native
         */
        Point.prototype.equals = function (toCompare) {
            return (this.x == toCompare.x && this.y == toCompare.y);
        };
        /**
         * @language en_US
         * Scales the line segment between(0,0) and the current point to a set
         * length.
         *
         * @param thickness The scaling value. For example, if the current point is
         *                 (0,5), and you normalize it to 1, the point returned is
         *                  at(0,1).
         */
        /**
         * @language zh_CN
         * 当前Point标准化
         * @param thickness 默认参数为1，使当前Point的长度为thickness 原点(0, 0)到(x, y)的距离
         * @version Egret 3.0
         * @platform Web,Native
         */
        Point.prototype.normalize = function (thickness) {
            if (thickness === void 0) { thickness = 1; }
            var len = this.length;
            if (len != 0) {
                var invLength = thickness / len;
                this.x *= invLength;
                this.y *= invLength;
                return;
            }
            throw "Cannot divide by zero length.";
        };
        /**
         * @language en_US
         * Offsets the Point object by the specified amount. The value of
         * <code>dx</code> is added to the original value of <i>x</i> to create the
         * new <i>x</i> value. The value of <code>dy</code> is added to the original
         * value of <i>y</i> to create the new <i>y</i> value.
         *
         * @param dx The amount by which to offset the horizontal coordinate,
         *           <i>x</i>.
         * @param dy The amount by which to offset the vertical coordinate, <i>y</i>.
         */
        /**
         * @language zh_CN
         * 当前Point偏移位置
         * @param dx 偏移的x坐标
         * @param dx 偏移的y坐标
         * @version Egret 3.0
         * @platform Web,Native
         */
        Point.prototype.offset = function (dx, dy) {
            this.x += dx;
            this.y += dy;
        };
        /**
         * @language en_US
         * Subtracts the coordinates of another point from the coordinates of this
         * point to create a new point.
         *
         * @param v The point to be subtracted.
         * @returns The new point.
         */
        /**
         * @language zh_CN
         * 当前Point减去v Point,结果返回一个新实例
         * @param v
         * @returns Point 结果返回
         * @version Egret 3.0
         * @platform Web,Native
         */
        Point.prototype.subtract = function (v) {
            return new Point(this.x - v.x, this.y - v.y);
        };
        /**
         * @language en_US
         * Returns a string that contains the values of the <i>x</i> and <i>y</i>
         * coordinates. The string has the form <code>"(x=<i>x</i>,
         * y=<i>y</i>)"</code>, so calling the <code>toString()</code> method for a
         * point at 23,17 would return <code>"(x=23, y=17)"</code>.
         *
         * @returns The string representation of the coordinates.
         */
        /**
        * @language zh_CN
        * 当前Point以字符串形式返回
        * @returns string
         * @version Egret 3.0
         * @platform Web,Native
        */
        Point.prototype.toString = function () {
            return "[Point] (x=" + this.x + ", y=" + this.y + ")";
        };
        /**
         * @language en_US
         * Returns the distance between <code>pt1</code> and <code>pt2</code>.
         *
         * @param pt1 The first point.
         * @param pt2 The second point.
         * @returns The distance between the first and second points.
         */
        /**
        * @language zh_CN
        * 计算两个Point之间的距离
        * @returns number 返回两个Point之间的距离
         * @version Egret 3.0
         * @platform Web,Native
        */
        Point.distance = function (pt1, pt2) {
            var dx = pt2.x - pt1.x;
            var dy = pt2.y - pt1.y;
            return Math.sqrt(dx * dx + dy * dy);
        };
        return Point;
    }());
    egret3d.Point = Point;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.PointUtils
    * @classdesc
    * 这个类里面封装了一个用于判定一个2d点是否在另外3个2d点的三角形内部的方法。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PointUtils = (function () {
        function PointUtils() {
        }
        /**
       * @language zh_CN
       * 判定2d点是否在一个2d的三角形内
       * @param pt0        被判定的点
       * @param pt1        三角形的顶点1
       * @param pt2        三角形的顶点2
       * @param pt3        三角形的顶点3
       * @returns boolean 是否处于三角形内
       * @version Egret 3.0
       * @platform Web,Native
       */
        PointUtils.pointInsideTriangle = function (pt, pt0, pt1, pt2) {
            PointUtils.pp.setTo(pt.x, pt.z);
            PointUtils.p1.setTo(pt0.x, pt0.z);
            PointUtils.p2.setTo(pt1.x, pt1.z);
            PointUtils.p3.setTo(pt2.x, pt2.z);
            return PointUtils.pointInsideTriangle2d();
        };
        /**
        * @language zh_CN
        * @private
        * @returns boolean 判定2d点是否在一个2d的三角形内
        * @version Egret 3.0
        * @platform Web,Native
        */
        PointUtils.pointInsideTriangle2d = function () {
            if (PointUtils.product2d(PointUtils.p1, PointUtils.p2, PointUtils.p3) >= 0) {
                return (PointUtils.product2d(PointUtils.p1, PointUtils.p2, PointUtils.pp) >= 0)
                    && (PointUtils.product2d(PointUtils.p2, PointUtils.p3, PointUtils.pp)) >= 0
                    && (PointUtils.product2d(PointUtils.p3, PointUtils.p1, PointUtils.pp) >= 0);
            }
            else {
                return (PointUtils.product2d(PointUtils.p1, PointUtils.p2, PointUtils.pp) <= 0)
                    && (PointUtils.product2d(PointUtils.p2, PointUtils.p3, PointUtils.pp)) <= 0
                    && (PointUtils.product2d(PointUtils.p3, PointUtils.p1, PointUtils.pp) <= 0);
            }
        };
        /**
        * @language zh_CN
        * 叉乘计算
        * @param pt1        点1
        * @param pt2        点2
        * @param pt3        点3
        * @returns number 结果值
        * @version Egret 3.0
        * @platform Web,Native
        */
        PointUtils.product2d = function (p1, p2, p3) {
            var val = (p1.x - p3.x) * (p2.y - p3.y) - (p1.y - p3.y) * (p2.x - p3.x);
            if (val > -0.00001 && val < 0.00001)
                val = 0;
            return val;
        };
        /**
        * @language zh_CN
        * @private
        * 静态变量2d点
        * @version Egret 3.0
        * @platform Web,Native
        */
        PointUtils.p1 = new egret3d.Point();
        /**
        * @language zh_CN
        * @private
        * 静态变量2d点
        * @version Egret 3.0
        * @platform Web,Native
        */
        PointUtils.p2 = new egret3d.Point();
        /**
        * @language zh_CN
        * @private
        * 静态变量2d点
        * @version Egret 3.0
        * @platform Web,Native
        */
        PointUtils.p3 = new egret3d.Point();
        /**
        * @language zh_CN
        * @private
        * 静态变量2d点
        * @version Egret 3.0
        * @platform Web,Native
        */
        PointUtils.pp = new egret3d.Point();
        return PointUtils;
    }());
    egret3d.PointUtils = PointUtils;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Vector3D
    * @classdesc
    * 用 Vector3D 表示三维空间中的位置,也可以做4维向量,当为3维向量时w始终为0。</p>
    * 定义了一个三元的浮点向量。</p>
    * 当使用一个向量表示一个表面法线时，向量应该是标准化的。</p>
    * 其他用途的定向矢量的大小不变。当用作一个点，元素的矢量表示在三维空间中的位置。</p>
    * @includeExample geom/Vector3D.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Vector3D = (function () {
        /**
        * @language en_US
        * Creates an instance of a Vector3D object. If you do not specify a。
        * parameter for the constructor, a Vector3D object is created with
        * the elements (0,0,0,0).
        *
        * @param x The first element, such as the x coordinate.
        * @param y The second element, such as the y coordinate.
        * @param z The third element, such as the z coordinate.
        * @param w An optional element for additional data such as the angle
        *          of rotation.
        */
        /**
        * @language zh_CN
        * 创建一个对象实例，默认为(0, 0, 0, 0)
        * @param x x的值
        * @param y y的值
        * @param z z的值
        * @param w w的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Vector3D(x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 0; }
            /**
            * @language en_US
            * The first element of a Vector3D object, such as the x coordinate of
            * a point in the three-dimensional space. The default value is 0.
            */
            /**
            * @language zh_CN
            * 在三维空间中x坐标，默认值是0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.x = 0;
            /**
            * @language en_US
            * The second element of a Vector3D object, such as the y coordinate of
            * a point in the three-dimensional space. The default value is 0.
            */
            /**
            * @language zh_CN
            * 在三维空间中y坐标，默认值是0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.y = 0;
            /**
            * @language en_US
            * The third element of a Vector3D object, such as the y coordinate of
            * a point in the three-dimensional space. The default value is 0.
            */
            /**
            * @language zh_CN
            * 在三维空间中z坐标，默认值是0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.z = 0;
            /**
            * @language zh_CN
            * 可作为一种透视投影的三维位置或投影
            * 也可以做四元数中的w
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.w = 0;
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        Object.defineProperty(Vector3D.prototype, "a", {
            /**
            * @language en_US
            *  得到w分量
            * @returns 获得w的值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.w;
            },
            /**
            * @language en_US
            *  设置w分量
            * @param value 设置给w的值
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.w = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "r", {
            /**
            * @language en_US
            *  得到x分量
            * @returns 获得x的值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.x;
            },
            /**
            * @language en_US
            *  设置x分量
            * @param value 设置给x的值
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "g", {
            /**
            * @language en_US
            *  得到y分量
            * @returns 获得y的值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.y;
            },
            /**
            * @language en_US
            *  设置y分量
            * @param value 设置给y的值
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "b", {
            /**
            * @language en_US
            *  得到z分量
            * @returns 获得z的值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.z;
            },
            /**
            * @language en_US
            *  设置z分量
            * @param value 设置给z的值
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.z = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "length", {
            /**
            * @language en_US
            * The length, magnitude, of the current Vector3D object from the
            * origin (0,0,0) to the object's x, y, and z coordinates. The w
            * property is ignored. A unit vector has a length or magnitude of
            * one.
            */
            /**
            * @language zh_CN
            * 向量的长度，原点(0, 0, 0)到(x, y, z)的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return Math.sqrt(this.lengthSquared);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "lengthSquared", {
            /**
            * @language en_US
            * The square of the length of the current Vector3D object, calculated。
            * using the x, y, and z properties. The w property is ignored. Use the
            * <code>lengthSquared()</code> method whenever possible instead of the
            * slower <code>Math.sqrt()</code> method call of the
            * <code>Vector3D.length()</code> method.
            */
            /**
            * @language zh_CN
            * 3维向量的坐标x的平方加 y的平方加 z的平方
            * @returns 获得长度的平方
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language en_US
        * Adds the value of the x, y, and z elements of the current Vector3D。
        * object to the values of the x, y, and z elements of another Vector3D
        * object. The <code>add()</code> method does not change the current
        * Vector3D object. Instead, it returns a new Vector3D object with
        * the new values.
        *
        * <p>The result of adding two vectors together is a resultant vector.
        * One way to visualize the result is by drawing a vector from the
        * origin or tail of the first vector to the end or head of the second
        * vector. The resultant vector is the distance between the origin
        * point of the first vector and the end point of the second vector.
        * </p>
        */
        /**
        * @language zh_CN
        * 向量相加，结果返回一个新实例
        * @param a Vector3D 加成的值
        * @param target Vector3D 默认为null
        * @returns Vector3D 结果返回
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.add = function (a, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Vector3D();
            }
            var a0x = this.x;
            var a0y = this.y;
            var a0z = this.z;
            var a0w = this.w;
            var a1x = a.x;
            var a1y = a.y;
            var a1z = a.z;
            var a1w = a.w;
            target.setTo(a0x + a1x, a0y + a1y, a0z + a1z, a0w + a1w);
            return target;
        };
        /**
        * @language en_US
        * Returns a new Vector3D object that is an exact copy of the current
        * Vector3D object.
        *
        * @returns A new Vector3D object that is a copy of the current
        * Vector3D object.
        */
        /**
        * @language zh_CN
        * 克隆一个Vector3D
        * @returns 返回克隆后的实例
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.clone = function () {
            return new Vector3D(this.x, this.y, this.z, this.w);
        };
        /**
        * @language en_US
        * Copies all of vector data from the source Vector3D object into the
        * calling Vector3D object.
        *
        * @param src The Vector3D object from which to copy the data.
        */
        /**
        * @language zh_CN
        * 复制Vector3D对象
        * @param src 数据源
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.copyFrom = function (src) {
            var v = this;
            v.x = src.x;
            v.y = src.y;
            v.z = src.z;
            v.w = src.w;
        };
        /**
        * @language en_US
        * Returns a new Vector3D object that is perpendicular (at a right。
        * angle) to the current Vector3D and another Vector3D object. If the
        * returned Vector3D object's coordinates are (0,0,0), then the two
        * Vector3D objects are parallel to each other.
        *
        * <p>You can use the normalized cross product of two vertices of a
        * polygon surface with the normalized vector of the camera or eye
        * viewpoint to get a dot product. The value of the dot product can
        * identify whether a surface of a three-dimensional object is hidden
        * from the viewpoint.</p>
        *
        * @param a A second Vector3D object.
        * @returns A new Vector3D object that is perpendicular to the current
        *          Vector3D object and the Vector3D object specified as the
        *          parameter.
        */
        /**
        * @language zh_CN
        * 两个Vector3D进行叉乘 this 叉乘 a
        * 叉乘后的结果是这两条向量的垂直向量
        * @param a 求叉乘的另外一个向量
        * @returns Vector3D 返回叉乘结果向量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.crossProduct = function (a, target) {
            if (target === void 0) { target = null; }
            target = target || new Vector3D();
            target.x = this.y * a.z - this.z * a.y;
            target.y = this.z * a.x - this.x * a.z;
            target.z = this.x * a.y - this.y * a.x;
            target.w = 1;
            return target;
        };
        /**
        * @language en_US
        * Decrements the value of the x, y, and z elements of the current。
        * Vector3D object by the values of the x, y, and z elements of
        * specified Vector3D object. Unlike the
        * <code>Vector3D.subtract()</code> method, the
        * <code>decrementBy()</code> method changes the current Vector3D
        * object and does not return a new Vector3D object.
        *
        * @param a The Vector3D object containing the values to subtract from
        *          the current Vector3D object.
        */
        /**
        * @language zh_CN
        * 当前向量减去a向量，结果赋值给自己
        * @param a 减去的向量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.decrementBy = function (a) {
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
        };
        /**
        * @language en_US
        * Returns the distance between two Vector3D objects. The。
        * <code>distance()</code> method is a static method. You can use it
        * directly as a method of the Vector3D class to get the Euclidean
        * distance between two three-dimensional points.
        *
        * @param pt1 A Vector3D object as the first three-dimensional point.
        * @param pt2 A Vector3D object as the second three-dimensional point.
        * @returns The distance between two Vector3D objects.
        */
        /**
        * @language zh_CN
        * 计算两个Vector3D之间的距离
        * @param pt1 坐标1
        * @param pt2 坐标2
        * @returns number 两个Vector3D之间的距离
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.distance = function (pt1, pt2) {
            var x = (pt1.x - pt2.x);
            var y = (pt1.y - pt2.y);
            var z = (pt1.z - pt2.z);
            return Math.sqrt(x * x + y * y + z * z);
        };
        /**
        * @language en_US
        * If the current Vector3D object and the one specified as the。
        * parameter are unit vertices, this method returns the cosine of the
        * angle between the two vertices. Unit vertices are vertices that
        * point to the same direction but their length is one. They remove the
        * length of the vector as a factor in the result. You can use the
        * <code>normalize()</code> method to convert a vector to a unit
        * vector.
        *
        * <p>The <code>dotProduct()</code> method finds the angle between two
        * vertices. It is also used in backface culling or lighting
        * calculations. Backface culling is a procedure for determining which
        * surfaces are hidden from the viewpoint. You can use the normalized
        * vertices from the camera, or eye, viewpoint and the cross product of
        * the vertices of a polygon surface to get the dot product. If the dot
        * product is less than zero, then the surface is facing the camera or
        * the viewer. If the two unit vertices are perpendicular to each
        * other, they are orthogonal and the dot product is zero. If the two
        * vertices are parallel to each other, the dot product is one.</p>
        *
        * @param a The second Vector3D object.
        * @returns A scalar which is the dot product of the current Vector3D
        *          object and the specified Vector3D object.
        *
        */
        /**
        * @language zh_CN
        * 计算两个Vector3D的点积,返回两个Vector3D之间的夹角关系
        * @param a 另一个Vector3D
        * @returns number 返回两个Vector3D之间的夹角关系
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.dotProduct = function (a) {
            return this.x * a.x + this.y * a.y + this.z * a.z;
        };
        /**
        * @language en_US
        * @param toCompare The Vector3D object to be compared with the current
        *                  Vector3D object.
        * @param allFour   An optional parameter that specifies whether the w
        *                  property of the Vector3D objects is used in the
        *                  comparison.
        * @returns A value of true if the specified Vector3D object is equal
        *          to the current Vector3D object; false if it is not equal.
        */
        /**
        * @language zh_CN
        * 求两个Vector3D的值是否全等
        * @param toCompare 与些Vector3D进行比较
        * @param allFour 默认参数为1，是否比较w分量
        * @returns boolean 全等返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.equals = function (toCompare, allFour) {
            if (allFour === void 0) { allFour = false; }
            return (this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z && (!allFour || this.w == toCompare.w));
        };
        /**
        * @language en_US

        * Increments the value of the x, y, and z elements of the current
        * Vector3D object by the values of the x, y, and z elements of a
        * specified Vector3D object. Unlike the <code>Vector3D.add()</code>
        * method, the <code>incrementBy()</code> method changes the current
        * Vector3D object and does not return a new Vector3D object.
        *
        * @param a The Vector3D object to be added to the current Vector3D
        *          object.
        */
        /**
        * @language zh_CN
        * 当前Vector3D加等于a Vector3D，只加x y z 3个分量
        * @param a 加等a
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.incrementBy = function (a) {
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.fromArray = function (d) {
            this.x = d[0];
            this.y = d[1];
            this.z = d[2];
        };
        /**
        * @language zh_CN
        * 当前Vector3D除分量 或者 除Vector3D
        * @param v 如果是number就是除分量 如果为Vector3D 就是除Vector3D
        * @returns Vector3D 返回自己，计算之后的结果
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.divide = function (v) {
            if (v instanceof Vector3D)
                return new Vector3D(this.x / v.x, this.y / v.y, this.z / v.z);
            else {
                this.x = this.x / v;
                this.y = this.y / v;
                this.z = this.z / v;
            }
            return this;
        };
        /**
        * @language en_US
        * Sets the current Vector3D object to its inverse. The inverse object
        * is also considered the opposite of the original object. The value of
        * the x, y, and z properties of the current Vector3D object is changed
        * to -x, -y, and -z.
        */
        /**
        * @language zh_CN
        * 当前Vector3D x y z 3个分量取反
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.negate = function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
        };
        /**
        * @language en_US
        * Scales the line segment between(0,0) and the current point to a set
        * length.
        *
        * @param thickness The scaling value. For example, if the current
        * Vector3D object is (0,3,4), and you normalize it to
        * 1, the point returned is at(0,0.6,0.8).
        */
        /**
        * @language zh_CN
        * 当前Vector3D标准化
        * @param thickness 默认参数为1，使当前Vector3D的长度为thickness 原点(0, 0, 0)到(x, y, z)的距离
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.normalize = function (thickness) {
            if (thickness === void 0) { thickness = 1; }
            if (this.length != 0) {
                var invLength = thickness / this.length;
                this.x *= invLength;
                this.y *= invLength;
                this.z *= invLength;
                return;
            }
        };
        /**
        * @language en_US
        * Scales the current Vector3D object by a scalar, a magnitude. The
        * Vector3D object's x, y, and z elements are multiplied by the scalar
        * number specified in the parameter. For example, if the vector is
        * scaled by ten, the result is a vector that is ten times longer. The
        * scalar can also change the direction of the vector. Multiplying the
        * vector by a negative number reverses its direction.
        *
        * @param s A multiplier (scalar) used to scale a Vector3D object.
        */
        /**
        * @language zh_CN
        * 当前Vector3D扩大s倍
        * @param s 扩大的倍数
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.scaleBy = function (s) {
            this.x *= s;
            this.y *= s;
            this.z *= s;
        };
        /**
        * @language en_US
        * Sets the members of Vector3D to the specified values
        *
        * @param xa The first element, such as the x coordinate.
        * @param ya The second element, such as the y coordinate.
        * @param za The third element, such as the z coordinate.
        */
        /**
        * @language zh_CN
        * 填充当前Vector3D的x, y, z
        * @param xa
        * @param yz
        * @param za
        * @param wz
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.setTo = function (xa, ya, za, wa) {
            if (wa === void 0) { wa = 1; }
            this.x = xa;
            this.y = ya;
            this.z = za;
            this.w = wa;
        };
        /**
        * @language en_US
        * Subtracts the value of the x, y, and z elements of the current
        * Vector3D object from the values of the x, y, and z elements of
        * another Vector3D object. The <code>subtract()</code> method does not
        * change the current Vector3D object. Instead, this method returns a
        * new Vector3D object with the new values.
        *
        * @param a The Vector3D object to be subtracted from the current
        *          Vector3D object.
        * @returns A new Vector3D object that is the difference between the
        *          current Vector3D and the specified Vector3D object.
        */
        /**
        * @language zh_CN
        * 当前Vector3D减去a Vector3D 结果返回新实例
        * @param a 减去的Vector3D
        * @param target 默认参数为null,如果当前参数为null那么就会new一个新的Vector3D返回
        * @returns Vector3D 结果返回
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.subtract = function (a, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Vector3D();
            }
            target.setTo(this.x - a.x, this.y - a.y, this.z - a.z);
            return target;
        };
        /**
        * @language zh_CN
        * 当前Vector3D乘other Vector3D 结果返回新实例
        * @param a 相乘的Vector3D
        * @param target 如果当前参数为null那么就会new一个新的Vector3D返回
        * @returns Vector3D 结果返回
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.multiply = function (other, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Vector3D();
            }
            var x0 = this.x;
            var y0 = this.y;
            var z0 = this.z;
            var x1 = other.x;
            var y1 = other.y;
            var z1 = other.z;
            target.setTo(x0 * x1, y0 * y1, z0 * z1);
            return target;
        };
        /**
        * @language zh_CN
        * 当前Vector3D除以other Vector3D 结果返回新实例
        * @param a 相除的Vector3D
        * @param target 如果当前参数为null那么就会new一个新的Vector3D返回
        * @returns Vector3D 结果返回
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.divided = function (other, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Vector3D();
            }
            var x0 = this.x;
            var y0 = this.y;
            var z0 = this.z;
            var x1 = other.x;
            var y1 = other.y;
            var z1 = other.z;
            target.setTo(x0 / x1, y0 / y1, z0 / z1);
            return target;
        };
        /**
        * @language zh_CN
        * 计算两个Vector3D之间的线性插值，结果为当前对象
        * @param v0 Vector3D 1
        * @param v1 Vector3D 2
        * @param t 时刻
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.lerp = function (v0, v1, t) {
            var v0x = v0.x, v0y = v0.y, v0z = v0.z, v0w = v0.w;
            var v1x = v1.x, v1y = v1.y, v1z = v1.z, v1w = v1.w;
            this.x = (v1x - v0x) * t + v0x;
            this.y = (v1y - v0y) * t + v0y;
            this.z = (v1z - v0z) * t + v0z;
            this.w = (v1w - v0w) * t + v0w;
        };
        Vector3D.prototype.Dot = function (v0, v1) {
            return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z;
        };
        Vector3D.prototype.OrthoNormalVectorFast = function (n, target) {
            if (!target) {
                target = new Vector3D();
            }
            var a;
            var k;
            if (Math.abs(n.z) > 0.70710678) {
                // choose p in y-z plane
                a = n.y * n.y + n.z * n.z;
                k = 1.0 / Math.sqrt(a);
                target.x = 0;
                target.y = -n.z * k;
                target.z = n.y * k;
            }
            else {
                // choose p in x-y plane
                a = n.x * n.x + n.y * n.y;
                k = 1.0 / Math.sqrt(a);
                target.x = -n.y * k;
                target.y = n.x * k;
                target.z = 0;
            }
            return target;
        };
        /**
       * @language zh_CN
       * 计算两个Vector3D之间的线性插值，结果为当前对象
       * @param lhs Vector3D 1
       * @param rhs Vector3D 2
       * @param t 时刻
       * @version Egret 3.0
       * @platform Web,Native
       */
        Vector3D.prototype.slerp = function (lhs, rhs, t) {
            var lhsMag = Math.sqrt(this.Dot(lhs, lhs));
            var rhsMag = Math.sqrt(this.Dot(rhs, rhs));
            if (lhsMag < 0.00001 || rhsMag < 0.00001) {
                return this.lerp(lhs, rhs, t);
            }
            var lerpedMagnitude = lhsMag + t * (rhsMag - lhsMag);
            var dot = this.Dot(lhs, rhs) / (lhsMag * rhsMag);
            // direction is almost the same
            if (dot > 1.0 - 0.00001) {
                return this.lerp(lhs, rhs, t);
            }
            else if (dot < -1.0 + 0.00001) {
                Vector3D.HELP_0.copyFrom(lhs);
                var lhsNorm = Vector3D.HELP_0.divide(lhsMag);
                this.OrthoNormalVectorFast(lhsNorm, Vector3D.HELP_1);
                var axis = Vector3D.HELP_1;
                egret3d.Quaternion.HELP_0.fromAxisAngle(Vector3D.HELP_1, 3.1415926 * t * egret3d.MathUtil.RADIANS_TO_DEGREES);
                var m = egret3d.Quaternion.HELP_0.toMatrix3D(egret3d.Matrix4_4.helpMatrix);
                m.transformVector(lhsNorm, this);
                this.scaleBy(lerpedMagnitude);
                return;
            }
            else {
                lhs.dotProduct;
                this.Cross(lhs, rhs, Vector3D.HELP_0);
                var axis = Vector3D.HELP_0;
                Vector3D.HELP_1.copyFrom(lhs);
                var lhsNorm = Vector3D.HELP_1.divide(lhsMag);
                axis.normalize();
                var angle = Math.acos(dot) * t;
                egret3d.Quaternion.HELP_0.fromAxisAngle(axis, angle * egret3d.MathUtil.RADIANS_TO_DEGREES);
                var m = egret3d.Quaternion.HELP_0.toMatrix3D(egret3d.Matrix4_4.helpMatrix);
                m.transformVector(lhsNorm, this);
                this.scaleBy(lerpedMagnitude);
                return;
            }
        };
        Vector3D.prototype.Cross = function (lhs, rhs, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Vector3D();
            }
            target.x = lhs.y * rhs.z - lhs.z * rhs.y;
            target.y = lhs.z * rhs.x - lhs.x * rhs.z;
            target.z = lhs.x * rhs.y - lhs.y * rhs.x;
            return target;
        };
        /**
        * @language zh_CN
        * 当前Vector3D以字符串形式返回
        * @returns string
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.toString = function () {
            return "<" + this.x + ", " + this.y + ", " + this.z + ">";
        };
        /**
        * @language zh_CN
        * 解析字符串为Vector3D
        * @param str 格式用空格间隔开，只解析为x,y,z
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.prototype.parsing = function (str) {
            var strS = str.split(" ");
            if (strS.length < 3)
                return;
            this.x = parseFloat(strS[0]);
            this.y = parseFloat(strS[1]);
            this.z = parseFloat(strS[2]);
        };
        /**
         * @language zh_CN
         * 是否相等
         * @param rectangle  比较的对象
         * @returns boolean 相等返回ture
         * @version Egret 3.0
         * @platform Web,Native
         */
        Vector3D.prototype.equal = function (other) {
            return !((this.x != other.x) ||
                (this.y != other.y) ||
                (this.z != other.z) ||
                (this.w != other.w));
        };
        /**
        * @language en_US
        * The x axis defined as a Vector3D object with coordinates (1,0,0).
        */
        /**
        * @language zh_CN
        * X轴坐标 (1,0,0).
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.X_AXIS = new Vector3D(1, 0, 0);
        /**
        * @language en_US
        * The y axis defined as a Vector3D object with coordinates (0,1,0).
        */
        /**
        * @language zh_CN
        * Y轴坐标 (0,1,0).
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.Y_AXIS = new Vector3D(0, 1, 0);
        /**
        * @language en_US
        * The z axis defined as a Vector3D object with coordinates (0,0,1).
        */
        /**
        * @language zh_CN
        * Z轴坐标 (0,0,1).
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.Z_AXIS = new Vector3D(0, 0, 1);
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.HELP_0 = new Vector3D();
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.HELP_1 = new Vector3D();
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.HELP_2 = new Vector3D();
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        Vector3D.HELP_3 = new Vector3D();
        return Vector3D;
    }());
    egret3d.Vector3D = Vector3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Rectangle
    * @classdesc
    * Rectangle 类 表示矩形
    *
    * Rectangle 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。
    *
    * Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其它属性。
    *
    * 您可以使用 new Rectangle() 构造函数创建 Rectangle 对象。
    * @includeExample geom/Rectangle.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Rectangle = (function () {
        /**
         * @language zh_CN
         * 创建一个新 Rectangle 对象，其左上角由 x 和 y 参数指定，并具有指定的 width 和 height 参数。
         * @param x 矩形左上角的 x 坐标。
         * @param y 矩形左上角的 y 坐标。
         * @param width 矩形的宽度
         * @param height 矩形的高度
         * @version Egret 3.0
         * @platform Web,Native
         */
        function Rectangle(x, y, width, height) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (width === void 0) { width = 0; }
            if (height === void 0) { height = 0; }
            /**
            * @language zh_CN
            * 矩形左上角的 x 坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.x = 0;
            /**
            * @language zh_CN
            * 矩形左上角的 y 坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.y = 0;
            /**
            * @language zh_CN
            * 矩形的宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.width = 0;
            /**
            * @language zh_CN
            * 矩形的高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.height = 0;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        /**
        * @language zh_CN
        * 从一个矩形拷贝数据
        * @param rect 拷贝的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Rectangle.prototype.copyFrom = function (rect) {
            this.x = rect.x;
            this.y = rect.y;
            this.width = rect.width;
            this.height = rect.height;
        };
        /**
        * @language zh_CN
        * 拷贝数据到一个矩形
        * @param rect 拷贝到目标矩形
        * @version Egret 3.0
        * @platform Web,Native
        */
        Rectangle.prototype.copyTo = function (rect) {
            rect.copyFrom(this);
        };
        /**
         * @language zh_CN
         * 检测x y 是否在当前矩形内
         * @param x  x 坐标。
         * @param y  y 坐标。
         * @returns boolean 是否在当前矩形内
         * @version Egret 3.0
         * @platform Web,Native
         */
        Rectangle.prototype.inner = function (x, y) {
            if (x < this.x || x > this.x + this.width ||
                y < this.y || y > this.y + this.height) {
                return false;
            }
            return true;
        };
        /**
         * @language zh_CN
         * 检测x y 是否在当前矩形内
         * @param x  x 坐标。
         * @param y  y 坐标。
         * @param lt_x  矩形左x坐标。
         * @param lt_y  矩形上y坐标。
         * @param rb_x  矩形右x坐标。
         * @param rb_y  矩形下y坐标。
         * @returns boolean 是否在当前矩形内
         * @version Egret 3.0
         * @platform Web,Native
         */
        Rectangle.pointInRect = function (x, y, lt_x, lt_y, rb_x, rb_y) {
            if (x < lt_x || x > rb_x ||
                y < lt_y || y > rb_y) {
                return false;
            }
            return true;
        };
        /**
         * @language zh_CN
         * 检测另外一个矩形是否和当前矩形等价
         * @param rectangle  比较的对象
         * @returns boolean 相等返回ture
         * @version Egret 3.0
         * @platform Web,Native
         */
        Rectangle.prototype.equal = function (rectangle) {
            return !((this.x != rectangle.x) ||
                (this.y != rectangle.y) ||
                (this.width != rectangle.width) ||
                (this.height != rectangle.height));
        };
        /**
         * @language zh_CN
         * 检测传入的数据构成的矩形是否和当前矩形等价
         * @param x  x坐标
         * @param y  y坐标
         * @param width  矩形宽度
         * @param height  矩形高度
         * @returns boolean 相等返回ture
         * @version Egret 3.0
         * @platform Web,Native
         */
        Rectangle.prototype.equalArea = function (x, y, width, height) {
            return !((this.x != x) ||
                (this.y != y) ||
                (this.width != width) ||
                (this.height != height));
        };
        /*
        * @private
        */
        Rectangle.prototype.equalInnerArea = function (source, target) {
            var Xa1 = this.x;
            var Ya1 = this.y;
            var Xa2 = this.x + this.width;
            var Ya2 = this.y + this.height;
            var Xb1 = source.x;
            var Yb1 = source.y;
            var Xb2 = source.x + source.width;
            var Yb2 = source.y + source.height;
            if (Math.max(Xa1, Xb1) <= Math.min(Xa2, Xb2) &&
                Math.max(Ya1, Yb1) <= Math.min(Ya2, Yb2)) {
                return true;
            }
            return false;
        };
        /**
        * @language zh_CN
        * 输入一个矩形和当前矩形做比较，获得交叉区域的矩形
        * @param source  比较区域
        * @param target  目标接参
        * @returns Rectangle 返回相交的区域
        * @version Egret 3.0
        * @platform Web,Native
        */
        Rectangle.prototype.innerArea = function (source, target) {
            target = target || new Rectangle();
            var Xa1 = this.x;
            var Ya1 = this.y;
            var Xa2 = this.x + this.width;
            var Ya2 = this.y + this.height;
            var Xb1 = source.x;
            var Yb1 = source.y;
            var Xb2 = source.x + source.width;
            var Yb2 = source.y + source.height;
            var top = Math.max(Ya1, Yb1);
            var bottom = Math.min(Ya2, Yb2);
            var left = Math.max(Xa1, Xb1);
            var right = Math.min(Xb2, Xa2);
            if (top >= 0 && bottom >= 0 && (bottom - top) >= 0 && (right - left) > 0) {
                target.x = left;
                target.y = top;
                target.width = right - left;
                target.height = bottom - top;
            }
            else {
                target.x = 0;
                target.y = 0;
                target.width = 0;
                target.height = 0;
            }
            return target;
        };
        /**
        * @language zh_CN
        * 重置一个矩形数据
        * @param x  x坐标
        * @param y  y坐标
        * @param width  宽度
        * @param height  高度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Rectangle.prototype.setTo = function (x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        };
        return Rectangle;
    }());
    egret3d.Rectangle = Rectangle;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Quaternion
    * @classdesc
    * Quaternion类
    *
    * 定义了一个四元数表示物体在空间的旋转。
    * 四元数通常用作替代欧拉角和旋转矩阵的方式来实现平滑插值和避免万向节锁
    * 注意，这四元数类不自动保持四元数标准化。因此，在必要的时候，必须采取单位化的四元数，通过调用单位化方法
    * @includeExample geom/Quaternion.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Quaternion = (function () {
        /**
        * @language en_US
        * Creates a new Quaternion object.
        * @param x The x value of the quaternion.
        * @param y The y value of the quaternion.
        * @param z The z value of the quaternion.
        * @param w The w value of the quaternion.
        */
        /**
        * @language zh_CN
        * 创建一个四元数.
        * @param x
        * @param y
        * @param z
        * @param w
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Quaternion(x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 1; }
            /**
            * @language en_US
            * The x value of the quaternion.
            */
            /**
            * @language zh_CN
            * 四元数的x值.
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.x = 0;
            /**
            * @language en_US
            * The y value of the quaternion.
            */
            /**
            * @language zh_CN
            * 四元数的y值.
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.y = 0;
            /**
            * @language en_US
            * The z value of the quaternion.
            */
            /**
            * @language zh_CN
            * 四元数的z值.
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.z = 0;
            /**
            * @language en_US
            * The w value of the quaternion.
            */
            /**
            * @language zh_CN
            * 四元数的w值.
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.w = 1;
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        /*
        * @language zh_CN
        * 设置四元数的值
        * @param x
        * @param y
        * @param z
        * @param w 默认为1
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.setTo = function (x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 1; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        };
        Object.defineProperty(Quaternion.prototype, "magnitude", {
            /**
            * @language en_US
            *
            * @returns the magnitude of the quaternion object.
            */
            /**
            * @language zh_CN
            *
            * 返回四元数的大小.
            * @param w
            * @returns number 四元数的大小.
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        *
        * @returns the magnitude of the quaternion object.
        */
        Quaternion.prototype.fromArray = function (d) {
            this.x = -d[0];
            this.y = -d[1];
            this.z = d[2];
            this.w = d[3];
        };
        /**
        * @language en_US
        * Fills the quaternion object with the result from a multiplication of two quaternion objects.
        *
        * @param    qa    The first quaternion in the multiplication.
        * @param    qb    The second quaternion in the multiplication.
        */
        /**
        * @language zh_CN
        * 两个四元数相乘,然后结果给当调用者.
        * @param qa 第一个四元数
        * @param qb 第二个四元数
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.multiply = function (qa, qb) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            this.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            this.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            this.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
        };
        /**
        * @language zh_CN
        * 四元数乘以一个3维向量，结果返回一个四元数
        * @param vector 相乘的向量
        * @param target 返回的结果，如果为null就会实例化一个四元数对象返回
        * @returns Quaternion 返回相乘后的结果
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.multiplyVector = function (vector, target) {
            if (target === void 0) { target = null; }
            if (target === null) {
                target = new Quaternion();
            }
            var x2 = vector.x;
            var y2 = vector.y;
            var z2 = vector.z;
            target.w = -this.x * x2 - this.y * y2 - this.z * z2;
            target.x = this.w * x2 + this.y * z2 - this.z * y2;
            target.y = this.w * y2 - this.x * z2 + this.z * x2;
            target.z = this.w * z2 + this.x * y2 - this.y * x2;
            return target;
        };
        /**
        * @language en_US
        * Fills the quaternion object with values representing the given rotation around a vector.
        *
        * @param    axis    The axis around which to rotate
        * @param    angle    The angle in radians of the rotation.
        */
        /**
        * @language zh_CN
        * 创建一个以axis轴为中心旋转angle角度的四元数
        *
        * @param axis   旋转轴
        * @param angle  旋转角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.fromAxisAngle = function (axis, angle) {
            angle *= Math.PI / 180.0;
            var halfAngle = angle * 0.5;
            var sin_a = Math.sin(halfAngle);
            this.w = Math.cos(halfAngle);
            this.x = axis.x * sin_a;
            this.y = axis.y * sin_a;
            this.z = axis.z * sin_a;
            this.normalize();
        };
        /**
        * @language zh_CN
        * 返回四元数绕轴心和角度
        *
        * @param axis 轴心
        * @returns 角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.toAxisAngle = function (axis) {
            var sqrLength = this.x * this.x + this.y * this.y + this.z * this.z;
            var angle = 0;
            if (sqrLength > 0.0) {
                angle = 2.0 * Math.acos(this.w);
                sqrLength = 1.0 / Math.sqrt(sqrLength);
                axis.x = this.x * sqrLength;
                axis.y = this.y * sqrLength;
                axis.z = this.z * sqrLength;
            }
            else {
                angle = 0;
                axis.x = 1.0;
                axis.y = 0;
                axis.z = 0;
            }
            angle /= Math.PI / 180.0;
            return angle;
        };
        /**
        * @language en_US
        * Spherically interpolates between two quaternions, providing an interpolation between rotations with constant angle change rate.
        * @param qa The first quaternion to interpolate.
        * @param qb The second quaternion to interpolate.
        * @param t The interpolation weight, a value between 0 and 1.
        */
        /**
        * @language zh_CN
        * 两个四元数之间球形插值，插值之间提供旋转恒定角变化率。
        *
        * @param qa 四元数1
        * @param qb 四元数2
        * @param t 插值时刻
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.slerp = function (qa, qb, t) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            var dot = w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2;
            // shortest direction
            if (dot < 0) {
                dot = -dot;
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            if (dot < 0.95) {
                // interpolate angle linearly
                var angle = Math.acos(dot);
                var s = 1 / Math.sin(angle);
                var s1 = Math.sin(angle * (1 - t)) * s;
                var s2 = Math.sin(angle * t) * s;
                this.w = w1 * s1 + w2 * s2;
                this.x = x1 * s1 + x2 * s2;
                this.y = y1 * s1 + y2 * s2;
                this.z = z1 * s1 + z2 * s2;
            }
            else {
                // nearly identical angle, interpolate linearly
                this.w = w1 + t * (w2 - w1);
                this.x = x1 + t * (x2 - x1);
                this.y = y1 + t * (y2 - y1);
                this.z = z1 + t * (z2 - z1);
                var len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
                this.w *= len;
                this.x *= len;
                this.y *= len;
                this.z *= len;
            }
        };
        /**
        * @language en_US
        * Linearly interpolates between two quaternions.
        * @param qa The first quaternion to interpolate.
        * @param qb The second quaternion to interpolate.
        * @param t The interpolation weight, a value between 0 and 1.
        */
        /**
        * @language zh_CN
        * 两个四元数之间的线性插值
        *
        * @param qa 四元数1
        * @param qb 四元数2
        * @param t 插值时刻
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.lerp = function (qa, qb, t) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            var len;
            // shortest direction
            if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            this.w = w1 + t * (w2 - w1);
            this.x = x1 + t * (x2 - x1);
            this.y = y1 + t * (y2 - y1);
            this.z = z1 + t * (z2 - z1);
            len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
            this.w *= len;
            this.x *= len;
            this.y *= len;
            this.z *= len;
        };
        /**
        * @language en_US
        * Fills the quaternion object with values representing the given euler rotation.
        *
        * @param    ax        The angle in radians of the rotation around the ax axis.
        * @param    ay        The angle in radians of the rotation around the ay axis.
        * @param    az        The angle in radians of the rotation around the az axis.
        */
        /**
        * @language zh_CN
        * 用数值表示给定的欧拉旋转填充四元数对象。
        *
        * @param ax x轴旋转角度
        * @param ay y轴旋转角度
        * @param az z轴旋转角度
        * @returns Quaternion 四元数对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.fromEulerAngles = function (ax, ay, az) {
            ax *= egret3d.MathUtil.DEGREES_TO_RADIANS;
            ay *= egret3d.MathUtil.DEGREES_TO_RADIANS;
            az *= egret3d.MathUtil.DEGREES_TO_RADIANS;
            var halfX = ax * 0.5, halfY = ay * 0.5, halfZ = az * 0.5;
            var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
            var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
            var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
            this.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            this.x = sinX * cosY * cosZ - cosX * sinY * sinZ;
            this.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
            this.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
            return this;
        };
        /**
        * @language en_US
        * Fills a target Vector3D object with the Euler angles that form the rotation represented by this quaternion.
        * @param target An optional Vector3D object to contain the Euler angles. If not provided, a new object is created.
        * @returns The Vector3D containing the Euler angles.
        */
        /**
        * @language zh_CN
        * 把四元数转成欧拉角返回
        *
        * @param target 默认参数为null，转成的欧拉返回值，如果为null就新建一个对象返回
        * @retruns Vector3D 转成的欧拉返回值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.toEulerAngles = function (target) {
            if (target === void 0) { target = null; }
            if (target === null) {
                target = new egret3d.Vector3D();
            }
            target.x = Math.atan2(2.0 * (this.w * this.x + this.y * this.z), 1.0 - 2.0 * (this.x * this.x + this.y * this.y));
            var temp = 2.0 * (this.w * this.y - this.z * this.x);
            temp = egret3d.MathUtil.clampf(temp, -1.0, 1.0);
            target.y = Math.asin(temp);
            target.z = Math.atan2(2.0 * (this.w * this.z + this.x * this.y), 1.0 - 2.0 * (this.y * this.y + this.z * this.z));
            target.x /= egret3d.MathUtil.DEGREES_TO_RADIANS;
            target.y /= egret3d.MathUtil.DEGREES_TO_RADIANS;
            target.z /= egret3d.MathUtil.DEGREES_TO_RADIANS;
            return target;
        };
        /**
        * @language en_US
        * Normalises the quaternion object.
        */
        /**
        * @language zh_CN
        * 单位化四元数
        * param val 单位系数，默认为1
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.normalize = function (val) {
            if (val === void 0) { val = 1; }
            var mag = val / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            this.x *= mag;
            this.y *= mag;
            this.z *= mag;
            this.w *= mag;
        };
        /**
        * @language en_US
        * Used to trace the values of a quaternion.
        *
        * @returns A string representation of the quaternion object.
        */
        /**
        * @language zh_CN
        * 以字符串形式返回四元数的值
        * @returns string
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.toString = function () {
            return "{x:" + this.x + " y:" + this.y + " z:" + this.z + " w:" + this.w + "}";
        };
        /**
        * @language en_US
        * Converts the quaternion to a Matrix3D object representing an equivalent rotation.
        * @param target An optional Matrix3D container to store the transformation in. If not provided, a new object is created.
        * @returns A Matrix3D object representing an equivalent rotation.
        */
        /**
        * @language zh_CN
        * 把一个四元数转换成矩阵
        * @param target 返回转换后的矩阵，如果为null就新建一个对象返回
        * @returns  Matrix4_4 返回转换后的矩阵
        * @see egret3d.Matrix4_4
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.toMatrix3D = function (target) {
            if (target === void 0) { target = null; }
            var x = this.x;
            var y = this.y;
            var z = this.z;
            var w = this.w;
            var rawData = egret3d.MathUtil.RAW_DATA_CONTAINER;
            var xy2 = 2.0 * x * y, xz2 = 2.0 * x * z, xw2 = 2.0 * x * w;
            var yz2 = 2.0 * y * z, yw2 = 2.0 * y * w, zw2 = 2.0 * z * w;
            var xx = x * x, yy = y * y, zz = z * z, ww = w * w;
            rawData[0] = xx - yy - zz + ww;
            rawData[4] = xy2 - zw2;
            rawData[8] = xz2 + yw2;
            rawData[12] = 0;
            rawData[1] = xy2 + zw2;
            rawData[5] = -xx + yy - zz + ww;
            rawData[9] = yz2 - xw2;
            rawData[13] = 0;
            rawData[2] = xz2 - yw2;
            rawData[6] = yz2 + xw2;
            rawData[10] = -xx - yy + zz + ww;
            rawData[14] = 0;
            rawData[3] = 0.0;
            rawData[7] = 0.0;
            rawData[11] = 0;
            rawData[15] = 1;
            if (!target)
                return new egret3d.Matrix4_4(new Float32Array(rawData));
            target.copyRawDataFrom(rawData);
            return target;
        };
        /**
        * @language en_US
        * Extracts a quaternion rotation matrix out of a given Matrix3D object.
        * @param matrix The Matrix3D out of which the rotation will be extracted.
        */
        /**
        * @language zh_CN
        * 用一个旋转矩阵生成四元数
        * @param matrix 旋转矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.fromMatrix = function (matrix) {
            var v = matrix.decompose(egret3d.Orientation3D.QUATERNION)[1];
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = v.w;
        };
        /**
        * @language zh_CN
        * 返回一个把当前四元数取逆后的四元数
        * @param target 默认参数为null,如果当前参数为null那么就会new一个新的四元数对象返回
        * @returns Quaternion 四元数
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.inverse = function (target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Quaternion();
            }
            var norm = this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z;
            if (norm > 0.0) {
                var invNorm = 1.0 / norm;
                target.w = this.w * invNorm;
                target.x = -this.x * invNorm;
                target.y = -this.y * invNorm;
                target.z = -this.z * invNorm;
            }
            return target;
        };
        /**
        * @language en_US
        * Clones the quaternion.
        * @returns An exact duplicate of the current Quaternion.
        */
        /**
        * @language zh_CN
        * 克隆一个四元数
        * @returns Quaternion 当前四元数复制后返回新对象.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.clone = function () {
            return new Quaternion(this.x, this.y, this.z, this.w);
        };
        /**
        * @language en_US
        * Rotates a point.
        * @param vector The Vector3D object to be rotated.
        * @param target An optional Vector3D object that will contain the rotated coordinates. If not provided, a new object will be created.
        * @returns A Vector3D object containing the rotated point.
        */
        /**
        * @language zh_CN
        * 旋转一个3量坐标点
        * @param vector 被旋转的对象
        * @param target 默认参数为null，旋转后的坐标对象。如果为null，将创建一个新的对象
        * @returns Vector3D 返回旋转后的坐标对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.transformVector = function (vector, target) {
            if (target === void 0) { target = null; }
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            if (target === null) {
                target = new egret3d.Vector3D();
            }
            // p*q'
            w1 = -this.x * x2 - this.y * y2 - this.z * z2;
            x1 = this.w * x2 + this.y * z2 - this.z * y2;
            y1 = this.w * y2 - this.x * z2 + this.z * x2;
            z1 = this.w * z2 + this.x * y2 - this.y * x2;
            target.x = -w1 * this.x + x1 * this.w - y1 * this.z + z1 * this.y;
            target.y = -w1 * this.y + x1 * this.z + y1 * this.w - z1 * this.x;
            target.z = -w1 * this.z - x1 * this.y + y1 * this.x + z1 * this.w;
            return target;
        };
        /**
        * @language zh_CN
        * 计算出一个方向变换到另一个方向的四元数
        * @param fromDirection 初始方向
        * @param toDirection 变换后的方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.fromToRotation = function (fromDirection, toDirection) {
            var mat = new egret3d.Matrix4_4;
            egret3d.Matrix4_4.fromToRotation(fromDirection, toDirection, mat);
            this.fromMatrix(mat);
        };
        /**
        * @language zh_CN
        * 计算出一个方向变换到另一个方向的四元数
        * @param fromDirection 初始方向
        * @param toDirection 变换后的方向
        * @param target 计算出的四元数 默认为null 结果会返回
        * @returns Quaternion 计算出的四元数 如果 target为null 就会创建新实例返回
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.fromToRotation = function (fromDirection, toDirection, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Quaternion();
            }
            target.fromToRotation(fromDirection, toDirection);
            return target;
        };
        /**
        * @language en_US
        * Copies the data from a quaternion into this instance.
        * @param q The quaternion to copy from.
        */
        /**
        * @language zh_CN
        * 将数据从四元数复制到该实例
        * @param q 被复制的四元数对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.prototype.copyFrom = function (q) {
            var v = this;
            v.x = q.x;
            v.y = q.y;
            v.z = q.z;
            v.w = q.w;
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.HELP_0 = new Quaternion();
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.HELP_1 = new Quaternion();
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quaternion.HELP_2 = new Quaternion();
        return Quaternion;
    }());
    egret3d.Quaternion = Quaternion;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Orientation3D
     * @classdesc
     * 定义 Orientation3D 常量。</p>
     * Matrix4_4.decompose 会分 axisAngle、eulerAngles、quaternion这3种类型进行分解。</p>
     * 比如:</p>
     <pre>
     matrix.decompose(Orientation3D.QUATERNION)
     </pre>
     *
     * @see egret3d.Matrix4_4
     * @see egret3d.Quaternion
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Orientation3D = (function () {
        function Orientation3D() {
        }
        /**
        * @language zh_CN
        * 按轴旋转角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Orientation3D.AXIS_ANGLE = "axisAngle";
        /**
        * @language zh_CN
        * 按欧拉角旋转角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Orientation3D.EULER_ANGLES = "eulerAngles";
        /**
        * @language zh_CN
        * 四元数旋转角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Orientation3D.QUATERNION = "quaternion";
        return Orientation3D;
    }());
    egret3d.Orientation3D = Orientation3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Plane3D
    * @classdesc
    * Plane3D 类 3D空间中的平面表示数据
    * 由a,b,c,d4个分量组成 在三维空间中定义了一个平面 Ax + By + Cz + D = 0
    * @includeExample geom/Plane3D.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Plane3D = (function () {
        /**
         * @language en_US
         * Create a Plane3D with ABCD coefficients
         */
        /**
        * @language zh_CN
        * 创建一个平面实例
        * @param a
        * @param b
        * @param c
        * @param d
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Plane3D(a, b, c, d) {
            if (a === void 0) { a = 0; }
            if (b === void 0) { b = 0; }
            if (c === void 0) { c = 0; }
            if (d === void 0) { d = 0; }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
        }
        /**
        * @language zh_CN
        * 填充平面的各分量的值
        * @param a
        * @param b
        * @param c
        * @param d
        * @version Egret 3.0
        * @platform Web,Native
        */
        Plane3D.prototype.setTo = function (a, b, c, d) {
            if (a === void 0) { a = 0; }
            if (b === void 0) { b = 0; }
            if (c === void 0) { c = 0; }
            if (d === void 0) { d = 0; }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
        };
        /**
         * @language en_US
         * Fills this Plane3D with the coefficients from 3 points in 3d space.
         * @param p0 Vector3D
         * @param p1 Vector3D
         * @param p2 Vector3D
         */
        /**
        * @language zh_CN
        * 由3个坐标来创建一个3d平面
        * @param p0 Vector3D
        * @param p1 Vector3D
        * @param p2 Vector3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Plane3D.prototype.fromPoints = function (p0, p1, p2) {
            var d1x = p1.x - p0.x;
            var d1y = p1.y - p0.y;
            var d1z = p1.z - p0.z;
            var d2x = p2.x - p0.x;
            var d2y = p2.y - p0.y;
            var d2z = p2.z - p0.z;
            this.a = d1y * d2z - d1z * d2y;
            this.b = d1z * d2x - d1x * d2z;
            this.c = d1x * d2y - d1y * d2x;
            this.d = -(this.a * p0.x + this.b * p0.y + this.c * p0.z);
        };
        /**
         * @language en_US
         * Fills this Plane3D with the coefficients from the plane's normal and a point in 3d space.
         * @param normal Vector3D
         * @param point  Vector3D
         */
        /**
        * @language zh_CN
        * 由一条normal向量和一个坐标创建一个3d平面
        * @param normal Vector3D
        * @param point  Vector3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Plane3D.prototype.fromNormalAndPoint = function (normal, point) {
            this.a = normal.x;
            this.b = normal.y;
            this.c = normal.z;
            this.d = -(this.a * point.x + this.b * point.y + this.c * point.z);
        };
        /**
         * @language en_US
         * Normalize this Plane3D
         * @returns Plane3D This Plane3D.
         */
        /**
        * @language zh_CN
        * 单位化3d平面
        * @returns number 返回平面长度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Plane3D.prototype.normalize = function () {
            var len = Math.sqrt(this.a * this.a + this.b * this.b + this.c * this.c);
            if (len > 0.0) {
                var invLength = 1.0 / len;
                this.a *= invLength;
                this.b *= invLength;
                this.c *= invLength;
                this.d *= invLength;
            }
            return len;
        };
        /**
         * @language en_US
         * Returns the signed distance between this Plane3D and the point p.
         * @param p Vector3D
         * @returns Number
         */
        /**
        * @language zh_CN
        * 计算3d平面到点p的距离
        * @param p Vector3D
        * @returns number 返回计算后的距离
        * @version Egret 3.0
        * @platform Web,Native
        */
        Plane3D.prototype.distance = function (p) {
            return this.a * p.x + this.b * p.y + this.c * p.z + this.d;
        };
        /**
         * @language en_US
         * Classify a point against this Plane3D. (in front, back or intersecting)
         * @param p Vector3D
         * @param epsilon
         * @returns PlaneClassification.FRONT在平面正面
         * PlaneClassification.BACK在平面背面面
         * PlaneClassification.INTERSECT在平面上
         */
        /**
        * @language zh_CN
        * 计算3d平面和点p的空间关系
        * @param p Vector3D
        * @param epsilon 相对偏移值
        * @returns number int Plane3.FRONT or Plane3D.BACK or Plane3D.INTERSECT
        * @version Egret 3.0
        * @platform Web,Native
        */
        Plane3D.prototype.classifyPoint = function (p, epsilon) {
            if (epsilon === void 0) { epsilon = 0.01; }
            var dis = this.distance(p);
            if (dis < -epsilon) {
                return egret3d.PlaneClassification.BACK;
            }
            else if (dis > epsilon) {
                return egret3d.PlaneClassification.FRONT;
            }
            return egret3d.PlaneClassification.INTERSECT;
        };
        /**
        * @language zh_CN
        * 当前Plane3D以字符串形式返回
        * @returns string
        * @version Egret 3.0
        * @platform Web,Native
        */
        Plane3D.prototype.toString = function () {
            return "Plane3D [a:" + this.a + ", b:" + this.b + ", c:" + this.c + ", d:" + this.d + "]";
        };
        // indicates the alignment of the plane
        /**
         * @private
         */
        Plane3D.ALIGN_ANY = 0;
        /**
         * @private
         */
        Plane3D.ALIGN_XY_AXIS = 1;
        /**
         * @private
         */
        Plane3D.ALIGN_YZ_AXIS = 2;
        /**
         * @private
         */
        Plane3D.ALIGN_XZ_AXIS = 3;
        return Plane3D;
    }());
    egret3d.Plane3D = Plane3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Matrix4_4
    * @classdesc
    *
    * Matrix4_4 类表示一个转换矩阵，该矩阵确定三维 (3D) 显示对象的位置和方向。
    * 该矩阵可以执行转换功能，包括平移（沿 x、y 和 z 轴重新定位）、旋转和缩放（调整大小）.
    * Matrix4_4 类还可以执行透视投影，这会将 3D 坐标空间中的点映射到二维 (2D) 视图.
    * 单一矩阵可以将多个转换组合在一起，并一次性对 3D 显示对象应用这些转换.
    * 例如，可以将一个矩阵应用于 3D 坐标，以便依次执行旋转和平移.
    *
    * @includeExample geom/Matrix4_4.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Matrix4_4 = (function () {
        /**
        * @language zh_CN
        * 构造
        * @param datas {number[16]}
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Matrix4_4(datas) {
            if (datas === void 0) { datas = null; }
            this.length = 16;
            this.rowLength = 4;
            if (datas) {
                this.rawData = datas;
            }
            else
                this.rawData = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        }
        /**
        * @language zh_CN
        * 生成一个注视目标的矩阵.
        * @param eye 眼睛的位置.
        * @param at 目标的位置.
        * @param up 向上的方向.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.lookAt = function (eye, at, up) {
            if (up === void 0) { up = egret3d.Vector3D.Y_AXIS; }
            var data = this.rawData;
            at.subtract(eye, egret3d.Vector3D.HELP_0);
            var zaxis = egret3d.Vector3D.HELP_0;
            zaxis.normalize();
            var xaxis = up.crossProduct(zaxis, egret3d.Vector3D.HELP_1);
            if (xaxis.length < 0.05) {
                xaxis.x = up.y;
                xaxis.y = up.x;
                if (Math.abs(xaxis.x - xaxis.y) < 0.05) {
                    xaxis.x = -up.z;
                    xaxis.y = up.x;
                    xaxis.z = 0;
                }
                else {
                    xaxis.z = 0;
                }
            }
            xaxis.normalize();
            var yaxis = zaxis.crossProduct(xaxis, egret3d.Vector3D.HELP_2);
            data[0] = xaxis.x;
            data[1] = yaxis.x;
            data[2] = zaxis.x;
            data[3] = 0;
            data[4] = xaxis.y;
            data[5] = yaxis.y;
            data[6] = zaxis.y;
            data[7] = 0;
            data[8] = xaxis.z;
            data[9] = yaxis.z;
            data[10] = zaxis.z;
            data[11] = 0;
            data[12] = -xaxis.dotProduct(eye);
            data[13] = -yaxis.dotProduct(eye);
            data[14] = -zaxis.dotProduct(eye);
            data[15] = 1;
        };
        /**
        * @language zh_CN
        * 矩阵相乘.
        * @param mat4 相乘的矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.multiply = function (mat4) {
            var a = this.rawData, b = mat4.rawData, r = Matrix4_4.helpMatrix;
            r[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
            r[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
            r[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
            r[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];
            r[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
            r[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
            r[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
            r[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];
            r[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
            r[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
            r[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
            r[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];
            r[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
            r[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
            r[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
            r[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
            a[0] = r[0];
            a[1] = r[1];
            a[2] = r[2];
            a[3] = r[3];
            a[4] = r[4];
            a[5] = r[5];
            a[6] = r[6];
            a[7] = r[7];
            a[8] = r[8];
            a[9] = r[9];
            a[10] = r[10];
            a[11] = r[11];
            a[12] = r[12];
            a[13] = r[13];
            a[14] = r[14];
            a[15] = r[15];
        };
        /**
        * @private
        * @language zh_CN
        */
        Matrix4_4.prototype.perspectiveB = function (fov, aspect, near, far) {
            var y = Math.tan(fov * Math.PI / 360) * near;
            var x = y * aspect;
            return this.frustum(-x, x, -y, y, near, far);
        };
        /**
        * @private
        * @language zh_CN
        */
        Matrix4_4.prototype.frustum = function (l, r, b, t, n, f) {
            var m = this.rawData;
            m[0] = 2 * n / (r - l);
            m[1] = 0;
            m[2] = (r + l) / (r - l);
            m[3] = 0;
            m[4] = 0;
            m[5] = 2 * n / (t - b);
            m[6] = (t + b) / (t - b);
            m[7] = 0;
            m[8] = 0;
            m[9] = 0;
            m[10] = -(f + n) / (f - n);
            m[11] = -2 * f * n / (f - n);
            m[12] = 0;
            m[13] = 0;
            m[14] = -1;
            m[15] = 0;
            return this;
        };
        //public ortho(l: number, r: number, b: number, t: number, n: number, f: number): Matrix4_4 {
        //    var m = data;
        //    m[0] = 2 / (r - l);
        //    m[1] = 0;
        //    m[2] = 0;
        //    m[3] = -(r + l) / (r - l);
        //    m[4] = 0;
        //    m[5] = 2 / (t - b);
        //    m[6] = 0;
        //    m[7] = -(t + b) / (t - b);
        //    m[8] = 0;
        //    m[9] = 0;
        //    m[10] = -2 / (f - n);
        //    m[11] = -(f + n) / (f - n);
        //    m[12] = 0;
        //    m[13] = 0;
        //    m[14] = 0;
        //    m[15] = 1;
        //    return this;
        //}
        /**
        * @language zh_CN
        * 生成一个透视投影矩阵.
        * @param fovy 观察时y 轴方向的角度，就是观察范围夹角。
        * @param aspect 横纵比，在视空间宽度除以高度.
        * @param zn 近裁剪面位置Z值.
        * @param zf 远裁剪面位置Z值.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.perspective = function (fovy, aspect, zn, zf) {
            var data = this.rawData;
            var angle = fovy * (Math.PI / 180.0);
            var yScale = Math.tan((Math.PI - angle) / 2.0);
            var xScale = yScale / aspect;
            data[0] = xScale;
            data[1] = 0;
            data[2] = 0;
            data[3] = 0;
            data[4] = 0;
            data[5] = yScale;
            data[6] = 0;
            data[7] = 0;
            data[8] = 0;
            data[9] = 0;
            data[10] = zf / (zf - zn);
            data[11] = 1;
            data[12] = 0;
            data[13] = 0;
            data[14] = -zn * zf / (zf - zn);
            data[15] = 0;
        };
        /**
        * @language zh_CN
        * 生成一个透视投影矩阵.
        * @param w 屏幕的宽度。
        * @param h 屏幕的高度.
        * @param zn 近裁剪面位置Z值.
        * @param zf 远裁剪面位置Z值.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.ortho = function (w, h, zn, zf) {
            var data = this.rawData;
            data[0] = 2 / w;
            data[1] = 0;
            data[2] = 0;
            data[3] = 0;
            data[4] = 0;
            data[5] = 2 / h;
            data[6] = 0;
            data[7] = 0;
            data[8] = 0;
            data[9] = 0;
            data[10] = 1 / (zf - zn);
            data[11] = 0;
            data[12] = 0;
            data[13] = 0;
            data[14] = zn / (zn - zf);
            data[15] = 1;
        };
        /**
        * @language zh_CN
        * 生成一个透视投影矩阵.
        * @param l 观察时X轴最小值.
        * @param r 观察时X轴最大值.
        * @param b 观察时Y轴最小值。
        * @param t 观察时Y轴最大值.
        * @param zn 近裁剪面位置Z值.
        * @param zf 远裁剪面位置Z值.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.orthoOffCenter = function (l, r, b, t, zn, zf) {
            var data = this.rawData;
            data[0] = 2 / (r - l);
            data[1] = 0;
            data[2] = 0;
            data[3] = 0;
            data[4] = 0;
            data[5] = 2 / (t - b);
            data[6] = 0;
            data[7] = 0;
            data[8] = 0;
            data[9] = 0;
            data[10] = 1.0 / (zf - zn);
            data[11] = 0;
            data[12] = (l + r) / (l - r);
            data[13] = (t + b) / (b - t);
            data[14] = zn / (zn - zf);
            data[15] = 1;
        };
        /**
        * @language zh_CN
        * 计算出一个方向变换到另一个方向的旋转矩阵
        * @param fromDirection 初始方向
        * @param toDirection 变换后的方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.fromToRotation = function (fromDirection, toDirection) {
            var data = this.rawData;
            var EPSILON = 0.000001;
            var v = egret3d.Vector3D.HELP_0;
            toDirection.crossProduct(fromDirection, v);
            var e = toDirection.dotProduct(fromDirection);
            if (e > 1.0 - EPSILON) {
                this.identity();
            }
            else if (3 < -1.0 + EPSILON) {
                var up = egret3d.Vector3D.HELP_1;
                var left = egret3d.Vector3D.HELP_2;
                var invlen = 0;
                var fxx = void 0, fyy = void 0, fzz = void 0, fxy = void 0, fxz = void 0, fyz = void 0;
                var uxx = void 0, uyy = void 0, uzz = void 0, uxy = void 0, uxz = void 0, uyz = void 0;
                var lxx = void 0, lyy = void 0, lzz = void 0, lxy = void 0, lxz = void 0, lyz = void 0;
                left.x = 0.0;
                left.y = fromDirection.z;
                left.z = -fromDirection.y;
                if (left.dotProduct(left) < EPSILON) {
                    left.x = -fromDirection.z;
                    left.y = 0.0;
                    left.z = fromDirection.x;
                }
                /* normalize "left" */
                invlen = 1.0 / Math.sqrt(left.dotProduct(left));
                left[0] *= invlen;
                left[1] *= invlen;
                left[2] *= invlen;
                left.crossProduct(fromDirection, up);
                fxx = -fromDirection.x * fromDirection.x;
                fyy = -fromDirection.y * fromDirection.y;
                fzz = -fromDirection.z * fromDirection.z;
                fxy = -fromDirection.x * fromDirection.y;
                fxz = -fromDirection.x * fromDirection.z;
                fyz = -fromDirection.y * fromDirection.z;
                uxx = up.x * up.x;
                uyy = up.y * up.y;
                uzz = up.z * up.z;
                uxy = up.x * up.y;
                uxz = up.x * up.z;
                uyz = up.y * up.z;
                lxx = -left.x * left.x;
                lyy = -left.y * left.y;
                lzz = -left.z * left.z;
                lxy = -left.x * left.y;
                lxz = -left.x * left.z;
                lyz = -left.y * left.z;
                data[0] = fxx + uxx + lxx;
                data[1] = fxy + uxy + lxy;
                data[2] = fxz + uxz + lxz;
                data[4] = data[1];
                data[5] = fyy + uyy + lyy;
                data[6] = fyz + uyz + lyz;
                data[8] = data[2];
                data[9] = data[6];
                data[10] = fzz + uzz + lzz;
                data[3] = 0;
                data[7] = 0;
                data[11] = 0;
                data[15] = 1;
            }
            else {
                var hvx = void 0, hvz = void 0, hvxy = void 0, hvxz = void 0, hvyz = void 0;
                var h = (1.0 - e) / v.dotProduct(v);
                hvx = h * v.x;
                hvz = h * v.z;
                hvxy = hvx * v.y;
                hvxz = hvx * v.z;
                hvyz = hvz * v.y;
                data[0] = e + hvx * v.x;
                data[1] = hvxy - v.z;
                data[2] = hvxz + v.y;
                data[4] = hvxy + v.z;
                data[5] = e + h * v.y * v.y;
                data[6] = hvyz - v.x;
                data[8] = hvxz - v.y;
                data[9] = hvyz + v.x;
                data[10] = e + hvz * v.z;
                data[3] = 0;
                data[7] = 0;
                data[11] = 0;
                data[15] = 1;
            }
        };
        /**
        * @language zh_CN
        * 计算出一个方向变换到另一个方向的旋转矩阵
        * @param fromDirection 初始方向
        * @param toDirection 变换后的方向
        * @param target 计算出的旋转矩阵 默认为null 结果会返回
        * @returns Matrix4_4 计算出的旋转矩阵 如果 target为null 就会创建新实例返回
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.fromToRotation = function (fromDirection, toDirection, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Matrix4_4();
            }
            target.fromToRotation(fromDirection, toDirection);
            return target;
        };
        /**
        * @language zh_CN
        * 通过将当前 Matrix4_4 对象与另一个 Matrix4_4 对象相乘来前置一个矩阵
        * @param lhs 目标矩阵.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.append = function (lhs) {
            var data = this.rawData;
            var m111 = data[0], m121 = data[4], m131 = data[8], m141 = data[12], m112 = data[1], m122 = data[5], m132 = data[9], m142 = data[13], m113 = data[2], m123 = data[6], m133 = data[10], m143 = data[14], m114 = data[3], m124 = data[7], m134 = data[11], m144 = data[15];
            data[0] = m111 * lhs.rawData[0] + m112 * lhs.rawData[4] + m113 * lhs.rawData[8] + m114 * lhs.rawData[12];
            data[1] = m111 * lhs.rawData[1] + m112 * lhs.rawData[5] + m113 * lhs.rawData[9] + m114 * lhs.rawData[13];
            data[2] = m111 * lhs.rawData[2] + m112 * lhs.rawData[6] + m113 * lhs.rawData[10] + m114 * lhs.rawData[14];
            data[3] = m111 * lhs.rawData[3] + m112 * lhs.rawData[7] + m113 * lhs.rawData[11] + m114 * lhs.rawData[15];
            data[4] = m121 * lhs.rawData[0] + m122 * lhs.rawData[4] + m123 * lhs.rawData[8] + m124 * lhs.rawData[12];
            data[5] = m121 * lhs.rawData[1] + m122 * lhs.rawData[5] + m123 * lhs.rawData[9] + m124 * lhs.rawData[13];
            data[6] = m121 * lhs.rawData[2] + m122 * lhs.rawData[6] + m123 * lhs.rawData[10] + m124 * lhs.rawData[14];
            data[7] = m121 * lhs.rawData[3] + m122 * lhs.rawData[7] + m123 * lhs.rawData[11] + m124 * lhs.rawData[15];
            data[8] = m131 * lhs.rawData[0] + m132 * lhs.rawData[4] + m133 * lhs.rawData[8] + m134 * lhs.rawData[12];
            data[9] = m131 * lhs.rawData[1] + m132 * lhs.rawData[5] + m133 * lhs.rawData[9] + m134 * lhs.rawData[13];
            data[10] = m131 * lhs.rawData[2] + m132 * lhs.rawData[6] + m133 * lhs.rawData[10] + m134 * lhs.rawData[14];
            data[11] = m131 * lhs.rawData[3] + m132 * lhs.rawData[7] + m133 * lhs.rawData[11] + m134 * lhs.rawData[15];
            data[12] = m141 * lhs.rawData[0] + m142 * lhs.rawData[4] + m143 * lhs.rawData[8] + m144 * lhs.rawData[12];
            data[13] = m141 * lhs.rawData[1] + m142 * lhs.rawData[5] + m143 * lhs.rawData[9] + m144 * lhs.rawData[13];
            data[14] = m141 * lhs.rawData[2] + m142 * lhs.rawData[6] + m143 * lhs.rawData[10] + m144 * lhs.rawData[14];
            data[15] = m141 * lhs.rawData[3] + m142 * lhs.rawData[7] + m143 * lhs.rawData[11] + m144 * lhs.rawData[15];
        };
        /**
        * @language zh_CN
        * 矩阵相加.
        * @param lhs 目标矩阵.
        * @returns Matrix4_4 相加后的结果.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.add = function (lhs) {
            var data = this.rawData;
            var m111 = data[0], m121 = data[4], m131 = data[8], m141 = data[12], m112 = data[1], m122 = data[5], m132 = data[9], m142 = data[13], m113 = data[2], m123 = data[6], m133 = data[10], m143 = data[14], m114 = data[3], m124 = data[7], m134 = data[11], m144 = data[15], m211 = lhs.rawData[0], m221 = lhs.rawData[4], m231 = lhs.rawData[8], m241 = lhs.rawData[12], m212 = lhs.rawData[1], m222 = lhs.rawData[5], m232 = lhs.rawData[9], m242 = lhs.rawData[13], m213 = lhs.rawData[2], m223 = lhs.rawData[6], m233 = lhs.rawData[10], m243 = lhs.rawData[14], m214 = lhs.rawData[3], m224 = lhs.rawData[7], m234 = lhs.rawData[11], m244 = lhs.rawData[15];
            data[0] = m111 + m211;
            data[1] = m112 + m212;
            data[2] = m113 + m213;
            data[3] = m114 + m214;
            data[4] = m121 + m221;
            data[5] = m122 + m222;
            data[6] = m123 + m223;
            data[7] = m124 + m224;
            data[8] = m131 + m231;
            data[9] = m132 + m232;
            data[10] = m133 + m233;
            data[11] = m134 + m234;
            data[12] = m141 + m241;
            data[13] = m142 + m242;
            data[14] = m143 + m243;
            data[15] = m144 + m244;
            return this;
        };
        /**
        * @language zh_CN
        * 矩阵相减.
        * @param lhs 目标矩阵.
        * @returns Matrix4_4 相加减的结果.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.sub = function (lhs) {
            var data = this.rawData;
            var m111 = data[0], m121 = data[4], m131 = data[8], m141 = data[12], m112 = data[1], m122 = data[5], m132 = data[9], m142 = data[13], m113 = data[2], m123 = data[6], m133 = data[10], m143 = data[14], m114 = data[3], m124 = data[7], m134 = data[11], m144 = data[15], m211 = lhs.rawData[0], m221 = lhs.rawData[4], m231 = lhs.rawData[8], m241 = lhs.rawData[12], m212 = lhs.rawData[1], m222 = lhs.rawData[5], m232 = lhs.rawData[9], m242 = lhs.rawData[13], m213 = lhs.rawData[2], m223 = lhs.rawData[6], m233 = lhs.rawData[10], m243 = lhs.rawData[14], m214 = lhs.rawData[3], m224 = lhs.rawData[7], m234 = lhs.rawData[11], m244 = lhs.rawData[15];
            data[0] = m111 - m211;
            data[1] = m112 - m212;
            data[2] = m113 - m213;
            data[3] = m114 - m214;
            data[4] = m121 - m221;
            data[5] = m122 - m222;
            data[6] = m123 - m223;
            data[7] = m124 - m224;
            data[8] = m131 - m231;
            data[9] = m132 - m232;
            data[10] = m133 - m233;
            data[11] = m134 - m234;
            data[12] = m141 - m241;
            data[13] = m142 - m242;
            data[14] = m143 - m243;
            data[15] = m144 - m244;
            return this;
        };
        /**
        * @language zh_CN
        * 矩阵乘分量.
        * @param v 该矩阵会乘以这个值
        * @returns Matrix4_4 返回一个相乘后的结果 矩阵.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.mult = function (v) {
            var data = this.rawData;
            data[0] *= v;
            data[1] *= v;
            data[2] *= v;
            data[3] *= v;
            data[4] *= v;
            data[5] *= v;
            data[6] *= v;
            data[7] *= v;
            data[8] *= v;
            data[9] *= v;
            data[10] *= v;
            data[11] *= v;
            data[12] *= v;
            data[13] *= v;
            data[14] *= v;
            data[15] *= v;
            return this;
        };
        /**
        * @language zh_CN
        * 创建一个欧拉旋转矩阵.
        * @param x 绕x轴旋转角度.
        * @param y 绕y轴旋转角度.
        * @param z 绕z轴旋转角度.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.rotation = function (x, y, z) {
            egret3d.MathUtil.CALCULATION_QUATERNION.fromEulerAngles(x, y, z);
            this.makeTransform(Matrix4_4.position_000, Matrix4_4.scale_111, egret3d.MathUtil.CALCULATION_QUATERNION);
        };
        /**
       * @language zh_CN
       * 给当前矩阵追加一个方向角旋转 (按axis轴旋转degrees角度创建出来的矩阵)
       * @param degrees 旋转角度.
       * @param axis 绕axis轴旋转角度
       * @version Egret 3.0
       * @platform Web,Native
       */
        Matrix4_4.prototype.appendRotation = function (degrees, axis) {
            var m = Matrix4_4.getAxisRotation(axis.x, axis.y, axis.z, degrees);
            this.append(m);
        };
        /**
        * @language zh_CN
        * 根据坐标轴和旋转角，创建矩阵 (按axis轴旋转degrees角度创建出来的矩阵)
        * @param degrees 旋转角度.
        * @param axis 绕axis轴旋转角度.axis需要指定为x/y/z之间的一个轴的朝向
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.createByRotation = function (degrees, axis) {
            var tmp = egret3d.MathUtil.CALCULATION_MATRIX;
            var s, c;
            var angle = degrees * egret3d.MathUtil.DEGREES_TO_RADIANS;
            s = Math.sin(angle);
            c = Math.cos(angle);
            if (axis.x == 1) {
                tmp.rawData[0] = 1.0;
                tmp.rawData[1] = 0.0;
                tmp.rawData[2] = 0.0;
                tmp.rawData[3] = 0.0;
                tmp.rawData[4] = 0.0;
                tmp.rawData[5] = c;
                tmp.rawData[6] = s;
                tmp.rawData[7] = 0.0;
                tmp.rawData[8] = 0.0;
                tmp.rawData[9] = -s;
                tmp.rawData[10] = c;
                tmp.rawData[11] = 0.0;
                tmp.rawData[12] = 0.0;
                tmp.rawData[13] = 0.0;
                tmp.rawData[14] = 0.0;
                tmp.rawData[15] = 1.0;
            }
            if (axis.y == 1) {
                tmp.rawData[0] = c;
                tmp.rawData[1] = 0.0;
                tmp.rawData[2] = -s;
                tmp.rawData[3] = 0.0;
                tmp.rawData[4] = 0.0;
                tmp.rawData[5] = 1.0;
                tmp.rawData[6] = 0.0;
                tmp.rawData[7] = 0.0;
                tmp.rawData[8] = s;
                tmp.rawData[9] = 0.0;
                tmp.rawData[10] = c;
                tmp.rawData[11] = 0.0;
                tmp.rawData[12] = 0.0;
                tmp.rawData[13] = 0.0;
                tmp.rawData[14] = 0.0;
                tmp.rawData[15] = 1.0;
            }
            if (axis.z == 1) {
                tmp.rawData[0] = c;
                tmp.rawData[1] = s;
                tmp.rawData[2] = 0.0;
                tmp.rawData[3] = 0.0;
                tmp.rawData[4] = -s;
                tmp.rawData[5] = c;
                tmp.rawData[6] = 0.0;
                tmp.rawData[7] = 0.0;
                tmp.rawData[8] = 0.0;
                tmp.rawData[9] = 0.0;
                tmp.rawData[10] = 1.0;
                tmp.rawData[11] = 0.0;
                tmp.rawData[12] = 0.0;
                tmp.rawData[13] = 0.0;
                tmp.rawData[14] = 0.0;
                tmp.rawData[15] = 1.0;
            }
            this.append(tmp);
        };
        /**
        * @language zh_CN
        * 追加三轴缩放值
        * @param xScale x轴缩放
        * @param yScale y轴缩放
        * @param zScale z轴缩放
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.appendScale = function (xScale, yScale, zScale) {
            Matrix4_4.helpMatrix.createByScale(xScale, yScale, zScale);
            this.append(Matrix4_4.helpMatrix);
        };
        /**
        * @language zh_CN
        * 生成一个缩放矩阵，其他的属性会被重置
        * @param xScale x轴缩放
        * @param yScale y轴缩放
        * @param zScale z轴缩放
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.createByScale = function (xScale, yScale, zScale) {
            var data = this.rawData;
            data[0] = xScale;
            data[1] = 0.0;
            data[2] = 0.0;
            data[3] = 0.0;
            data[4] = 0.0;
            data[5] = yScale;
            data[6] = 0.0;
            data[7] = 0.0;
            data[8] = 0.0;
            data[9] = 0.0;
            data[10] = zScale;
            data[11] = 0.0;
            data[12] = 0.0;
            data[13] = 0.0;
            data[14] = 0.0;
            data[15] = 1.0;
        };
        /**
        * @language zh_CN
        * 加上一个平移矩阵
        * @param x x轴坐标
        * @param y y轴坐标
        * @param z z轴坐标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.appendTranslation = function (x, y, z) {
            var data = this.rawData;
            data[12] += x;
            data[13] += y;
            data[14] += z;
        };
        /**
        * @language zh_CN
        * 返回一个当前矩阵的克隆矩阵
        * @returns Matrix4_4 克隆后的矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.clone = function () {
            var ret = new Matrix4_4();
            ret.copyFrom(this);
            return ret;
        };
        /**
        * @language zh_CN
        * 给当前矩阵其中一行赋值
        * @param row 拷贝的行
        * @param vector3D 拷贝的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyRowFrom = function (row, vector3D) {
            var data = this.rawData;
            switch (row) {
                case 0:
                    data[0] = vector3D.x;
                    data[1] = vector3D.y;
                    data[2] = vector3D.z;
                    data[3] = vector3D.w;
                    break;
                case 1:
                    data[4] = vector3D.x;
                    data[5] = vector3D.y;
                    data[6] = vector3D.z;
                    data[7] = vector3D.w;
                    break;
                case 2:
                    data[8] = vector3D.x;
                    data[9] = vector3D.y;
                    data[10] = vector3D.z;
                    data[11] = vector3D.w;
                    break;
                case 3:
                    data[12] = vector3D.x;
                    data[13] = vector3D.y;
                    data[14] = vector3D.z;
                    data[15] = vector3D.w;
                    break;
                default:
            }
        };
        /**
        * @language zh_CN
        * 拷贝矩阵中的其中一行 把值存在vector3D.
        * @param row 拷贝的行
        * @param vector3D 拷贝存值目标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyRowTo = function (row, vector3D) {
            var data = this.rawData;
            switch (row) {
                case 0:
                    vector3D.x = data[0];
                    vector3D.y = data[1];
                    vector3D.z = data[2];
                    vector3D.w = data[3];
                    break;
                case 1:
                    vector3D.x = data[4];
                    vector3D.y = data[5];
                    vector3D.z = data[6];
                    vector3D.w = data[7];
                    break;
                case 2:
                    vector3D.x = data[8];
                    vector3D.y = data[9];
                    vector3D.z = data[10];
                    vector3D.w = data[11];
                    break;
                case 3:
                    vector3D.x = data[12];
                    vector3D.y = data[13];
                    vector3D.z = data[14];
                    vector3D.w = data[15];
                    break;
                default:
            }
        };
        /**
        * @language zh_CN
        * 把一个矩阵的值赋给当前矩阵.
        * @param sourceMatrix3D 源矩阵.
        * @returns 返回当前矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyFrom = function (sourceMatrix3D) {
            var data = this.rawData;
            data[0] = sourceMatrix3D.rawData[0];
            data[1] = sourceMatrix3D.rawData[1];
            data[2] = sourceMatrix3D.rawData[2];
            data[3] = sourceMatrix3D.rawData[3];
            data[4] = sourceMatrix3D.rawData[4];
            data[5] = sourceMatrix3D.rawData[5];
            data[6] = sourceMatrix3D.rawData[6];
            data[7] = sourceMatrix3D.rawData[7];
            data[8] = sourceMatrix3D.rawData[8];
            data[9] = sourceMatrix3D.rawData[9];
            data[10] = sourceMatrix3D.rawData[10];
            data[11] = sourceMatrix3D.rawData[11];
            data[12] = sourceMatrix3D.rawData[12];
            data[13] = sourceMatrix3D.rawData[13];
            data[14] = sourceMatrix3D.rawData[14];
            data[15] = sourceMatrix3D.rawData[15];
            return this;
        };
        /**
        * @language zh_CN
        * 把一个 float 数组赋值给当前矩阵.
        * @param vector 源数组.
        * @param index 从数组的index 开始copy.
        * @param transpose 是否转置当前矩阵.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyRawDataFrom = function (vector, index, transpose) {
            if (index === void 0) { index = 0; }
            if (transpose === void 0) { transpose = false; }
            var data = this.rawData;
            data[0] = vector[0 + index];
            data[1] = vector[1 + index];
            data[2] = vector[2 + index];
            data[3] = vector[3 + index];
            data[4] = vector[4 + index];
            data[5] = vector[5 + index];
            data[6] = vector[6 + index];
            data[7] = vector[7 + index];
            data[8] = vector[8 + index];
            data[9] = vector[9 + index];
            data[10] = vector[10 + index];
            data[11] = vector[11 + index];
            data[12] = vector[12 + index];
            data[13] = vector[13 + index];
            data[14] = vector[14 + index];
            data[15] = vector[15 + index];
        };
        /**
        * @language zh_CN
        * 把当前矩阵的值拷贝给一个 float 数组.
        * @param vector 目标数组.
        * @param index 从数组的index 开始copy.
        * @param transpose 是否转置当前矩阵.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyRawDataTo = function (vector, index, transpose) {
            if (index === void 0) { index = 0; }
            if (transpose === void 0) { transpose = false; }
            var data = this.rawData;
            vector[0 + index] = data[0];
            vector[1 + index] = data[1];
            vector[2 + index] = data[2];
            vector[3 + index] = data[3];
            vector[4 + index] = data[4];
            vector[5 + index] = data[5];
            vector[6 + index] = data[6];
            vector[7 + index] = data[7];
            vector[8 + index] = data[8];
            vector[9 + index] = data[9];
            vector[10 + index] = data[10];
            vector[11 + index] = data[11];
            vector[12 + index] = data[12];
            vector[13 + index] = data[13];
            vector[14 + index] = data[14];
            vector[15 + index] = data[15];
        };
        /**
        * @language zh_CN
        * 给当前矩阵的某一列 赋值
        * @param col 列
        * @param vector3D 值来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyColFrom = function (col, vector3D) {
            var data = this.rawData;
            switch (col) {
                case 0:
                    data[0] = vector3D.x;
                    data[4] = vector3D.y;
                    data[8] = vector3D.z;
                    data[12] = vector3D.w;
                    break;
                case 1:
                    data[1] = vector3D.x;
                    data[5] = vector3D.y;
                    data[9] = vector3D.z;
                    data[13] = vector3D.w;
                    break;
                case 2:
                    data[2] = vector3D.x;
                    data[6] = vector3D.y;
                    data[10] = vector3D.z;
                    data[14] = vector3D.w;
                    break;
                case 3:
                    data[3] = vector3D.x;
                    data[7] = vector3D.y;
                    data[11] = vector3D.z;
                    data[15] = vector3D.w;
                    break;
                default:
                    new Error("no more raw!");
            }
        };
        /**
        * @language zh_CN
        * 拷贝当前矩阵的某一列
        * @param col 列
        * @param vector3D 拷贝目标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyColTo = function (col, vector3D) {
            var data = this.rawData;
            switch (col) {
                case 0:
                    vector3D.x = data[0];
                    vector3D.y = data[4];
                    vector3D.z = data[8];
                    vector3D.w = data[12];
                    break;
                case 1:
                    vector3D.x = data[1];
                    vector3D.y = data[5];
                    vector3D.z = data[9];
                    vector3D.w = data[13];
                    break;
                case 2:
                    vector3D.x = data[2];
                    vector3D.y = data[6];
                    vector3D.z = data[10];
                    vector3D.w = data[14];
                    break;
                case 3:
                    vector3D.x = data[3];
                    vector3D.y = data[7];
                    vector3D.z = data[11];
                    vector3D.w = data[15];
                    break;
                default:
                    new Error("no more raw!");
            }
        };
        /**
        * @language zh_CN
        * 拷贝当前矩阵
        * @param dest 拷贝目标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.copyToMatrix3D = function (dest) {
            dest.rawData = this.rawData.slice(0);
        };
        /**
        * @language zh_CN
        * 分解当前矩阵
        * @param orientationStyle 分解类型 默认为 Orientation3D.EULER_ANGLES
        * @see egret3d.Orientation3D.AXIS_ANGLE
        * @see egret3d.Orientation3D.EULER_ANGLES
        * @see egret3d.Orientation3D.QUATERNION
        * @returns Vector3D[3] pos rot scale
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.decompose = function (orientationStyle, target) {
            if (orientationStyle === void 0) { orientationStyle = "eulerAngles"; }
            if (target === void 0) { target = null; }
            var q = egret3d.MathUtil.CALCULATION_QUATERNION;
            var vec = target ? target : Matrix4_4.prs;
            this.copyRawDataTo(Matrix4_4.helpMatrix.rawData);
            var mr = Matrix4_4.helpMatrix.rawData;
            var pos = vec[0];
            pos.x = mr[12];
            pos.y = mr[13];
            pos.z = mr[14];
            mr[12] = 0;
            mr[13] = 0;
            mr[14] = 0;
            var scale = vec[2];
            scale.x = Math.sqrt(mr[0] * mr[0] + mr[1] * mr[1] + mr[2] * mr[2]);
            scale.y = Math.sqrt(mr[4] * mr[4] + mr[5] * mr[5] + mr[6] * mr[6]);
            scale.z = Math.sqrt(mr[8] * mr[8] + mr[9] * mr[9] + mr[10] * mr[10]);
            if (mr[0] * (mr[5] * mr[10] - mr[6] * mr[9]) - mr[1] * (mr[4] * mr[10] - mr[6] * mr[8]) + mr[2] * (mr[4] * mr[9] - mr[5] * mr[8]) < 0)
                scale.z = -scale.z;
            mr[0] /= scale.x;
            mr[1] /= scale.x;
            mr[2] /= scale.x;
            mr[4] /= scale.y;
            mr[5] /= scale.y;
            mr[6] /= scale.y;
            mr[8] /= scale.z;
            mr[9] /= scale.z;
            mr[10] /= scale.z;
            var rot = vec[1];
            switch (orientationStyle) {
                case egret3d.Orientation3D.AXIS_ANGLE:
                    rot.w = Math.acos((mr[0] + mr[5] + mr[10] - 1) / 2);
                    var len = Math.sqrt((mr[6] - mr[9]) * (mr[6] - mr[9]) + (mr[8] - mr[2]) * (mr[8] - mr[2]) + (mr[1] - mr[4]) * (mr[1] - mr[4]));
                    rot.x = (mr[6] - mr[9]) / len;
                    rot.y = (mr[8] - mr[2]) / len;
                    rot.z = (mr[1] - mr[4]) / len;
                    break;
                case egret3d.Orientation3D.QUATERNION:
                    var tr = mr[0] + mr[5] + mr[10];
                    if (tr > 0) {
                        rot.w = Math.sqrt(1 + tr) / 2;
                        rot.x = (mr[6] - mr[9]) / (4 * rot.w);
                        rot.y = (mr[8] - mr[2]) / (4 * rot.w);
                        rot.z = (mr[1] - mr[4]) / (4 * rot.w);
                    }
                    else if ((mr[0] > mr[5]) && (mr[0] > mr[10])) {
                        rot.x = Math.sqrt(1 + mr[0] - mr[5] - mr[10]) / 2;
                        rot.w = (mr[6] - mr[9]) / (4 * rot.x);
                        rot.y = (mr[1] + mr[4]) / (4 * rot.x);
                        rot.z = (mr[8] + mr[2]) / (4 * rot.x);
                    }
                    else if (mr[5] > mr[10]) {
                        rot.y = Math.sqrt(1 + mr[5] - mr[0] - mr[10]) / 2;
                        rot.x = (mr[1] + mr[4]) / (4 * rot.y);
                        rot.w = (mr[8] - mr[2]) / (4 * rot.y);
                        rot.z = (mr[6] + mr[9]) / (4 * rot.y);
                    }
                    else {
                        rot.z = Math.sqrt(1 + mr[10] - mr[0] - mr[5]) / 2;
                        rot.x = (mr[8] + mr[2]) / (4 * rot.z);
                        rot.y = (mr[6] + mr[9]) / (4 * rot.z);
                        rot.w = (mr[1] - mr[4]) / (4 * rot.z);
                    }
                    break;
                case egret3d.Orientation3D.EULER_ANGLES:
                    var tr = mr[0] + mr[5] + mr[10];
                    if (tr > 0) {
                        q.w = Math.sqrt(1 + tr) / 2;
                        q.x = (mr[6] - mr[9]) / (4 * q.w);
                        q.y = (mr[8] - mr[2]) / (4 * q.w);
                        q.z = (mr[1] - mr[4]) / (4 * q.w);
                    }
                    else if ((mr[0] > mr[5]) && (mr[0] > mr[10])) {
                        q.x = Math.sqrt(1 + mr[0] - mr[5] - mr[10]) / 2;
                        q.w = (mr[6] - mr[9]) / (4 * q.x);
                        q.y = (mr[1] + mr[4]) / (4 * q.x);
                        q.z = (mr[8] + mr[2]) / (4 * q.x);
                    }
                    else if (mr[5] > mr[10]) {
                        rot.y = Math.sqrt(1 + mr[5] - mr[0] - mr[10]) / 2;
                        q.x = (mr[1] + mr[4]) / (4 * q.y);
                        q.w = (mr[8] - mr[2]) / (4 * q.y);
                        q.z = (mr[6] + mr[9]) / (4 * q.y);
                    }
                    else {
                        q.z = Math.sqrt(1 + mr[10] - mr[0] - mr[5]) / 2;
                        q.x = (mr[8] + mr[2]) / (4 * q.z);
                        q.y = (mr[6] + mr[9]) / (4 * q.z);
                        q.w = (mr[1] - mr[4]) / (4 * q.z);
                    }
                    q.toEulerAngles(rot);
                    break;
            }
            vec[0] = pos;
            vec[1] = rot;
            vec[2] = scale;
            return vec;
        };
        /**
        * @language zh_CN
        * 当前矩阵变换一个向量
        * @param v 要变换的向量
        * @param target 默认为 null 如果当前参数为null那么就会new一个新的Vector3D返回
        * @returns Vector3D 变换后的向量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.deltaTransformVector = function (v, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new egret3d.Vector3D();
            }
            var data = this.rawData;
            var x = v.x;
            var y = v.y;
            var z = v.z;
            target.x = x * data[0] + y * data[4] + z * data[8];
            target.y = x * data[1] + y * data[5] + z * data[9];
            target.z = x * data[2] + y * data[6] + z * data[10];
            target.w = x * data[3] + y * data[7] + z * data[11];
            return target;
        };
        /**
        * @language zh_CN
        * 单位化当前矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.identity = function () {
            var data = this.rawData;
            data[1] = 0;
            data[2] = 0;
            data[3] = 0;
            data[4] = 0;
            data[6] = 0;
            data[7] = 0;
            data[8] = 0;
            data[9] = 0;
            data[11] = 0;
            data[12] = 0;
            data[13] = 0;
            data[14] = 0;
            data[0] = 1;
            data[5] = 1;
            data[10] = 1;
            data[15] = 1;
        };
        /**
        * @language zh_CN
        * 填充当前矩阵
        * @param value 填充的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.fill = function (value) {
            var data = this.rawData;
            data[1] = value;
            data[2] = value;
            data[3] = value;
            data[4] = value;
            data[6] = value;
            data[7] = value;
            data[8] = value;
            data[9] = value;
            data[11] = value;
            data[12] = value;
            data[13] = value;
            data[14] = value;
            data[0] = value;
            data[5] = value;
            data[10] = value;
            data[15] = value;
        };
        /**
        * @language zh_CN
        * 当前矩阵求逆
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.invers33 = function () {
            /// Invert a 3x3 using cofactors.  This is about 8 times faster than
            /// the Numerical Recipes code which uses Gaussian elimination.
            var data = this.rawData;
            var rkInverse_00 = data[5] * data[10] - data[9] * data[6];
            var rkInverse_01 = data[8] * data[6] - data[4] * data[10];
            var rkInverse_02 = data[4] * data[9] - data[8] * data[5];
            var rkInverse_10 = data[9] * data[2] - data[1] * data[10];
            var rkInverse_11 = data[0] * data[10] - data[8] * data[2];
            var rkInverse_12 = data[8] * data[1] - data[0] * data[9];
            var rkInverse_20 = data[1] * data[6] - data[5] * data[2];
            var rkInverse_21 = data[4] * data[2] - data[0] * data[6];
            var rkInverse_22 = data[0] * data[5] - data[4] * data[1];
            var fDet = data[0] * rkInverse_00 +
                data[4] * rkInverse_10 +
                data[8] * rkInverse_20;
            if (Math.abs(fDet) > 0.00000000001) {
                var fInvDet = 1.0 / fDet;
                data[0] = fInvDet * rkInverse_00;
                data[4] = fInvDet * rkInverse_01;
                data[8] = fInvDet * rkInverse_02;
                data[1] = fInvDet * rkInverse_10;
                data[5] = fInvDet * rkInverse_11;
                data[9] = fInvDet * rkInverse_12;
                data[2] = fInvDet * rkInverse_20;
                data[6] = fInvDet * rkInverse_21;
                data[10] = fInvDet * rkInverse_22;
            }
        };
        /**
        * private
        */
        Matrix4_4.transpose = function (matrix, result) {
            result = result || new Matrix4_4();
            var m = matrix.rawData, r = result.rawData;
            r[0] = m[0];
            r[1] = m[4];
            r[2] = m[8];
            r[3] = m[12];
            r[4] = m[1];
            r[5] = m[5];
            r[6] = m[9];
            r[7] = m[13];
            r[8] = m[2];
            r[9] = m[6];
            r[10] = m[10];
            r[11] = m[14];
            r[12] = m[3];
            r[13] = m[7];
            r[14] = m[11];
            r[15] = m[15];
            return result;
        };
        ;
        /**
        * private
        */
        Matrix4_4.inverse = function (matrix, result) {
            result = result || new Matrix4_4();
            var m = matrix.rawData, r = result.rawData;
            r[0] = m[5] * m[10] * m[15] - m[5] * m[14] * m[11] - m[6] * m[9] * m[15] + m[6] * m[13] * m[11] + m[7] * m[9] * m[14] - m[7] * m[13] * m[10];
            r[1] = -m[1] * m[10] * m[15] + m[1] * m[14] * m[11] + m[2] * m[9] * m[15] - m[2] * m[13] * m[11] - m[3] * m[9] * m[14] + m[3] * m[13] * m[10];
            r[2] = m[1] * m[6] * m[15] - m[1] * m[14] * m[7] - m[2] * m[5] * m[15] + m[2] * m[13] * m[7] + m[3] * m[5] * m[14] - m[3] * m[13] * m[6];
            r[3] = -m[1] * m[6] * m[11] + m[1] * m[10] * m[7] + m[2] * m[5] * m[11] - m[2] * m[9] * m[7] - m[3] * m[5] * m[10] + m[3] * m[9] * m[6];
            r[4] = -m[4] * m[10] * m[15] + m[4] * m[14] * m[11] + m[6] * m[8] * m[15] - m[6] * m[12] * m[11] - m[7] * m[8] * m[14] + m[7] * m[12] * m[10];
            r[5] = m[0] * m[10] * m[15] - m[0] * m[14] * m[11] - m[2] * m[8] * m[15] + m[2] * m[12] * m[11] + m[3] * m[8] * m[14] - m[3] * m[12] * m[10];
            r[6] = -m[0] * m[6] * m[15] + m[0] * m[14] * m[7] + m[2] * m[4] * m[15] - m[2] * m[12] * m[7] - m[3] * m[4] * m[14] + m[3] * m[12] * m[6];
            r[7] = m[0] * m[6] * m[11] - m[0] * m[10] * m[7] - m[2] * m[4] * m[11] + m[2] * m[8] * m[7] + m[3] * m[4] * m[10] - m[3] * m[8] * m[6];
            r[8] = m[4] * m[9] * m[15] - m[4] * m[13] * m[11] - m[5] * m[8] * m[15] + m[5] * m[12] * m[11] + m[7] * m[8] * m[13] - m[7] * m[12] * m[9];
            r[9] = -m[0] * m[9] * m[15] + m[0] * m[13] * m[11] + m[1] * m[8] * m[15] - m[1] * m[12] * m[11] - m[3] * m[8] * m[13] + m[3] * m[12] * m[9];
            r[10] = m[0] * m[5] * m[15] - m[0] * m[13] * m[7] - m[1] * m[4] * m[15] + m[1] * m[12] * m[7] + m[3] * m[4] * m[13] - m[3] * m[12] * m[5];
            r[11] = -m[0] * m[5] * m[11] + m[0] * m[9] * m[7] + m[1] * m[4] * m[11] - m[1] * m[8] * m[7] - m[3] * m[4] * m[9] + m[3] * m[8] * m[5];
            r[12] = -m[4] * m[9] * m[14] + m[4] * m[13] * m[10] + m[5] * m[8] * m[14] - m[5] * m[12] * m[10] - m[6] * m[8] * m[13] + m[6] * m[12] * m[9];
            r[13] = m[0] * m[9] * m[14] - m[0] * m[13] * m[10] - m[1] * m[8] * m[14] + m[1] * m[12] * m[10] + m[2] * m[8] * m[13] - m[2] * m[12] * m[9];
            r[14] = -m[0] * m[5] * m[14] + m[0] * m[13] * m[6] + m[1] * m[4] * m[14] - m[1] * m[12] * m[6] - m[2] * m[4] * m[13] + m[2] * m[12] * m[5];
            r[15] = m[0] * m[5] * m[10] - m[0] * m[9] * m[6] - m[1] * m[4] * m[10] + m[1] * m[8] * m[6] + m[2] * m[4] * m[9] - m[2] * m[8] * m[5];
            var det = m[0] * r[0] + m[1] * r[4] + m[2] * r[8] + m[3] * r[12];
            for (var i = 0; i < 16; i++)
                r[i] /= det;
            return result;
        };
        ;
        /**
        * @language zh_CN
        * 当前矩阵求逆
        * @returns boolean 是否能求逆
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.invert = function () {
            var d = this.determinant;
            var invertable = Math.abs(d) > 0.00000000001;
            var data = this.rawData;
            if (invertable) {
                d = 1 / d;
                var m11 = data[0];
                var m21 = data[4];
                var m31 = data[8];
                var m41 = data[12];
                var m12 = data[1];
                var m22 = data[5];
                var m32 = data[9];
                var m42 = data[13];
                var m13 = data[2];
                var m23 = data[6];
                var m33 = data[10];
                var m43 = data[14];
                var m14 = data[3];
                var m24 = data[7];
                var m34 = data[11];
                var m44 = data[15];
                data[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
                data[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
                data[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
                data[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
                data[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
                data[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
                data[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
                data[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
                data[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
                data[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
                data[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
                data[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
                data[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
                data[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
                data[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
                data[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
            }
            return invertable;
        };
        /**
        * @language zh_CN
        * 生成一个变换矩阵
        * @param pos  位移
        * @param scale 缩放
        * @param rot 旋转的四元素
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.makeTransform = function (pos, scale, rot) {
            //let data: Float32Array = this.rawData;
            //data[0] = scale.x;
            //data[5] = scale.y;
            //data[10] = scale.z;
            //rot.toMatrix3D(Matrix4_4.helpMatrix);
            //this.append(Matrix4_4.helpMatrix);
            //data[12] = pos.x;
            //data[13] = pos.y;
            //data[14] = pos.z;
            //data[15] = 1.0;
            this.createByScale(scale.x, scale.y, scale.z);
            rot.toMatrix3D(egret3d.MathUtil.CALCULATION_MATRIX);
            this.append(egret3d.MathUtil.CALCULATION_MATRIX);
            this.rawData[12] = pos.x;
            this.rawData[13] = pos.y;
            this.rawData[14] = pos.z;
            this.rawData[15] = 1;
        };
        /**
        * @language zh_CN
        * 生成一个变换矩阵
        * @param components Vector3D[3] 位移 旋转 缩放
        * @returns boolean 生成是否成功
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.recompose = function (components) {
            egret3d.MathUtil.CALCULATION_QUATERNION.fromEulerAngles(components[1].x, components[1].y, components[1].z);
            this.makeTransform(components[0], components[2], egret3d.MathUtil.CALCULATION_QUATERNION);
            return true;
        };
        /**
        * @language zh_CN
        * 用当前矩阵变换一个3D向量
        * @param v 变换的向量
        * @param target 如果当前参数为null那么就会new一个新的Vector3D返回
        * @returns Vector3D 变换后的向量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.transformVector = function (v, target) {
            if (target === void 0) { target = null; }
            var data = this.rawData;
            if (!target) {
                target = new egret3d.Vector3D();
            }
            var x = v.x;
            var y = v.y;
            var z = v.z;
            target.x = x * data[0] + y * data[4] + z * data[8] + data[12];
            target.y = x * data[1] + y * data[5] + z * data[9] + data[13];
            target.z = x * data[2] + y * data[6] + z * data[10] + data[14];
            target.w = x * data[3] + y * data[7] + z * data[11] + data[15];
            return target;
        };
        /**
        * @language zh_CN
        * 用当前矩阵变换一个3D向量
        * @param v 变换的向量  w 会进行计算
        * @param target 如果当前参数为null那么就会new一个新的Vector3D返回
        * @returns Vector3D 变换后的向量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.transformVector4 = function (v, target) {
            if (target === void 0) { target = null; }
            var data = this.rawData;
            if (!target) {
                target = new egret3d.Vector3D();
            }
            var x = v.x;
            var y = v.y;
            var z = v.z;
            var w = v.w;
            target.x = x * data[0] + y * data[4] + z * data[8] + w * data[12];
            target.y = x * data[1] + y * data[5] + z * data[9] + w * data[13];
            target.z = x * data[2] + y * data[6] + z * data[10] + w * data[14];
            target.w = x * data[3] + y * data[7] + z * data[11] + w * data[15];
            return target;
        };
        /**
        * @language zh_CN
        * 用当前矩阵变换一个3D向量 不处理位移
        * @param v 变换的向量
        * @param target 如果当前参数为null那么就会new一个新的Vector3D返回
        * @returns Vector3D 变换后的向量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.mat3TransformVector = function (v, target) {
            if (target === void 0) { target = null; }
            var data = this.rawData;
            if (!target) {
                target = new egret3d.Vector3D();
            }
            var x = v.x;
            var y = v.y;
            var z = v.z;
            target.x = x * data[0] + y * data[4] + z * data[8];
            target.y = x * data[1] + y * data[5] + z * data[9];
            target.z = x * data[2] + y * data[6] + z * data[10];
            return target;
        };
        /**
        * @language zh_CN
        * 用当前矩阵变换一个3D平面
        * @param plane 变换的平面
        * @returns Plane3D 变换后的平面
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.transformPlane = function (plane) {
            var mat = new Matrix4_4();
            mat.copyFrom(this);
            mat.invert();
            mat.transpose();
            var v = new egret3d.Vector3D(plane.a, plane.b, plane.c, plane.d);
            v.copyFrom(mat.transformVector(v));
            var p = new egret3d.Plane3D();
            p.a = v.x;
            p.b = v.y;
            p.c = v.z;
            p.d = v.w / Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
            return p;
        };
        /**
        * @language zh_CN
        * 当前矩阵转置
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.transpose = function () {
            var data = this.rawData;
            for (var i = 0; i < Matrix4_4.helpMatrix.rawData.length; i++) {
                Matrix4_4.helpMatrix.rawData[i] = data[i];
            }
            data[1] = Matrix4_4.helpMatrix.rawData[4];
            data[2] = Matrix4_4.helpMatrix.rawData[8];
            data[3] = Matrix4_4.helpMatrix.rawData[12];
            data[4] = Matrix4_4.helpMatrix.rawData[1];
            data[6] = Matrix4_4.helpMatrix.rawData[9];
            data[7] = Matrix4_4.helpMatrix.rawData[13];
            data[8] = Matrix4_4.helpMatrix.rawData[2];
            data[9] = Matrix4_4.helpMatrix.rawData[6];
            data[11] = Matrix4_4.helpMatrix.rawData[14];
            data[12] = Matrix4_4.helpMatrix.rawData[3];
            data[13] = Matrix4_4.helpMatrix.rawData[7];
            data[14] = Matrix4_4.helpMatrix.rawData[11];
        };
        /**
        * @language zh_CN
        * 生成一个(以x,y,z为中心轴旋转degrees角度)的矩阵
        * @param x 中心轴的x
        * @param y 中心轴的y
        * @param z 中心轴的z
        * @param degrees 旋转角度
        * @returns Matrix4_4 矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.getAxisRotation = function (x, y, z, degrees) {
            var m = new Matrix4_4();
            var rad = degrees * (Math.PI / 180);
            var c = Math.cos(rad);
            var s = Math.sin(rad);
            var t = 1 - c;
            var tmp1, tmp2;
            m.rawData[0] = c + x * x * t;
            m.rawData[5] = c + y * y * t;
            m.rawData[10] = c + z * z * t;
            tmp1 = x * y * t;
            tmp2 = z * s;
            m.rawData[1] = tmp1 + tmp2;
            m.rawData[4] = tmp1 - tmp2;
            tmp1 = x * z * t;
            tmp2 = y * s;
            m.rawData[8] = tmp1 + tmp2;
            m.rawData[2] = tmp1 - tmp2;
            tmp1 = y * z * t;
            tmp2 = x * s;
            m.rawData[9] = tmp1 - tmp2;
            m.rawData[6] = tmp1 + tmp2;
            return m;
        };
        Object.defineProperty(Matrix4_4.prototype, "determinant", {
            /**
            * @language zh_CN
            * 返回矩阵行列式
            * @returns number 行列式值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                var data = this.rawData;
                return ((data[0] * data[5] - data[4] * data[1]) * (data[10] * data[15] - data[14] * data[11]) - (data[0] * data[9] - data[8] * data[1]) * (data[6] * data[15] - data[14] * data[7]) + (data[0] * data[13] - data[12] * data[1]) * (data[6] * data[11] - data[10] * data[7]) + (data[4] * data[9] - data[8] * data[5]) * (data[2] * data[15] - data[14] * data[3]) - (data[4] * data[13] - data[12] * data[5]) * (data[2] * data[11] - data[10] * data[3]) + (data[8] * data[13] - data[12] * data[9]) * (data[2] * data[7] - data[6] * data[3]));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4_4.prototype, "position", {
            /**
            * @language zh_CN
            * 返回矩阵位移
            *
            * @returns Vector3D 位移
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                var data = this.rawData;
                return new egret3d.Vector3D(data[12], data[13], data[14]);
            },
            /**
            * @language zh_CN
            * 设置矩阵位移
            *
            * @param value 位移
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                var data = this.rawData;
                data[12] = value.x;
                data[13] = value.y;
                data[14] = value.z;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4_4.prototype, "scale", {
            /**
            * @language zh_CN
            * 返回矩阵缩放
            *
            * @returns Vector3D 缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                var data = this.rawData;
                return new egret3d.Vector3D(data[0], data[5], data[10]);
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 以字符串返回矩阵的值
        *
        * @returns string 字符
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.toString = function () {
            var data = this.rawData;
            return "matrix3d(" + Math.round(data[0] * 1000) / 1000 + "," + Math.round(data[1] * 1000) / 1000 + "," + Math.round(data[2] * 1000) / 1000 + "," + Math.round(data[3] * 1000) / 1000 + "," + Math.round(data[4] * 1000) / 1000 + "," + Math.round(data[5] * 1000) / 1000 + "," + Math.round(data[6] * 1000) / 1000 + "," + Math.round(data[7] * 1000) / 1000 + "," + Math.round(data[8] * 1000) / 1000 + "," + Math.round(data[9] * 1000) / 1000 + "," + Math.round(data[10] * 1000) / 1000 + "," + Math.round(data[11] * 1000) / 1000 + "," + Math.round(data[12] * 1000) / 1000 + "," + Math.round(data[13] * 1000) / 1000 + "," + Math.round(data[14] * 1000) / 1000 + "," + Math.round(data[15] * 1000) / 1000 + ")";
        };
        /**
        * @language zh_CN
        * 求两个矩阵之间的插值
        * @param m0 矩阵0
        * @param m1 矩阵1
        * @param t 时间差 0.0 - 1.0
        * @version Egret 3.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.lerp = function (m0, m1, t) {
            ///t(m1 - m0) + m0
            this.copyFrom(m1).sub(m0).mult(t).add(m0);
        };
        /**
        * @language zh_CN
        * 求矩阵在各个轴上缩放的最大值
        * @version Egret 4.0
        * @platform Web,Native
        */
        Matrix4_4.prototype.getMaxScaleOnAxis = function () {
            var te = this.rawData;
            var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
            var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
            var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        };
        /**
        * @private
        */
        Matrix4_4.helpMatrix = new Matrix4_4();
        Matrix4_4.helpMatrix2 = new Matrix4_4();
        Matrix4_4.position_000 = new egret3d.Vector3D();
        Matrix4_4.scale_111 = new egret3d.Vector3D(1, 1, 1);
        Matrix4_4.prs = [new egret3d.Vector3D(), new egret3d.Vector3D(), new egret3d.Vector3D()];
        return Matrix4_4;
    }());
    egret3d.Matrix4_4 = Matrix4_4;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.PlaneClassification
     * @classdesc
     * 定义 PlaneClassification 常量
     * @version Egret 3.0
     * @platform Web,Native
     */
    var PlaneClassification = (function () {
        function PlaneClassification() {
        }
        /**
        * @language zh_CN
        * 背面
        * @version Egret 3.0
        * @platform Web,Native
        */
        PlaneClassification.BACK = 0;
        /**
        * @language zh_CN
        * 正面
        * @version Egret 3.0
        * @platform Web,Native
        */
        PlaneClassification.FRONT = 1;
        /**
        * @language zh_CN
        * 在法线朝上的一面
        * @version Egret 3.0
        * @platform Web,Native
        */
        PlaneClassification.IN = 0;
        /**
        * @language zh_CN
        * 在法线朝下的一面
        * @version Egret 3.0
        * @platform Web,Native
        */
        PlaneClassification.OUT = 1;
        /**
        * @language zh_CN
        * 相交
        * @version Egret 3.0
        * @platform Web,Native
        */
        PlaneClassification.INTERSECT = 2;
        return PlaneClassification;
    }());
    egret3d.PlaneClassification = PlaneClassification;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.MathUtil
    * @classdesc
    * 可使用 MathUtil 类 进行3d矩阵的计算
    * @includeExample geom/MathUtil.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MathUtil = (function () {
        function MathUtil() {
        }
        /**
        * @private
        * @language zh_CN
        * 两个Float是否相等
        * @param f0 float
        * @param f1 float
        * @returns boolean 是否相等
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.FloatEqual = function (f0, f1) {
            return Math.abs(f0 - f1) < 0.00000001;
        };
        /**
        * @private
        * @language zh_CN
        * 四元数转矩阵
        * @param quarternion 源四元数
        * @param m 目标矩阵 默认为null 如果为null将会new 一个Matrix4_4
        * @returns 返回转出矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.quaternion2matrix = function (quarternion, m) {
            if (m === void 0) { m = null; }
            var x = quarternion.x;
            var y = quarternion.y;
            var z = quarternion.z;
            var w = quarternion.w;
            var xx = x * x;
            var xy = x * y;
            var xz = x * z;
            var xw = x * w;
            var yy = y * y;
            var yz = y * z;
            var yw = y * w;
            var zz = z * z;
            var zw = z * w;
            var raw = MathUtil.RAW_DATA_CONTAINER;
            raw[0] = 1 - 2 * (yy + zz);
            raw[1] = 2 * (xy + zw);
            raw[2] = 2 * (xz - yw);
            raw[4] = 2 * (xy - zw);
            raw[5] = 1 - 2 * (xx + zz);
            raw[6] = 2 * (yz + xw);
            raw[8] = 2 * (xz + yw);
            raw[9] = 2 * (yz - xw);
            raw[10] = 1 - 2 * (xx + yy);
            raw[3] = raw[7] = raw[11] = raw[12] = raw[13] = raw[14] = 0;
            raw[15] = 1;
            if (m) {
                m.copyRawDataFrom(raw);
                return m;
            }
            else
                return new egret3d.Matrix4_4(new Float32Array(raw));
        };
        /**
        * @private
        * @language zh_CN
        * 得到矩阵朝前的方向
        * @param m 源矩阵
        * @param v 返回的方向 可为null 如果为null将会new 一个Vector3D
        * @returns Vector3D 返回方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.getForward = function (m, v) {
            if (v === void 0) { v = null; }
            if (v === null) {
                v = new egret3d.Vector3D(0.0, 0.0, 0.0);
            }
            m.copyRowTo(2, v);
            v.normalize();
            return v;
        };
        /**
        * @private
        * @language zh_CN
        * 得到矩阵朝上的方向
        * @param m 源矩阵
        * @param v 返回的方向 可为null 如果为null将会new 一个Vector3D
        * @returns Vector3D 返回方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.getUp = function (m, v) {
            //v ||= new Vector3D(0.0, 0.0, 0.0);
            if (v === void 0) { v = null; }
            if (v === null) {
                v = new egret3d.Vector3D(0.0, 0.0, 0.0);
            }
            m.copyRowTo(1, v);
            v.normalize();
            return v;
        };
        /**
        * @private
        * @language zh_CN
        * 得到矩阵朝右的方向
        * @param m 源矩阵
        * @param v 返回的方向 可为null 如果为null将会new 一个Vector3D
        * @returns Vector3D 返回方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.getRight = function (m, v) {
            if (v === void 0) { v = null; }
            //v ||= new Vector3D(0.0, 0.0, 0.0);
            if (v === null) {
                v = new egret3d.Vector3D(0.0, 0.0, 0.0);
            }
            m.copyRowTo(0, v);
            v.normalize();
            return v;
        };
        /**
        * @private
        * @language zh_CN
        * 比较两个矩阵是否相同
        * @param m1 矩阵1
        * @param m2 矩阵2
        * @returns boolean 相同返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.compare = function (m1, m2) {
            var r1 = MathUtil.RAW_DATA_CONTAINER;
            var r2 = m2.rawData;
            m1.copyRawDataTo(r1);
            for (var i = 0; i < 16; ++i) {
                if (r1[i] != r2[i])
                    return false;
            }
            return true;
        };
        /**
        * @private
        * @language zh_CN
        * 得到平面的反射矩阵
        * @param plane 反射的面
        * @param target 计算返回的矩阵 可为null 如果为null将会new 一个Matrix4_4
        * @returns Matrix4_4 返回计算的结果
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.reflection = function (plane, target) {
            if (target === void 0) { target = null; }
            if (target === null)
                target = new egret3d.Matrix4_4();
            var a = plane.a, b = plane.b, c = plane.c, d = plane.d;
            var rawData = MathUtil.RAW_DATA_CONTAINER;
            var ab2 = -2 * a * b;
            var ac2 = -2 * a * c;
            var bc2 = -2 * b * c;
            // reflection matrix
            rawData[0] = 1 - 2 * a * a;
            rawData[4] = ab2;
            rawData[8] = ac2;
            rawData[12] = -2 * a * d;
            rawData[1] = ab2;
            rawData[5] = 1 - 2 * b * b;
            rawData[9] = bc2;
            rawData[13] = -2 * b * d;
            rawData[2] = ac2;
            rawData[6] = bc2;
            rawData[10] = 1 - 2 * c * c;
            rawData[14] = -2 * c * d;
            rawData[3] = 0;
            rawData[7] = 0;
            rawData[11] = 0;
            rawData[15] = 1;
            target.copyRawDataFrom(rawData);
            return target;
        };
        /**
        * @private
        * @language zh_CN
        * 得到矩阵的平移
        * @param transform 计算的矩阵
        * @param result 计算返回平移坐标 可为null 如果为null将会new 一个Vector3D
        * @returns Vector3D 返回平移坐标
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.getTranslation = function (transform, result) {
            if (result === void 0) { result = null; }
            if (!result)
                result = new egret3d.Vector3D();
            transform.copyRowTo(3, result);
            return result;
        };
        /**
        * @private
        * @language zh_CN
        * 把一个值固定在一个范围之内
        * @param value 当前判定的值
        * @param min_inclusive 最小取值
        * @param max_inclusive 最大取值
        * @returns number 计算后的结果
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.clampf = function (value, min_inclusive, max_inclusive) {
            if (min_inclusive > max_inclusive) {
                var temp = min_inclusive;
                min_inclusive = max_inclusive;
                max_inclusive = temp;
            }
            return value < min_inclusive ? min_inclusive : (value < max_inclusive ? value : max_inclusive);
        };
        /**
        * @private
        */
        MathUtil.ScreenToPosition = function (value, offset, max) {
            return (value + offset * 0.5) / max * 2 - 1;
        };
        /**
        * @private
        */
        MathUtil.PositionToScreen = function (value, offset, max) {
            return (value + 1) * 0.5 * max - offset * 0.5;
        };
        /**
        * @private
        */
        MathUtil.mix = function (value0, value1, t) {
            return value0 * (1 - t) + value1 * t;
        };
        /**
        * @private
        */
        MathUtil.calcDegree = function (quat, angleVector) {
            //计算billboard矩阵x
            quat.transformVector(egret3d.Vector3D.Y_AXIS, this._tempVector);
            this._tempVector.x = 0;
            this._tempVector.normalize();
            var dotX = egret3d.Vector3D.Y_AXIS.dotProduct(this._tempVector);
            var angleX = Math.acos(dotX) * MathUtil.RADIANS_TO_DEGREES;
            if (this._tempVector.z < 0) {
                angleX = 180 - angleX;
            }
            //计算billboard矩阵y
            quat.transformVector(egret3d.Vector3D.Z_AXIS, this._tempVector);
            this._tempVector.y = 0;
            this._tempVector.normalize();
            var dotY = egret3d.Vector3D.Z_AXIS.dotProduct(this._tempVector);
            var angleY = Math.acos(dotY) * MathUtil.RADIANS_TO_DEGREES;
            if (this._tempVector.x < 0) {
                angleY = 360 - angleY;
            }
            //计算billboard矩阵z
            quat.transformVector(egret3d.Vector3D.X_AXIS, this._tempVector);
            this._tempVector.z = 0;
            this._tempVector.normalize();
            var dotZ = egret3d.Vector3D.X_AXIS.dotProduct(this._tempVector);
            var angleZ = Math.acos(dotZ) * MathUtil.RADIANS_TO_DEGREES;
            if (this._tempVector.y < 0) {
                angleZ = 360 - angleZ;
            }
            angleX = this.clampAngle(angleX);
            angleY = this.clampAngle(angleY);
            angleZ = this.clampAngle(angleZ);
            angleVector.setTo(angleX, angleY, angleZ);
        };
        MathUtil.clampAngle = function (angle) {
            while (angle < -180) {
                angle += 360;
            }
            while (angle > 180) {
                angle -= 360;
            }
            return angle;
        };
        /**
        * @language zh_CN
        * 1弧度为多少角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.RADIANS_TO_DEGREES = 180 / Math.PI;
        /**
        * @language zh_CN
        * 1角度为多少弧度
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.DEGREES_TO_RADIANS = Math.PI / 180;
        /**
        * @language zh_CN
        * 整型最大值
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.MAX_VALUE = 0x7fffffff;
        /**
        * @language zh_CN
        * 整型最小值
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.MIN_VALUE = -0x7fffffff;
        /**
        * @private
        * 1角度为多少弧度
        * @version Egret 3.0
        * @platform Web,Native
        */
        MathUtil.RAW_DATA_CONTAINER = new Float32Array(16);
        /**
        * @private
        */
        MathUtil.CALCULATION_MATRIX = new egret3d.Matrix4_4();
        /**
        * @private
        */
        MathUtil.CALCULATION_QUATERNION = new egret3d.Quaternion();
        /**
        * @private
        */
        MathUtil.CALCULATION_VECTOR3D = new egret3d.Vector3D();
        /**
        * @private
        */
        MathUtil.CALCULATION_VECTOR3D_0 = new egret3d.Vector3D();
        /**
        * @private
        */
        MathUtil.CALCULATION_VECTOR3D_1 = new egret3d.Vector3D();
        /**
        * @private
        */
        MathUtil.CALCULATION_VECTOR3D_2 = new egret3d.Vector3D();
        MathUtil._tempVector = new egret3d.Vector3D();
        return MathUtil;
    }());
    egret3d.MathUtil = MathUtil;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Ray
    * @classdesc
    * 射线是指直线上的一点和它一旁的部分所组成的直线，射线有且仅有一个端点，无法测量，由一个原点,和一个方向构成
    * 用于检测射线,也可用于鼠标拣选场景中的模型
    *
    * @see egret3d.Picker
    * @see egret3d.Vector3D
    *
    * @includeExample geom/Ray.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Ray = (function () {
        /**
        * @language zh_CN
        * constructor
        * @origin 射线原点
        * @direction 射线方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Ray(origin, direction) {
            if (origin === void 0) { origin = new egret3d.Vector3D(); }
            if (direction === void 0) { direction = new egret3d.Vector3D(); }
            /**
            * @language zh_CN
            * 射线原点
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.origin = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 射线方向
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.dir = new egret3d.Vector3D();
            this.invViewMat = new egret3d.Matrix4_4();
            this.origin.copyFrom(origin);
            this.dir.copyFrom(direction);
        }
        /**
        * @language zh_CN
        * 计算一个三角形和一个射线的交点
        * @param v0 三角形的第一个顶点
        * @param v1 三角形的第二个顶点
        * @param v2 三角形的第三个顶点
        * @param ret t(交点到射线起始点的距离) u(交点在v1-v0上的投影的位置) v(交点在v1-v2上的投影的位置, 交点为ret=v0+pU*(v1-v0)+pV*(v2-v0))
        * @returns boolean 相交返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.IntersectTriangle = function (v0, v1, v2, ret) {
            if (ret === void 0) { ret = null; }
            var edge1 = v1.subtract(v0, Ray.v0);
            var edge2 = v2.subtract(v0, Ray.v1);
            var pvec = this.dir.crossProduct(edge2, Ray.v2);
            var det = edge1.dotProduct(pvec);
            var tvec;
            if (det > 0) {
                tvec = this.origin.subtract(v0, Ray.v3);
            }
            else {
                tvec = v0.subtract(this.origin, Ray.v3);
                det = -det;
            }
            if (det < 0.0001) {
                return false;
            }
            // Calculate U parameter and test bounds
            var u = tvec.dotProduct(pvec);
            if (ret != null) {
                ret[1] = u;
            }
            if (u < 0.0 || u > det) {
                return false;
            }
            // Prepare to test V parameter
            var qvec = tvec.crossProduct(edge1, Ray.v4);
            // Calculate V parameter and test bounds
            var v = this.dir.dotProduct(qvec);
            if (ret != null) {
                ret[2] = v;
            }
            if (v < 0.0 || u + v > det) {
                return false;
            }
            // Calculate T, scale parameters, ray intersects triangle
            var t = edge2.dotProduct(qvec);
            var invDet = 1.0 / det;
            t *= invDet;
            u *= invDet;
            v *= invDet;
            if (ret != null) {
                ret[0] = t;
                ret[1] = u;
                ret[2] = v;
            }
            if (t < 0) {
                return false;
            }
            return true;
        };
        /**
        * @language zh_CN
        * 计算射线是否和球相交
        * @param center 球中心点
        * @param radius 球的半径
        * @param ret 相交返回 数据
        * @param transform 是否要变换
        * @returns number[] 相交返回 数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.IntersectSphere = function (center, radius, ret, transform) {
            if (ret === void 0) { ret = null; }
            if (transform === void 0) { transform = null; }
            ret = ret || [];
            Ray.transformCenter.copyFrom(center);
            Ray.v0.copyFrom(egret3d.Vector3D.X_AXIS);
            Ray.v0.scaleBy(radius);
            Ray.v0.add(Ray.transformCenter, Ray.v0);
            transform.mat3TransformVector(Ray.v0, Ray.v0);
            Ray.v0.subtract(Ray.transformCenter, Ray.v0);
            radius = Ray.v0.length;
            if (transform) {
                transform.transformVector(center, Ray.transformCenter);
            }
            var t0 = 0.0;
            var t1 = 0.0;
            var oc = Ray.transformCenter.subtract(this.origin, egret3d.MathUtil.CALCULATION_VECTOR3D_0);
            var projoc = this.dir.dotProduct(oc);
            if (projoc < 0)
                return null;
            var oc2 = oc.dotProduct(oc);
            var distance2 = oc2 - projoc * projoc; //计算出的球心到射线的距离
            var radiusSquare = radius * radius;
            if (distance2 > radiusSquare)
                return null;
            var discriminant = radiusSquare - distance2; //使用勾股定理，计算出另一条边的长度
            if (discriminant < 0) {
                t0 = t1 = projoc;
            }
            else {
                discriminant = Math.sqrt(discriminant);
                t0 = projoc - discriminant;
                t1 = projoc + discriminant;
                if (t0 < 0) {
                    t0 = t1;
                }
            }
            ret.push(t0);
            ret.push(t1);
            return ret;
        };
        /**
        * @language zh_CN
        * 检测射线相交包围盒
        * @param bound 检测的包围盒
        * @param result 相交数据 默认为null
        * @returns PickResult 相交返回PickResult 对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.IntersectBound = function (bound, result) {
            if (result === void 0) { result = null; }
            result = result || new egret3d.PickResult();
            if (this.IntersectMesh(bound.vexData, bound.indexData, bound.vexLength, bound.indexData.length / 3, 0, bound.transform, result)) {
                return result;
            }
            return null;
        };
        /**
        * @language zh_CN
        * 检测射线相交模型
        * @param renderItem 检测的模型
        * @param uv_offset 顶点uv数据偏移 可以为-1
        * @param result 数据返回
        * @returns boolean 相交返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.IntersectMeshEx = function (renderItem, uv_offset, result) {
            return this.IntersectMesh(renderItem.geometry.vertexArray, renderItem.geometry.indexArray, renderItem.geometry.vertexAttLength, renderItem.geometry.faceCount, uv_offset, renderItem.modelMatrix, result);
        };
        /**
        * @language zh_CN
        * 检测射线相交模型
        * @param verticesData 检测的模型的顶点数据
        * @param indexData 检测的模型的索引数据
        * @param offset 每个顶点的大小
        * @param faces 模型面数
        * @param uv_offset 顶点uv数据偏移 可以为-1
        * @param mMat 顶点的世界变换矩阵
        * @param result 数据返回
        * @returns boolean 相交返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.IntersectMesh = function (verticesData, indexData, offset, faces, uv_offset, mMat, result) {
            var modletriangle = Ray.modletriangle;
            var uvarray = Ray.uvarray;
            var triangle = Ray.triangle;
            var v0 = triangle[0];
            var v1 = triangle[1];
            var v2 = triangle[2];
            var pos = Ray.pos;
            var uv = Ray.uv;
            var ret = Ray.ret;
            var face = -1;
            var t = egret3d.MathUtil.MAX_VALUE;
            var u = 0;
            var v = 0;
            for (var i = 0; i < faces; ++i) {
                for (var j = 0; j < 3; ++j) {
                    var index = indexData[3 * i + j];
                    pos.setTo(verticesData[offset * index + 0], verticesData[offset * index + 1], verticesData[offset * index + 2]);
                    pos.copyFrom(mMat.transformVector(pos));
                    triangle[j].x = pos.x;
                    triangle[j].y = pos.y;
                    triangle[j].z = pos.z;
                }
                if (this.IntersectTriangle(v0, v1, v2, ret)) {
                    if (ret[0] < t) {
                        face = i;
                        t = ret[0];
                        u = ret[1];
                        v = ret[2];
                    }
                }
            }
            if (face < faces && face >= 0) {
                for (var i = 0; i < 3; ++i) {
                    var index = indexData[3 * face + i];
                    pos.setTo(verticesData[offset * index + 0], verticesData[offset * index + 1], verticesData[offset * index + 2]);
                    modletriangle[i].copyFrom(pos);
                    if (uv_offset > 0) {
                        uv.x = verticesData[offset * index + 0 + uv_offset];
                        uv.y = verticesData[offset * index + 1 + uv_offset];
                        uvarray[i].x = uv.x;
                        uvarray[i].y = uv.y;
                    }
                    pos.copyFrom(mMat.transformVector(pos));
                    triangle[i].x = pos.x;
                    triangle[i].y = pos.y;
                    triangle[i].z = pos.z;
                }
                result.faceIndex = face;
                result.v0 = indexData[3 * face + 0];
                result.v1 = indexData[3 * face + 1];
                result.v2 = indexData[3 * face + 2];
                var tmp0 = v1.subtract(v0, Ray.v0);
                tmp0.scaleBy(u);
                var tmp1 = v2.subtract(v0, Ray.v1);
                tmp1.scaleBy(v);
                result.globalPosition.copyFrom(v0.add(tmp0.add(tmp1, Ray.v2), Ray.v3));
                tmp0 = modletriangle[1].subtract(modletriangle[0], tmp0);
                tmp0.scaleBy(u);
                tmp1 = modletriangle[2].subtract(modletriangle[0], tmp1);
                tmp1.scaleBy(v);
                result.localPosition.copyFrom(modletriangle[0].add(tmp0.add(tmp1, Ray.v2), Ray.v3));
                if (uv_offset > 0) {
                    tmp0 = uvarray[1].subtract(uvarray[0], tmp0);
                    tmp0.scaleBy(u);
                    tmp1 = uvarray[2].subtract(uvarray[0], tmp1);
                    tmp1.scaleBy(v);
                    result.uv.copyFrom(uvarray[0].add(tmp0.add(tmp1, Ray.v2), Ray.v3));
                }
                return true;
            }
            return false;
        };
        /**
        * @language zh_CN
        * 计算摄像机的射线
        * @param width 视口宽
        * @param height 视口高
        * @param modelMtx 相机世界矩阵
        * @param projMtx 相机投影矩阵
        * @param x 鼠标x
        * @param y 鼠标y
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.CalculateAndTransformRay = function (width, height, modelMtx, projMtx, x, y) {
            this.reset();
            this.dir.x = (2.0 * x / width - 1.0) / projMtx.rawData[0];
            this.dir.y = (-2.0 * y / height + 1.0) / projMtx.rawData[5];
            this.dir.z = 1.0;
            this.invViewMat.copyFrom(modelMtx);
            this.origin.copyFrom(this.invViewMat.transformVector(this.origin, Ray.v0));
            this.dir.copyFrom(this.invViewMat.deltaTransformVector(this.dir, Ray.v0));
            this.dir.normalize();
        };
        /**
        * @language zh_CN
        * 射线重置
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.reset = function () {
            this.origin.setTo(0, 0, 0);
            this.dir.setTo(0, 0, 0);
        };
        Ray.v0 = new egret3d.Vector3D();
        Ray.v1 = new egret3d.Vector3D();
        Ray.v2 = new egret3d.Vector3D();
        Ray.v3 = new egret3d.Vector3D();
        Ray.v4 = new egret3d.Vector3D();
        /*
        * @private
        */
        Ray.transformCenter = new egret3d.Vector3D();
        Ray.modletriangle = [new egret3d.Vector3D(), new egret3d.Vector3D(), new egret3d.Vector3D()];
        Ray.uvarray = [new egret3d.Vector3D(), new egret3d.Vector3D(), new egret3d.Vector3D()];
        Ray.triangle = [new egret3d.Vector3D(), new egret3d.Vector3D(), new egret3d.Vector3D()];
        Ray.ret = [0, 0, 0];
        Ray.pos = new egret3d.Vector3D();
        Ray.uv = new egret3d.Point();
        return Ray;
    }());
    egret3d.Ray = Ray;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Color
    * @classdesc
    * 可使用 Color 类调整显示对象的颜色值
    * 使用的时候需要区分当前的值是0-255之间，还是0-1之间
    * @includeExample geom/Color.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Color = (function () {
        /**
        * @language zh_CN
        * 创建一个Color对象
        * @param r red
        * @param g green
        * @param b blue
        * @param a alpha
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Color(r, g, b, a) {
            if (r === void 0) { r = 0; }
            if (g === void 0) { g = 0; }
            if (b === void 0) { b = 0; }
            if (a === void 0) { a = 255; }
            /**
            * @language zh_CN
            * alpha
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.a = 255;
            /**
            * @language zh_CN
            * red
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.r = 255;
            /**
            * @language zh_CN
            * green
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.g = 255;
            /**
            * @language zh_CN
            * blue
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.b = 255;
            this.a = a;
            this.r = r;
            this.g = g;
            this.b = b;
        }
        /**
        * @language zh_CN
        * 返回白色 new Color(255, 255, 255, 255)
        * @retruns Color 白色
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.white = function () {
            return new Color(255, 255, 255, 255);
        };
        /**
        * @language zh_CN
        * 返回黑色 new Color(0, 0, 0, 255)
        * @retrun Color 黑色
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.black = function () {
            return new Color(0, 0, 0, 255);
        };
        /**
        * @language zh_CN
        * 返回白色 new Color(255, 0, 0, 255)
        * @retrun 白色
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.red = function () {
            return new Color(255, 0, 0, 255);
        };
        /**
        * @language zh_CN
        * 返回绿色 new Color(0, 255, 0, 255)
        * @retrun 绿色
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.green = function () {
            return new Color(0, 255, 0, 255);
        };
        /**
        * @language zh_CN
        * 返回蓝色 new Color(0, 0, 255, 255)
        * @retruns 蓝色
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.blue = function () {
            return new Color(0, 0, 255, 255);
        };
        /**
        * @language zh_CN
        * 返回Vector3D格式的颜色数据
        * @param color 颜色数据
        * @param colorFormat 指定的颜色格式
        * @param target 传入的Vector3D对象，如果为null，会自动创建一个用于返回
        * @retruns 返回Vector3D格式的颜色数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.getColor = function (color, colorFormat, target) {
            if (colorFormat === void 0) { colorFormat = egret3d.ContextConfig.ColorFormat_RGBA8888; }
            if (target === void 0) { target = null; }
            if (!target) {
                target = new egret3d.Vector3D();
            }
            target.setTo((color >> 16 & 0xff) / 255, (color >> 8 & 0xff) / 255, (color & 0xff) / 255, (color >> 24 & 0xff) / 255);
            return target;
        };
        /**
        * @language zh_CN
        * 将rgba四个通道，分离过的数据合并为一个颜色数据
        * @param r red通道
        * @param g green通道
        * @param b blue通道
        * @param a alpha通道
        * @retruns number 返回颜色数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.RGBAToColor = function (r, g, b, a) {
            return (a << 24) | (r << 16) | (g << 8) | b;
        };
        /**
        * @language zh_CN
        * 以number值返加颜色
        * @param colorFormat 格式
        * @returns number 颜色
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.prototype.getColor = function (colorFormat) {
            if (colorFormat === void 0) { colorFormat = egret3d.ContextConfig.ColorFormat_RGBA8888; }
            if (colorFormat == egret3d.ContextConfig.ColorFormat_RGB565)
                return 0;
            if (colorFormat == egret3d.ContextConfig.ColorFormat_RGBA5551)
                return 0;
            if (colorFormat == egret3d.ContextConfig.ColorFormat_RGBA4444)
                return 0;
            return this.r << 24 | this.g << 16 | this.b << 8 | this.a;
        };
        /**
        * @language zh_CN
        * 颜色取插值
        * @param c0 颜色1
        * @param c1 颜色2
        * @param t (0.0-1.0)
        * @version Egret 3.0
        * @platform Web,Native
        */
        Color.prototype.lerp = function (c0, c1, t) {
            ///t(c1 - c0) + c0
            this.a = t * (c1.a - c0.a) + c0.a;
            this.r = t * (c1.r - c0.r) + c0.r;
            this.g = t * (c1.g - c0.g) + c0.g;
            this.b = t * (c1.b - c0.b) + c0.b;
            this.a = Math.floor(this.a);
            this.r = Math.floor(this.r);
            this.g = Math.floor(this.g);
            this.b = Math.floor(this.b);
        };
        /**
         * @language zh_CN
         * 拷贝颜色值
         * @param src Color 被拷贝对象颜色
         * @version Egret 3.0
         * @platform Web,Native
         */
        Color.prototype.copyFrom = function (src) {
            this.a = src.a;
            this.r = src.r;
            this.g = src.g;
            this.b = src.b;
        };
        /**
         * @language zh_CN
         * 设置颜色值
         * @param a Alpha
         * @param r Red
         * @param g Green
         * @param b Blue
         * @version Egret 3.0
         * @platform Web,Native
         */
        Color.prototype.setTo = function (a, r, g, b) {
            if (a === void 0) { a = 255; }
            if (r === void 0) { r = 255; }
            if (g === void 0) { g = 255; }
            if (b === void 0) { b = 255; }
            this.a = a;
            this.r = r;
            this.g = g;
            this.b = b;
        };
        /**
         * @language zh_CN
         * 创建颜色值
         * @param argb 0xff00ff00格式
         * @returns color
         * @version Egret 3.0
         * @platform Web,Native
         */
        Color.createColor = function (argb) {
            var color = new Color();
            color.setColorARGB(argb);
            return color;
        };
        /**
         * @language zh_CN
         * 设置颜色值
         * @param argb 0xff00ff00格式
         * @version Egret 3.0
         * @platform Web,Native
         */
        Color.prototype.setColorARGB = function (argb) {
            this.a = argb / 0x1000000;
            this.a >>= 0;
            this.r = argb & 0xff0000;
            this.r >>= 16;
            this.g = argb & 0xff00;
            this.g >>= 8;
            this.b = argb & 0xff;
        };
        /**
         * @language zh_CN
         * 设置颜色值
         * @param rgb 0xffffff格式
         * @version Egret 3.0
         * @platform Web,Native
         */
        Color.prototype.setColorRGB = function (rgb) {
            this.r = rgb & 0xff0000;
            this.r >>= 16;
            this.g = rgb & 0xff00;
            this.g >>= 8;
            this.b = rgb & 0xff;
        };
        /**
         * @language zh_CN
         * 在2个颜色之间取随机颜色
         * @param c1 第一个颜色
         * @param c2 第二个颜色
         * @param sameRandom 是否argb的随机种子使用同一个
         * @version Egret 3.0
         * @platform Web,Native
         */
        Color.prototype.randomColor = function (c1, c2, sameRandom) {
            if (sameRandom === void 0) { sameRandom = false; }
            if (sameRandom) {
                var random = Math.random();
                this.a = c1.a + (c2.a - c1.a) * random;
                this.r = c1.r + (c2.r - c1.r) * random;
                this.g = c1.g + (c2.g - c1.g) * random;
                this.b = c1.b + (c2.b - c1.b) * random;
            }
            else {
                this.a = c1.a + (c2.a - c1.a) * Math.random();
                this.r = c1.r + (c2.r - c1.r) * Math.random();
                this.g = c1.g + (c2.g - c1.g) * Math.random();
                this.b = c1.b + (c2.b - c1.b) * Math.random();
            }
            this.a = Math.floor(this.a);
            this.r = Math.floor(this.r);
            this.g = Math.floor(this.g);
            this.b = Math.floor(this.b);
        };
        /**
         * @language zh_CN
         * 缩放当前颜色
         * @param value 缩放系数
         * @version Egret 3.0
         * @platform Web,Native
         */
        Color.prototype.scaleBy = function (value) {
            this.a *= value;
            this.r *= value;
            this.g *= value;
            this.b *= value;
        };
        return Color;
    }());
    egret3d.Color = Color;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ColorGradients
    * @classdesc
    * 用于描述一个颜色渐变信息，由一个颜色数组和一个时间数组构成，并且数据一一对应。</p>
    * [clr1, clr2, clr3...], [t1, t2, t3...]含义为在t1时间点颜色值为clr1，t2时间点颜色值为clr2，以此类推。</p>
    * t1至t2之间的颜色信息渐变插值生成出来。该数据目前主要用于粒子在存活，颜色线性变化过渡过程。
    * @includeExample geom/ColorGradients.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ColorGradients = (function () {
        /**
        * @language zh_CN
        * 创建一个ColorGradients对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ColorGradients() {
            /**
            * @language zh_CN
            * 渐变色列表，对应时间列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.colors = [];
            /**
            * @language zh_CN
            * 渐变色所处时间下标位置[0-1]，对应颜色列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.times = [];
        }
        /**
        * @language zh_CN
        * 渐变颜色取插值，根据时间线性插值获得。
        * @param t (0.0-1.0)
        * @returns Color，线性插值获得的颜色。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ColorGradients.prototype.lerpColor = function (t, dst) {
            if (dst === void 0) { dst = null; }
            if (t < 0) {
                t = 0;
            }
            else if (t > 1) {
                t = 1;
            }
            if (dst == null)
                dst = new egret3d.Color();
            var clr;
            var nextClr;
            for (var i = 0, count = this.times.length - 1; i < count; i++) {
                if (t >= this.times[i] && t < this.times[i + 1]) {
                    t = (t - this.times[i]) / (this.times[i + 1] - this.times[i]);
                    dst.lerp(this.colors[i], this.colors[i + 1], t);
                    break;
                }
            }
            return dst;
        };
        return ColorGradients;
    }());
    egret3d.ColorGradients = ColorGradients;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Bound
    * @classdesc
    * 可使用 Bound 类 取得包围盒的数据。</p>
    * 包含包围盒的各顶点信息，当包围盒要进行世界变换时，应当变换各顶点信息。</p>
    * 包围物体的顶点数据都是和绑定物体同一空间,变换信息也是用的共同的
    *
    * @includeExample geom/Bound.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Bound = (function () {
        /**
        * @language zh_CN
        * 创建一个包围对象
        * @prame owner 绑定的Object3D对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Bound(owner) {
            /**
            * @language zh_CN
            * 顶点长度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.vexLength = 3;
            this.matrix = new egret3d.Matrix4_4();
            this.temp = new egret3d.Vector3D();
            this.owner = owner;
        }
        Bound.prototype.initBound = function () {
            if (this._bound == null) {
                this._bound = new egret3d.Wireframe();
                this._bound.material.diffuseColor = 0xffffff;
                this._bound.name = "Bound";
                this._bound.geometry.vertexCount = 8;
                this._bound.geometry.indexCount = 24;
                this._bound.geometry.setVertexIndices(0, [0, 1, 1, 2, 2, 3, 0, 3, 4, 5, 5, 6, 6, 7, 4, 7, 0, 4, 1, 5, 3, 7, 2, 6]);
            }
        };
        Object.defineProperty(Bound.prototype, "visible", {
            /**
            * @language zh_CN
            * 获取是否可见
            * @returns boolean 是否可见
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._bound == null) {
                    return false;
                }
                return this._bound.parent ? true : false;
            },
            /**
            * @language zh_CN
            * 设置是否可见
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.initBound();
                if (value) {
                    if (!this._bound.parent) {
                        this.owner.addChild(this._bound);
                    }
                    else {
                        if (this._bound.parent != this.owner) {
                            this._bound.parent.removeChild(this._bound);
                            this.owner.addChild(this._bound);
                        }
                    }
                }
                else {
                    if (this._bound.parent) {
                        this._bound.parent.removeChild(this._bound);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bound.prototype, "transform", {
            /**
            * @language zh_CN
            * 得到变换矩阵，如果没有绑定Object3D对象返回本身的矩阵，否则返回父节点的模型矩阵
            * @returns 变换矩阵
            */
            get: function () {
                if (!this.owner) {
                    return this.matrix;
                }
                return this.owner.modelMatrix;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 检测一个点是否包围盒内
        * @param pos 检测的点
        * @returns 成功返回true
        */
        Bound.prototype.pointIntersect = function (pos) {
            return false;
        };
        /**
        * @language zh_CN
        * 检测两个包围对象是否相交
        * @param target 检测的目标
        * @param intersect 默认参数为null 相交的结果 可以为null
        * @returns  成功返回true
        */
        Bound.prototype.intersect = function (target, intersect) {
            if (intersect === void 0) { intersect = null; }
            return true;
        };
        /**
        * @language zh_CN
        * 克隆一个包围对象
        * @returns Bound 包圍對象
        */
        Bound.prototype.clone = function () {
            var bound = new Bound(this.owner);
            bound.copyVertex(this);
            return bound;
        };
        /**
        * @private
        */
        Bound.prototype.calculateTransform = function () {
            for (var j = 0; j < this.vexData.length; j += 3) {
                this.temp.setTo(this.vexData[j], this.vexData[j + 1], this.vexData[j + 2]);
                this.transform.transformVector(this.temp, this.temp);
                this.vexData[j + 0] = this.temp.x;
                this.vexData[j + 1] = this.temp.y;
                this.vexData[j + 2] = this.temp.z;
            }
        };
        /**
        * @private
        */
        Bound.prototype.copyVertex = function (bound) {
            for (var i = 0; i < bound.vexData.length; ++i) {
                this.vexData[i] = bound.vexData[i];
            }
            for (var i = 0; i < bound.indexData.length; ++i) {
                this.indexData[i] = bound.indexData[i];
            }
            this.vexLength = bound.vexLength;
        };
        /**
        * @private
        */
        Bound.prototype.createChild = function () {
            this.childBound = new Bound(this.owner);
        };
        /**
        * @private
        * @language zh_CN
        */
        Bound.prototype.inBound = function (frustum) {
            return true;
        };
        Bound.prototype.updateAABB = function () {
        };
        /**
        * @language zh_CN
        * 释放所有数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        Bound.prototype.dispose = function () {
            if (this._bound != null) {
                this._bound.dispose();
            }
            if (this.childBound) {
                this.childBound.dispose();
            }
        };
        return Bound;
    }());
    egret3d.Bound = Bound;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    * @class egret3d.HashMap
    * @classdesc
    * 用来做数据存储使用 hash map 映射表
    * <p> 通用的hash map 映射表  key为键 value为任意类型的值
    * <p> 还可以通过开启开关使用双线列表能正常使用list带有顺序的存储方式
    *
    */
    var HashMap = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @param useOrderList 是否使用外部传入的自定义数据列
        * @version Egret 3.0
        * @platform Web,Native
        */
        function HashMap(useOrderList) {
            if (useOrderList === void 0) { useOrderList = false; }
            this.data = [];
            this.list = new Array();
            if (useOrderList) {
                this.list = new Array();
            }
        }
        /**
        * @language zh_CN
        * 是否含有某个key为键的内容
        * @param key 指定的键
        * @returns boolean 返回布尔值
        * @version Egret 3.0
        * @platform Web,Native
        */
        HashMap.prototype.isHas = function (key) {
            if (this.data[key])
                return true;
            return false;
        };
        /**
        * @language zh_CN
        * 根据输入的key，返回对应的value
        * @param key 指定的键
        * @returns any 返回该key对于的value
        * @version Egret 3.0
        * @platform Web,Native
        */
        HashMap.prototype.getValue = function (key) {
            return this.data[key];
        };
        /**
        * @language zh_CN
        * 获取所有值的列表
        * @returns Array<any> 返回值的列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        HashMap.prototype.getList = function () {
            return this.list;
        };
        /**
        * @language zh_CN
        * 加入一个键值对
        * @param key 键
        * @param value 值
        * @version Egret 3.0
        * @platform Web,Native
        */
        HashMap.prototype.add = function (key, value) {
            this.data[key] = value;
            if (this.list) {
                this.list.push(value);
            }
        };
        /**
        * @language zh_CN
        * 输入一个key，删除对应的键值对
        * @param key 键
        * @version Egret 3.0
        * @platform Web,Native
        */
        HashMap.prototype.remove = function (key) {
            if (this.list) {
                var index = this.list.indexOf(this.data[key]);
                if (index != -1) {
                    this.list.splice(index);
                }
            }
            delete this.data[key];
        };
        /**
        * @language zh_CN
        * 释放该对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        HashMap.prototype.dispose = function () {
            delete this.data;
            delete this.list;
        };
        return HashMap;
    }());
    egret3d.HashMap = HashMap;
})(egret3d || (egret3d = {}));
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.BoundBox
    * @classdesc
    * 可使用 Bound 类取得包围盒的数据。使用包围盒简化一个复杂模型的空间信息，执行碰撞检测和可视检测，这样可以大大提高计算效率。</p>
    * 包含包围盒的各顶点信息，当包围盒要进行世界变换时，应当变换各顶点信息。</p>
    * @see egret3d.Bound
    * @includeExample geom/BoundBox.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var BoundBox = (function (_super) {
        __extends(BoundBox, _super);
        /**
        * @language zh_CN
        * 创建一个包围
        * @param owner 绑定的Object3D对象
        * @param min 最小点
        * @param max 最大点
        * @version Egret 3.0
        * @platform Web,Native
        */
        function BoundBox(owner, min, max) {
            if (owner === void 0) { owner = null; }
            if (min === void 0) { min = null; }
            if (max === void 0) { max = null; }
            _super.call(this, owner);
            /**
            * @language zh_CN
            * 盒子最小点
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.min = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 盒子最大点
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.max = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 盒子宽
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.width = 0;
            /**
            * @language zh_CN
            * 盒子高
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.heigth = 0;
            /**
            * @language zh_CN
            * 盒子长
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.depth = 0;
            /**
            * @language zh_CN
            * 盒子体积
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.volume = 0;
            /**
            * @language zh_CN
            * 盒子包围球中心点
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.center = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 盒子包围球半径
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.radius = 0;
            if (!min) {
                min = new egret3d.Vector3D();
            }
            if (!max) {
                max = new egret3d.Vector3D();
            }
            this.min.copyFrom(min);
            this.max.copyFrom(max);
            this.calculateBox();
        }
        /**
        * @language zh_CN
        * 拷贝一个包围盒
        * @param box 数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.copyFrom = function (box) {
            this.min.copyFrom(box.min);
            this.max.copyFrom(box.max);
            this.calculateBox();
        };
        /**
        * @language zh_CN
        * 填充当前包围盒
        * @param min 最小点
        * @param max 最大点
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.fillBox = function (min, max) {
            this.min.copyFrom(min);
            this.max.copyFrom(max);
            this.calculateBox();
        };
        /**
        * @language zh_CN
        * 检测一个点是否包围盒内
        * @param pos 检测的点
        * @returns boolean 成功返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.pointIntersect = function (pos) {
            if (pos.x <= this.max.x && pos.x >= this.min.x &&
                pos.y <= this.max.y && pos.y >= this.min.y &&
                pos.z <= this.max.z && pos.z >= this.min.z) {
                return true;
            }
            return false;
        };
        /**
        * @language zh_CN
        * 检测两个包围盒是否相交
        * 功能和 intersect 一样 为版本兼容没有删除此API
        * @param box2 其中一个包围盒
        * @param boxIntersect  默认参数为null 相交的包围盒 可以为null
        * @returns boolean 成功返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.intersectAABBs = function (box2, boxIntersect) {
            if (boxIntersect === void 0) { boxIntersect = null; }
            if (this.min.x > box2.max.x) {
                return false;
            }
            if (this.max.x < box2.min.x) {
                return false;
            }
            if (this.min.y > box2.max.y) {
                return false;
            }
            if (this.max.y < box2.min.y) {
                return false;
            }
            if (this.min.z > box2.max.z) {
                return false;
            }
            if (this.max.z < box2.min.z) {
                return false;
            }
            if (boxIntersect != null) {
                boxIntersect.min.x = Math.max(this.min.x, box2.min.x);
                boxIntersect.max.x = Math.min(this.max.x, box2.max.x);
                boxIntersect.min.y = Math.max(this.min.y, box2.min.y);
                boxIntersect.max.y = Math.min(this.max.y, box2.max.y);
                boxIntersect.min.z = Math.max(this.min.z, box2.min.z);
                boxIntersect.max.z = Math.min(this.max.z, box2.max.z);
                boxIntersect.calculateBox();
            }
            return true;
        };
        /**
        * @language zh_CN
        * 检测两个包围对象是否相交
        * 注意：target 和 intersect 必须为BoundBox对象
        * @param target 检测的目标
        * @param intersect 默认参数为null 相交的结果 可以为null
        * @returns boolean 成功返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.intersect = function (target, intersect) {
            if (intersect === void 0) { intersect = null; }
            if (!this._box0) {
                this._box0 = this.clone();
            }
            else {
                this._box0.copyVertex(this);
                this._box0.owner = this.owner;
            }
            this._box0.calculateTransform();
            this._box0.updateAABB();
            if (!this._box1) {
                this._box1 = target.clone();
            }
            else {
                this._box1.copyVertex(this);
                this._box1.owner = target.owner;
            }
            this._box1.calculateTransform();
            this._box1.updateAABB();
            return this._box0.intersectAABBs(this._box1, intersect);
        };
        /**
        * @language zh_CN
        * 以字符串形式返回box的值
        * @returns string 字符串
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.toString = function () {
            return "BoundBox [min:(" + this.min.x + ", " + this.min.y + ", " + this.min.z + ") max:(" + this.max.x + ", " + this.max.y + ", " + this.max.z + ")]";
        };
        /**
        * @language zh_CN
        * 计算包围盒数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.calculateBox = function () {
            var sub = this.max.subtract(this.min, egret3d.MathUtil.CALCULATION_VECTOR3D_0);
            this.vexData = this.vexData || new Float32Array(24);
            this.indexData = this.indexData || new Uint16Array(36);
            this.vexData[0] = this.min.x;
            this.vexData[1] = this.min.y;
            this.vexData[2] = this.min.z;
            this.vexData[3] = this.min.x;
            this.vexData[4] = this.min.y;
            this.vexData[5] = this.min.z + sub.z;
            this.vexData[6] = this.min.x + sub.x;
            this.vexData[7] = this.min.y;
            this.vexData[8] = this.min.z + sub.z;
            this.vexData[9] = this.min.x + sub.x;
            this.vexData[10] = this.min.y;
            this.vexData[11] = this.min.z;
            this.vexData[12] = this.max.x - sub.x;
            this.vexData[13] = this.max.y;
            this.vexData[14] = this.max.z - sub.z;
            this.vexData[15] = this.max.x - sub.x;
            this.vexData[16] = this.max.y;
            this.vexData[17] = this.max.z;
            this.vexData[18] = this.max.x;
            this.vexData[19] = this.max.y;
            this.vexData[20] = this.max.z;
            this.vexData[21] = this.max.x;
            this.vexData[22] = this.max.y;
            this.vexData[23] = this.max.z - sub.z;
            this.indexData[0] = 0;
            this.indexData[1] = 4;
            this.indexData[2] = 7;
            this.indexData[3] = 0;
            this.indexData[4] = 7;
            this.indexData[5] = 3;
            this.indexData[6] = 2;
            this.indexData[7] = 6;
            this.indexData[8] = 5;
            this.indexData[9] = 2;
            this.indexData[10] = 5;
            this.indexData[11] = 1;
            this.indexData[12] = 4;
            this.indexData[13] = 5;
            this.indexData[14] = 6;
            this.indexData[15] = 4;
            this.indexData[16] = 6;
            this.indexData[17] = 7;
            this.indexData[18] = 0;
            this.indexData[19] = 3;
            this.indexData[20] = 2;
            this.indexData[21] = 0;
            this.indexData[22] = 2;
            this.indexData[23] = 1;
            this.indexData[24] = 0;
            this.indexData[25] = 1;
            this.indexData[26] = 5;
            this.indexData[27] = 0;
            this.indexData[28] = 5;
            this.indexData[29] = 4;
            this.indexData[30] = 3;
            this.indexData[31] = 7;
            this.indexData[32] = 6;
            this.indexData[33] = 3;
            this.indexData[34] = 6;
            this.indexData[35] = 2;
            this.width = this.max.x - this.min.x;
            this.heigth = this.max.y - this.min.y;
            this.depth = this.max.z - this.min.z;
            this.volume = this.width * this.heigth * this.depth;
            var c = this.max.subtract(this.min, egret3d.MathUtil.CALCULATION_VECTOR3D_1);
            c.scaleBy(0.5);
            this.radius = c.length;
            this.center.copyFrom(this.min);
            var tmp = this.center.add(c, egret3d.MathUtil.CALCULATION_VECTOR3D_2);
            this.center.copyFrom(tmp);
            if (this._bound != null) {
                for (var i = 0; i < 8; ++i) {
                    this._bound.geometry.setVerticesForIndex(i, egret3d.VertexFormat.VF_POSITION, [this.vexData[i * 3 + 0], this.vexData[i * 3 + 1], this.vexData[i * 3 + 2]], 1);
                }
            }
        };
        Object.defineProperty(BoundBox.prototype, "visible", {
            set: function (value) {
                if (this._bound == null) {
                    this.initBound();
                }
                for (var i = 0; i < 8; ++i) {
                    this._bound.geometry.setVerticesForIndex(i, egret3d.VertexFormat.VF_POSITION, [this.vexData[i * 3 + 0], this.vexData[i * 3 + 1], this.vexData[i * 3 + 2]], 1);
                }
                if (value) {
                    if (!this._bound.parent) {
                        this.owner.addChild(this._bound);
                    }
                    else {
                        if (this._bound.parent != this.owner) {
                            this._bound.parent.removeChild(this._bound);
                            this.owner.addChild(this._bound);
                        }
                    }
                }
                else {
                    if (this._bound.parent) {
                        this._bound.parent.removeChild(this._bound);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 检测一个盒子是否在视椎体内
        * @param frustum 视椎体
        * @returns boolean 在视椎内返回ture
        * @version Egret 3.0
        * @platform Web,Native
        */
        BoundBox.prototype.inBound = function (frustum) {
            this.transform.transformVector(this.center, egret3d.MathUtil.CALCULATION_VECTOR3D);
            var radius = this.transform.getMaxScaleOnAxis() * this.radius;
            return frustum.inSphere(egret3d.MathUtil.CALCULATION_VECTOR3D, radius);
        };
        BoundBox.prototype.updateAABB = function () {
            this.min.copyFrom(new egret3d.Vector3D(egret3d.MathUtil.MAX_VALUE, egret3d.MathUtil.MAX_VALUE, egret3d.MathUtil.MAX_VALUE));
            this.max.copyFrom(new egret3d.Vector3D(-egret3d.MathUtil.MAX_VALUE, -egret3d.MathUtil.MAX_VALUE, -egret3d.MathUtil.MAX_VALUE));
            for (var i = 0; i < this.vexData.length; i += this.vexLength) {
                if (this.max.x < this.vexData[i]) {
                    this.max.x = this.vexData[i];
                }
                if (this.max.y < this.vexData[i + 1]) {
                    this.max.y = this.vexData[i + 1];
                }
                if (this.max.z < this.vexData[i + 2]) {
                    this.max.z = this.vexData[i + 2];
                }
                if (this.min.x > this.vexData[i]) {
                    this.min.x = this.vexData[i];
                }
                if (this.min.y > this.vexData[i + 1]) {
                    this.min.y = this.vexData[i + 1];
                }
                if (this.min.z > this.vexData[i + 2]) {
                    this.min.z = this.vexData[i + 2];
                }
            }
        };
        /**
        * @private
        */
        BoundBox.prototype.createChild = function () {
            this.childBound = new BoundBox(this.owner);
            var max = new egret3d.Vector3D();
            var min = new egret3d.Vector3D();
            max.x = this.center.x + this.width / 4;
            max.y = this.center.y + this.heigth / 4;
            max.z = this.center.z + this.depth / 4;
            min.x = this.center.x - this.width / 4;
            min.y = this.center.y - this.heigth / 4;
            min.z = this.center.z - this.depth / 4;
            this.childBound.fillBox(min, max);
        };
        /**
        * @language zh_CN
        * 克隆一個包圍對象
        * @returns Bound 包圍對象
        */
        BoundBox.prototype.clone = function () {
            var bound = new BoundBox(this.owner, this.min, this.max);
            return bound;
        };
        return BoundBox;
    }(egret3d.Bound));
    egret3d.BoundBox = BoundBox;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.BezierCurve
    * @classdesc
    * 贝塞尔曲线
    * @includeExample geom/BezierCurve.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var BezierCurve = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function BezierCurve() {
        }
        /**
        * @language zh_CN
        * 计算贝塞尔曲线在t值时候的y值
        * @param pos 贝塞尔曲线的坐标列表
        * @param t 时刻
        * @version Egret 3.0
        * @platform Web,Native
        */
        BezierCurve.prototype.calcLineX = function (pos, t) {
            var A0;
            var A1;
            for (var i = 0, count = pos.length - 1; i < count; i++) {
                A0 = pos[i];
                A1 = pos[i + 1];
                if (A0.x <= t && A1.x >= t) {
                    break;
                }
            }
            return egret3d.MathUtil.mix(A0.y, A1.y, (t - A0.x) / (t - A1.x));
        };
        BezierCurve.prototype.calcBezierY = function (pos, ctrl, t) {
            var A0;
            var B0;
            var A1;
            var B1;
            for (var i = 0; i < 3; i++) {
                if (t >= pos[i].x && t <= pos[i + 1].x) {
                    A0 = pos[i];
                    B0 = ctrl[i];
                    A1 = pos[i + 1];
                    B1 = ctrl[i + 1];
                    break;
                }
            }
            if (!A0) {
                A0 = pos[pos.length - 1];
            }
            if (!B0) {
                B0 = ctrl[ctrl.length - 1];
            }
            A1 = A1 || A0;
            B1 = B1 || B0;
            t = (t - A0.x) / (A1.x - A0.x);
            return this.cubic_bezier(A0.y, B0.y, B1.y, A1.y, t);
        };
        BezierCurve.prototype.calcBezierX = function (pos, ctrl, t) {
            var A0;
            var B0;
            var A1;
            var B1;
            for (var i = 0; i < 3; i++) {
                if (t >= pos[i].x && t <= pos[i + 1].x) {
                    A0 = pos[i];
                    B0 = ctrl[i];
                    A1 = pos[i + 1];
                    B1 = ctrl[i + 1];
                    break;
                }
            }
            t = (t - A0.x) / (A1.x - A0.x);
            return this.cubic_bezier(A0.x, B0.x, B1.x, A1.x, t);
        };
        BezierCurve.prototype.cubic_bezier = function (p0, p1, p2, p3, t) {
            //第一次混合
            p0 = egret3d.MathUtil.mix(p0, p1, t);
            p1 = egret3d.MathUtil.mix(p1, p2, t);
            p2 = egret3d.MathUtil.mix(p2, p3, t);
            //第二次混合
            p0 = egret3d.MathUtil.mix(p0, p1, t);
            p1 = egret3d.MathUtil.mix(p1, p2, t);
            //第三次混合
            p0 = egret3d.MathUtil.mix(p0, p1, t);
            return p0;
        };
        return BezierCurve;
    }());
    egret3d.BezierCurve = BezierCurve;
    /**
    * @private
    * @language zh_CN
    * @class egret3d.BezierData
    * @classdesc
    * @version Egret 3.0
    * @platform Web,Native
    */
    var BezierData = (function () {
        function BezierData() {
            this.posPoints = [];
            this.ctrlPoints = [];
            this.lineMode = false;
            this.linePoints = [];
        }
        BezierData.prototype.calc = function (t) {
            var value;
            if (!this.lineMode) {
                value = BezierData.calc.calcBezierY(this.posPoints, this.ctrlPoints, t);
            }
            else {
                value = BezierData.calc.calcLineX(this.linePoints, t);
            }
            return value;
        };
        BezierData.prototype.trySampler = function () {
            var dataValide;
            if (this.lineMode) {
                for (var i = 0, count = this.linePoints.length; i < count; i++) {
                    if (this.linePoints[i].y != 0) {
                        dataValide = true;
                        break;
                    }
                }
            }
            else {
                for (var i = 0, count = this.posPoints.length; i < count; i++) {
                    if (this.posPoints[i].y != 0 || this.ctrlPoints[i].y != 0) {
                        dataValide = true;
                        break;
                    }
                }
            }
            if (dataValide) {
                return this.sampler();
                ;
            }
            return null;
        };
        BezierData.prototype.sampler = function () {
            if (this.lineMode) {
                return this.samplerLine();
            }
            return this.samplerBezier();
        };
        BezierData.prototype.samplerLine = function () {
            var SampleNum = 8;
            var res = new Float32Array(1 + (SampleNum * 2 + 1) * 2);
            res[res.length - 1] = this.linePoints.length;
            for (var i = 0, count = this.linePoints.length; i < count; i++) {
                res[i * 2] = this.linePoints[i].x;
                res[i * 2 + 1] = this.linePoints[i].y;
            }
            return res;
        };
        /*
        * @private
        * 采样bezier变成线段的形式
        */
        BezierData.prototype.samplerBezier = function () {
            //2段bezier，第一段9个点，第二段8个点
            //每个点有(x,y)
            //最后一个数据表示当前采样了几个点，如果是bezier的情况，值是9+8；如果是线段类型，则在(1，8 + 9)之间的一个整数
            var SampleNum = 8;
            var res = new Float32Array(1 + (SampleNum * 2 + 1) * 2);
            var tempTime;
            var now = 0;
            var i, j, count;
            var position = 0;
            res[position] = now;
            position++;
            res[position] = this.posPoints[0].y;
            position++;
            for (i = 0, count = BezierData.SegCount; i < count; i++) {
                tempTime = this.posPoints[i * 2 + 1].x - this.posPoints[i * 2].x;
                tempTime /= SampleNum;
                for (j = 0; j < SampleNum; j++) {
                    now += tempTime;
                    if (now > 1) {
                        now = 1;
                    }
                    res[position] = now;
                    position++;
                    res[position] = this.calc(now);
                    position++;
                }
            }
            //最后放入数量
            res[position] = SampleNum * 2 + 1;
            position++;
            return res;
        };
        //private doSampler1(): Float32Array {
        //    var floats: Array<number> = [];
        //    var times: Array<number> = [];
        //    var segmentTime: number;
        //    var segmentStartTime: number = 0;
        //    var segmentEndTime: number = 0;
        //    //每段有10个数据，将该段曲线分为10小段
        //    const SegmentCount: number = 9;
        //    var i: number;
        //    var count: number;
        //    for (i = 0, count = BezierData.SegCount; i < count; i++) {
        //        floats.push(this.posPoints[i * 2].y);//第一个数字
        //        segmentStartTime = this.posPoints[i * 2].x;
        //        segmentEndTime = this.posPoints[i * 2 + 1].x;
        //        segmentTime = (segmentEndTime - segmentStartTime) / SegmentCount;//该贝塞尔的每小段
        //        times.push(segmentTime);
        //        for (var j: number = 1; j < SegmentCount; j++) {
        //            floats.push(this.calc(segmentStartTime + segmentTime * j));
        //        }
        //        floats.push(this.posPoints[i * 2 + 1].y);//第10个数字
        //    }
        //    var res: Float32Array = new Float32Array(floats.length + times.length);
        //    for (i = 0, count = floats.length; i < count; i++) {
        //        res[i] = floats[i];
        //    }
        //    for (var j: number = 0, count = times.length; j < count; i++ , j++) {
        //        res[i] = times[j];
        //    }
        //    return res;
        //}
        BezierData.prototype.validate = function () {
            var i = 0, count = 0;
            if (!this.lineMode) {
                if (this.posPoints == null) {
                    this.posPoints = [];
                }
                if (this.ctrlPoints == null) {
                    this.ctrlPoints = [];
                }
                for (i = this.posPoints.length / 2, count = BezierData.SegCount; i < count; i++) {
                    this.posPoints.push(new egret3d.Point(0, 0));
                    this.posPoints.push(new egret3d.Point(1, 0));
                }
                for (i = this.ctrlPoints.length / 2, count = BezierData.SegCount; i < count; i++) {
                    this.ctrlPoints.push(new egret3d.Point(0, 0));
                    this.ctrlPoints.push(new egret3d.Point(1, 0));
                }
                this.ctrlPoints.length = BezierData.SegCount * 2;
                this.posPoints.length = BezierData.SegCount * 2;
            }
            else {
                if (this.linePoints == null) {
                    this.linePoints = [];
                }
                for (i = this.linePoints.length, count = 17 /*(8 + 9)*/; i < count; i++) {
                    this.linePoints.push(new egret3d.Point(1, 0));
                }
            }
        };
        BezierData.SegCount = 2; //最多2段贝塞尔曲线
        BezierData.calc = new BezierCurve();
        return BezierData;
    }());
    egret3d.BezierData = BezierData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ColorTransform
    * @classdesc
    * 可使用 ColorTransform 类调整显示对象的颜色值
    * @includeExample geom/ColorTransform.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ColorTransform = (function () {
        /**
        * @language zh_CN
        * @class egret3d.ColorTransform
        * @classdesc 创建一个颜色变化矩阵对象，用于偏色某个材质球
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ColorTransform() {
            /**
            * @language zh_CN
            * 颜色变化矩阵(r,g,b)数据，a单独放在外面计算
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.m44 = new egret3d.Matrix4_4();
            /**
            * @language zh_CN
            * 透明度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.alpha = 1.0;
        }
        /**
        * @language zh_CN
        * 缩放颜色，对rgba进行对应比例的系数缩放
        * @param r red通道
        * @param g green通道
        * @param b blue通道
        * @param a alpha通道
        * @version Egret 3.0
        * @platform Web,Native
        */
        ColorTransform.prototype.scale = function (r, g, b, a) {
            if (r === void 0) { r = 1.0; }
            if (g === void 0) { g = 1.0; }
            if (b === void 0) { b = 1.0; }
            if (a === void 0) { a = 1.0; }
            this.m44.appendScale(r, g, b);
            this.alpha *= a;
        };
        /**
        * @language zh_CN
        * 偏移颜色，对rgba进行对应便宜
        * @param r red通道偏移值
        * @param g green通道偏移值
        * @param b blue通道偏移值
        * @param a alpha通道偏移值
        * @version Egret 3.0
        * @platform Web,Native
        */
        ColorTransform.prototype.offset = function (r, g, b, a) {
            if (r === void 0) { r = 0.0; }
            if (g === void 0) { g = 0.0; }
            if (b === void 0) { b = 0.0; }
            if (a === void 0) { a = 0.0; }
            this.m44.appendTranslation(r, g, b);
            this.alpha += a;
        };
        /**
        * @language zh_CN
        * 灰度变换
        * @version Egret 3.0
        * @platform Web,Native
        */
        ColorTransform.prototype.gray = function () {
            var grayFloats = new Float32Array(16);
            grayFloats[0] = 0.2126;
            grayFloats[1] = 0.7152;
            grayFloats[2] = 0.0722;
            grayFloats[3] = 1;
            grayFloats[4] = 0.2126;
            grayFloats[5] = 0.7152;
            grayFloats[6] = 0.0722;
            grayFloats[7] = 1;
            grayFloats[8] = 0.2126;
            grayFloats[9] = 0.7152;
            grayFloats[10] = 0.0722;
            grayFloats[11] = 1;
            grayFloats[12] = 0;
            grayFloats[13] = 0;
            grayFloats[14] = 0;
            grayFloats[15] = 1;
            this.m44.copyRawDataFrom(grayFloats);
        };
        /**
        * @language zh_CN
        * 重置数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        ColorTransform.prototype.reset = function () {
            this.m44.identity();
            this.alpha = 1;
        };
        /**
        * @language zh_CN
        * 颜色变换叠加
        * @param ctf 叠加的颜色变换的矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        ColorTransform.prototype.multiply = function (ctf) {
            this.m44.multiply(ctf.m44);
            this.alpha *= ctf.alpha;
        };
        /**
        * @language zh_CN
        * 拷贝一个颜色变换数据
        * @param transform 被拷贝的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        ColorTransform.prototype.copyFrom = function (transform) {
            this.m44.copyFrom(transform.m44);
            this.alpha = transform.alpha;
        };
        /**
        * @language zh_CN
        * 拷贝该颜色变换数据
        * @param transform 拷贝至目标对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        ColorTransform.prototype.copyTo = function (transform) {
            transform.copyFrom(this);
        };
        /**
         * @language zh_CN
         * 设置颜色值
         * @param value rgb，0xffffff格式
         * @version Egret 3.0
         * @platform Web,Native
         */
        ColorTransform.prototype.setColorRGB = function (value) {
            var r = value & 0xff0000;
            r >>= 16;
            var g = value & 0xff00;
            g >>= 8;
            var b = value & 0xff;
            r /= 0xff;
            g /= 0xff;
            b /= 0xff;
            this.m44.identity();
            this.scale(r, g, b, 1.0);
        };
        return ColorTransform;
    }());
    egret3d.ColorTransform = ColorTransform;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.PickResult
    * @classdesc
    * 鼠标拾取返回数据。</p>
    * 鼠标拾取模型上的交点 (本地坐标、世界坐标)。</p>
    * 鼠标拾取模型的uv。</p>
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PickResult = (function () {
        function PickResult() {
            /**
            * @language zh_CN
            * 鼠标拾取模型上的交点 (本地坐标)。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.localPosition = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 鼠标拾取模型上的交点 (世界坐标)。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.globalPosition = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 鼠标拾取模型的uv。
            * 只有对象的PickType为UVPick 并且模型有uv才会返回
            * @see egret3d.PickType
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.uv = new egret3d.Vector3D();
        }
        return PickResult;
    }());
    egret3d.PickResult = PickResult;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Event3D
    * @classdesc
    * Event3D 类作为创建 Event3D 对象的基类，当发生事件时，Event3D 对象将作为参数传递给事件侦听器。
    * Event3D 类的属性包含有关事件的基本信息，例如事件的类型。对于许多事件（如由 Event3D 类常量表示的事件），
    * 此基本信息就足够了。但其他事件可能需要更详细的信息。
    * 例如，与鼠标单击关联的事件需要包括有关单击事件的位置以及在单击事件期间是否按下了任何键的其他信息。
    * 您可以通过扩展 Event3D 类（MouseEvent 类执行的操作）将此类其他信息传递给事件侦听器。
    * @includeExample events/Event3D.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Event3D = (function () {
        /**
        * @language zh_CN
        * 创建一个作为参数传递给事件侦听器的 Event3D 对象。
        * @param eventType {any} 事件类型
        * @param data {any} 附加数据(可选)
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Event3D(eventType, data) {
            if (eventType === void 0) { eventType = null; }
            if (data === void 0) { data = null; }
            /**
            * @language zh_CN
            * 当前时间戳。
            * @see egret3d.Egret3DCanvas
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.time = 0;
            /**
            * @language zh_CN
            * 每帧间隔延时。
            * @see egret3d.Egret3DCanvas
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.delay = 0;
            this._stopImmediatePropagation = false;
            this.eventType = eventType;
            this.data = data;
        }
        /**
        * @language zh_CN
        * 防止对事件流中当前节点的后续节点中的所有事件侦听器进行处理。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.prototype.stopImmediatePropagation = function () {
            this._stopImmediatePropagation = true;
        };
        /**
         * @private
       * @language zh_CN
       * 重置_stopImmediatePropagation等属性为默认值.引擎内部使用.不对外开放
       * @version Egret 3.0
       * @platform Web,Native
       */
        Event3D.prototype.reset = function () {
            this._stopImmediatePropagation = false;
        };
        Object.defineProperty(Event3D.prototype, "isStopImmediatePropagation", {
            /**
            * @language zh_CN
            * (只读)是否调用过 stopImmediatePropagation() 方法.
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._stopImmediatePropagation;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * COMPLETE 常量定义 相关完成事件。
        * @version Egret 3.0
        * @platform Web,Native
        */
        //static COMPLETE: string = "complete";
        /**
        * @language zh_CN
        * CHANGE_PROPERTY 常量定义 changeProperty 事件对象的 type 属性的值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        //static CHANGE: string = "change";
        /**
        * @language zh_CN
        * ENTER_FRAME 常量定义 每帧更新事件标识。
        * 可注册对象 : Egret3DCanvas类型。
        * 事件响应状态 : 每帧更新时响应一次。
        * 响应事件参数 : Event3D类型,其中Event3D.target的内容即为此次注册事件的Egret3DCanvas对象。
        * @see egret3d.Egret3DCanvas
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.ENTER_FRAME = "enter_frame";
        /**
        * @language zh_CN
        * RESIZE 常量定义 窗体尺寸变换事件标识。
        * 可注册对象 : Input类型。
        * 事件响应状态 : 窗体尺寸变换时响应一次。
        * 响应事件参数 : Event3D类型,其中Event3D.target的内容即为此次注册事件的Input对象。
        * @see egret3d.Input
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.RESIZE = "resize";
        /**
        * @private
        * @language zh_CN
        * CHANGE 常量定义 change 事件对象的 type 属性值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.CHANGE = "change";
        return Event3D;
    }());
    egret3d.Event3D = Event3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.AnimationEvent3D
    * @classdesc
    * 在骨骼动画、粒子动画和属性动画播放时，会有触发动画播放完成事件和动画帧更改事件。
    * AnimationEvent3D内定义了这两种事件的标识符，发生事件时。
    * AnimationEvent3D 对象将作为参数传递给事件侦听器。
    * EVENT_PLAY_COMPLETE 粒子动画 骨骼动画 属性动画 都会触发。
    * EVENT_FRAME_CHANGE 骨骼动画会触发。
    *
    * @see egret3d.PropertyAnimController
    * @see egret3d.SkeletonAnimation
    * @see egret3d.ParticleAnimation
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    * @includeExample events/PropertyAnimEvent3D.ts
    * @includeExample events/SkeletonAnimationEvent3D.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var AnimationEvent3D = (function (_super) {
        __extends(AnimationEvent3D, _super);
        function AnimationEvent3D() {
            _super.apply(this, arguments);
        }
        /**
        * @language zh_CN
        * 动画属性是循环状态下触发
        * 动画一个周期结束后循环
        * 可注册对象 : SkeletonAnimation
        * 响应事件参数 : AnimationEvent3D类型。
        * @see egret3d.Event3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        AnimationEvent3D.CYCLE = "cycle";
        /**
        * @language zh_CN
        * 动画属性是非循环状态下触发
        * 动画在不循环的时候完成动画触发
        * 可注册对象 : SkeletonAnimation
        * 响应事件参数 : AnimationEvent3D类型。
        * @see egret3d.Event3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        AnimationEvent3D.COMPLETE = "complete";
        return AnimationEvent3D;
    }(egret3d.Event3D));
    egret3d.AnimationEvent3D = AnimationEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * 鼠标键码
     * @version Egret 3.0
     * @platform Web,Native
     */
    (function (MouseCode) {
        /**
        * @language zh_CN
        * 鼠标左键
        * @version Egret 3.0
        * @platform Web,Native
        */
        MouseCode[MouseCode["Mouse_Left"] = 0] = "Mouse_Left";
        /**
        * @language zh_CN
        * 鼠标中键
        * @version Egret 3.0
        * @platform Web,Native
        */
        MouseCode[MouseCode["Mouse_Mid"] = 1] = "Mouse_Mid";
        /**
        * @language zh_CN
        * 鼠标右键
        * @version Egret 3.0
        * @platform Web,Native
        */
        MouseCode[MouseCode["Mouse_Right"] = 2] = "Mouse_Right";
    })(egret3d.MouseCode || (egret3d.MouseCode = {}));
    var MouseCode = egret3d.MouseCode;
    /**
    * @language zh_CN
    * @class egret3d.MouseEvent3D
    * @classdesc
    * MouseEvent3D 是所有引擎中可操作鼠标事件节点 的事件类型标记。
    * 只有Input.addEventListener 才会产生下类事件
    * @includeExample events/MouseEvent3D.ts
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    * @see egret3d.Input
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MouseEvent3D = (function (_super) {
        __extends(MouseEvent3D, _super);
        function MouseEvent3D() {
            _super.apply(this, arguments);
            /**
               * @language zh_CN
               * 鼠标code值,枚举值可以参考egret3d.MouseCode
               * @see egret3d.MouseCode
               * @version Egret 3.0
               * @platform Web,Native
               */
            this.mouseCode = 0;
        }
        /**
         * @language zh_CN
         * MOUSE_CLICK 常量定义 鼠标点击事件标识。
         * 可注册对象 : Input类型。
         * 事件响应状态 : 鼠标点击后触发。
         * 响应事件参数 : MouseEvent3D类型,其中LoaderEvent3D.mouseCode的内容即为此次鼠标键码。
         * @see egret3d.Input
         * @version Egret 3.0
         * @platform Web,Native
         */
        MouseEvent3D.MOUSE_CLICK = "onMouseClick";
        /**
         * @language zh_CN
         * MOUSE_DOWN 常量定义 鼠标按下事件标识。
         * 可注册对象 : Input类型。
         * 事件响应状态 : 鼠标按下后触发。
         * 响应事件参数 : MouseEvent3D类型,其中LoaderEvent3D.mouseCode的内容即为此次鼠标键码。
         * @see egret3d.Input
         * @version Egret 3.0
         * @platform Web,Native
         */
        MouseEvent3D.MOUSE_DOWN = "onMouseDown";
        /**
         * @language zh_CN
         * MOUSE_UP 常量定义 鼠标弹回事件标识
         * 可注册对象 : Input类型。
         * 事件响应状态 : 鼠标弹回后触发。
         * 响应事件参数 : MouseEvent3D类型,其中LoaderEvent3D.mouseCode的内容即为此次鼠标键码。
         * @see egret3d.Input
         * @version Egret 3.0
         * @platform Web,Native
         */
        MouseEvent3D.MOUSE_UP = "onMouseUp";
        /**
         * @language zh_CN
         * MOUSE_MOVE 常量定义 鼠标移动事件标识。
         * 可注册对象 : Input类型。
         * 事件响应状态 : 鼠标移动时触发。
         * 响应事件参数 : MouseEvent3D类型,其中LoaderEvent3D.mouseCode的内容即为此次鼠标键码。
         * @see egret3d.Input
         * @version Egret 3.0
         * @platform Web,Native
         */
        MouseEvent3D.MOUSE_MOVE = "onMouseMove";
        /**
         * @language zh_CN
         * MOUSE_OVER 常量定义 鼠标穿过物体事件标识。
         * 可注册对象 : Input类型。
         * 事件响应状态 : 鼠标穿过物体时触发。
         * 响应事件参数 : MouseEvent3D类型,其中LoaderEvent3D.mouseCode的内容即为此次鼠标键码。
         * @see egret3d.Input
         * @version Egret 3.0
         * @platform Web,Native
         */
        MouseEvent3D.MOUSE_OVER = "onMouseOver";
        /**
        * @language zh_CN
        * MOUSE_OVER 常量定义 鼠标离开物体事件标识。
        * 可注册对象 : Input类型。
        * 事件响应状态 : 鼠标离开物体时触发。
        * 响应事件参数 : MouseEvent3D类型,其中LoaderEvent3D.mouseCode的内容即为此次鼠标键码。
        * @see egret3d.Input
        * @version Egret 3.0
        * @platform Web,Native
        */
        MouseEvent3D.MOUSE_OUT = "onMouseOut";
        /**
         * @language zh_CN
         * MOUSE_WHEEL 常量定义 滚轮事件标识。
         * 可注册对象 : Input类型。
         * 事件响应状态 : 鼠标滚轮滚动时触发。
         * 响应事件参数 : MouseEvent3D类型。
         * @see egret3d.Input
         * @version Egret 3.0
         * @platform Web,Native
         */
        MouseEvent3D.MOUSE_WHEEL = "onMouseWheel";
        return MouseEvent3D;
    }(egret3d.Event3D));
    egret3d.MouseEvent3D = MouseEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.TouchEvent3D
    * @classdesc
    * TouchEvent3D 是所有引擎中可操作触摸事件节点 的事件类型标记。
    * 只有Input.addEventListener 才会产生下类事件
    * @includeExample events/TouchEvent3D.ts
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    * @see egret3d.Input
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TouchEvent3D = (function (_super) {
        __extends(TouchEvent3D, _super);
        function TouchEvent3D() {
            _super.apply(this, arguments);
        }
        /**
         * @language zh_CN
         * TOUCH_MOVE 常量定义 触摸滑动事件标识。
         * 可注册对象 : Input类型。
         * 事件响应状态 : 触摸滑动时触发。
         * 响应事件参数 : TouchEvent3D类型,其中TouchEvent3D.targetTouches的内容即为此次触摸列表。
         * @see egret3d.Input
         * @version Egret 3.0
         * @platform Web,Native
         */
        TouchEvent3D.TOUCH_MOVE = "onTouchMove";
        /**
        * @language zh_CN
        * TOUCH_END 常量定义 触摸开始事件标识。
        * 可注册对象 : Input类型。
        * 事件响应状态 : 触摸开始触发。
        * 响应事件参数 : TouchEvent3D类型,其中TouchEvent3D.targetTouches的内容即为此次触摸列表。
        * @see egret3d.Input
        * @version Egret 3.0
        * @platform Web,Native
        */
        TouchEvent3D.TOUCH_START = "onTouchStart";
        /**
        * @language zh_CN
        * TOUCH_START 常量定义 触摸结束事件标识。
        * 可注册对象 : Input类型。
        * 事件响应状态 : 触摸结束触发。
        * 响应事件参数 : TouchEvent3D类型,其中TouchEvent3D.targetTouches的内容即为此次触摸列表。
        * @see egret3d.Input
        * @version Egret 3.0
        * @platform Web,Native
        */
        TouchEvent3D.TOUCH_END = "onTouchEnd";
        return TouchEvent3D;
    }(egret3d.Event3D));
    egret3d.TouchEvent3D = TouchEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.PickEvent3D
    * @classdesc
    * PickEvent3D 是所有引擎中可操作物体拣选事件的事件类型标记。
    * 当IRender对象开启了 enablePick ，并且监听了PickEvent3D事件后，
    * 鼠标或触摸对IRender对象进行操作后会产生一些对应的事件进行影响。
    * 只有Object3D对象调用addEventListener 才会产生下类事件
    * @includeExample events/PickEvent3D.ts
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    * @see egret3d.Object3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PickEvent3D = (function (_super) {
        __extends(PickEvent3D, _super);
        function PickEvent3D() {
            _super.apply(this, arguments);
        }
        /**
         * @language zh_CN
         * PICK_CLICK 点击拣选事件标识
         * 可注册对象 : Object3D类型。
         * 事件响应状态 : 点击拣选时触发，手机上不触发此事件。
         * 响应事件参数 : PickEvent3D类型,其中PickEvent3D.pickResult的内容即为此次拣选结果。
         * @version Egret 3.0
         * @platform Web,Native
         */
        PickEvent3D.PICK_CLICK = "onPickClick";
        /**
         * @language zh_CN
         * PICK_DOWN  按下拣选事件标识
         * 可注册对象 : Object3D类型。
         * 事件响应状态 : 按下拣选时触发。
         * 响应事件参数 : PickEvent3D类型,其中PickEvent3D.pickResult的内容即为此次拣选结果。
         * @version Egret 3.0
         * @platform Web,Native
         */
        PickEvent3D.PICK_DOWN = "onPickDown";
        /**
         * @language zh_CN
         * PICK_UP 弹起拣选事件标识
         * 可注册对象 : Object3D类型。
         * 事件响应状态 : 弹起拣选时触发。
         * 响应事件参数 : PickEvent3D类型,其中PickEvent3D.pickResult的内容即为此次拣选结果。
         * @version Egret 3.0
         * @platform Web,Native
         */
        PickEvent3D.PICK_UP = "onPickUp";
        /**
         * @language zh_CN
         * PICK_MOVE 光标移动拣选事件标识
         * 可注册对象 : Object3D类型。
         * 事件响应状态 : 光标移动拣选时触发。
         * 响应事件参数 : PickEvent3D类型,其中PickEvent3D.pickResult的内容即为此次拣选结果。
         * @version Egret 3.0
         * @platform Web,Native
         */
        PickEvent3D.PICK_MOVE = "onPickMove";
        /**
         * @language zh_CN
         * PICK_WHEEL 滚轮滚动拣选事件标识
         * 可注册对象 : Object3D类型。
         * 事件响应状态 : 滚轮滚动拣选时触发。
         * 响应事件参数 : PickEvent3D类型,其中PickEvent3D.pickResult的内容即为此次拣选结果。
         * @version Egret 3.0
         * @platform Web,Native
         */
        PickEvent3D.PICK_WHEEL = "onPickWheel";
        return PickEvent3D;
    }(egret3d.Event3D));
    egret3d.PickEvent3D = PickEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * 按键码
     * @version Egret 3.0
     * @platform Web,Native
     */
    (function (KeyCode) {
        KeyCode[KeyCode["Key_BackSpace"] = 8] = "Key_BackSpace";
        KeyCode[KeyCode["Key_Tab"] = 9] = "Key_Tab";
        KeyCode[KeyCode["Key_Clear"] = 12] = "Key_Clear";
        KeyCode[KeyCode["Key_Enter"] = 13] = "Key_Enter";
        KeyCode[KeyCode["Key_Shift_L"] = 16] = "Key_Shift_L";
        KeyCode[KeyCode["Key_Control_L"] = 17] = "Key_Control_L";
        KeyCode[KeyCode["Key_Alt_L"] = 18] = "Key_Alt_L";
        KeyCode[KeyCode["Key_Pause"] = 19] = "Key_Pause";
        KeyCode[KeyCode["Key_CapsLock"] = 20] = "Key_CapsLock";
        KeyCode[KeyCode["Key_Escape"] = 21] = "Key_Escape";
        KeyCode[KeyCode["Key_Space"] = 32] = "Key_Space";
        KeyCode[KeyCode["Key_Prior"] = 33] = "Key_Prior";
        KeyCode[KeyCode["Key_Next"] = 34] = "Key_Next";
        KeyCode[KeyCode["Key_End"] = 35] = "Key_End";
        KeyCode[KeyCode["Key_Home"] = 36] = "Key_Home";
        KeyCode[KeyCode["Key_Left"] = 37] = "Key_Left";
        KeyCode[KeyCode["Key_Up"] = 38] = "Key_Up";
        KeyCode[KeyCode["Key_Right"] = 39] = "Key_Right";
        KeyCode[KeyCode["Key_Down"] = 40] = "Key_Down";
        KeyCode[KeyCode["Key_Select"] = 41] = "Key_Select";
        KeyCode[KeyCode["Key_Print"] = 42] = "Key_Print";
        KeyCode[KeyCode["Key_Execute"] = 43] = "Key_Execute";
        KeyCode[KeyCode["Key_Insert"] = 45] = "Key_Insert";
        KeyCode[KeyCode["Key_Delete"] = 46] = "Key_Delete";
        KeyCode[KeyCode["Key_Help"] = 47] = "Key_Help";
        KeyCode[KeyCode["Key_0"] = 48] = "Key_0";
        KeyCode[KeyCode["Key_1"] = 49] = "Key_1";
        KeyCode[KeyCode["Key_2"] = 50] = "Key_2";
        KeyCode[KeyCode["Key_3"] = 51] = "Key_3";
        KeyCode[KeyCode["Key_4"] = 52] = "Key_4";
        KeyCode[KeyCode["Key_5"] = 53] = "Key_5";
        KeyCode[KeyCode["Key_6"] = 54] = "Key_6";
        KeyCode[KeyCode["Key_7"] = 55] = "Key_7";
        KeyCode[KeyCode["Key_8"] = 56] = "Key_8";
        KeyCode[KeyCode["Key_9"] = 57] = "Key_9";
        KeyCode[KeyCode["Key_A"] = 65] = "Key_A";
        KeyCode[KeyCode["Key_B"] = 66] = "Key_B";
        KeyCode[KeyCode["Key_C"] = 67] = "Key_C";
        KeyCode[KeyCode["Key_D"] = 68] = "Key_D";
        KeyCode[KeyCode["Key_E"] = 69] = "Key_E";
        KeyCode[KeyCode["Key_F"] = 70] = "Key_F";
        KeyCode[KeyCode["Key_G"] = 71] = "Key_G";
        KeyCode[KeyCode["Key_H"] = 72] = "Key_H";
        KeyCode[KeyCode["Key_I"] = 73] = "Key_I";
        KeyCode[KeyCode["Key_J"] = 74] = "Key_J";
        KeyCode[KeyCode["Key_K"] = 75] = "Key_K";
        KeyCode[KeyCode["Key_L"] = 76] = "Key_L";
        KeyCode[KeyCode["Key_M"] = 77] = "Key_M";
        KeyCode[KeyCode["Key_N"] = 78] = "Key_N";
        KeyCode[KeyCode["Key_O"] = 79] = "Key_O";
        KeyCode[KeyCode["Key_P"] = 80] = "Key_P";
        KeyCode[KeyCode["Key_Q"] = 81] = "Key_Q";
        KeyCode[KeyCode["Key_R"] = 82] = "Key_R";
        KeyCode[KeyCode["Key_S"] = 83] = "Key_S";
        KeyCode[KeyCode["Key_T"] = 84] = "Key_T";
        KeyCode[KeyCode["Key_U"] = 85] = "Key_U";
        KeyCode[KeyCode["Key_V"] = 86] = "Key_V";
        KeyCode[KeyCode["Key_W"] = 87] = "Key_W";
        KeyCode[KeyCode["Key_X"] = 88] = "Key_X";
        KeyCode[KeyCode["Key_Y"] = 89] = "Key_Y";
        KeyCode[KeyCode["Key_Z"] = 90] = "Key_Z";
        KeyCode[KeyCode["Key_KP_0"] = 96] = "Key_KP_0";
        KeyCode[KeyCode["Key_KP_1"] = 97] = "Key_KP_1";
        KeyCode[KeyCode["Key_KP_2"] = 98] = "Key_KP_2";
        KeyCode[KeyCode["Key_KP_3"] = 99] = "Key_KP_3";
        KeyCode[KeyCode["Key_KP_4"] = 100] = "Key_KP_4";
        KeyCode[KeyCode["Key_KP_5"] = 101] = "Key_KP_5";
        KeyCode[KeyCode["Key_KP_6"] = 102] = "Key_KP_6";
        KeyCode[KeyCode["Key_KP_7"] = 103] = "Key_KP_7";
        KeyCode[KeyCode["Key_KP_8"] = 104] = "Key_KP_8";
        KeyCode[KeyCode["Key_KP_9"] = 105] = "Key_KP_9";
        KeyCode[KeyCode["Key_Multiply"] = 106] = "Key_Multiply";
        KeyCode[KeyCode["Key_Add"] = 107] = "Key_Add";
        KeyCode[KeyCode["Key_Separator"] = 108] = "Key_Separator";
        KeyCode[KeyCode["Key_Subtract"] = 109] = "Key_Subtract";
        KeyCode[KeyCode["Key_Decimal"] = 110] = "Key_Decimal";
        KeyCode[KeyCode["Key_Divide"] = 111] = "Key_Divide";
        KeyCode[KeyCode["Key_F1"] = 112] = "Key_F1";
        KeyCode[KeyCode["Key_F2"] = 113] = "Key_F2";
        KeyCode[KeyCode["Key_F3"] = 114] = "Key_F3";
        KeyCode[KeyCode["Key_F4"] = 115] = "Key_F4";
        KeyCode[KeyCode["Key_F5"] = 116] = "Key_F5";
        KeyCode[KeyCode["Key_F6"] = 117] = "Key_F6";
        KeyCode[KeyCode["Key_F7"] = 118] = "Key_F7";
        KeyCode[KeyCode["Key_F8"] = 119] = "Key_F8";
        KeyCode[KeyCode["Key_F9"] = 120] = "Key_F9";
        KeyCode[KeyCode["Key_F10"] = 121] = "Key_F10";
        KeyCode[KeyCode["Key_F11"] = 122] = "Key_F11";
        KeyCode[KeyCode["Key_F12"] = 123] = "Key_F12";
        KeyCode[KeyCode["Key_F13"] = 124] = "Key_F13";
        KeyCode[KeyCode["Key_F14"] = 125] = "Key_F14";
        KeyCode[KeyCode["Key_F15"] = 126] = "Key_F15";
        KeyCode[KeyCode["Key_F16"] = 127] = "Key_F16";
        KeyCode[KeyCode["Key_F17"] = 128] = "Key_F17";
        KeyCode[KeyCode["Key_F18"] = 129] = "Key_F18";
        KeyCode[KeyCode["Key_F19"] = 130] = "Key_F19";
        KeyCode[KeyCode["Key_F20"] = 131] = "Key_F20";
        KeyCode[KeyCode["Key_F21"] = 132] = "Key_F21";
        KeyCode[KeyCode["Key_F22"] = 133] = "Key_F22";
        KeyCode[KeyCode["Key_F23"] = 134] = "Key_F23";
        KeyCode[KeyCode["Key_F24"] = 135] = "Key_F24";
        KeyCode[KeyCode["Key_Num_Lock"] = 136] = "Key_Num_Lock";
        KeyCode[KeyCode["Key_Scroll_Lock"] = 137] = "Key_Scroll_Lock";
    })(egret3d.KeyCode || (egret3d.KeyCode = {}));
    var KeyCode = egret3d.KeyCode;
    /**
    * @language zh_CN
    * @class egret3d.MouseEvent3D
    * @classdesc
    * KeyEvent3D 按键事件，
    * 只有Input.addEventListener 才会产生下类事件
    * @includeExample events/KeyEvent3D.ts
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    * @see egret3d.Input
    * @version Egret 3.0
    * @platform Web,Native
    */
    var KeyEvent3D = (function (_super) {
        __extends(KeyEvent3D, _super);
        function KeyEvent3D() {
            _super.apply(this, arguments);
            /**
            * @language zh_CN
            * 按键code值,枚举类型可以参考egret3d.KeyCode
            * @see egret3d.KeyCode
            * @default 0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.keyCode = 0;
        }
        ///**
        //* @language zh_CN
        //* KEY_CLICK 常量定义 按键点击事件标识。
        //* 可注册对象 : Input类型。
        //* 事件响应状态 : 按键每次点击响应，按下回弹为一次点击。
        //* 响应事件参数 : KeyEvent3D类型,其中KeyEvent3D.keyCode的内容即为Key的值。
        //* @see egret3d.Input
        //* @default "onKeyClick"
        //* @version Egret 3.0
        //* @platform Web,Native
        //*/
        //public static KEY_CLICK: string = "onKeyClick";
        /**
        * @language zh_CN
        * KEY_DOWN 常量定义  按键按下事件标识。
        * 可注册对象 : Input类型。
        * 事件响应状态 : 按键每次按下时响应。
        * 响应事件参数 : KeyEvent3D类型,其中KeyEvent3D.keyCode的内容即为Key的值。
        * @see egret3d.Input
        * @default "onKeyDown"
        * @version Egret 3.0
        * @platform Web,Native
        */
        KeyEvent3D.KEY_DOWN = "onKeyDown";
        /**
        * @language zh_CN
        * KEY_UP 常量定义 按键回弹事件标识。
        * 可注册对象 : Input类型。
        * 事件响应状态 : 按键每次回弹时响应。
        * 响应事件参数 : KeyEvent3D类型,其中KeyEvent3D.keyCode的内容即为Key的值。
        * @see egret3d.Input
        * @default "onKeyUp"
        * @version Egret 3.0
        * @platform Web,Native
        */
        KeyEvent3D.KEY_UP = "onKeyUp";
        return KeyEvent3D;
    }(egret3d.Event3D));
    egret3d.KeyEvent3D = KeyEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * 设备的方向(设备横向持有或纵向持有)。
     * @version Egret 3.0
     * @platform Web,Native
     */
    (function (Orientation) {
        /**
         * 设备纵向持有0°,即纵向主方向。
         * @version Egret 3.0
         * @platform Web,Native
         */
        Orientation[Orientation["Portrait_Primary"] = 0] = "Portrait_Primary";
        /**
         * 设备纵向持有180°，即纵向次方向
         * @version Egret 3.0
         * @platform Web,Native
         */
        Orientation[Orientation["Portrait_Secondary"] = 180] = "Portrait_Secondary";
        /**
         * 设备横向持有-90°,即横向主方向。
         * @version Egret 3.0
         * @platform Web,Native
         */
        Orientation[Orientation["Landscape_Primary"] = -90] = "Landscape_Primary";
        /**
        * 设备横向持有90°,即横向次方向。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Orientation[Orientation["Landscape_Secondary"] = 90] = "Landscape_Secondary";
    })(egret3d.Orientation || (egret3d.Orientation = {}));
    var Orientation = egret3d.Orientation;
    /**
    * @language zh_CN
    * @class egret3d.MouseEvent3D
    * @classdesc
    * OrientationEvent3D 是所有引擎中可重力感应事件节点的事件类型标记。
    * 只有Input.addEventListener 才会产生下类事件
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    * @see egret3d.Input
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample events/OrientationEvent3D.ts
    */
    var OrientationEvent3D = (function (_super) {
        __extends(OrientationEvent3D, _super);
        function OrientationEvent3D() {
            _super.apply(this, arguments);
        }
        Object.defineProperty(OrientationEvent3D.prototype, "orientation", {
            /**
             * @language zh_CN
             * 获取设备的方向枚举值,枚举值为其对应角度
             * @returns {Orientation} 设备的方向枚举值
             * @see egret3d.Orientation
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                var value = window.orientation;
                return value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrientationEvent3D.prototype, "acceleration", {
            /**
             * @language zh_CN
             * 获取排除重力影响的加速度
             * @returns {DeviceAcceleration} 加速度,单位是m/s2
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._acceleration;
            },
            /**
             * @language zh_CN
             * 设置排除重力影响的加速度
             * @param deviceAcceleration {DeviceAcceleration} 加速度,单位是m/s2。
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (deviceAcceleration) {
                this._acceleration = deviceAcceleration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrientationEvent3D.prototype, "accelerationIncludingGravity", {
            /**
            * @language zh_CN
            * 获取受到重力影响的加速度
            * @returns {DeviceAcceleration} 加速度,单位是m/s2
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._accelerationIncludingGravity;
            },
            /**
            * @language zh_CN
            * 设置受到重力影响的加速度
            * @param deviceAcceleration {DeviceAcceleration} 加速度,单位是m/s2。
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (deviceAcceleration) {
                this._accelerationIncludingGravity = deviceAcceleration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrientationEvent3D.prototype, "rotationRate", {
            /**
             * @language zh_CN
             * 获取旋转角度的变化速率
             * @returns {DeviceAcceleration} 旋转速率,单位是deg/s。
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._rotationRate;
            },
            /**
             * @language zh_CN
             * 设置旋转速率
             * @param deviceRotationRate {DeviceRotationRate} 旋转速率,单位是deg/s。
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (deviceRotationRate) {
                this._rotationRate = deviceRotationRate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrientationEvent3D.prototype, "absolute", {
            /**
             * @language zh_CN
             * 获取是否是绝对旋转重力方向
             * @returns {boolean}。
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._absolute;
            },
            /**
             * @language zh_CN
             * 设置是否是绝对旋转重力方向
             * @param value {boolean}。
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this._absolute = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrientationEvent3D.prototype, "alpha", {
            /**
             * @language zh_CN
             * 获取Alpha旋转，围绕Z轴旋转，即水平方向旋转
             * @returns {number} 旋转角度。
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._alpha;
            },
            /**
             * @language zh_CN
             * 设置Alpha旋转，围绕Z轴旋转，即水平方向旋转
             * @param value {number} 旋转角度。
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this._alpha = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrientationEvent3D.prototype, "beta", {
            /**
             * @language zh_CN
             * 获取Beta旋转，围绕X轴旋转，即前后方向旋转
             * @returns {number} 旋转角度。
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._beta;
            },
            /**
             * @language zh_CN
             * 设置Beta旋转，围绕X轴旋转，即前后方向旋转
             * @param value {number} 旋转角度。
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this._beta = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrientationEvent3D.prototype, "gamma", {
            /**
             * @language zh_CN
             * 获取Gamma旋转，围绕Y轴旋转，即左右方向旋转
             * @returns {number} 旋转角度。
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._gamma;
            },
            /**
             * @language zh_CN
             * 设置Gamma旋转，围绕Y轴旋转，即左右方向旋转
             * @param value {number} 旋转角度。
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this._gamma = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         * ORIENTATION_CHANGE 常量定义 屏幕方向改变事件标识。
         * 可注册对象 : Input类型。
         * 事件响应状态 : 屏幕方向改变事件时响应。
         * 响应事件参数 : OrientationEvent3D类型,其中OrientationEvent3D.Orientation的内容即为方向枚举值。
         * @see egret3d.Input
         * @version Egret 3.0
         * @platform Web,Native
         */
        OrientationEvent3D.ORIENTATION_CHANGE = "onOrientationChange";
        /**
         * @language zh_CN
         * DEVICE_MOTION 常量定义 晃动事件标识
         * 可注册对象 : Input类型。
         * 事件响应状态 : 晃动时响应。
         * 响应事件参数 : OrientationEvent3D类型,其提供设备的加速信息，还提供了设备在坐标系中的自转速率。
         * @see egret3d.Input
         * @version Egret 3.0
         * @platform Web,Native
         */
        OrientationEvent3D.DEVICE_MOTION = "onDeviceMotion";
        /**
         * @language zh_CN
         * DEVICE_ORIENTATION 常量定义 设备方向事件标识。
         * 可注册对象 : Input类型。
         * 事件响应状态 : 设备方向变化响应。
         * 响应事件参数 : OrientationEvent3D类型,其提供设备的物理方向信息，表示为一系列本地坐标系的旋角。
         * @see egret3d.Input
         * @version Egret 3.0
         * @platform Web,Native
         */
        OrientationEvent3D.DEVICE_ORIENTATION = "onDeviceOrientation";
        return OrientationEvent3D;
    }(egret3d.Event3D));
    egret3d.OrientationEvent3D = OrientationEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.LoaderEvent3D
    * @classdesc
    * LoaderEvent3D 使用URLLoader加载资源的事件返回对象
    * 只有URLLoader对象调用addEventListener 才会产生下类事件
    * @includeExample events/LoaderEvent3D.ts
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    @ @see egret3d.URLLoader
    * @version Egret 3.0
    * @platform Web,Native
    */
    var LoaderEvent3D = (function (_super) {
        __extends(LoaderEvent3D, _super);
        function LoaderEvent3D() {
            _super.apply(this, arguments);
        }
        /**
        * @language zh_CN
        * LOADER_COMPLETE 常量定义 资源加载完成事件标识。
        * (3.2.5版本后请使用COMPLETE)
        * 可注册对象 : URLLoader类型。
        * 事件响应状态 : 加载完成后触发。
        * 响应事件参数 : LoaderEvent3D类型,其中LoaderEvent3D.data的内容即为此次加载的内容。
        * @see egret3d.URLLoader
        * @version Egret 3.0
        * @platform Web,Native
        */
        LoaderEvent3D.LOADER_COMPLETE = "onLoadComplete";
        /**
        * @language zh_CN
        * COMPLETE 常量定义 资源加载完成事件标识。
        * 可注册对象 : URLLoader类型。
        * 事件响应状态 : 加载完成后触发。
        * 响应事件参数 : LoaderEvent3D类型,其中LoaderEvent3D.data的内容即为此次加载的内容。
        * @see egret3d.URLLoader
        * @version Egret 3.0
        * @platform Web,Native
        */
        LoaderEvent3D.COMPLETE = "onLoadComplete";
        /**
        * @language zh_CN
        * LOADER_ONCE_COMPLETE 常量定义 资源加载一个文件完成事件标识。
        * (3.2.5版本后请使用ONCE_COMPLETE)
        * 可注册对象 : URLLoader类型。
        * 事件响应状态 : 加载一个文件完成触发。
        * 响应事件参数 : LoaderEvent3D类型,其中LoaderEvent3D.data的内容即为此次加载的内容。
        * @see egret3d.URLLoader
        * @version Egret 3.0
        * @platform Web,Native
        */
        LoaderEvent3D.LOADER_ONCE_COMPLETE = "onLoadOnceComplete";
        /**
        * @language zh_CN
        * ONCE_COMPLETE 常量定义 资源加载一个文件完成事件标识。
        * 可注册对象 : URLLoader类型。
        * 事件响应状态 : 加载一个文件完成触发。
        * 响应事件参数 : LoaderEvent3D类型,其中LoaderEvent3D.data的内容即为此次加载的内容。
        * @see egret3d.URLLoader
        * @version Egret 3.0
        * @platform Web,Native
        */
        LoaderEvent3D.ONCE_COMPLETE = "onLoadOnceComplete";
        /**
        * @language zh_CN
        * LOADER_PROGRESS 常量定义 加载进度事件标识。
        * (3.2.5版本后请使用PROGRESS)
        * 可注册对象 : URLLoader类型。
        * 事件响应状态 : 加载过程中事件响应。
        * 响应事件参数 : LoaderEvent3D类型,其中LoaderEvent3D.currentProgress的内容即为此次加载的进度。
        * @see egret3d.URLLoader
        * @version Egret 3.0
        * @platform Web,Native
        */
        LoaderEvent3D.LOADER_PROGRESS = "onLoadProgress";
        /**
        * @language zh_CN
        * PROGRESS 常量定义 加载进度事件标识。
        * 可注册对象 : URLLoader类型。
        * 事件响应状态 : 加载过程中事件响应。
        * 响应事件参数 : LoaderEvent3D类型,其中LoaderEvent3D.currentProgress的内容即为此次加载的进度。
        * @see egret3d.URLLoader
        * @version Egret 3.0
        * @platform Web,Native
        */
        LoaderEvent3D.PROGRESS = "onLoadProgress";
        /**
        * @language zh_CN
        * LOADER_ERROR 常量定义 加载出错事件标识。
        * (3.2.5版本后请使用ERROR)
        * 可注册对象 : URLLoader类型。
        * 事件响应状态 : 加载出错时事件响应。
        * 响应事件参数 : LoaderEvent3D类型,其中LoaderEvent3D.loader的内容即为出错的加载器。
        * @see egret3d.URLLoader
        * @version Egret 3.0
        * @platform Web,Native
        */
        LoaderEvent3D.LOADER_ERROR = "onLoadError";
        /**
        * @language zh_CN
        * LOADER_ERROR 常量定义 加载出错事件标识。
        * 可注册对象 : URLLoader类型。
        * 事件响应状态 : 加载出错时事件响应。
        * 响应事件参数 : LoaderEvent3D类型,其中LoaderEvent3D.loader的内容即为出错的加载器。
        * @see egret3d.URLLoader
        * @version Egret 3.0
        * @platform Web,Native
        */
        LoaderEvent3D.ERROR = "onLoadError";
        return LoaderEvent3D;
    }(egret3d.Event3D));
    egret3d.LoaderEvent3D = LoaderEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.ParserEvent3D
    * @classdesc
    * ParserEvent3D 使用ParserUtils加载资源的事件返回对象
    * @see egret3d.Event3D
    * @see egret3d.EventDispatcher
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParserEvent3D = (function (_super) {
        __extends(ParserEvent3D, _super);
        function ParserEvent3D() {
            _super.apply(this, arguments);
        }
        /**
         * @language zh_CN
         * PARSER_COMPLETE 常量定义 egret3d资源加载完成事件标识符。
         * 可注册对象 : ParserUtils类型。
         * 事件响应状态 : gret3d资源加载完成时触发。
         * 响应事件参数 : ParserEvent3D类型,其中ParserEvent3D.parser的内容即为此次解析对象。
         * @see egret3d.ParserUtils
         * @version Egret 3.0
         * @platform Web,Native
         */
        ParserEvent3D.PARSER_COMPLETE = "onParserComplete";
        return ParserEvent3D;
    }(egret3d.Event3D));
    egret3d.ParserEvent3D = ParserEvent3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    *
    * @language zh_CN
    * @class egret3d.EventListener
    * @classdesc
    * EventListener类，用于添加或删除事件侦听器。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EventListener = (function () {
        /**
        * @language zh_CN
        * @param type {string} 事件的类型。
        * @param thisObject {any} 注册的对象
        * @param handler {Function} 处理事件的侦听器函数
        * @param param {any} 注册事件时指定的参数，事件响应时传出
        * @param priority {number} 事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在
        * 优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function EventListener(type, thisObject, handler, param, priority) {
            if (type === void 0) { type = null; }
            if (thisObject === void 0) { thisObject = null; }
            if (handler === void 0) { handler = null; }
            if (param === void 0) { param = null; }
            if (priority === void 0) { priority = 0; }
            this.type = type;
            this.thisObject = thisObject;
            this.handler = handler;
            this.param = param;
            this.priority = priority;
        }
        /**
        * @language zh_CN
        * 比较两个事件是否是同一事件。
        * @param type {string} 事件的类型。
        * @param handler {Function} 处理事件的侦听器函数
        * @param thisObject {any} 注册的对象
        * @param param {any} 注册事件时指定的参数，事件响应时传出
        * @returns {boolean} 一致时返回true，反之为false
        * @version Egret 3.0
        * @platform Web,Native
        */
        EventListener.prototype.equalCurrentListener = function (type, handler, thisObject, param) {
            if (this.type == type && this.thisObject == thisObject && this.handler == handler && this.param == param) {
                return true;
            }
            return false;
        };
        /**
        * @private
        */
        EventListener.event_id_count = 0;
        return EventListener;
    }());
    egret3d.EventListener = EventListener;
    /**
    * @language zh_CN
    * @class egret3d.EventDispatcher
    * @classdesc
    * EventDispatcher 类是可调度事件的所有类的基类,包含了事件的注册,注销，分发和清理等功能实现。
    * @includeExample events/EventDispatcher.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EventDispatcher = (function () {
        function EventDispatcher() {
            /**
             * @language zh_CN
             * @private
             */
            this.listeners = {};
        }
        /**
         * @language zh_CN
         * 派发一个 Event3D 事件到所有注册了特定类型侦听器的对象中。
         * @param event3D {Event3D} 事件信息，其中Event3D.eventType为事件标识符，通过该标识进行派发。
         * @see egret3d.Event3D
         * @version Egret 3.0
         * @platform Web,Native
         */
        EventDispatcher.prototype.dispatchEvent = function (event3D) {
            var list = this.listeners[event3D.eventType];
            if (list != null) {
                list = list.slice();
                for (var i = 0; i < list.length; i++) {
                    if (event3D.isStopImmediatePropagation) {
                        break;
                    }
                    var listener = list[i];
                    try {
                        event3D.param = listener.param;
                        event3D.target = this;
                        event3D.currentTarget = listener;
                        listener.handler.call(listener.thisObject, event3D);
                    }
                    catch (error) {
                        if (window.console) {
                            console.error(error.stack);
                        }
                    }
                }
            }
        };
        /**
        * @language zh_CN
        * 释放所有数据。
        * @version Egret 3.0
        * @platform Web,Native
        */
        EventDispatcher.prototype.dispose = function () {
            for (var key in this.listeners) {
                var list = this.listeners[key];
                while (list.length > 0) {
                    var listener = list[0];
                    listener.handler = null;
                    listener.thisObject = null;
                    list.splice(0, 1);
                }
            }
        };
        /**
        * @language zh_CN
        * 使用 EventDispatcher 对象注册事件侦听器对象，以使侦听器能够接收事件通知。可以为特定类型的事件和优先级注册事件侦听器。成功注册一个事件侦听器后，无法通过额外调用 addEventListener() 来更改其优先级。要更改侦听器的优先级，必须首先调用 removeEventListener()。然后，可以使用新的优先级再次注册该侦听器。
        * @param type {string} 事件的类型标识符。
        * @param callback {Function} 处理事件的侦听器函数。此函数必须接受 Event3D 对象作为其唯一的参数，并且不能返回任何结果，
        * 如下面的示例所示： function(evt:Event3D):void 函数可以有任何名称。
        * @param thisObject {any} 当前注册对象。
        * @param param {any} 事件携带参数，默认为空。
        * @param priority {number} 事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在
        * 优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
        * @returns {number} 注册事件位置标识id
         * @version Egret 3.0
         * @platform Web,Native
        */
        EventDispatcher.prototype.addEventListener = function (type, callback, thisObject, param, priority) {
            if (param === void 0) { param = null; }
            if (priority === void 0) { priority = 0; }
            if (this.listeners[type] == null) {
                this.listeners[type] = [];
            }
            var listener = new EventListener(type, thisObject, callback, param, priority);
            listener.id = ++EventListener.event_id_count;
            this.listeners[type].push(listener);
            this.listeners[type].sort(function (listener1, listener2) {
                return listener2.priority - listener1.priority;
            });
            return listener.id;
        };
        /**
         * @language zh_CN
         * 移除事件侦听器。
         * @param type {string} 事件名。
         * @param callback {Function} 侦听函数。
         * @param thisObject {any} 当前注册对象。
         * @version Egret 3.0
         * @platform Web,Native
         */
        EventDispatcher.prototype.removeEventListener = function (type, callback, thisObject) {
            if (this.hasEventListener(type, callback, thisObject)) {
                for (var i = 0; i < this.listeners[type].length; i++) {
                    var listener = this.listeners[type][i];
                    if (listener.equalCurrentListener(type, callback, thisObject, listener.param)) {
                        listener.handler = null;
                        listener.thisObject = null;
                        this.listeners[type].splice(i, 1);
                        return;
                    }
                }
            }
        };
        /**
         * @language zh_CN
         * 移除事件侦听器。
         * @param id  事件id,调用addEventListener的返回值即为事件id.
         * @version Egret 3.0
         * @platform Web,Native
         */
        EventDispatcher.prototype.removeEventListenerAt = function (id) {
            for (var key in this.listeners) {
                for (var i = 0; i < this.listeners[key].length; i++) {
                    var listener = this.listeners[key][i];
                    if (listener.id == id) {
                        listener.handler = null;
                        listener.thisObject = null;
                        this.listeners[key].splice(i, 1);
                        return;
                    }
                }
            }
        };
        /**
         * @language zh_CN
         * 移除所有事件侦听器。
         * @version Egret 3.0
         * @platform Web,Native
         */
        EventDispatcher.prototype.clearEventListener = function () {
            this.listeners = {};
        };
        /**
        * @language zh_CN
        * 检测是否存在监听器。
        * @param type {string} 事件类型标识符
        * @returns {boolean} 是否存在该类型监视器，true为存在，反之不存在。
         * @version Egret 3.0
         * @platform Web,Native
        */
        EventDispatcher.prototype.containEventListener = function (type) {
            if (this.listeners[type] == null)
                return false;
            return this.listeners[type].length > 0;
        };
        /**
        * @language zh_CN
        * 检测是否存在监听器。
        * @param type {string} 事件名
        * @param callback {Function} 处理事件的侦听器函数
        * @param thisObject {any} 注册对象。
        * @returns {boolean} 是否存在该事件，true为存在，反之不存在。
        * @version Egret 3.0
        * @platform Web,Native
        */
        EventDispatcher.prototype.hasEventListener = function (type, callback, thisObject) {
            if (callback === void 0) { callback = null; }
            if (thisObject === void 0) { thisObject = null; }
            if (this.listeners[type] == null)
                return false;
            if (thisObject && callback) {
                for (var i = 0; i < this.listeners[type].length; i++) {
                    var listener = this.listeners[type][i];
                    if (listener.equalCurrentListener(type, callback, thisObject, listener.param)) {
                        return true;
                    }
                }
            }
            return false;
        };
        return EventDispatcher;
    }());
    egret3d.EventDispatcher = EventDispatcher;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.EventManager
    * @classdesc
    * 事件管理。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EventManager = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @param canvas 画布
        * @version Egret 3.0
        * @platform Web,Native
        */
        function EventManager(canvas) {
            this._retRenderList = new Array();
            this._ray = new egret3d.Ray();
            this._canvas = canvas;
            this._pickEvent3d = new egret3d.PickEvent3D();
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_CLICK, this.onMouseClick, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_DOWN, this.onMouseDown, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.onMouseUp, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_MOVE, this.onMouseMove, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_WHEEL, this.onMouseWheel, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_START, this.onTouchDown, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_END, this.onTouchUp, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_MOVE, this.onTouchMove, this);
        }
        Object.defineProperty(EventManager.prototype, "_view3ds", {
            get: function () {
                return this._canvas.view3Ds;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 清理EventManager
        * @version Egret 3.0
        * @platform Web,Native
        */
        EventManager.prototype.onClear = function () {
            this._canvas = null;
        };
        /**
        * @language zh_CN
        * 清除绑定关系。
        * @version Egret 3.0
        * @platform Web,Native
        */
        EventManager.prototype.onClearListeners = function () {
        };
        /**
         * @language zh_CN
         * 分发事件。
         * @param e {any} 事件参数
         * @param typeStr {string} 事件类型
         * @version Egret 3.0
         * @platform Web,Native
         */
        EventManager.prototype.sendEvent = function (e, typeStr, func) {
            var canvas = this._canvas;
            if (!canvas) {
                return;
            }
            for (var i = 0; i < this._view3ds.length; i++) {
                var view = this._view3ds[i];
                var collect = view.entityCollect.specialCastItem[egret3d.SpecialCast.Pick];
                if (!view.entityCollect || !collect) {
                    continue;
                }
                var object3d = null;
                var ray = null;
                this._retRenderList.length = 0;
                var ret = this._retRenderList;
                for (var j = 0; j < collect.length; ++j) {
                    object3d = collect[j];
                    if (!object3d.containEventListener(e.eventType) && !object3d.containEventListener(typeStr)) {
                        continue;
                    }
                    if (!ray) {
                        ray = egret3d.Picker.createRayToView(view, this._ray);
                    }
                    if (egret3d.Picker.doPickerObject(this._ray, object3d)) {
                        ret.push(object3d);
                    }
                }
                var len = ret.length;
                if (len <= 0) {
                    continue;
                }
                var render = null;
                var dis = egret3d.MathUtil.MAX_VALUE;
                var temp_dis = 0;
                for (var j = 0; j < len; j++) {
                    object3d = ret[j];
                    temp_dis = egret3d.Vector3D.distance(object3d.globalPosition, view.camera3D.globalPosition);
                    if (temp_dis < dis) {
                        dis = temp_dis;
                        render = object3d;
                    }
                }
                if (render) {
                    render.dispatchEvent(e);
                    render.dispatchEvent(func.call(this, typeStr, e, render));
                }
            }
        };
        EventManager.prototype.initPickEvent3D = function (typeStr, e, render) {
            this._pickEvent3d.eventType = typeStr;
            this._pickEvent3d.data = e;
            this._pickEvent3d.pickResult = render.pickResult;
            return this._pickEvent3d;
        };
        EventManager.prototype.clearEvent = function () {
            this._pickEvent3d.target = null;
            this._pickEvent3d.data = null;
            this._pickEvent3d.pickResult = null;
            this._pickEvent3d.targetEvent = null;
        };
        EventManager.prototype.onTouchMove = function (e) {
            this._pickEvent3d.targetEvent = e;
            this.sendEvent(e, egret3d.PickEvent3D.PICK_MOVE, this.initPickEvent3D);
            this.clearEvent();
        };
        EventManager.prototype.onTouchUp = function (e) {
            this._pickEvent3d.targetEvent = e;
            this.sendEvent(e, egret3d.PickEvent3D.PICK_UP, this.initPickEvent3D);
            this.clearEvent();
        };
        EventManager.prototype.onTouchDown = function (e) {
            this._pickEvent3d.targetEvent = e;
            this.sendEvent(e, egret3d.PickEvent3D.PICK_DOWN, this.initPickEvent3D);
            this.clearEvent();
        };
        EventManager.prototype.onMouseClick = function (e) {
            this._pickEvent3d.targetEvent = e;
            this.sendEvent(e, egret3d.PickEvent3D.PICK_CLICK, this.initPickEvent3D);
            this.clearEvent();
        };
        EventManager.prototype.onMouseDown = function (e) {
            this._pickEvent3d.targetEvent = e;
            this.sendEvent(e, egret3d.PickEvent3D.PICK_DOWN, this.initPickEvent3D);
            this.clearEvent();
        };
        EventManager.prototype.onMouseUp = function (e) {
            this._pickEvent3d.targetEvent = e;
            this.sendEvent(e, egret3d.PickEvent3D.PICK_UP, this.initPickEvent3D);
            this.clearEvent();
        };
        EventManager.prototype.onMouseMove = function (e) {
            this._pickEvent3d.targetEvent = e;
            this.sendEvent(e, egret3d.PickEvent3D.PICK_MOVE, this.initPickEvent3D);
            this.clearEvent();
        };
        EventManager.prototype.onMouseWheel = function (e) {
            this._pickEvent3d.targetEvent = e;
            this.sendEvent(e, egret3d.PickEvent3D.PICK_WHEEL, this.initPickEvent3D);
            this.clearEvent();
        };
        return EventManager;
    }());
    egret3d.EventManager = EventManager;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @private
    * @class egret3d.ShaderBase
    * @classdesc
    * shader 基类
    */
    var ShaderBase = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param materialData
        * @param usage
        */
        function ShaderBase(type) {
            this.index = 0;
            this.shadersName = new Array();
            this.endShadername = "";
            this.stateChange = false;
            /**
            * @language zh_CN
            *
            */
            this.maxBone = 0;
            this.shaderType = -1;
            this.shaderType = type;
        }
        /**
        * @language zh_CN
        *
        * @param shaderName xxx
        */
        ShaderBase.prototype.addUseShaderName = function (shaderName) {
            this.shadersName.push(shaderName);
        };
        /**
        * @language zh_CN
        *
        * @param shaderName xxx
        */
        ShaderBase.prototype.addEndShaderName = function (shaderName) {
            this.endShadername = shaderName;
        };
        /**
        * @language zh_CN
        *
        * @returns string
        */
        ShaderBase.prototype.getShader = function (passUsage) {
            if (this.endShadername != "") {
                var index = this.shadersName.indexOf(this.endShadername);
                if (index == -1) {
                    this.shadersName.push(this.endShadername);
                }
            }
            return egret3d.ShaderUtil.instance.fillShaderContent(this, this.shadersName, passUsage);
        };
        return ShaderBase;
    }());
    egret3d.ShaderBase = ShaderBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.VarRegister
        * @classdesc
        * shader 变量 基类
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var VarRegister = (function () {
            function VarRegister() {
                /**
                * @language zh_CN
                * 值名字
                */
                this.varName = ""; /// a
                /**
                * @language zh_CN
                * 变量名
                */
                this.name = ""; /// a[0]
                /**
                * @language zh_CN
                * 变量属性类型
                */
                this.key = ""; /// att varying uniform
                /**
                * @language zh_CN
                * 变量类型
                */
                this.valueType = ""; /// float vec2 vec3 vec4 int int2 int3 int4
                /**
                * @language zh_CN
                * 变量值
                */
                this.value = ""; /// var value
                /**
                * @language zh_CN
                * active Texture Index
                */
                this.activeTextureIndex = -1;
                /**
                * @language zh_CN
                * index
                */
                this.index = -1;
                /**
                * @language zh_CN
                * level
                */
                this.level = "";
                this.size = 0;
                this.dataType = 0;
                this.normalized = false;
                this.stride = 0;
                this.offset = 0;
                this.offsetIndex = 0;
                this.offsetBytes = 0;
            }
            /**
            * @language zh_CN
            * 得到组合后的字符串
            * @param compoments
            */
            VarRegister.prototype.var = function (compoments) {
                return this.level + " " + this.valueType + " " + name + "." + compoments;
            };
            /**
            * @language zh_CN
            *
            * @param compoments
            */
            VarRegister.prototype.use = function (compoments) {
                if (compoments === void 0) { compoments = ""; }
                if (compoments != "")
                    return this.name + "." + compoments;
                return this.name;
            };
            /**
            * @language zh_CN
            *
            * @returns VarRegister
            */
            VarRegister.prototype.clone = function () {
                var temp = new VarRegister();
                temp.name = this.name;
                temp.valueType = this.valueType;
                temp.level = this.level;
                temp.varName = this.varName;
                temp.value = this.value;
                temp.key = this.key;
                return temp;
            };
            VarRegister.prototype.computeVarName = function () {
                var index = this.name.indexOf("[");
                if (index >= 0) {
                    this.varName = this.name.substr(0, index);
                }
                else {
                    this.varName = this.name;
                }
            };
            return VarRegister;
        }());
        GLSL.VarRegister = VarRegister;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.Attribute
        * @classdesc
        * 变量属性
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Attribute = (function (_super) {
            __extends(Attribute, _super);
            /**
            * @language zh_CN
            * constructor
            * @param name
            * @param valueType
            */
            function Attribute(name, valueType) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "attribute";
                this.valueType = valueType;
            }
            return Attribute;
        }(GLSL.VarRegister));
        GLSL.Attribute = Attribute;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.AttributeType
        * @classdesc
        *
        * shader中的变量属性类型
        * @version Egret 3.0
        * @platform Web,Native
        */
        var AttributeType = (function () {
            function AttributeType() {
            }
            /**
            * shader int类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.int = "int";
            /**
            * shader float类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.float = "float";
            /**
            * shader vec2类型 两个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.vec2 = "vec2";
            /**
            * shader vec3类型 三个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.vec3 = "vec3";
            /**
            * shader vec4类型 四个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.vec4 = "vec4";
            /**
            * shader 2x2 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.mat2 = "mat2";
            /**
            * shader 3x3 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.mat3 = "mat3";
            /**
            * shader 4x4 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.mat4 = "mat4";
            return AttributeType;
        }());
        GLSL.AttributeType = AttributeType;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.ConstVar
        * @classdesc
        * shader中常量类型变量的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var ConstVar = (function (_super) {
            __extends(ConstVar, _super);
            /**
            * @language zh_CN
            * 构造
            * @param name 常量名
            * @param valueType 常量类型
            * @param value 常量的值
            */
            function ConstVar(name, valueType, value) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "const";
                this.valueType = valueType;
                this.value = value;
            }
            return ConstVar;
        }(GLSL.VarRegister));
        GLSL.ConstVar = ConstVar;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.Sampler2D
        * @classdesc
        *
        * shader中sampler2D类型变量的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Sampler2D = (function (_super) {
            __extends(Sampler2D, _super);
            /**
            * @language zh_CN
            * 构造
            * @param name 变量名
            */
            function Sampler2D(name) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "sampler2D";
                ///this.valueType = valueType;
            }
            return Sampler2D;
        }(GLSL.VarRegister));
        GLSL.Sampler2D = Sampler2D;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @private
        * @class egret3d.Sampler3D
        * @classdesc
        *
        * shader中samplerCube类型变量的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Sampler3D = (function (_super) {
            __extends(Sampler3D, _super);
            /**
            * @language zh_CN
            * 构造
            * @param name 变量名
            */
            function Sampler3D(name) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "samplerCube";
            }
            return Sampler3D;
        }(GLSL.VarRegister));
        GLSL.Sampler3D = Sampler3D;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.TmpVar
        * @classdesc
        *
        * shader中临时变量类型的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var TmpVar = (function (_super) {
            __extends(TmpVar, _super);
            /**
            * @language zh_CN
            * 构造
            * @param name 变量名
            * @param valueType 变量类型
            */
            function TmpVar(name, valueType) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "";
                this.valueType = valueType;
            }
            return TmpVar;
        }(GLSL.VarRegister));
        GLSL.TmpVar = TmpVar;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.Uniform
        * @classdesc
        *
        * shader中uniform类型的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Uniform = (function (_super) {
            __extends(Uniform, _super);
            /**
            * @language zh_CN
            * 创建一个Uniform对象
            * @param name 变量名
            * @param valueType 变量类型
            */
            function Uniform(name, valueType) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "uniform";
                this.valueType = valueType;
            }
            return Uniform;
        }(GLSL.VarRegister));
        GLSL.Uniform = Uniform;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.UniformType
        * @classdesc
        * shader Uniform 变量的类型
        */
        var UniformType = (function () {
            function UniformType() {
            }
            /**
            * shader bool类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.bool = "bool";
            /**
            * shader int类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.int = "int";
            /**
            * shader float类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.float = "float";
            /**
            * shader vec2类型 两个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.vec2 = "vec2";
            /**
            * shader vec3类型 三个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.vec3 = "vec3";
            /**
            * shader vec4类型 四个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.vec4 = "vec4";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.bvec2 = "bvec2";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.bvec3 = "bvec3";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.bvec4 = "bvec4";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.ivec2 = "ivec2";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.ivec3 = "ivec3";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.ivec4 = "ivec4";
            /**
            * shader 2x2 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.mat2 = "mat2";
            /**
            * shader 3x3 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.mat3 = "mat3";
            /**
            * shader 4x4 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.mat4 = "mat4";
            /**
            * shader 贴图对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.sampler2D = "sampler2D";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.sampleCube = "sampleCube";
            return UniformType;
        }());
        GLSL.UniformType = UniformType;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.VarConstName
        * @classdesc
        * shader 变量 名字定义
        * 用户在写自定义shader时，按照引擎中已经列取出来的变量名进行命名
        */
        var VarConstName = (function () {
            function VarConstName() {
            }
            VarConstName.attribute_position = "attribute_position";
            VarConstName.attribute_normal = "attribute_normal";
            VarConstName.attribute_tangent = "attribute_tangent";
            VarConstName.attribute_vertexColor = "attribute_vertexColor";
            VarConstName.attribute_uv0 = "attribute_uv0";
            VarConstName.attribute_uv1 = "attribute_uv1";
            VarConstName.varying_pos = "varying_pos";
            VarConstName.varying_normal = "varying_normal";
            VarConstName.varying_tangent = "varying_tangent";
            VarConstName.varying_color = "varying_color";
            VarConstName.varying_uv0 = "varying_uv0";
            VarConstName.varying_uv1 = "varying_uv1";
            VarConstName.varying_globalPos = "varying_globalPos";
            VarConstName.varying_lightDir = "varying_lightDir";
            VarConstName.varying_eye = "varying_eye";
            VarConstName.uniform_floatv_0 = "uniform_floatv_0";
            VarConstName.uniform_floatv_1 = "uniform_floatv_1";
            VarConstName.uniform_floatv_2 = "uniform_floatv_2";
            VarConstName.uniform_iv_0 = "uniform_iv_0";
            VarConstName.uniform_iv_1 = "uniform_iv_1";
            VarConstName.uniform_iv_2 = "uniform_iv_2";
            VarConstName.uniform_bv_0 = "uniform_bv_0";
            VarConstName.uniform_bv_1 = "uniform_bv_1";
            VarConstName.uniform_bv_2 = "uniform_bv_2";
            VarConstName.uniform_vec2fv_0 = "uniform_vec2fv_0";
            VarConstName.uniform_vec2fv_1 = "uniform_vec2fv_1";
            VarConstName.uniform_vec2fv_2 = "uniform_vec2fv_2";
            VarConstName.uniform_vec3fv_0 = "uniform_vec3fv_0";
            VarConstName.uniform_vec3fv_1 = "uniform_vec3fv_1";
            VarConstName.uniform_vec3fv_2 = "uniform_vec3fv_2";
            VarConstName.uniform_vec4fv_0 = "uniform_vec4fv_0";
            VarConstName.uniform_vec4fv_1 = "uniform_vec4fv_1";
            VarConstName.uniform_vec4fv_2 = "uniform_vec4fv_2";
            VarConstName.uniform_vec2iv_0 = "uniform_vec2iv_0";
            VarConstName.uniform_vec2iv_1 = "uniform_vec2iv_1";
            VarConstName.uniform_vec2iv_2 = "uniform_vec2iv_2";
            VarConstName.uniform_vec3iv_0 = "uniform_vec3iv_0";
            VarConstName.uniform_vec3iv_1 = "uniform_vec3iv_1";
            VarConstName.uniform_vec3iv_2 = "uniform_vec3iv_2";
            VarConstName.uniform_vec4iv_0 = "uniform_vec4iv_0";
            VarConstName.uniform_vec4iv_1 = "uniform_vec4iv_1";
            VarConstName.uniform_vec4iv_2 = "uniform_vec4iv_2";
            VarConstName.uniform_vec2bv_0 = "uniform_vec2bv_0";
            VarConstName.uniform_vec2bv_1 = "uniform_vec2bv_1";
            VarConstName.uniform_vec2bv_2 = "uniform_vec2bv_2";
            VarConstName.uniform_vec3bv_0 = "uniform_vec3bv_0";
            VarConstName.uniform_vec3bv_1 = "uniform_vec3bv_1";
            VarConstName.uniform_vec3bv_2 = "uniform_vec3bv_2";
            VarConstName.uniform_vec4bv_0 = "uniform_vec4bv_0";
            VarConstName.uniform_vec4bv_1 = "uniform_vec4bv_1";
            VarConstName.uniform_vec4bv_2 = "uniform_vec4bv_2";
            VarConstName.uniform_modelMatrix = "uniform_modelMatrix";
            VarConstName.uniform_projectionMatrix = "uniform_projectionMatrix";
            VarConstName.uniform_normalMatrix = "uniform_normalMatrix";
            VarConstName.uniform_eye = "uniform_eye";
            VarConstName.uniform_lightDir = "uniform_lightDir";
            VarConstName.texture2D_0 = "texture2D_0";
            VarConstName.texture2D_1 = "texture2D_1";
            VarConstName.texture2D_2 = "texture2D_2";
            VarConstName.texture2D_3 = "texture2D_3";
            VarConstName.texture2D_4 = "texture2D_4";
            return VarConstName;
        }());
        GLSL.VarConstName = VarConstName;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.Varying
        * @classdesc
        *
        * shader中varying类型的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Varying = (function (_super) {
            __extends(Varying, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @param name 变量名
            * @param valueType 变量类型
            */
            function Varying(name, valueType) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "varying";
                this.valueType = valueType;
            }
            return Varying;
        }(GLSL.VarRegister));
        GLSL.Varying = Varying;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.Extension
        * @classdesc
        * 变量属性
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Extension = (function (_super) {
            __extends(Extension, _super);
            /**
            * @language zh_CN
            * constructor
            * @param name
            * @param valueType
            */
            function Extension(name) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "#extension";
            }
            return Extension;
        }(GLSL.VarRegister));
        GLSL.Extension = Extension;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.ConstVar
        * @classdesc
        * shader中常量类型变量的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.DefineVar
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var DefineVar = (function (_super) {
            __extends(DefineVar, _super);
            /**
            * @language zh_CN
            * 构造
            * @param name 常量名
            * @param value 常量的值
            */
            function DefineVar(name, value) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "#define";
                this.value = value;
            }
            return DefineVar;
        }(GLSL.VarRegister));
        GLSL.DefineVar = DefineVar;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.VaryingType
        * @classdesc
        * shader中varying 变量 类型
        * @version Egret 3.0
        * @platform Web,Native
        */
        var VaryingType = (function () {
            function VaryingType() {
            }
            /**
            * shader bool类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.bool = "bool";
            /**
            * shader int类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.int = "int";
            /**
            * shader float类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.float = "float";
            /**
            * shader vec2类型 两个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.vec2 = "vec2";
            /**
            * shader vec3类型 三个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.vec3 = "vec3";
            /**
            * shader vec4类型 四个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.vec4 = "vec4";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.bvec2 = "bvec2";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.bvec3 = "bvec3";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.bvec4 = "bvec4";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.ivec2 = "ivec2";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.ivec3 = "ivec3";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.ivec4 = "ivec4";
            /**
            * shader 2x2 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.mat2 = "mat2";
            /**
            * shader 3x3 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.mat3 = "mat3";
            /**
            * shader 4x4 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.mat4 = "mat4";
            /**
            * shader 贴图对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.sampler2D = "sampler2D";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.sampleCube = "sampleCube";
            return VaryingType;
        }());
        GLSL.VaryingType = VaryingType;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderLib = (function () {
        function ShaderLib() {
        }
        ShaderLib.lib = {
            AOMap_fs: "uniform sampler2D aoTexture ;\nuniform float aoPower ;\nvoid main(void){\n    float ao = texture2D( aoTexture , varying_uv1 ).x ;\n\tdiffuseColor.xyz *= (ao * aoPower) ; \n}\n",
            AmbientOcclusion: "varying vec2 varying_uv0;\nuniform sampler2D positionPass;\nuniform sampler2D normalPass;\nvoid main(){\n    gl_FragColor = texture2D(positionPass,varying_uv0) + texture2D(normalPass,varying_uv0) ;\n}\n",
            FakePBR_fs: "#extension GL_OES_standard_derivatives:enable\n#define max_directLight 1 \nstruct DirectLight{\n   vec3 direction;\n\t vec3 diffuse;\n\t vec3 ambient;\n};\nuniform float uniform_directLightSource[9*max_directLight] ;\nvarying vec4 varying_mvPose; \nvarying vec3 varying_eyeNormal; \nvarying vec2 varying_uv0; \nuniform sampler2D albedoTex; \nuniform sampler2D normalTex; \nuniform sampler2D glossTex; \nuniform sampler2D specularTex; \nuniform sampler2D opacityTex; \nuniform samplerCube reflectionMap;\nuniform mat4 uniform_ViewMatrix; \nmat3 TBN; \nmat4 normalMatrix ;\nvec3 normalDirection;\nvec3 light;\nvec3 normalTexColor ;\nvec4 opacityTexColor ;\nvec4 glossTexColor ;\nvec4 specularTexColor ;\nvec4 albedoTexColor ;\nvec2 uv_0;\nmat4 transpose(mat4 inMatrix) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n    mat4 outMatrix = mat4(\n                 vec4(i0.x, i1.x, i2.x, i3.x),\n                 vec4(i0.y, i1.y, i2.y, i3.y),\n                 vec4(i0.z, i1.z, i2.z, i3.z),\n                 vec4(i0.w, i1.w, i2.w, i3.w)\n                 );\n    return outMatrix;\n}\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\nvec3 unpackNormal(vec4 packednormal)\n{\n\treturn packednormal.xyz * 2.0 - 1.0;\n}\nmat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) { \nvec3 dp1 = dFdx(p); \nvec3 dp2 = dFdy(p); \nvec2 duv1 = dFdx(uv); \nvec2 duv2 = dFdy(uv);  \nvec3 dp2perp = cross(dp2, N); \nvec3 dp1perp = cross(N, dp1); \nvec3 T = dp2perp * duv1.x + dp1perp * duv2.x; \nvec3 B = dp2perp * duv1.y + dp1perp * duv2.y; \nfloat invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B))); \nreturn mat3(T * invmax, B * invmax, N); \n}\nvec3 fakePBRLight( vec3 lightDir , vec3 viewDir , vec3 lightColor , vec3 ambient ){\n    vec3 lightDirection = mat3(uniform_ViewMatrix) * normalize(lightDir);\n    vec3 halfDirection = normalize( lightDirection + viewDir) ;\n    float attenuation = 1.0 ;    vec3 attenColor = attenuation * lightColor;\n    float Pi = 3.141592654;\n    float InvPi = 0.31830988618;\n    float gloss = glossTexColor.r;\n    float specPow = exp2( gloss * 10.0 + 1.0 );\n    float NdotL = max(0.0, dot( normalDirection, lightDirection ));\n    float specularMonochrome = max( max(specularTexColor.r, specularTexColor.g), specularTexColor.b);\n    float normTerm = (specPow + 8.0 ) / (8.0 * Pi);\n    vec3 directSpecular =  (floor(attenuation) * lightColor ) * pow(max(0.0,dot(halfDirection,normalDirection)),normTerm) * specularTexColor.xyz * normTerm ;\n    vec3 specular = directSpecular;\n    NdotL = max(0.0,dot( normalDirection , normalize(lightDirection) ));\n    vec3 directDiffuse = max( 0.0, NdotL) * attenColor;\n    vec3 indirectDiffuse = vec3(0.0,0.0,0.0);\n\t\t indirectDiffuse +=  ambient ;    vec3 diffuseColor = albedoTexColor.rgb;\n    diffuseColor *= 1.0-specularMonochrome;\n    vec3 diffuse = (directDiffuse + indirectDiffuse) * diffuseColor;\n    vec3 finalColor = diffuse + specular ;\n    return finalColor ;\n}\nvoid calculateDirectLight(  ){\n    float lambertTerm , specular ; \n    vec3 dir ,viewDir = normalize(varying_mvPose.xyz/varying_mvPose.w); \n    for(int i = 0 ; i < max_directLight ; i++){ \n         DirectLight directLight ; \n         directLight.direction = vec3(uniform_directLightSource[i*9],uniform_directLightSource[i*9+1],uniform_directLightSource[i*9+2]); \n         directLight.diffuse = vec3(uniform_directLightSource[i*9+3],uniform_directLightSource[i*9+4],uniform_directLightSource[i*9+5]); \n         directLight.ambient = vec3(uniform_directLightSource[i*9+6],uniform_directLightSource[i*9+7],uniform_directLightSource[i*9+8]); \n         dir = normalize(directLight.direction) ; \n         light.xyz += fakePBRLight( dir , viewDir , directLight.diffuse , directLight.ambient); \n    }\n}\nvoid main(void){ \n     TBN = cotangentFrame(normalize(varying_eyeNormal), normalize(-varying_mvPose.xyz) , uv_0); \n  \n     albedoTexColor = texture2D(albedoTex, varying_uv0 );\n      normalTexColor = unpackNormal(texture2D(normalTex, uv_0 )) ; \n     opacityTexColor = texture2D(opacityTex, uv_0 ) ; \n     glossTexColor = texture2D(glossTex, uv_0 );\n     specularTexColor = texture2D(specularTex, uv_0 );\n     normalDirection = TBN * normalTexColor.xyz ;\n     if( (step(materialSource.cutAlpha,opacityTexColor.g) - 0.5) < 0.0 ){\n        discard;\n     }\n     calculateDirectLight();\n     vec4 finalRGBA = vec4(light,1.0) ;     gl_FragColor = finalRGBA;   \n}",
            FakePBR_vs: "attribute vec3 attribute_position;\nattribute vec3 attribute_normal;\nattribute vec2 attribute_uv0;\nuniform mat4 uniform_ModelMatrix ;\nuniform mat4 uniform_ViewMatrix ;\nuniform mat4 uniform_ProjectionMatrix ;\nvarying vec4 varying_mvPose;\nvarying vec3 varying_eyeNormal;\nvarying vec2 varying_uv0;\nvec4 outPosition; \nmat4 transpose(mat4 inMatrix) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n    mat4 outMatrix = mat4(\n                 vec4(i0.x, i1.x, i2.x, i3.x),\n                 vec4(i0.y, i1.y, i2.y, i3.y),\n                 vec4(i0.z, i1.z, i2.z, i3.z),\n                 vec4(i0.w, i1.w, i2.w, i3.w)\n                 );\n    return outMatrix;\n}\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\nvoid main(void){ \n    mat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix); \n    varying_mvPose = mvMatrix * vec4( attribute_position , 1.0 )  ; \n    \n    mat4 normalMatrix = inverse(mvMatrix) ;\n    normalMatrix = transpose(normalMatrix); \n    \n    varying_eyeNormal = mat3(normalMatrix) * -attribute_normal ; \n    varying_uv0 = attribute_uv0 ;\n    \n    outPosition = uniform_ProjectionMatrix * varying_mvPose ; \n    gl_Position = outPosition; \n}",
            MultiUVSprite_fs: "uniform vec4 multiUV ; \nuniform sampler2D diffuseTexture;\nvec4 diffuseColor ;\nvoid main() {\n    vec2 scale = vec2(1.0/multiUV.xy) ; \n    float a = mod(multiUV.w , multiUV.x) ;\n    float b = (multiUV.w / multiUV.x) - fract(multiUV.w / multiUV.x) ; \n    vec2 rec = scale * vec2(a,b) + uv_0 * scale;\n\tdiffuseColor = texture2D(diffuseTexture , rec ); \n    if( diffuseColor.w < materialSource.cutAlpha ){\n\t\tdiscard;\n\t}\n}\n",
            SSAO: "#define DL 2.399963229728653\n#define EULER 2.718281828459045\nvarying vec2 varying_uv0; \nfloat aoClamp =  0.5 ; \nfloat lumInfluence =  0.5 ; \nconst vec2 size =  vec2(512.0,512.0); \nconst int samples =  64; \nconst float radius =  2.0; \nconst bool useNoise =  false; \nconst float noiseAmount =  0.00000003; \nconst float diffArea =  0.4; \nconst float gDisplace =  0.4; \nuniform sampler2D positionPass; \nuniform sampler2D normalPass; \nuniform sampler2D colorPass; \nvec2 rand( vec2 coord ) { \nvec2 noise; \nif ( useNoise ) { \nfloat nx = dot ( coord, vec2( 12.9898, 78.233 ) ); \nfloat ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 ); \nnoise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 ); \n} else { \nfloat ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) ); \nfloat gg = fract( coord.t * ( size.y / 2.0 ) ); \nnoise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg; \n} \nreturn ( noise * 2.0  - 1.0 ) * noiseAmount; \n}\nfloat readDepth(vec2 coord){ \nfloat cameraNear = 1.0 ; \nfloat cameraFar = 10000.0; \nfloat cameraFarPlusNear = cameraFar + cameraNear; \nfloat cameraFarMinusNear = cameraFar - cameraNear; \nfloat cameraCoef = 2.0 * cameraNear; \nreturn texture2D(positionPass,coord).z / (cameraFar-cameraNear); \n}\nfloat compareDepths( const in float depth1, const in float depth2, inout int far ) { \nfloat garea = 2.0; \nfloat diff = ( depth1 - depth2 ) * 100.0; \nif ( diff < gDisplace ) { \ngarea = diffArea; \n} else { \nfar = 1; \n} \nfloat dd = diff - gDisplace; \nfloat gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) ); \nreturn gauss; \n}\nfloat calcAO( float depth, float dw, float dh ) { \nfloat dd = radius - depth * radius; \nvec2 vv = vec2( dw, dh ); \nvec2 vUv = varying_uv0 ; \nvec2 coord1 = vUv + dd * vv; \nvec2 coord2 = vUv - dd * vv; \nfloat temp1 = 0.0; \nfloat temp2 = 0.0; \nint far = 0; \ntemp1 = compareDepths( depth, readDepth( coord1 ), far ); \nif ( far > 0 ) { \ntemp2 = compareDepths( readDepth( coord2 ), depth, far ); \ntemp1 += ( 1.0 - temp1 ) * temp2; \n} \nreturn temp1; \n}\nvoid main(){ \nvec2 noise = rand( varying_uv0 ); \nfloat depth = readDepth( varying_uv0 ); \nfloat tt = clamp( depth, aoClamp, 1.0 ); \nfloat w = ( 1.0 / size.x )  / tt + ( noise.x * ( 1.0 - noise.x ) ); \nfloat h = ( 1.0 / size.y ) / tt + ( noise.y * ( 1.0 - noise.y ) ); \nfloat ao = 0.0; \nfloat dz = 1.0 / float( samples ); \nfloat z = 1.0 - dz / 2.0; \nfloat l = 0.0; \nfor ( int i = 0; i <= samples; i ++ ) { \nfloat r = sqrt( 1.0 - z ); \nfloat pw = cos( l ) * r; \nfloat ph = sin( l ) * r; \nao += calcAO( depth, pw * w, ph * h ); \nz = z - dz; \nl = l + DL; \n} \nao /= float( samples ); \nao = 1.0 - ao; \nvec3 color = texture2D(colorPass,varying_uv0).xyz ; \nvec3 lumcoeff = vec3( 0.299, 0.587, 0.114 ); \nfloat lum = dot( color.rgb, lumcoeff ); \nvec3 luminance = vec3( lum ); \nvec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) ); \ngl_FragColor = vec4( final, 1.0 ); \n}",
            alphaMask_fs: "uniform sampler2D maskTexture ;\nvoid main(void){\n\tfloat maskAlpha = texture2D( maskTexture , uv_0 ).x;\n\tif(maskAlpha * diffuseColor.w < 0.001){\n\t\tdiscard;\n\t}\n    materialSource.alpha *= maskAlpha;\n}\n",
            baseShadowPass_fs: "varying vec2 varying_uv0;\nvarying vec4 varying_color;\nvec4 outColor ; \nvec2 uv_0;\nvoid main() {\n\tuv_0 = varying_uv0;\n}",
            baseShadowPass_vs: "attribute vec3 attribute_position;\nattribute vec2 attribute_uv0;\nattribute vec4 attribute_color;\nuniform mat4 uniform_ProjectionMatrix ;\nvarying vec2 varying_uv0;\nvarying vec4 varying_color;\nvec3 e_position = vec3(0.0, 0.0, 0.0);\nvec4 outPosition ;\nvoid main(void){\n    e_position = attribute_position;\n    varying_color = attribute_color;\n    varying_uv0 = attribute_uv0;\n}",
            base_fs: "#extension GL_OES_standard_derivatives : enable\nvarying vec3 varying_eyeNormal  ;\nvarying vec2 varying_uv0;\nvarying vec4 varying_color;\nuniform mat4 uniform_ViewMatrix ;\nstruct SurfaceOutput{\n  vec3 Albedo;\n  vec3 Normal;\n  vec4 Specular;\n  float Alpha ;\n};\nSurfaceOutput s ;\nvec4 outColor ;\nvec4 diffuseColor ;\nvec4 light ;\nvec3 normal;\nvec2 uv_0;\nvec3 flatNormals(vec3 pos) {\n  vec3 fdx = dFdx(pos);\n  vec3 fdy = dFdy(pos);\n  return normalize(cross(fdx, fdy));\n}\nvec3 Fresnel_Schlick(float cosT, vec3 F0)\n{\n  return F0 + (1.0-F0) * pow( 1.0 - cosT, 5.0);\n}\nvoid main() {\n\tdiffuseColor  = vec4(1.0);\n\tlight         = vec4(0.0,0.0,0.0,-1.0); \n     \n    normal = normalize(varying_eyeNormal) ;\n\tuv_0 = varying_uv0;\n}",
            base_vs: "attribute vec3 attribute_position;\nattribute vec3 attribute_normal;\nattribute vec4 attribute_color;\nattribute vec2 attribute_uv0;\nvec3 e_position = vec3(0.0, 0.0, 0.0);\nvec3 e_normal = vec3(0.0, 0.0, 0.0);\nuniform mat4 uniform_ModelMatrix ;\nuniform mat4 uniform_ViewMatrix ;\nuniform mat4 uniform_ProjectionMatrix ;\nvarying vec3 varying_eyeNormal  ;\nvarying vec2 varying_uv0;\nvarying vec4 varying_color;\nvec4 outPosition ;\nmat4 rotVertexMatrix;\nmat4 transpose(mat4 inMatrix) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n    mat4 outMatrix = mat4(\n                 vec4(i0.x, i1.x, i2.x, i3.x),\n                 vec4(i0.y, i1.y, i2.y, i3.y),\n                 vec4(i0.z, i1.z, i2.z, i3.z),\n                 vec4(i0.w, i1.w, i2.w, i3.w)\n                 );\n    return outMatrix;\n}\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\nvoid main(void){\n\te_position = attribute_position;\n\te_normal = attribute_normal;\n\tvarying_color = attribute_color;\n\tvarying_uv0 = attribute_uv0;\n}",
            bezier: "vec2 quadratic_bezier(vec2 A, vec2 B, vec2 C, float t)\n{\n    vec2 D = mix(A, B, t);\n    vec2 E = mix(B, C, t); \n    return mix(D, E, t);\n}\nvec2 cubic_bezier(vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    vec2 E = mix(A, B, t);\n    vec2 F = mix(B, C, t);\n    vec2 G = mix(C, D, t);\n    return quadratic_bezier(E, F, G, t);\n}",
            bloom_fs: "varying vec2 varying_uv0; \nuniform sampler2D diffuseTexture; \nuniform float bloom_amount = 0.15;\nvoid main(void) { \n\tvec2 uv = vec2( varying_uv0.x , 1.0-varying_uv0.y );\n\tvec4 color = texture2D(diffuseTexture, uv); \n  \tvec4 sum = vec4(0), add = vec4(0), val = texture2D(diffuseTexture, uv);\n  \n        for( int i = -4 ; i < 4; i++) {\n             for ( int j = -4; j < 4; j++) {\n                 add += texture2D(diffuseTexture, uv + vec2(j, i)*0.002) * bloom_amount;\n             }\n        }\n\tif (val.r < 0.2) { sum = add*add*0.012 + val; } else \n\tif (val.r < 0.5) { sum = add*add*0.009 + val; } else {\n      sum = add*add*0.0075 + val;\n  }\n\tgl_FragColor = vec4(sum.rgb, 1.0);\n}",
            colorCorrectionRamp_fs: "precision highp float;            \t\nvarying vec2 varying_uv0; \nuniform float saturation; \nuniform sampler2D diffuseTexture; \nuniform sampler2D lutTexture; \nfloat Luminance( vec3 c ){ \nreturn dot( c , vec3(0.22,0.707,0.071) ); \n}\nvoid main() \n{ \nvec2 uv = varying_uv0 ; \nvec4 color = texture2D(diffuseTexture, uv); \nfloat red = texture2D(lutTexture, color.rr).r ;\nfloat green = texture2D(lutTexture,color.gg ).g ;\nfloat blue = texture2D(lutTexture, color.bb ).b ;\ncolor = vec4(red,green,blue, color.a); \ngl_FragColor = color ; \n}",
            colorCorrection_fs: "varying vec2 varying_uv0;\nuniform sampler2D diffuseTexture;\nuniform sampler2D lutTexture;\nuniform float saturation ;\nfloat Luminance( vec3 c ){\n    return dot( c , vec3(0.22,0.707,0.071) );\n}\nvoid main()\n{\n     vec2 uv = varying_uv0 ; \n\t vec4 color = texture2D(diffuseTexture, uv); \n\t\t\n\t vec3 red = texture2D(lutTexture, vec2(color.r, 0.5/4.0)).rgb * vec3(1.0,0.0,0.0);\n\t vec3 green = texture2D(lutTexture, vec2(color.g, 1.5/4.0)).rgb * vec3(0.0,1.0,0.0);\n\t vec3 blue = texture2D(lutTexture, vec2(color.b, 2.5/4.0)).rgb * vec3(0.0,0.0,1.0);\n\t \n\t color = vec4(red+green+blue, color.a);\n\t float lum = Luminance(color.rgb);\n     gl_FragColor = color ;\n}",
            colorGradients_fs: "varying vec4 varying_mvPose;\nuniform float uniform_colorGradientsSource[6] ;\nvoid main(void){\n\tfloat posStartY = uniform_colorGradientsSource[0]; \n\tfloat posEndY = uniform_colorGradientsSource[1]; \n\tvec4 color = vec4(uniform_colorGradientsSource[2], uniform_colorGradientsSource[3], uniform_colorGradientsSource[4], uniform_colorGradientsSource[5]); \n\tcolor.w *= clamp((varying_mvPose.y - posStartY) / (posEndY - posStartY), 0.0, 1.0); \n\tcolor.xyz *= color.w;\n\toutColor.xyz = outColor.xyz * (1.0 - color.w) + color.xyz * color.w; \n\t\n}\n ",
            colorPassEnd_fs: "void main() {\n\t gl_FragColor = vec4(diffuseColor.xyz,1.0);\n}",
            colorTransform_fs: "uniform float uniform_colorTransformAlpha ;\nuniform mat4 uniform_colorTransformM44 ;\nvoid main(){\n\tdiffuseColor.xyz = (uniform_colorTransformM44 * vec4(diffuseColor.xyz, 1.0)).xyz;\n\tdiffuseColor.w *= diffuseColor.w * uniform_colorTransformAlpha;\n}\n",
            color_fragment: "void main() {\n\ts.Albedo.xyz = vec3(1.0, 1.0, 1.0);\n\ts.Alpha = 1.0 ; \n  \n\tif( varying_color.w < materialSource.cutAlpha ){ \n\t\tdiscard; \n\t}\n}",
            combin_fs: "uniform sampler2D colorTexture;\nvoid main(void){\n}",
            cube_fragment: "uniform samplerCube diffuseTexture3D ;\nvarying vec3 varying_pos;\nvec4 diffuseColor ;\nvoid main() {\n    if( diffuseColor.w == 0.0 ){\n\t\tdiscard;\n\t}\n\tvec3 uvw = normalize(varying_pos.xyz);\n\tdiffuseColor = vec4(textureCube(diffuseTexture3D, uvw.xyz));\n    \n    if( diffuseColor.w < materialSource.cutAlpha ){\n\t\tdiscard;\n\t}else\n\t\tdiffuseColor.xyz *= diffuseColor.w ;\n}",
            cube_vertex: "varying vec3 varying_pos;\nvoid main(void){\n   varying_pos =  e_position;\n} ",
            detail_Bending_vs: "uniform float uniformTime[4] ;\nvoid main(void){\n\te_position = attribute_position; \nvarying_uv0 = attribute_uv0; \n  \n  varying_color = attribute_color; \nvec4 curve = SmoothTriangleWave(vec4(sin(uniformTime[0]*0.001),1.0,1.0,1.0));\n e_position.xyz += curve.x * vec3(1.0,0.5,0.0) * ( attribute_color.xyz) ;\n}",
            diffuse_fragment: "uniform sampler2D diffuseTexture;\nvarying vec4 varying_mvPose;\nvoid main() {\n  \tvec3 fc = vec3(0.0, 0.0, 0.0);\n\tvec4 c = texture2D( diffuseTexture , uv_0 );\n\tc.a = materialSource.alpha * c.a;\n    c.xyz = c.xyz * materialSource.diffuse * c.a ; \n\tif (c.a < materialSource.cutAlpha)\n\t\tdiscard;\n\tif(materialSource.refraction<2.41){ \n       float vl = dot(normal,-normalize(varying_mvPose.xyz)); \n       fc = Fresnel_Schlick(vl,vec3(materialSource.refraction)) * materialSource.refractionintensity ; \n       fc.xyz = max(fc,vec3(0.0)) ; \n    } \n\ts.Normal = normal;\n\ts.Specular = vec4(1.0) ;\n\ts.Albedo = c.rgb + fc.xyz * c.rgb + materialSource.ambient * c.rgb;\n    s.Albedo.x = pow(s.Albedo.x, materialSource.gamma);\n    s.Albedo.y = pow(s.Albedo.y, materialSource.gamma);\n    s.Albedo.z = pow(s.Albedo.z, materialSource.gamma);\n\ts.Alpha = c.a;\n\toutColor.xyz = s.Albedo * 0.5 ;\n\toutColor.w = s.Alpha;\n}\n",
            diffuse_vertex: "attribute vec3 attribute_normal;\nattribute vec4 attribute_color;\nvarying vec4 varying_mvPose; \nvoid main(void){\n    \n    mat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix); \n    \n    varying_mvPose = mvMatrix * vec4( e_position , 1.0 )  ; \n    \n    mat4 normalMatrix = inverse(mvMatrix) ;\n    normalMatrix = transpose(normalMatrix); \n    \n    varying_eyeNormal = mat3(normalMatrix) * -attribute_normal ; \n    \n    outPosition = varying_mvPose ; \n    varying_color = attribute_color; \n    \n}\n",
            directLight_fragment: "const int max_directLight = 0 ;\nuniform float uniform_directLightSource[10*max_directLight] ;\nvarying vec4 varying_mvPose; \nuniform mat4 uniform_ViewMatrix;\nmat4 normalMatrix ;\nstruct DirectLight{\n    vec3 direction;\n\tvec3 diffuse;\n\tvec3 ambient;\n    float intensity;\n};\nmat4 transpose(mat4 inMatrix) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n    mat4 outMatrix = mat4(\n                 vec4(i0.x, i1.x, i2.x, i3.x),\n                 vec4(i0.y, i1.y, i2.y, i3.y),\n                 vec4(i0.z, i1.z, i2.z, i3.z),\n                 vec4(i0.w, i1.w, i2.w, i3.w)\n                 );\n    return outMatrix;\n}\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\nvec4 calculateDirectLight( MaterialSource materialSource ){ \n    float lambertTerm , specular ; \n    vec3 dir ,viewDir = normalize(varying_mvPose.xyz/varying_mvPose.w); \n    diffuseColor = vec4(0.0,0.0,0.0,1.0);\n    for(int i = 0 ; i < max_directLight ; i++){ \n        DirectLight directLight ; \n        directLight.direction = (normalMatrix * vec4(uniform_directLightSource[i*9],uniform_directLightSource[i*9+1],uniform_directLightSource[i*9+2],1.0)).xyz; \n\t\tdirectLight.diffuse = vec3(uniform_directLightSource[i*9+3],uniform_directLightSource[i*9+4],uniform_directLightSource[i*9+5]); \n\t\tdirectLight.ambient = vec3(uniform_directLightSource[i*9+6],uniform_directLightSource[i*9+7],uniform_directLightSource[i*9+8]); \n\t\tdirectLight.intensity = uniform_directLightSource[i*9+9] ; \n\t\tdir = normalize(directLight.direction) ; \n\t\tdiffuseColor += LightingBlinnPhong(dir,directLight.diffuse,directLight.ambient,s.Normal,viewDir,directLight.intensity); \n    } \n    return diffuseColor ;\n}\nvoid main() {\n\tnormalMatrix = inverse(uniform_ViewMatrix);\n\tnormalMatrix = transpose(normalMatrix);\n\tlight += calculateDirectLight( materialSource ).xyzw ; \n}\n",
            endShadowPass_fs: "void main() {\n    if(varying_color.w<=0.0){\n       discard;\n    }\n    outColor.x =  outColor.y = outColor.z = varying_ViewPose.z/varying_ViewPose.w  ;\n    outColor.w = 1.0 ;\n    gl_FragColor = outColor ;\n}\n",
            endShadowPass_vs: "void main() {\n\t outPosition = uniform_ProjectionMatrix * outPosition ;\n     gl_Position = outPosition ;\n}\n                      ",
            end_fs: "varying vec4 varying_mvPose; \nvec4 diffuseColor ;\nvec4 specularColor ;\nvec4 ambientColor;\nvec4 light ;\nvoid main() {\n\tif(light.w < 0.0 ){\n\t   outColor.xyz = s.Albedo.xyz ; \n\t}else{\n\t   outColor.xyzw = light ; \n\t}\n    outColor.xyzw *= varying_color.xyzw;\n}\n",
            end_vs: "vec4 endPosition ;\nuniform float uniform_materialSource[20];\nvoid main() {\n\t gl_PointSize = uniform_materialSource[17];\n     outPosition = uniform_ProjectionMatrix * outPosition ;\n}\n                      ",
            environmentDiffuse_vertex: "\nvoid main(){\n}\n",
            environmentMapping_fragment: "uniform samplerCube environmentMapTex ;\nuniform float reflectValue;\nvarying vec3 varying_ViewDir ;\nvoid main(){\n\t vec3 N = normalize(normal);\n\tvec3 V = normalize(varying_mvPose.xyz/varying_mvPose.w);\n\tfloat dotNV = clamp(dot(N,V), 0.0, 1.0);\tfloat FV = pow((1.0 - dotNV), 2.0);\n\t\n\tmat4 invViewMatrix = inverse(uniform_ViewMatrix);\n\tvec3 ecReflected = reflect(normalize(varying_ViewDir.xyz), normalize(mat3(invViewMatrix)*normal));\tvec4 reflectiveColor = textureCube(environmentMapTex,-normalize(ecReflected.xyz)); \n\tdiffuseColor.xyz = mix( diffuseColor.xyz,reflectiveColor.xyz, reflectValue + FV );  \n\t\n}\n         ",
            expFog_fs: "struct Fog{\n   vec3 fogColor  ;\n   float globalDensity ;\n   vec3 distance ;\n};\nvarying vec4 varying_pos;\nuniform float uniform_globalFog[7];\nvoid main(void){\n    Fog fog; \n    fog.fogColor = vec3(uniform_globalFog[0],uniform_globalFog[1],uniform_globalFog[2]); \n    fog.globalDensity = uniform_globalFog[3]; \n    fog.distance = vec2(uniform_globalFog[4], uniform_globalFog[5]); \n    float d = distance(uniform_eyepos,varying_pos.xyz); \n    float distFog = max( 0.0 , d - fog.distance.x )* fog.distance.y; \n    float fogFactor = (1.0-exp( -distFog * 0.000001 * fog.globalDensity )) ; \n    diffuseColor.xyz = mix( diffuseColor.xyz  , fog.fogColor , min(fogFactor,1.0) ); \n}\n ",
            expHeightFog_fs: "struct Fog{\n   vec3 fogColor  ;\n   float globalDensity ;\n   float fogStartDistance ;\n   float fogHeightStart ;\n   float fogAlpha ;\n};\nvarying vec4 varying_pos;\nuniform float uniform_globalFog[7];\nvec3 applyFog( float yDistance, vec3  vpos , Fog fog ) \n{\n    float d = distance(uniform_eyepos,varying_pos.xyz); \n    float distFog = max( 0.0 , d - fog.fogStartDistance ) ; \n    float yFog = max(0.0, (vpos.y - fog.fogHeightStart - yDistance) )  ; \n    float fogAmount =  1.0-(exp(-distFog * fog.globalDensity )) + (exp(-yFog * fog.globalDensity )); \n    return mix( diffuseColor.xyz,fog.fogColor, clamp(fogAmount,0.0,fog.fogAlpha) );\n}\n \nvoid main(void){\n    Fog fog; \n    fog.fogColor = vec3(uniform_globalFog[0],uniform_globalFog[1],uniform_globalFog[2]); \n    fog.globalDensity = uniform_globalFog[3]; \n    fog.fogStartDistance = uniform_globalFog[4] ; \n    fog.fogHeightStart = uniform_globalFog[5] ;\n    fog.fogAlpha = uniform_globalFog[6] ; \n    fog.fogColor *= diffuseColor.w;\n    float yd = uniform_eyepos.y - varying_pos.y ;\n    diffuseColor.xyz = applyFog( yd , varying_pos.xyz , fog );\n}\n ",
            flatNormal_fs: "#extension GL_OES_standard_derivatives : enable\nvec3 flatNormal(vec3 pos){\n    vec3 fdx = dFdx(pos);\n    vec3 fdy = dFdy(pos);\n    return normalize(cross(fdx, fdy));\n}",
            gamma_fs: "\nconst float gamma = 2.2;\nfloat toLinear_float_v1(float v) {\n  return pow(v, gamma);\n}\nvec2 toLinear_vec2_v1(vec2 v) {\n  return pow(v, vec2(gamma));\n}\nvec3 toLinear_vec3_v1(vec3 v) {\n  return pow(v, vec3(gamma));\n}\nvec4 toLinear_vec4_v1(vec4 v) {\n  return vec4(toLinear_vec3_v1(v.rgb), v.a);\n}\nfloat toGamma_float_v2(float v) {\n  return pow(v, 1.0 / gamma);\n}\nvec2 toGamma_vec2_v2(vec2 v) {\n  return pow(v, vec2(1.0 / gamma));\n}\nvec3 toGamma_vec3_v2(vec3 v) {\n  return pow(v, vec3(1.0 / gamma));\n}\nvec4 toGamma_vec4_v2(vec4 v) {\n  return vec4(toGamma_vec3_v2(v.rgb), v.a);\n}\nvec4 textureLinear(sampler2D uTex, vec2 uv) {\n  return toLinear_vec4_v1(texture2D(uTex, uv));\n}",
            gaussian_H_fs: "varying vec2 varying_uv0;\nuniform sampler2D diffuseTexture;\nvec4 blur9_1_0(sampler2D image, vec2 uv, float radius , float resolution, vec2 dir) {\n    vec4 color = vec4(0.0);\n    vec2 tc = uv;\n    float blur = radius/resolution ; \n    float hstep = dir.x;\n    float vstep = dir.y;\n    color += texture2D(image, vec2(tc.x - 4.0*blur*hstep, tc.y - 4.0*blur*vstep)) * 0.0162162162;\n    color += texture2D(image, vec2(tc.x - 3.0*blur*hstep, tc.y - 3.0*blur*vstep)) * 0.0540540541;\n    color += texture2D(image, vec2(tc.x - 2.0*blur*hstep, tc.y - 2.0*blur*vstep)) * 0.1216216216;\n    color += texture2D(image, vec2(tc.x - 1.0*blur*hstep, tc.y - 1.0*blur*vstep)) * 0.1945945946;\n    color += texture2D(image, vec2(tc.x, tc.y)) * 0.2270270270;\n    color += texture2D(image, vec2(tc.x + 1.0*blur*hstep, tc.y + 1.0*blur*vstep)) * 0.1945945946;\n    color += texture2D(image, vec2(tc.x + 2.0*blur*hstep, tc.y + 2.0*blur*vstep)) * 0.1216216216;\n    color += texture2D(image, vec2(tc.x + 3.0*blur*hstep, tc.y + 3.0*blur*vstep)) * 0.0540540541;\n    color += texture2D(image, vec2(tc.x + 4.0*blur*hstep, tc.y + 4.0*blur*vstep)) * 0.0162162162;\n  return color;\n}\nvoid main(void) { \n\tvec4 color = vec4(0.0,0.0,0.0,0.0); \n\tcolor =blur9_1_0(diffuseTexture,varying_uv0,3.0,2048.0,vec2(0.0,1.0));\n\tgl_FragColor  = color; \n}",
            gaussian_V_fs: "varying vec2 varying_uv0;\nuniform sampler2D diffuseTexture;\nuniform sampler2D colorTexture;\nvec4 blur9_1_0(sampler2D image, vec2 uv, float radius , float resolution, vec2 dir) {\n    vec4 color = vec4(0.0);\n    vec2 tc = uv;\n    float blur = radius/resolution ; \n    float hstep = dir.x;\n    float vstep = dir.y;\n    color += texture2D(image, vec2(tc.x - 4.0*blur*hstep, tc.y - 4.0*blur*vstep)) * 0.0162162162;\n    color += texture2D(image, vec2(tc.x - 3.0*blur*hstep, tc.y - 3.0*blur*vstep)) * 0.0540540541;\n    color += texture2D(image, vec2(tc.x - 2.0*blur*hstep, tc.y - 2.0*blur*vstep)) * 0.1216216216;\n    color += texture2D(image, vec2(tc.x - 1.0*blur*hstep, tc.y - 1.0*blur*vstep)) * 0.1945945946;\n    color += texture2D(image, vec2(tc.x, tc.y)) * 0.2270270270;\n    color += texture2D(image, vec2(tc.x + 1.0*blur*hstep, tc.y + 1.0*blur*vstep)) * 0.1945945946;\n    color += texture2D(image, vec2(tc.x + 2.0*blur*hstep, tc.y + 2.0*blur*vstep)) * 0.1216216216;\n    color += texture2D(image, vec2(tc.x + 3.0*blur*hstep, tc.y + 3.0*blur*vstep)) * 0.0540540541;\n    color += texture2D(image, vec2(tc.x + 4.0*blur*hstep, tc.y + 4.0*blur*vstep)) * 0.0162162162;\n  return color;\n}\nvoid main(void) { \n\tvec4 color = vec4(0.0,0.0,0.0,0.0); \n\tvec2 uv = vec2(varying_uv0.x,1.0-varying_uv0.y);\n\tcolor = blur9_1_0(diffuseTexture,varying_uv0,3.0,2048.0,vec2(1.0,0.0));\n\tcolor += texture2D(colorTexture,uv);\n\tgl_FragColor  = color; \n}",
            grass_fs: "uniform float uniform_lightMap_data[5];\nuniform sampler2D diffuseTexture;\nuniform sampler2D lightMapTexture;\nvarying vec4 varying_scenePose;\nvec4 diffuseColor;\nvoid main() {\n\tvec2 lightUV;\n\tdiffuseColor = texture2D(diffuseTexture, varying_uv0);\n\tif( diffuseColor.w < materialSource.cutAlpha ){\n\t\tdiscard;\n\t}\n\tif(uniform_lightMap_data[0] > 0.5){\n\t\tlightUV.x = (varying_scenePose.x + uniform_lightMap_data[1]) / uniform_lightMap_data[3]; \n\t\tlightUV.y = (varying_scenePose.z + uniform_lightMap_data[2]) / uniform_lightMap_data[4]; \n\t\tdiffuseColor *= texture2D(lightMapTexture, lightUV); \n\t}\n\toutColor = diffuseColor;\n}",
            grass_vs: "attribute vec3 attribute_grassOffset;\nattribute float attribute_grassAngleY;\nuniform float uniform_grass_data[9];\nuniform float uniform_squeeze_data[6];\nuniform float uniform_lightMap_data[5];\nuniform mat4 uniform_cameraMatrix;\nuniform mat4 uniform_billboardMatrix;\nvarying vec4 varying_mvPose; \nvarying vec4 varying_scenePose;\nconst float TrueOrFalse = 0.5;\nconst float PI_2 = 6.283;\nstruct SqueezeData{\n\tfloat enable;\n\tvec3 position;\n\tfloat strength;\n\tfloat radius;\n};\nSqueezeData squeezeData;\nmat4 buildRotMat4(vec3 rot)\n{\n\tfloat s;\n\tfloat c;\n\ts = sin(rot.x);\n\tc = cos(rot.x);\n\t\n\tmat4 ret = mat4(\n\tvec4(1.0, 0.0, 0.0, 0.0),\n\tvec4(0.0, c, s, 0.0),\n\tvec4(0.0, -s, c, 0.0),\n\tvec4(0.0, 0.0, 0.0, 1.0)\n\t);\n\t\n\ts = sin(rot.y);\n\tc = cos(rot.y);\n\t\n\tret = mat4(\n\tvec4(c, 0.0, -s, 0.0),\n\tvec4(0.0, 1.0, 0.0, 0.0),\n\tvec4(s, 0.0, c, 0.0),\n\tvec4(0.0, 0.0, 0.0, 1.0)\n\t) * ret;\n\ts = sin(rot.z);\n\tc = cos(rot.z);\n\tret = mat4(\n\tvec4(c, s, 0.0, 0.0),\n\tvec4(-s, c, 0.0, 0.0),\n\tvec4(0.0, 0.0, 1.0, 0.0),\n\tvec4(0.0, 0.0, 0.0, 1.0)\n\t) * ret;\n\treturn ret;\n}\nvec4 buildQuat(vec3 axis, float angle){\n  axis = normalize(axis);\n  vec4 ret;\n  \n  float halfAngle = angle * 0.5;\n  float sin_a = sin(angle);\n  ret.w = cos(halfAngle);\n  ret.x = axis.x * sin_a;\n  ret.y = axis.y * sin_a;\n  ret.z = axis.z * sin_a;\n  \n  ret = normalize(ret);\n  return ret;\n}\nmat4 buildMat4Quat(vec4 quat)\n{\n\tfloat xx = quat.x * quat.x;\n\tfloat xy = quat.x * quat.y;\n\tfloat xz = quat.x * quat.z;\n\tfloat xw = quat.x * quat.w;\n\tfloat yy = quat.y * quat.y;\n\tfloat yz = quat.y * quat.z;\n\tfloat yw = quat.y * quat.w;\n\tfloat zz = quat.z * quat.z;\n\tfloat zw = quat.z * quat.w;\n\treturn mat4(\n\t\t1.0 - 2.0 * (yy + zz),\t\t2.0 * (xy + zw),\t\t2.0 * (xz - yw),\t\t0,\n\t\t2.0 * (xy - zw),\t\t\t\t1.0 - 2.0 * (xx + zz),\t2.0 * (yz + xw),\t\t0,\n\t\t2.0 * (xz + yw),\t\t\t\t2.0 * (yz - xw),\t\t1.0 - 2.0 * (xx + yy),\t0,\n\t\t0.0,\t\t\t\t\t\t\t0.0,\t\t\t\t\t0.0,\t\t\t\t\t1\n\t);\n}\nvoid main(void){\n\t\n\tif(uniform_grass_data[8] > TrueOrFalse){\n\t\trotVertexMatrix = uniform_billboardMatrix;\n\t}else{\n\t\trotVertexMatrix = buildRotMat4(vec3(0.0, attribute_grassAngleY, 0.0));\n\t}\n\te_position.xyz = (rotVertexMatrix * vec4(e_position, 1.0)).xyz;\n\te_normal.xyz = (rotVertexMatrix * vec4(e_normal, 1.0)).xyz;\n\tif(e_position.y > 0.0){ \n\t\tfloat windDirectionX\t\t\t= uniform_grass_data[0];\n\t\tfloat windDirectionZ\t\t\t= uniform_grass_data[1];\n\t\tfloat windSpaceX\t\t\t\t= uniform_grass_data[2];\n\t\tfloat windSpaceZ\t\t\t\t= uniform_grass_data[3];\n\t\tfloat windStrength\t\t\t\t= uniform_grass_data[4];\n\t\tfloat windSpeed\t\t\t\t\t= uniform_grass_data[5];\n\t\tfloat shakeScale\t\t\t\t= uniform_grass_data[6];\n\t\tfloat grassTime\t\t\t\t\t= uniform_grass_data[7];\n\t\tsqueezeData.enable\t\t\t= uniform_squeeze_data[0];\n\t\tsqueezeData.position.x\t\t= uniform_squeeze_data[1];\n\t\tsqueezeData.position.y\t\t= uniform_squeeze_data[2];\n\t\tsqueezeData.position.z\t\t= uniform_squeeze_data[3];\n\t\tsqueezeData.radius\t\t\t= uniform_squeeze_data[4];\n\t\tsqueezeData.strength\t\t= uniform_squeeze_data[5];\n\t\twindSpaceX = PI_2 * (attribute_grassOffset.x + abs(windDirectionX) * windSpeed * grassTime) / windSpaceX;\n\t\twindSpaceZ = PI_2 * (attribute_grassOffset.z + abs(windDirectionZ) * windSpeed * grassTime) / windSpaceZ;\n\t\t\n\t\tfloat angle = sin(windSpaceX + windSpaceZ) * shakeScale + windStrength;\n\t\tangle = clamp(angle, -1.57, 1.57);\n    \n\t\tvec3 windDir = vec3(windSpaceX, 0.0, windSpaceZ);\n\t\tvec3 windDirY = vec3(0.0, 1.0, 0.0);\n\t\twindDir = normalize(windDir);\n    \n\t\tvec3 axis = cross(windDirY,windDir); \n\t\tvec4 quat = buildQuat(axis, angle);\n\t\tmat4 matrix = buildMat4Quat(quat);\n    \n\t\tvec2 orgXZ = vec2(e_position.x, e_position.z);\n\t\te_position.x = e_position.z = 0.0;\n\t\te_position = (matrix * vec4(e_position, 1.0)).xyz;\n   \n\t\te_position.xz += orgXZ;\n\t\tif(squeezeData.enable > TrueOrFalse){\n\t\t\tvec3 distanceVec3 = squeezeData.position - attribute_grassOffset;\n\t\t\tvec2 distance2D = vec2(distanceVec3.x, distanceVec3.z);\n\t\t\tfloat distanceFloat = sqrt(dot(distance2D, distance2D));\n\t\t\tif(distanceFloat < squeezeData.radius){\n\t\t\t\tfloat ratio = distanceFloat / squeezeData.radius;\n\t\t\t\tratio = 1.0 - ratio;\n\t\t\t\tdistanceVec3 = normalize(distanceVec3);\n\t\t\t\tdistanceVec3 *= squeezeData.strength * ratio * abs(e_position.y - squeezeData.position.y);\n\t\t\t\te_position -= distanceVec3;\n\t\t\t}\n\t\t}\n\t}\n\te_position += attribute_grassOffset;\n\tmat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix);\n\tvarying_mvPose = outPosition = mvMatrix * vec4( e_position , 1.0 ); \n    varying_scenePose = vec4( e_position, 1.0 );\n    mat4 normalMatrix = inverse(mvMatrix) ;\n    normalMatrix = transpose(normalMatrix); \n    varying_eyeNormal = mat3(normalMatrix) * - e_normal; \n    varying_color = attribute_color; \n    \n}\n",
            gui_fs: "varying vec4 varying_uv; \nvarying vec4 varying_color; \nvarying vec4 varying_pos; \nvarying vec4 varying_mask; \nvec4 diffuseColor; \nuniform sampler2D uiTexture_0; \nuniform sampler2D uiTexture_1; \nuniform sampler2D uiTexture_2; \nuniform sampler2D uiTexture_3; \nuniform sampler2D uiTexture_4; \nuniform sampler2D uiTexture_5; \nuniform sampler2D uiTexture_6; \nconst int FLAG_VALLID_QUAD = 0;\nconst int FLAG_IS_VISIBLE = 1;\nconst int FLAG_HAS_MASK = 2;\nconst int FLAG_HAS_TEXTURE = 3;\nconst int FLAG_IS_TEXTFIELD = 4;\nbool booleanArray[5];\nvoid decodeBooleanArray(float data){\n\tfloat headData;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[0] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[1] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[2] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[3] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[4] = (headData - data) > 0.2;\n}\nvoid main(void){\n\tdecodeBooleanArray(varying_pos.w);\n\t\n\t\n\tif(booleanArray[FLAG_VALLID_QUAD] == false || booleanArray[FLAG_IS_VISIBLE] == false || booleanArray[FLAG_HAS_TEXTURE] == false){\n\t\tdiscard;\n\t}\n\tif(booleanArray[FLAG_HAS_MASK]){\n      vec4 mask = varying_mask;\n      if( (2.0*mask.x-1.0) > varying_pos.x){ \n\t\tdiscard; \n      } \n      if( (-2.0*mask.y+1.0) < varying_pos.y){\n\t\tdiscard; \n      }\n      if( (2.0*mask.z-1.0) < varying_pos.x){\n\t\tdiscard; \n      }\n      if( (-2.0*mask.w+1.0) > varying_pos.y){\n\t\tdiscard; \n      }\n\t}\n\tvec2 uv = varying_uv.xy ;\n\tint index = int(floor(varying_pos.z)); \n\tif(booleanArray[FLAG_HAS_TEXTURE] == false){\n\t\tdiffuseColor = vec4(1.0, 1.0, 1.0, 1.0);\t}\n\telse{\n\t\tif(index==0){\n\t\t\tdiffuseColor = texture2D(uiTexture_0, uv ); \n\t\t}\n\t\telse if(index==1){\n\t\t\tdiffuseColor = texture2D(uiTexture_1, uv ); \n\t\t}\n\t\telse if(index==2){\n\t\t\tdiffuseColor = texture2D(uiTexture_2, uv ); \n\t\t}\n\t\telse if(index==3){\n\t\t\tdiffuseColor = texture2D(uiTexture_3, uv ); \n\t\t}\n\t\telse if(index==4){\n\t\t\tdiffuseColor = texture2D(uiTexture_4, uv ); \n\t\t}\n\t\telse if(index==5){\n\t\t\tdiffuseColor = texture2D(uiTexture_5, uv ); \n\t\t}\n\t\telse if(index==6){\n\t\t\tdiffuseColor = texture2D(uiTexture_6, uv ); \n\t\t}\n\t\tif(booleanArray[FLAG_IS_TEXTFIELD]){\n\t\t\tint clrChannel = int(uv.x);\n\t\t\tuv.x -= float(clrChannel);\n\t\t\tfloat fontAlpha = 1.0;\n\t\t\tif(clrChannel == 0){\n\t\t\t\tfontAlpha = diffuseColor.x;\n\t\t\t}else if(clrChannel == 1){\n\t\t\t\tfontAlpha = diffuseColor.y;\n\t\t\t} else if(clrChannel == 2){\n\t\t\t\tfontAlpha = diffuseColor.z;\n\t\t\t}else if(clrChannel == 3){\n\t\t\t\tfontAlpha = diffuseColor.w;\n\t\t\t}\n\t\t\tif(fontAlpha > 0.9){\n\t\t\t\tfontAlpha = 1.0;\n\t\t\t}\n\t\t\tdiffuseColor = vec4(1.0, 1.0, 1.0, fontAlpha);\n\t\t}\n\t}\n \n\tif(diffuseColor.w < 0.01 || varying_color.w < 0.01){\n\t\tdiscard;\n\t}\n\tdiffuseColor.xyz *= varying_color.xyz;\n\tdiffuseColor.w *= varying_color.w;\n\tdiffuseColor.xyz *= diffuseColor.w;\n\tdiffuseColor = clamp(diffuseColor, 0.0, 1.0); \n\tgl_FragColor = diffuseColor; \n}",
            gui_vs: "attribute vec4 attribute_position; \nattribute vec4 attribute_shapePosition; \nattribute vec4 attribute_uvRec; \nattribute vec4 attribute_rotate; \nattribute vec4 attribute_maskRectangle; \nattribute vec4 attribute_quad_color; \nvarying vec4 varying_uv; \nvarying vec4 varying_color; \nvarying vec4 varying_pos; \nvarying vec4 varying_mask; \nvarying float varying_boolList;\nvec4 outPosition; \nuniform mat4 uniform_ModelMatrix; \nuniform mat4 uniform_ViewMatrix; \nuniform mat4 uniform_ProjectionMatrix; \nuniform mat4 uniform_orthProjectMatrix; \nuniform float uniform_materialSource[20]; \nmat4 buildMat4Quat(vec4 quat){ \nfloat xx = quat.x * quat.x; \nfloat xy = quat.x * quat.y; \nfloat xz = quat.x * quat.z; \nfloat xw = quat.x * quat.w; \nfloat yy = quat.y * quat.y; \nfloat yz = quat.y * quat.z; \nfloat yw = quat.y * quat.w; \nfloat zz = quat.z * quat.z; \nfloat zw = quat.z * quat.w; \nreturn mat4( \n1.0 - 2.0 * (yy + zz),\t\t2.0 * (xy + zw),\t\t2.0 * (xz - yw),\t\t0, \n2.0 * (xy - zw),\t\t\t\t1.0 - 2.0 * (xx + zz),\t2.0 * (yz + xw),\t\t0, \n2.0 * (xz + yw),\t\t\t\t2.0 * (yz - xw),\t\t1.0 - 2.0 * (xx + yy),\t0, \n0.0,\t\t\t\t\t\t\t0.0,\t\t\t\t\t0.0,\t\t\t\t\t1 \n); \n}\nconst int FLAG_VALLID_QUAD = 0;\nconst int FLAG_IS_VISIBLE = 1;\nconst int FLAG_HAS_MASK = 2;\nconst int FLAG_HAS_TEXTURE = 3;\nconst int FLAG_IS_TEXTFIELD = 4;\nbool booleanArray[5];\nvoid decodeBooleanArray(float data){\n\tfloat headData;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[0] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[1] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[2] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[3] = (headData - data) > 0.2;\n\tdata *= 0.5;\n\theadData = data;\n\tdata = floor(data);\n\tbooleanArray[4] = (headData - data) > 0.2;\n}\nvoid main(void){\n\tgl_PointSize = uniform_materialSource[18];\n\tvarying_pos.zw = attribute_shapePosition.zw;\n\tdecodeBooleanArray(attribute_shapePosition.w);\n\tif(booleanArray[FLAG_VALLID_QUAD] == false || booleanArray[FLAG_IS_VISIBLE] == false || booleanArray[FLAG_HAS_TEXTURE] == false){\n\t\toutPosition = vec4(0.0,0.0,0.0,1.0);\n\t\tgl_Position = outPosition; \n\t\treturn;\n\t}\n    float devicePixelRatio = 1.0;    mat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix); \n    mat4 po = buildMat4Quat(attribute_rotate.xyzw); \n    mat4 oth = uniform_orthProjectMatrix; \n    float px = oth[0].x ;\n    float py = oth[1].y ;\n    \n    oth[0].x = oth[0].x / devicePixelRatio ; \n    oth[1].y = oth[1].y / devicePixelRatio ; \n    \n    vec3 pos = mat3(po) * (attribute_position.xyz * vec3(attribute_uvRec.zw,1.0) ) + vec3(attribute_shapePosition.xy,1.0) ; \n    vec3 sceneWH = vec3( 1.0/ oth[0].x, -1.0/oth[1].y , 0.0 )  ; \n    outPosition = mvMatrix * vec4( pos - sceneWH , 1.0 ) ; \n    varying_color = attribute_quad_color ; \n    \n    outPosition = oth * outPosition ; \n\tvarying_pos.xy = outPosition.xy;\n    vec4 maskk = attribute_maskRectangle;\n    \n    sceneWH = vec3(2.0/px*devicePixelRatio,2.0/py*devicePixelRatio,1.0) ;\n    \n    varying_mask = vec4(maskk.xy/sceneWH.xy,(maskk.x+maskk.z)/sceneWH.x, (maskk.y+maskk.w)/(sceneWH.y)) ; \n    varying_uv = attribute_uvRec; \n\tgl_Position = outPosition; \n    \n}",
            hud_H_fs: "varying vec2 varying_uv0;\nuniform sampler2D diffuseTexture;\nvoid main(void) {\n\tvec2 uv = vec2(varying_uv0.x ,1.0-varying_uv0.y);\n\tvec4 color = texture2D(diffuseTexture, uv);\n\tgl_FragColor  = color;\n}\n",
            hud_V_fs: "varying vec2 varying_uv0;\nuniform sampler2D diffuseTexture;\nvoid main(void) {\n\tvec4 color = texture2D(diffuseTexture, varying_uv0);\n\tgl_FragColor  = color;\n}\n",
            hud_cull_fs: "varying vec2 varying_uv0;\nuniform sampler2D diffuseTexture;\nuniform vec2 uv_scale;\nvoid main(void) {\n\tvec2 uv_0 = varying_uv0;\n\tuv_0 *= uv_scale;\n\tvec4 color = texture2D(diffuseTexture, varying_uv0);\n\tfloat mask = 1.0;\n\tfloat f = uv_scale.y - varying_uv0.y;\n\tif (varying_uv0.y < uv_scale.y){\n\t\tif(f < 0.03 && f > 0.0){\n\t\t\tmask =1.0 - (f / 0.03 * 0.9 + 0.1);\n\t\t}\n\t\telse{\n\t\t\tmask = 0.1;\n\t\t}\n\t}\n\tcolor.xyz *= mask;\n\tgl_FragColor  = color;\n}\n",
            hud_vs: "attribute vec3 attribute_position;\nattribute vec2 attribute_uv0;\nvarying  vec2 varying_uv0;                      \nuniform  mat4 uniform_ViewProjectionMatrix;\nvoid main(void) {\n    vec4 pos = vec4(attribute_position, 1.0);\n    gl_Position = uniform_ViewProjectionMatrix * pos;\n    varying_uv0 = attribute_uv0;\n}",
            lightMapSpecularPower_fs: "uniform sampler2D lightTexture ;\nvarying vec2 varying_uv1 ;\nvec4 decode_hdr( vec4 data ){ \n    data.w = data.w * 255.0 - 128.0 ; \n    data.w = pow( 2.0 ,data.w); \n    data.xyz *= data.w ; \n    return data ; \n}\nvoid main(void){\n\tvec4 lightmap = texture2D( lightTexture , varying_uv1 );\n    lightmap.xyz = decode_hdr(lightmap).xyz ;\n\toutColor.xyz *= lightmap.xyz ;\n}\n ",
            lightMap_fs: "uniform sampler2D lightTexture ;\nvarying vec2 varying_uv1 ;\nvec4 decode_hdr( vec4 data ){ \n    data.w = data.w * 255.0 - 128.0 ; \n    data.w = pow( 2.0 ,data.w); \n    data.xyz *= data.w ; \n    return data ; \n}\nvoid main(void){\n\tvec4 lightmap = texture2D( lightTexture , varying_uv1 );\n\tlightmap.xyz = decode_hdr(lightmap).xyz  ;\n    outColor.xyz *= lightmap.xyz ; \n}\n",
            lightingBase_fs: "vec4 LightingBlinnPhong(vec3 lightDir, vec3 lightColor , vec3 lightAmbient , vec3 normal , vec3 viewDir, float atten){ \n\tvec3 h = normalize(lightDir + normalize(viewDir)); \n\tfloat diff = max(dot(normal, lightDir),0.0); \n\tfloat nh = max(dot(normal,h),0.0); \n\tfloat spec = pow(nh, materialSource.shininess ) * materialSource.specularScale ; \n\tvec4 c ; \n\tc.rgb = (s.Albedo * lightColor * diff + lightColor * materialSource.specular.rgb * s.Specular.rgb * spec) * (atten * 2.0); \n\tc.a = s.Alpha + spec * atten; \n\treturn c; \n}\nvoid main(void) {\n}\n",
            lineFog: " \nstruct Fog{\n   vec3 fogColor  ;\n   float globalDensity ;\n   float fogStartDistance ;\n   float fogFarDistance ;\n   float fogAlpha ;\n};\nuniform float uniform_globalFog[7];\nvarying vec4 varying_mvPose;\nvoid main(void){\n    Fog fog; \n    fog.fogColor = vec3(uniform_globalFog[0],uniform_globalFog[1],uniform_globalFog[2]); \n    fog.globalDensity = uniform_globalFog[3]; \n    fog.fogStartDistance = uniform_globalFog[4] ;\n    fog.fogFarDistance = uniform_globalFog[5] ;\n    fog.fogAlpha = uniform_globalFog[6] ;\n    \n\tfog.fogColor *= outColor.w;\n\tfloat d = varying_mvPose.z ; \n\tfloat distFog = max( 0.0 , d -  fog.fogStartDistance ) ; \n\toutColor.xyz = mix( outColor.xyz,fog.fogColor, clamp(distFog/fog.fogFarDistance,0.0,1.0) * fog.fogAlpha ) ; \n}\n",
            matCapPass_vs: "varying vec2 capCoord ;\nvoid main(void){\n        capCoord.x = dot(normalMatrix[0].xyz,normal);\n        capCoord.y = dot(normalMatrix[1].xyz,normal);\n        capCoord = capCoord * 0.5 + 0.5;\n        ambientColor.xyz +=  + capCoord.xyz * 2.0 - 1.0 ;\n}",
            matCap_TextureAdd_fs: "uniform sampler2D matcapTexture;\nvoid main() {\n  \tvec4 capCoord ; \n\tcapCoord.x = -normal.x; \n\tcapCoord.y = normal.y; \n\tcapCoord.xy = capCoord.xy * 0.5 + 0.5; \n\tcapCoord = texture2D(matcapTexture , capCoord.xy ) * 2.0 - 1.0 ; \n\tambientColor.xyz += capCoord.xyz ; \n}\n",
            matCap_TextureMult_fs: "uniform sampler2D matcapTexture;\nvoid main() {\n  \tvec4 capCoord ; \n\tcapCoord.x = -normal.x; \n\tcapCoord.y = normal.y; \n\tcapCoord.xy = capCoord.xy * 0.5 + 0.5; \n\tcapCoord = texture2D(matcapTexture , capCoord.xy ) ; \n\tdiffuseColor.xyz *= capCoord.xyz * 2.0 ; \n}\n",
            materialSource_fs: "struct MaterialSource{\n    vec3 diffuse;\n    vec3 ambient;\n    vec3 specular;\n    float alpha;\n    float cutAlpha;\n    float shininess;\n    float normalDir;\n    vec4 uvRectangle;\n    float gamma;\n    float specularScale;\n    float refraction;\n    float refractionintensity;\n}; \nuniform float uniform_materialSource[20] ;\nMaterialSource materialSource ;\nvec2 uv_0 ;\nvoid main(){\n\tmaterialSource.diffuse.x = uniform_materialSource[0];\n\tmaterialSource.diffuse.y = uniform_materialSource[1];\n\tmaterialSource.diffuse.z = uniform_materialSource[2];\n\t\n\tmaterialSource.ambient.x = uniform_materialSource[3];\n\tmaterialSource.ambient.y = uniform_materialSource[4];\n\tmaterialSource.ambient.z = uniform_materialSource[5];\n\t\n\tmaterialSource.specular.x = uniform_materialSource[6];\n\tmaterialSource.specular.y = uniform_materialSource[7];\n\tmaterialSource.specular.z = uniform_materialSource[8];\n\t\n\tmaterialSource.alpha = uniform_materialSource[9];\n\tmaterialSource.cutAlpha = uniform_materialSource[10];\n\tmaterialSource.shininess = uniform_materialSource[11];\n\tmaterialSource.specularScale = uniform_materialSource[12];\n\tmaterialSource.normalDir = 1.0 ;    \n\tmaterialSource.uvRectangle.x = uniform_materialSource[13];\n\tmaterialSource.uvRectangle.y = uniform_materialSource[14];\n\tmaterialSource.uvRectangle.z = uniform_materialSource[15];\n\tmaterialSource.uvRectangle.w = uniform_materialSource[16];\n\tmaterialSource.gamma = uniform_materialSource[17];\n\tmaterialSource.refraction = uniform_materialSource[18];\n\tmaterialSource.refractionintensity = uniform_materialSource[19];\n\tuv_0 = varying_uv0.xy * materialSource.uvRectangle.zw + materialSource.uvRectangle.xy ;\n}",
            mulUvRoll_fs: "uniform float mulUvRoll[4] ;\nuniform sampler2D diffuseTexture;\nuniform sampler2D diffuseTexture1;\nvec4 diffuseColor ;\nvec2 uv_1;\nvoid main() {\n\tuv_1 = varying_uv0;\n    uv_0.xy += vec2(mulUvRoll[0],mulUvRoll[1]);\n\tuv_1.xy += vec2(mulUvRoll[2],mulUvRoll[3]);\n\tdiffuseColor = texture2D(diffuseTexture , uv_0 ) * texture2D(diffuseTexture1 , uv_1 );\n\tdiffuseColor.xyz = clamp(diffuseColor.xyz / diffuseColor.w,0.0,1.0);\n}",
            normalMap_fragment: "uniform sampler2D normalTexture;\nvarying vec2 varying_uv0        ;\nvarying vec4 varying_mvPose        ;\nmat3 TBN ;\nmat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) {\n  vec3 dp1 = dFdx(p);\n  vec3 dp2 = dFdy(p);\n  vec2 duv1 = dFdx(uv);\n  vec2 duv2 = dFdy(uv);\n  vec3 dp2perp = cross(dp2, N);\n  vec3 dp1perp = cross(N, dp1);\n  vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n  vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n  float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));\n  return mat3(T * invmax, B * invmax, N);\n}\nvec3 tbn(vec3 map, vec3 N, vec3 V, vec2 texcoord) {\n  mat3 TBN = cotangentFrame(N, -V, texcoord);\n  return normalize(TBN * map);\n}\nvoid main(){\n   s.Normal = texture2D(normalTexture,uv_0).xyz *2.0 - 1.0; \n   s.Normal = tbn( s.Normal.xyz , normal.xyz , varying_mvPose.xyz , uv_0 ) ; \n}\n",
            normalPassEnd_fs: "void main() {\n    outColor = vec4(normal,1.0);\n}\n",
            outLine_fs: "uniform float uniform_ouline[5] ;\nvoid main(){\n     diffuseColor = vec4(uniform_ouline[1],\n                    uniform_ouline[2],\n                    uniform_ouline[3],\n                    uniform_ouline[4]) ;\n    outColor = diffuseColor; \n}",
            outLine_vs: "attribute vec3 attribute_normal;\nattribute vec4 attribute_color;\nvarying vec4 varying_mvPose; \nuniform float uniform_ouline[5] ;\nvoid main(void){\n    outPosition.xy -= normalize(varying_eyeNormal.xyz).xy * uniform_ouline[0]; \n}",
            out_fs: "void main(){\n    gl_FragColor = outColor;\n}",
            out_vs: "void main(){\n     gl_Position = outPosition ;\n}",
            particle_bezier: "float calcBezierArea(float bzData[35], float tCurrent, float tTotal){\n\tfloat res = 0.0;\n\tfloat v0;\n\tfloat v1;\n\tfloat t0;\n\tfloat t1;\n\tfloat deltaTime = 0.0;\n\tfloat a_deltaTime;\n\tfor(int i = 0; i < 16; i ++)\n\t{\n\t\tt0 = bzData[i * 2 + 0] * tTotal;\n\t\tv0 = bzData[i * 2 + 1];\n\t\tt1 = bzData[i * 2 + 2] * tTotal;\n\t\tv1 = bzData[i * 2 + 3];\n\t\tdeltaTime = t1 - t0;\n\t\t\ta_deltaTime = 0.5 * (v1 - v0);\n\t\t\tif(tCurrent >= t1)\n\t\t\t{\n\t\t\t\tres += deltaTime * (v0 + a_deltaTime);\n\t\t\t}else\n\t\t\t{\n\t\t\t\tdeltaTime = tCurrent - t0;\n\t\t\t\tres += deltaTime * (v0 + a_deltaTime);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn res;\n}\nfloat calcBezierSize(float bzData[35], float tCurrent, float tTotal){\n\tfloat res = 0.0;\n\tfloat y0;\n\tfloat y1;\n\tfloat t0;\n\tfloat t1;\n\tfloat deltaTime = 0.0;\n\tfloat v;\n\tfor(int i = 0; i < 16; i ++)\n\t{\n\t\tt0 = bzData[i * 2 + 0] * tTotal;\n\t\ty0 = bzData[i * 2 + 1];\n\t\tt1 = bzData[i * 2 + 2] * tTotal;\n\t\ty1 = bzData[i * 2 + 3];\n\t\tdeltaTime = t1 - t0;\n\t\t\tif(tCurrent <= t1)\n\t\t\t{\n\t\t\t\tv = (y1 - y0) / deltaTime;\n\t\t\t\tdeltaTime = tCurrent - t0;\n\t\t\t\tres = y0 + v * deltaTime;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn res;\n}\n",
            particle_bezier_low: "float calcBezierArea(float bzData[35], float tCurrent, float tTotal){\n\tfloat res = 0.0;\n\tfloat v0;\n\tfloat v1;\n\tfloat t0;\n\tfloat t1;\n\tfloat breakFlag = 1.0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tt1 = bzData[i * 4];\n\t\tv1 = bzData[i * 4 + 1];\n\t\tt0 = bzData[(i - 1) * 4];\n\t\tv0 = bzData[(i - 1) * 4 + 1];\n\t\tres += (min(tCurrent, t1) - t0) * (0.5 * (v1 + v0)) * breakFlag;\n\t\tif(t1 >= tCurrent) {\n\t\t\tbreakFlag = 0.0;\n\t\t}\n\t}\n\treturn res;\n}\nfloat calcBezierSize(float bzData[35], float tCurrent, float tTotal){\n\tfloat res = 0.0;\n\tfloat y0;\n\tfloat y1;\n\tfloat t0;\n\tfloat t1;\n\t\n\tfor (int i = 1; i < 4; i ++) {\n\t\tt1 = bzData[i * 4];\n\t\ty1 = bzData[i * 4 + 1];\n\t\tif(t1 >= tCurrent) {\n\t\t\tt0 = bzData[(i - 1) * 4];\n\t\t\ty0 = bzData[(i - 1) * 4 + 1];\n\t\t\tfloat age = (tCurrent - t0) / (t1 - t0);\n\t\t\tres = y0 + (y1 - y0) * age;\n\t\t}\n\t}\n\treturn res;\n}\n",
            particle_color_fs: "//##FilterBegin## ##Particle##\r\nuniform float uniform_colorTransform[40];\r\n//ѹ��������ɫ,rg.b�ĸ�ʽ\r\nvec3 unpack_color(float rgb_data)\r\n{\r\n    vec3 res;\r\n    res.z = fract( rgb_data );\r\n    rgb_data -= res.z;\r\n    \r\n    rgb_data = rgb_data/256.0;\r\n    res.y = fract( rgb_data );\r\n    rgb_data -= res.y;\r\n    \r\n    res.x = rgb_data/256.0;\r\n    return res;\r\n}\r\n\r\nvoid main() {\r\n    float startColor ;\r\n    float startSegment ;\r\n    \r\n    float nextColor ;\r\n    float nextSegment ;\r\n\r\n    float startAlpha;\r\n\tfloat nextAlpha;\r\n\r\n    float progress = varying_particleData.x/varying_particleData.y;\r\n\tconst int maxColorCount = 20;\r\n\tconst int loopCount = 20;\r\n    for( int i = 1 ; i < loopCount ; i++ ){\r\n       if( progress >= fract(uniform_colorTransform[i+maxColorCount-1]) ){\r\n          startColor = uniform_colorTransform[i-1] ;\r\n          startSegment = fract(uniform_colorTransform[i+maxColorCount-1]) ;\r\n          nextColor = uniform_colorTransform[i];\r\n          nextSegment = fract(uniform_colorTransform[i+maxColorCount]) ;\r\n\r\n\t\t  startAlpha = uniform_colorTransform[i+maxColorCount-1] - startSegment;\r\n\t\t  nextAlpha = uniform_colorTransform[i+maxColorCount] - nextSegment;\r\n       }else{\r\n          break;\r\n       }\r\n    } \r\n    \r\n    float len = nextSegment - startSegment ;\r\n    float ws = ( progress - startSegment ) / len ;\r\n\tws = clamp(ws,0.0,1.0);\r\n    globalColor = mix(vec4(unpack_color(startColor).xyz,startAlpha / 256.0),vec4(unpack_color(nextColor).xyz, nextAlpha / 256.0),ws) ;\r\n\tglobalColor = clamp(globalColor,0.0,1.0);\r\n}\r\n//##FilterEnd##",
            particle_color_fs_low: "//##FilterBegin## ##Particle##\r\nuniform float uniform_colorTransform[40];\r\n//ѹ��������ɫ,rg.b�ĸ�ʽ\r\nvec3 unpack_color(float rgb_data)\r\n{\r\n    vec3 res;\r\n    res.z = fract( rgb_data );\r\n    rgb_data -= res.z;\r\n    \r\n    rgb_data = rgb_data/256.0;\r\n    res.y = fract( rgb_data );\r\n    rgb_data -= res.y;\r\n    \r\n    res.x = rgb_data/256.0;\r\n    return res;\r\n}\r\n\r\nvoid main() {\r\n    float startColor ;\r\n    float startSegment ;\r\n    \r\n    float nextColor ;\r\n    float nextSegment ;\r\n\r\n    float startAlpha;\r\n\tfloat nextAlpha;\r\n\r\n    float progress = varying_particleData.x/varying_particleData.y;\r\n\tconst int maxColorCount = 20;\r\n\tconst int loopCount = 4;\r\n    for( int i = 1 ; i < loopCount ; i++ ){\r\n       if( progress >= fract(uniform_colorTransform[i+maxColorCount-1]) ){\r\n          startColor = uniform_colorTransform[i-1] ;\r\n          startSegment = fract(uniform_colorTransform[i+maxColorCount-1]) ;\r\n          nextColor = uniform_colorTransform[i];\r\n          nextSegment = fract(uniform_colorTransform[i+maxColorCount]) ;\r\n\r\n\t\t  startAlpha = uniform_colorTransform[i+maxColorCount-1] - startSegment;\r\n\t\t  nextAlpha = uniform_colorTransform[i+maxColorCount] - nextSegment;\r\n       }else{\r\n          break;\r\n       }\r\n    } \r\n    \r\n    float len = nextSegment - startSegment ;\r\n    float ws = ( progress - startSegment ) / len ;\r\n\tws = clamp(ws,0.0,1.0);\r\n    globalColor = mix(vec4(unpack_color(startColor).xyz,startAlpha / 256.0),vec4(unpack_color(nextColor).xyz, nextAlpha / 256.0),ws) ;\r\n\tglobalColor = clamp(globalColor,0.0,1.0);\r\n}\r\n//##FilterEnd##",
            particle_color_vs: "void getNodeData(){\n\t\n}\n//##FilterEnd##",
            particle_diffuse_fragment: "uniform sampler2D diffuseTexture;\nvec4 diffuseColor ;\nvec4 globalColor = vec4(1.0, 1.0, 1.0, 1.0);\nvoid calcUVCoord(){\n}\nvoid main() {\n    if( diffuseColor.w == 0.0 ){\n\t\tdiscard;\n\t}\n\tcalcUVCoord();\n\tdiffuseColor = texture2D(diffuseTexture , uv_0 );\n    \n    if( diffuseColor.w < materialSource.cutAlpha ){\n\t\tdiscard;\n\t}\n}\n",
            particle_end_fs: "varying vec4 varying_particleData;\nvarying vec4 varying_mvPose;\nvoid main() {\n\tvec3 fc ;\n\tif(materialSource.refraction<2.41){ \n\t   float vl = dot(normal,-normalize(varying_mvPose.xyz)); \n\t   fc = Fresnel_Schlick(vl,vec3(materialSource.refraction)) * materialSource.refractionintensity ; \n\t   fc.xyz = max(fc,vec3(0.0)) ; \n\t} \n  \n\ts.Albedo = diffuseColor.rgb * globalColor.xyz ;\ts.Albedo.x = pow(s.Albedo.x, materialSource.gamma);\n    s.Albedo.y = pow(s.Albedo.y, materialSource.gamma);\n    s.Albedo.z = pow(s.Albedo.z, materialSource.gamma);\n\ts.Albedo = s.Albedo * varying_color.xyz;\n\ts.Alpha = diffuseColor.a * globalColor.w * materialSource.alpha * varying_color.w ; \n\toutColor.xyz = s.Albedo ; \n\toutColor.w = s.Alpha; \n\tif(varying_particleData.w > 0.5){ \n\toutColor.xyz *= outColor.w; \n\t} \n\toutColor = clamp(outColor, 0.0, 1.0) ; \n}\n",
            particle_end_vs: "varying vec4 varying_pos;\nmat4 buildModelMatrix(vec4 quat, vec3 scale, vec3 position)\n{\n\tmat4 ret = mat4( \n\t\tvec4(scale.x, 0.0, 0.0, 0.0), \n\t\tvec4(0.0, scale.y, 0.0, 0.0), \n\t\tvec4(0.0, 0.0, scale.z, 0.0), \n\t\tvec4(0.0, 0.0, 0.0, 1.0) \n\t);\n\tret = buildMat4Quat(quat) * ret; \n\t \n\tret[3][0] = position.x;\n\tret[3][1] = position.y;\n\tret[3][2] = position.z;\n\treturn ret;\n}\nvec3 calcParticleMove(vec3 distanceXYZ){\n\tif(velocityLimitVec2.y > TrueOrFalse){\n\t\tvec3 temp = distanceXYZ * distanceXYZ;\n\t\tfloat distanceCurrent = sqrt(temp.x + temp.y + temp.z);\n\t\tfloat distanceLimit = velocityLimitVec2.x;\n\t\tif(distanceLimit < Tiny){\n\t\t\treturn vec3(0.0);\n\t\t}\n\t\tif(distanceCurrent > distanceLimit){\n\t\t\tfloat nowFrame = currentTime / 0.017;\n\t\t\tfloat dampen = 1.0 - particleStateData.velocityLimitDampen;\n\t\t\tfloat startDistance = (distanceCurrent - distanceLimit) / nowFrame;\n\t\t\tfloat distanceResult = 0.0;\n\t\t\tfloat tempDistance = startDistance;\n\t\t\tfor(int i = 1; i < 600; i++){\n\t\t\t\tdistanceResult += tempDistance;\n\t\t\t\ttempDistance *= dampen;\n\t\t\t\tif(float(i) > nowFrame)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdistanceXYZ *= (distanceResult + distanceLimit) / distanceCurrent;\n\t\t}\n\t}\n\treturn distanceXYZ;\n}\nbool updateStretchedBillBoard(vec3 moveVector){\n\treturn true;\t\n}\nvoid main(void) {\n\t\n\tvec3 position_emitter = attribute_offsetPosition;\n\tvec3 velocityLocalVec3 = velocityBaseVec3 * currentTime;\n\tvec3 velocityWorldVec3 = vec3(0.0,0.0,0.0);\n\tvec3 velocityMultiVec3 = vec3(0.0,0.0,0.0);\n\tif(particleStateData.velocityOverWorldSpace < TrueOrFalse){\n\t\tvelocityLocalVec3 += velocityOverVec3;\t\t\n\t}else{\n\t\tvelocityWorldVec3 += velocityOverVec3;\n\t}\n\tif(particleStateData.velocityForceWorldSpace < TrueOrFalse){\n\t\tvelocityLocalVec3 += velocityForceVec3;\n\t}else{\n\t\tvelocityWorldVec3 += velocityForceVec3;\n\t}\n\tposition_emitter *= vec3(particleStateData.scaleX, particleStateData.scaleY, particleStateData.scaleZ);\n\tif(particleStateData.worldSpace > TrueOrFalse){\n\t}else{\n\t\tfollowTargetPosition.x = particleStateData.positionX;\n\t\tfollowTargetPosition.y = particleStateData.positionY;\n\t\tfollowTargetPosition.z = particleStateData.positionZ;\n\t\tfollowTargetRotation.x = particleStateData.rotationX;\n\t\tfollowTargetRotation.y = particleStateData.rotationY;\n\t\tfollowTargetRotation.z = particleStateData.rotationZ;\n\t\tfollowTargetRotation.w = particleStateData.rotationW;\n\t}\n\tmat4 followRotQuat = buildMat4Quat(followTargetRotation);\n\tvelocityLocalVec3 = (followRotQuat * vec4(velocityLocalVec3, 1.0)).xyz;\n\tif(particleStateData.renderMode == Mesh){ \n\t\trotVertexMatrix = followRotQuat * rotVertexMatrix; \n\t}\n\tlocalPosition.xyz *= scaleSize;\n\tlocalPosition = rotVertexMatrix * localPosition; \n\ttrackPosition();\n\tmat4 modelMatrix = buildModelMatrix(followTargetRotation, followTargetScale, followTargetPosition);\n\tposition_emitter = (modelMatrix * vec4(position_emitter, 1.0)).xyz; \n\tvelocityMultiVec3 = velocityLocalVec3 + velocityWorldVec3;\n\tvelocityMultiVec3 = calcParticleMove(velocityMultiVec3);\n\tvelocityMultiVec3.y -= 4.9 * currentTime * currentTime * particleStateData.gravity;\t\t\n\tposition_emitter += velocityMultiVec3; \n\tif(particleStateData.renderMode == StretchedBillboard){\n\t\tdiscard_particle = discard_particle || updateStretchedBillBoard(velocityMultiVec3) == false; \n\t\toutPosition = localPosition;\n\t\trotVertexMatrix = rotVertexMatrix * uniform_billboardMatrix; \n\t}else{\n\t\toutPosition = uniform_billboardMatrix * localPosition;\n\t}\n\tif(discard_particle){\n\t\toutPosition = vec4(0.0,0.0,0.0,0.0); \n\t}else{\n\t\t\n\t\toutPosition.xyz += position_emitter.xyz;\n\t\toutPosition = uniform_ViewMatrix * outPosition;\n\t\te_normal.xyz = (rotVertexMatrix * vec4(e_normal, 1.0)).xyz;\n\t\te_normal = normalize(e_normal);\n\t\tmat4 mvMatrix = mat4(uniform_ViewMatrix * modelMatrix);\n\t\tvarying_mvPose = outPosition;\n    \t\n\t\tmat4 normalMatrix = inverse(mvMatrix) ;\n\t\tnormalMatrix = transpose(normalMatrix); \n\t\t\n\t\tvarying_eyeNormal = mat3(normalMatrix) * - e_normal; \n\t}\n\tvarying_pos = outPosition = uniform_ProjectionMatrix * outPosition;\n}\n\t\n//##FilterEnd##",
            particle_follow_vs: "attribute vec3 attribute_followPosition ;\nattribute vec4 attribute_followRotation ;\nattribute vec3 attribute_followScale;\nvoid getNodeData(){\n\t followTargetPosition = attribute_followPosition;\n\t followTargetRotation = attribute_followRotation;\n}\n\t\n//##FilterEnd##",
            particle_rotationConst: "attribute float attribute_rotationZ ;\nvoid getUnitRotate(){\n\trotResultVec3.z = currentTime * attribute_rotationZ;\n}\n",
            particle_rotationOneBezier: "uniform float uniform_rotationBezier[35];\nvoid getUnitRotate(){\n\tfloat rot = calcBezierArea(uniform_rotationBezier, currentTime, curParticle.life);\n\trotResultVec3.z = rot;\n}\n",
            particle_rotationTwoBezier: "attribute float attribute_rotationRandomSeed;\nuniform float uniform_rotationBezier[35];\nuniform float uniform_rotationBezier2[35];\nvoid getUnitRotate(){\n\tvec2 rotationTwoBezier = vec2(0.0);\n\trotationTwoBezier.x = calcBezierArea(uniform_rotationBezier, currentTime, curParticle.life);\n\trotationTwoBezier.y = calcBezierArea(uniform_rotationBezier2, currentTime, curParticle.life);\n\tfloat rot = mix(rotationTwoBezier.x, rotationTwoBezier.y, attribute_rotationRandomSeed);\n\trotResultVec3.z = rot;\n}\n",
            particle_rotationXYZConst: "attribute vec3 attribute_rotSpeedXYZ ;\nattribute vec3 attribute_rotBirthXYZ ;\nvoid getUnitRotate(){\n\trotResultVec3 = (attribute_rotBirthXYZ + particleStateData.time * attribute_rotSpeedXYZ);\n\trotResultVec3 = mod(rotResultVec3, 360.0);\n}\n",
            particle_scaleSizeBezier1: "uniform float uniform_scaleSizeBezier1[35];\nvoid main() {\n\tscaleSize *= calcBezierSize(uniform_scaleSizeBezier1, currentTime, curParticle.life);\n}\n",
            particle_scaleSizeBezier2: "attribute float attribute_bezierRandomSeed;\nuniform float uniform_scaleSizeBezier1[35];\nuniform float uniform_scaleSizeBezier2[35];\nvoid main() {\n\tvec2 scaleVec2 = vec2(0.0);\n\tscaleVec2.x = calcBezierArea(uniform_scaleSizeBezier1, currentTime, curParticle.life);\n\tscaleVec2.y = calcBezierArea(uniform_scaleSizeBezier2, currentTime, curParticle.life);\n\tscaleSize * = mix(scaleVec2.x, scaleVec2.y, attribute_bezierRandomSeed);\n}\n",
            particle_scaleSizeConst: "attribute float attribute_scaleSizeConst;\nvoid main() {\n\tscaleSize *= attribute_scaleSizeConst;\n}\n//##FilterEnd##",
            particle_stretched_mode: "\nbool updateStretchedBillBoard(vec3 moveVector){\n\tif(currentTime < 0.016){\n\t\treturn false;\n\t}\n\tfloat speed = dot(moveVector, moveVector); \n\tspeed = sqrt(speed) / currentTime; \n\tspeed /= 100.0;\n\tif(speed < Tiny){\n\t\treturn false;\n\t}\n\tlocalPosition.y = localPosition.y * particleStateData.lengthScale + speed * particleStateData.speedScale * localPosition.y / scaleSize;\n\tvec3 dir1 = vec3(0.0, 1.0, 0.0);\n\tvec3 dir2 = normalize(moveVector);\n\tvec3 axis = normalize(cross(dir1, dir2));\n    float angle = acos(dot(dir1, dir2));\n\tvec4 quat = vec4(0.0, 0.0, 0.0, 1.0);\n    float halfAngle = angle * 0.5;\n    float sin_a = sin(halfAngle);\n    quat.w = cos(halfAngle);\n    quat.x = axis.x * sin_a;\n    quat.y = axis.y * sin_a;\n    quat.z = axis.z * sin_a;\n    quat = normalize(quat);\n\t\n\tlocalPosition = uniform_billboardMatrix * localPosition;\n\trotVertexMatrix = buildMat4Quat(quat); \n\tlocalPosition = rotVertexMatrix * localPosition;\n\treturn true;\n}\n",
            particle_textureSheetConst: "\nvarying vec3 varying_textureSheetData;\nuniform float uniform_textureSheet[5];\nvec2 getSheetOffset(float frame, float tileX, float tileY)\n{\n\tframe = floor(frame);\n\tvec2 ret = vec2(0.0); \n\tret.x = (1.0 / tileX) * mod(frame, tileX); \n\tret.y = frame / tileX;\n\tret.y = floor(ret.y);\n\tret.y = (1.0 / tileY) * ret.y; \n\treturn ret;\n}\nvoid calcUVCoord() {\n\tvec2 rectUV = vec2(1.0 / uniform_textureSheet[0], 1.0 / uniform_textureSheet[1]);\n\tuv_0.xy *= rectUV;\n\t\n\tfloat frame = varying_textureSheetData.x + varying_textureSheetData.y;\n\tframe = clamp(frame, uniform_textureSheet[3], uniform_textureSheet[4]);\n\tuv_0.xy += getSheetOffset(frame, uniform_textureSheet[0], uniform_textureSheet[1]);\n}\n",
            particle_textureSheetOneBezier: "\nvarying vec3 varying_textureSheetData;\nuniform float uniform_textureSheet[5];\nuniform float uniform_frameBezier[35];\nvec2 getSheetOffset(float frame, float tileX, float tileY)\n{\n\tframe = floor(frame);\n\tvec2 ret = vec2(0.0); \n\tret.x = (1.0 / tileX) * mod(frame, tileX); \n\tret.y = frame / tileX;\n\tret.y = floor(ret.y);\n\tret.y = (1.0 / tileY) * ret.y; \n\treturn ret;\n}\nvoid calcUVCoord() {\n\tvec2 rectUV = vec2(1.0 / uniform_textureSheet[0], 1.0 / uniform_textureSheet[1]);\n\tuv_0.xy *= rectUV;\n\t\n\tfloat frame = varying_textureSheetData.x + varying_textureSheetData.y;\n\tfloat currentTime = varying_particleData.x * uniform_textureSheet[2];\n\tcurrentTime = mod(currentTime, varying_particleData.y);\n\tfloat bezierFrame = calcBezierSize(uniform_frameBezier, currentTime, varying_particleData.y);\n\tbezierFrame = clamp(bezierFrame, uniform_textureSheet[3], uniform_textureSheet[4]);\n\tframe += bezierFrame;\n\tuv_0.xy += getSheetOffset(frame, uniform_textureSheet[0], uniform_textureSheet[1]);\n}\n",
            particle_textureSheetTwoBezier: "\nvarying vec3 varying_textureSheetData;\nuniform float uniform_textureSheet[5];\nuniform float uniform_frameBezier1[35];\nuniform float uniform_frameBezier2[35];\nvec2 getSheetOffset(float frame, float tileX, float tileY)\n{\n\tframe = floor(frame);\n\tvec2 ret = vec2(0.0); \n\tret.x = (1.0 / tileX) * mod(frame, tileX); \n\tret.y = frame / tileX;\n\tret.y = floor(ret.y);\n\tret.y = (1.0 / tileY) * ret.y; \n\treturn ret;\n}\nvoid calcUVCoord() {\n\tvec2 rectUV = vec2(1.0 / uniform_textureSheet[0], 1.0 / uniform_textureSheet[1]);\n\tuv_0.xy *= rectUV;\n\t\n\tfloat frame = varying_textureSheetData.x + varying_textureSheetData.y;\n\tfloat currentTime = varying_particleData.x * uniform_textureSheet[2];\n\tcurrentTime = mod(currentTime, varying_particleData.y);\n\tfloat b1 = calcBezierSize(uniform_frameBezier1, currentTime2, varying_particleData.y);\n\tfloat b2 = calcBezierSize(uniform_frameBezier2, currentTime2, varying_particleData.y);\n\tfloat bezierFrame = mix(b1, b2, varying_particleData.z);\n\tbezierFrame = clamp(bezierFrame, uniform_textureSheet[3], uniform_textureSheet[4]);\n\tframe += bezierFrame;\n\tuv_0.xy += getSheetOffset(frame, uniform_textureSheet[0], uniform_textureSheet[1]);\n}\n",
            particle_textureSheet_vs: "attribute vec3 attribute_textureSheetData;\nvarying vec3 varying_textureSheetData;\nvoid getNodeData(){\n\tvarying_textureSheetData = attribute_textureSheetData;\n}\n\t\n",
            particle_trackPosition: "\nattribute vec3 attribute_trackPosition;\nvoid calcCubicPos(float time, float totalTime, vec3 fromPos, vec3 endPos){ \n \n\tvec3 distanceVec3 = endPos - fromPos; \n\tfloat distanceFloat = dot(distanceVec3, distanceVec3); \n\tdistanceFloat = sqrt(distanceFloat); \n\tfloat t = time / totalTime; \n\tt = easeInOut(t); \n\tvec3 centerPos = distanceVec3 * 0.5 + fromPos; \n\tvec3 zeroPos = vec3(0.0, distanceFloat * 0.05, 0.0); \n\tzeroPos = mix(centerPos, zeroPos, 0.6); \n\tvec3 bezier1 = mix(fromPos, zeroPos, t); \n\tvec3 bezier2 = mix(zeroPos, endPos, t); \n\tvec3 bezier3 = mix(bezier1, bezier2, t); \n\tcubicPos = bezier3 - fromPos; \n\tt = clamp(time / totalTime, 0.0, 1.0); \n\tif(t > 0.8){ \n\tt = (1.0 - t) * 5.0; \n\t}else if(t > 0.2){ \n\tt = 1.0; \n\t}else{ \n\tt *= 5.0; \n\t} \n\tt = 0.5 * (1.0 - cos(t * PI)); \n\tvec4 nrmVec4 = rotVertexMatrix * vec4(attribute_normal, 1.0); \n\tvec3 nrmPos = normalize(nrmVec4.xyz); \n\tnrmPos = nrmPos * t * distanceFloat * 0.04; \n\tt = clamp(time / totalTime, 0.0, 1.0); \n\tfloat heightOffset = 0.0; \n\theightOffset = sin(t * 3.0 * PI) * distanceFloat * 0.2 * sqrt(t * (1.0 - t)); \n\tcubicPos += nrmPos; \n\tcubicPos.y += heightOffset; \n}\nvoid trackPosition(){ \n \n\tcalcCubicPos(currentTime - 0.017, curParticle.life, attribute_offsetPosition, attribute_trackPosition); \n\tvec3 lastOffset = cubicPos; \n\tcalcCubicPos(currentTime, curParticle.life, attribute_offsetPosition, attribute_trackPosition); \n\tvec3 curOffset = cubicPos; \n\tvec3 trackVec3 = curOffset - lastOffset; \n\ttrackVec3 = normalize(trackVec3); \n\tfloat ratio = dot(localPosition.xyz, trackVec3); \n\tfloat t = clamp(currentTime / curParticle.life, 0.0, 1.0); \n\tt = 0.5 * (1.0 - cos(t * PI * 2.0)); \n\tt = sqrt(t); \n\tfloat speed = sqrt(dot(curOffset - lastOffset, curOffset - lastOffset)); \n\ttrackVec3 *= speed * 2.0 * t; \n\tlocalPosition.xyz += ratio * trackVec3; \n\tlocalPosition.xyz += curOffset; \n}\n",
            particle_uv_roll_fs: "\nuniform float uniform_particleUVRoll[2];\nvoid calcUVCoord() {\n\tuv_0.xy += vec2(varying_particleData.x * uniform_particleUVRoll[0], varying_particleData.x * uniform_particleUVRoll[1]);\n}\n",
            particle_velocity: "\nattribute vec3 attribute_velocity;\nvoid getNodeData(){\n\tvelocityBaseVec3 = attribute_velocity;\n}\n",
            particle_velocityForceConst: "attribute vec3 attribute_velocityForceConst ;\nvoid getNodeData(){\n\tvelocityForceVec3 = 0.5 * attribute_velocityForceConst * currentTime * currentTime;\n}\n",
            particle_velocityForceOneBezier: "\nvec3 velocityForceOneBezier = vec3(0.0);\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n}\nvoid main() {\n\tvelocityForceVec3.xyz = velocityForceOneBezier.xyz;\n\tcalcVelocityForceBezier(currentTime, curParticle.life);\n}\n",
            particle_velocityForceOneBezierX: "\nuniform float uniform_velocityForceX[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceOneBezier.x = calcBezierArea(uniform_velocityForceX, curTime, totalTime);\n}\n",
            particle_velocityForceOneBezierY: "\nuniform float uniform_velocityForceY[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceOneBezier.y = calcBezierArea(uniform_velocityForceY, curTime, totalTime);\n}\n",
            particle_velocityForceOneBezierZ: "\nuniform float uniform_velocityForceZ[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceOneBezier.z = calcBezierArea(uniform_velocityForceZ, curTime, totalTime);\n}\n",
            particle_velocityForceTwoBezier: "\nattribute float attribute_velocityForceRandomSeed;\nvec3 velocityForceTwoBezier1 = vec3(0.0);\nvec3 velocityForceTwoBezier2 = vec3(0.0);\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n}\nvoid main() {\n\tcalcVelocityForceBezier(currentTime, curParticle.life);\n\tvelocityForceVec3.x = mix(velocityForceTwoBezier1.x, velocityForceTwoBezier2.x, attribute_velocityForceRandomSeed);\n\tvelocityForceVec3.y = mix(velocityForceTwoBezier1.y, velocityForceTwoBezier2.y, attribute_velocityForceRandomSeed);\n\tvelocityForceVec3.z = mix(velocityForceTwoBezier1.z, velocityForceTwoBezier2.z, attribute_velocityForceRandomSeed);\n}\n",
            particle_velocityForceTwoBezierX1: "\nuniform float uniform_velocityForceX1[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceTwoBezier1.x = calcBezierArea(uniform_velocityForceX1, curTime, totalTime);\n}\n",
            particle_velocityForceTwoBezierX2: "\nuniform float uniform_velocityForceX2[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceTwoBezier2.x = calcBezierArea(uniform_velocityForceX2, curTime, totalTime);\n}\n",
            particle_velocityForceTwoBezierY1: "\nuniform float uniform_velocityForceY1[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceTwoBezier1.y = calcBezierArea(uniform_velocityForceY1, curTime, totalTime);\n}\n",
            particle_velocityForceTwoBezierY2: "\nuniform float uniform_velocityForceY2[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceTwoBezier2.y = calcBezierArea(uniform_velocityForceY2, curTime, totalTime);\n}\n",
            particle_velocityForceTwoBezierZ1: "\nuniform float uniform_velocityForceZ1[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceTwoBezier1.z = calcBezierArea(uniform_velocityForceZ1, curTime, totalTime);\n}\n",
            particle_velocityForceTwoBezierZ2: "\nuniform float uniform_velocityForceZ2[35];\nvoid calcVelocityForceBezier(float curTime, float totalTime)\n{\n\tvelocityForceTwoBezier2.z = calcBezierArea(uniform_velocityForceZ2, curTime, totalTime);\n}\n",
            particle_velocityLimitConst: "\nattribute float attribute_velocityLimit;\nvoid getNodeData(){\n\tvelocityLimitVec2.x = attribute_velocityLimit * currentTime;\n\tif(velocityLimitVec2.x < 0.0){\n\t\tvelocityLimitVec2.x = 0.0;\n\t}\n\tvelocityLimitVec2.y = 1.0;\n}\n",
            particle_velocityLimitOneBezier: "\nuniform float uniform_velocityLimit[35];\nvoid main() {\n\tvelocityLimitVec2.x = calcBezierArea(uniform_velocityLimit, currentTime, curParticle.life);\n\tvelocityLimitVec2.y = 1.0;\n}\n",
            particle_velocityLimitTwoBezier: "\nuniform float uniform_velocityLimit[35];\nuniform float uniform_velocityLimit2[35];\nattribute float attribute_velocityLimitRandomSeed;\nvoid main() {\n\tfloat velocity2Limit1 = calcBezierArea(uniform_velocityLimit, currentTime, curParticle.life);\n\tfloat velocity2Limit2 = calcBezierArea(uniform_velocityLimit2, currentTime, curParticle.life);\n\tvelocityLimitVec2.x = mix(velocity2Limit1, velocity2Limit1, attribute_velocityLimitRandomSeed);\n\tif(velocityLimitVec2.x < 0.0){\n\t\tvelocityLimitVec2.x = 0.0;\n\t}\n\tvelocityLimitVec2.y = 1.0;\n}\n",
            particle_velocityOverConst: "\nattribute vec3 attribute_velocityOverConst;\nvoid getNodeData(){\n\tvelocityOverVec3 = attribute_velocityOverConst * currentTime;\n}\n",
            particle_velocityOverOneBezier: "\nvec3 velocityTwoBezier = vec3(0.0);\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n}\nvoid main() {\n\tcalcVelocityOverBezier(currentTime, curParticle.life);\n\tvelocityOverVec3.xyz = velocityTwoBezier.xyz;\n}\n",
            particle_velocityOverOneBezierX: "\nuniform float uniform_velocityOverX[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityTwoBezier.x = calcBezierArea(uniform_velocityOverX, curTime, totalTime);\n}\n",
            particle_velocityOverOneBezierY: "\nuniform float uniform_velocityOverY[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityTwoBezier.y = calcBezierArea(uniform_velocityOverY, curTime, totalTime);\n}\n",
            particle_velocityOverOneBezierZ: "\nuniform float uniform_velocityOverZ[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityTwoBezier.z = calcBezierArea(uniform_velocityOverZ, curTime, totalTime);\n}\n",
            particle_velocityOverTwoBezier: "\nattribute float attribute_velocityOverRandomSeed;\nvec3 velocityOverTwoBezier1 = vec3(0.0);\nvec3 velocityOverTwoBezier2 = vec3(0.0);\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n}\nvoid main() {\n\tcalcVelocityOverBezier(currentTime, curParticle.life);\n\tvelocityOverVec3.x = mix(velocityOverTwoBezier1.x, velocityOverTwoBezier2.x, attribute_velocityOverRandomSeed);\n\tvelocityOverVec3.y = mix(velocityOverTwoBezier1.y, velocityOverTwoBezier2.y, attribute_velocityOverRandomSeed);\n\tvelocityOverVec3.z = mix(velocityOverTwoBezier1.z, velocityOverTwoBezier2.z, attribute_velocityOverRandomSeed);\n}\n",
            particle_velocityOverTwoBezierX1: "\nuniform float uniform_velocityOverX1[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityOverTwoBezier1.x = calcBezierArea(uniform_velocityOverX1, curTime, totalTime);\n}\n",
            particle_velocityOverTwoBezierX2: "\nuniform float uniform_velocityOverX2[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityOverTwoBezier2.x = calcBezierArea(uniform_velocityOverX2, curTime, totalTime);\n}\n",
            particle_velocityOverTwoBezierY1: "\nuniform float uniform_velocityOverY1[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityOverTwoBezier1.y = calcBezierArea(uniform_velocityOverY1, curTime, totalTime);\n}\n",
            particle_velocityOverTwoBezierY2: "\nuniform float uniform_velocityOverY2[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityOverTwoBezier2.y = calcBezierArea(uniform_velocityOverY2, curTime, totalTime);\n}\n",
            particle_velocityOverTwoBezierZ1: "\nuniform float uniform_velocityOverZ1[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityOverTwoBezier1.z = calcBezierArea(uniform_velocityOverZ1, curTime, totalTime);\n}\n",
            particle_velocityOverTwoBezierZ2: "\nuniform float uniform_velocityOverZ2[35];\nvoid calcVelocityOverBezier(float curTime, float totalTime)\n{\n\tvelocityOverTwoBezier2.z = calcBezierArea(uniform_velocityOverZ2, curTime, totalTime);\n}\n",
            particle_vs: "float currentTime = 0.0;\nfloat totalTime = 0.0;\nbool discard_particle = true;\nconst float PI = 3.1415926;\nconst float TrueOrFalse = 0.5;\nconst float Tiny = 0.0001;\nvarying vec4 varying_particleData;\nvarying vec4 varying_mvPose;\nattribute vec3 attribute_time;attribute vec4 attribute_color;\nattribute vec3 attribute_offsetPosition;\nattribute float attribute_rotationBirth;\nuniform mat4 uniform_cameraMatrix;\nuniform mat4 uniform_billboardMatrix;\nuniform mat4 uniform_ViewMatrix;\nuniform float uniform_particleState[27];\nvec3 cubicPos = vec3(1.0,1.0,1.0);\nvec3 rotResultVec3 = vec3(0.0);\nvec4 localPosition = vec4(0.0,0.0,0.0,1.0);\nvec3 velocityBaseVec3 = vec3(0.0,0.0,0.0);\nvec3 velocityOverVec3 = vec3(0.0,0.0,0.0);\nvec3 velocityForceVec3 = vec3(0.0,0.0,0.0);\nvec2 velocityBezierWeightVec2 = vec2(1.0, 1.0);\nvec2 velocityLimitVec2 = vec2(0.0,0.0);\nvec3 followTargetPosition = vec3(0.0,0.0,0.0);\nvec3 followTargetScale = vec3(1.0,1.0,1.0);\nvec4 followTargetRotation = vec4(0.0,0.0,0.0,0.0);\nfloat scaleSize = 1.0;\nconst float Billboard\t\t\t\t= 0.0;\nconst float StretchedBillboard\t\t= 1.0;\nconst float HorizontalBillboard\t\t= 2.0;\nconst float VerticalBillboard\t\t= 3.0;\nconst float Mesh\t\t\t\t\t= 4.0;\nstruct ParticleData{\n\tfloat bornTime;\tfloat life;\tfloat index;};                   \nParticleData curParticle;\nstruct ParticleStateData{\n\tfloat time;\t\t\t\t\t\t\n\tfloat loop;\t\t\t\t\t\t\n\tfloat worldSpace;\t\t\t\t\n\tfloat scaleX;\t\t\t\t\t\n\tfloat scaleY;\t\t\t\t\t\n\tfloat scaleZ;\t\t\t\t\t\n\tfloat rotationX;\t\t\t\t\n\tfloat rotationY;\t\t\t\t\n\tfloat rotationZ;\t\t\t\t\n\tfloat rotationW;\n\tfloat positionX;\t\t\t\t\n\tfloat positionY;\t\t\t\t\n\tfloat positionZ;\t\t\t\t\n\tfloat loopTime;\t\t\t\t\t\n\tfloat delay;\t\t\t\t\t\n\tfloat duration;\t\t\t\t\t\n\tfloat gravity;\t\t\t\t\t\n\tfloat velocityOverWorldSpace;\t\n\tfloat velocityForceWorldSpace;\t\n\tfloat velocityLimitDampen;\n\tfloat cameraScale;\n\tfloat speedScale;\n\tfloat lengthScale;\n\tfloat renderMode;\n\tfloat stayAtEnd;\n\tfloat blendMode;\n\tfloat shapeType;\n};\nParticleStateData particleStateData;\nmat4 buildRotMat4(vec3 rot)\n{\n\tfloat s;\n\tfloat c;\n\ts = sin(rot.x);\n\tc = cos(rot.x);\n\t\n\tmat4 ret = mat4(\n\tvec4(1.0, 0.0, 0.0, 0.0),\n\tvec4(0.0, c, s, 0.0),\n\tvec4(0.0, -s, c, 0.0),\n\tvec4(0.0, 0.0, 0.0, 1.0)\n\t);\n\t\n\ts = sin(rot.y);\n\tc = cos(rot.y);\n\t\n\tret = mat4(\n\tvec4(c, 0.0, -s, 0.0),\n\tvec4(0.0, 1.0, 0.0, 0.0),\n\tvec4(s, 0.0, c, 0.0),\n\tvec4(0.0, 0.0, 0.0, 1.0)\n\t) * ret;\n\ts = sin(rot.z);\n\tc = cos(rot.z);\n\tret = mat4(\n\tvec4(c, s, 0.0, 0.0),\n\tvec4(-s, c, 0.0, 0.0),\n\tvec4(0.0, 0.0, 1.0, 0.0),\n\tvec4(0.0, 0.0, 0.0, 1.0)\n\t) * ret;\n\treturn ret;\n}\nmat4 buildMat4Quat(vec4 quat)\n{\n\tfloat xx = quat.x * quat.x;\n\tfloat xy = quat.x * quat.y;\n\tfloat xz = quat.x * quat.z;\n\tfloat xw = quat.x * quat.w;\n\tfloat yy = quat.y * quat.y;\n\tfloat yz = quat.y * quat.z;\n\tfloat yw = quat.y * quat.w;\n\tfloat zz = quat.z * quat.z;\n\tfloat zw = quat.z * quat.w;\n\treturn mat4(\n\t\t1.0 - 2.0 * (yy + zz),\t\t2.0 * (xy + zw),\t\t2.0 * (xz - yw),\t\t0,\n\t\t2.0 * (xy - zw),\t\t\t\t1.0 - 2.0 * (xx + zz),\t2.0 * (yz + xw),\t\t0,\n\t\t2.0 * (xz + yw),\t\t\t\t2.0 * (yz - xw),\t\t1.0 - 2.0 * (xx + yy),\t0,\n\t\t0.0,\t\t\t\t\t\t\t0.0,\t\t\t\t\t0.0,\t\t\t\t\t1\n\t);\n}\nfloat easeInOut(float t)\n{\n\tt = clamp(t, 0.0, 1.0);\n\tfloat p0;\n\tfloat p1;\n\tfloat p2;\n\tif(t <= 0.5){ \n\t\tp0 = 0.0; \n\t\tp1 = 0.0; \n\t\tp2 = 0.5; \n\t}else{ \n\t\tp0 = 0.5; \n\t\tp1 = 1.0; \n\t\tp2 = 1.0; \n\t\tt -= 0.5;\n\t}\n\tt *= 2.0;\n\t\n\tp0 = mix(p0, p1, t);\n\tp1 = mix(p1, p2, t);\n\t\n\tp0 = mix(p0, p1, t);\n\treturn p0;\n}\nvoid calcParticleTime()\n{\n\tdiscard_particle = true;\n\tcurParticle.bornTime = attribute_time.x; \n\tcurParticle.life = attribute_time.y; \n\tcurParticle.index = attribute_time.z; \n\tfloat time = particleStateData.time - particleStateData.delay;\n\tcurrentTime = time - curParticle.bornTime;\n\tif(currentTime <= 0.0){\n\t\treturn;\n\t}\n\tif(particleStateData.stayAtEnd > TrueOrFalse){\n\t\tif(currentTime >= curParticle.life){\n\t\t\tcurrentTime = curParticle.life * 0.99999;\n\t\t}\n\t}\n\tif(particleStateData.loop < TrueOrFalse){\n\t\tif(curParticle.bornTime >= particleStateData.duration){\n\t\t\treturn;\n\t\t}\n\t\tif(currentTime >= curParticle.life){\n\t\t\treturn;\n\t\t}\n\t\t\n\t}\n\tcurrentTime = mod(currentTime, particleStateData.loopTime);\n\tif(currentTime > curParticle.life || currentTime <= 0.0){\n\t\treturn;\n\t}\n\tdiscard_particle = false;\n}\nvoid calcCubicPos(float time, float totalTime, vec3 fromPos, vec3 endPos)\n{\n}\nvoid trackPosition()\n{\n}\nvoid getUnitRotate(){\n}\nvoid getNodeData(){\n}\nvoid rotateParticleUnit()\n{\n\trotResultVec3.z += attribute_rotationBirth; \n\trotResultVec3 *= PI / 180.0; \n\tif(particleStateData.renderMode == Mesh){\n\t\tif(particleStateData.shapeType > 0.5){ \n\t\t\trotResultVec3 = vec3(0.0, rotResultVec3.z, 0.0); \n\t\t\trotVertexMatrix = buildRotMat4(rotResultVec3); \n\t  }else{ \n\t\t  rotResultVec3 = vec3(0.0, 0.0, rotResultVec3.z); \n\t\t  rotVertexMatrix = buildRotMat4(rotResultVec3); \n\t  } \n\t}else if(particleStateData.renderMode == HorizontalBillboard){ \n\t\trotVertexMatrix = buildRotMat4(vec3(0.5 * PI, 0.0, 0.0)); \n\t\trotResultVec3 = vec3(0.0, rotResultVec3.z, 0.0); \n\t\trotVertexMatrix = buildRotMat4(rotResultVec3) * rotVertexMatrix; \n\t}else if(particleStateData.renderMode == StretchedBillboard){\n\t\trotResultVec3 = vec3(0.0, 0.0, -0.5 * PI); \n\t\trotVertexMatrix = buildRotMat4(rotResultVec3);\n\t}else{\n\t\trotVertexMatrix = buildRotMat4(rotResultVec3); \n\t} \n\t\n}\nvoid main(void) \n{\n\tlocalPosition = vec4(e_position, 1.0);\n\tparticleStateData.time\t\t\t\t\t\t\t= uniform_particleState[0];\n\tparticleStateData.loop\t\t\t\t\t\t\t= uniform_particleState[1];\n\tparticleStateData.worldSpace\t\t\t\t\t= uniform_particleState[2];\n\tparticleStateData.scaleX\t\t\t\t\t\t= uniform_particleState[3];\n\tparticleStateData.scaleY\t\t\t\t\t\t= uniform_particleState[4];\n\tparticleStateData.scaleZ\t\t\t\t\t\t= uniform_particleState[5];\n\tparticleStateData.rotationX\t\t\t\t\t\t= uniform_particleState[6];\n\tparticleStateData.rotationY\t\t\t\t\t\t= uniform_particleState[7];\n\tparticleStateData.rotationZ\t\t\t\t\t\t= uniform_particleState[8];\n\tparticleStateData.rotationW\t\t\t\t\t\t= uniform_particleState[9];\n\tparticleStateData.positionX\t\t\t\t\t\t= uniform_particleState[10];\n\tparticleStateData.positionY\t\t\t\t\t\t= uniform_particleState[11];\n\tparticleStateData.positionZ\t\t\t\t\t\t= uniform_particleState[12];\n\tparticleStateData.loopTime\t\t\t\t\t\t= uniform_particleState[13];\n\tparticleStateData.delay\t\t\t\t\t\t\t= uniform_particleState[14];\n\tparticleStateData.duration\t\t\t\t\t\t= uniform_particleState[15];\n\tparticleStateData.gravity\t\t\t\t\t\t= uniform_particleState[16];\n\tparticleStateData.velocityOverWorldSpace\t\t= uniform_particleState[17];\n\tparticleStateData.velocityForceWorldSpace\t\t= uniform_particleState[18];\n\tparticleStateData.velocityLimitDampen\t\t\t= uniform_particleState[19];\n\tparticleStateData.cameraScale\t\t\t\t\t= uniform_particleState[20];\n\tparticleStateData.speedScale\t\t\t\t\t= uniform_particleState[21];\n\tparticleStateData.lengthScale\t\t\t\t\t= uniform_particleState[22];\n\tparticleStateData.renderMode\t\t\t\t\t= uniform_particleState[23];\n\tparticleStateData.stayAtEnd\t\t\t\t\t\t= uniform_particleState[24];\n\tparticleStateData.blendMode\t\t\t\t\t\t= uniform_particleState[25];\n\tparticleStateData.shapeType\t\t\t\t\t\t= uniform_particleState[26];\n\t\n\tcalcParticleTime();\n\tvarying_particleData.x = currentTime;\n\tvarying_particleData.y = curParticle.life;\n\tvarying_particleData.z = curParticle.index;\n\tvarying_particleData.w = particleStateData.blendMode;\n\tif(discard_particle){\n\t\tvarying_particleData.x = currentTime = 0.0;\n\t\tgl_Position = varying_pos = vec4(0.0, 0.0, 0.0, 1.0);\n\t\treturn;\n\t}\n\tgetNodeData();\n\tgetUnitRotate();\n\trotateParticleUnit();\n}\n",
            pointLight_fragment: "const int max_pointLight = 0 ;\nuniform float uniform_pointLightSource[12*max_pointLight] ;\nvarying vec4 varying_mvPose; \nstruct PointLight{\n        vec3 position ;\n        vec3 diffuse ;\n        vec3 ambient ;\n        float intensity;\n        float radius;\n        float cutoff;\n};\nvoid calculatePointLight(MaterialSource materialSource){\n    vec3 N = normal; \n\tvec3 viewDir = normalize(varying_mvPose.xyz/varying_mvPose.w); \n\tfor(int i = 0 ; i < max_pointLight ; i++){\n\t\tPointLight pointLight;\n\t\tpointLight.position = vec3(uniform_pointLightSource[i*12],uniform_pointLightSource[i*12+1],uniform_pointLightSource[i*12+2]);\n\t\tpointLight.diffuse = vec3(uniform_pointLightSource[i*12+3],uniform_pointLightSource[i*12+4],uniform_pointLightSource[i*12+5]);\n\t\tpointLight.ambient = vec3(uniform_pointLightSource[i*12+6],uniform_pointLightSource[i*12+7],uniform_pointLightSource[i*12+8]);\n\t    pointLight.intensity = uniform_pointLightSource[i*12+9];\n\t    pointLight.radius = uniform_pointLightSource[i*12+10];\n\t    pointLight.cutoff = uniform_pointLightSource[i*12+11];\n\t\t\n\t\tvec3 lightCentre = (mat4(uniform_ViewMatrix) * vec4(pointLight.position.xyz,1.0) ).xyz ; \n\t\tfloat r = pointLight.radius * 0.5 ;\n\t\tvec3 ldir = varying_mvPose.xyz - lightCentre ;\n\t\tfloat distance = length(ldir);\n\t\tfloat d = max(distance - r, 0.0);\n\t\tvec3 L = ldir / distance;\n\t\t\n\t\tfloat denom = d/r + 1.0;\n\t\tfloat attenuation = 1.0 / (denom*denom);\n\t\t\n\t\tfloat cutoff = pointLight.cutoff ;\n\t\tattenuation = (attenuation - cutoff) / (1.0 - cutoff);\n\t\tattenuation = max(attenuation*pointLight.intensity, 0.0);\n\t\tLightingBlinnPhong(normalize(ldir),pointLight.diffuse,pointLight.ambient,N,(viewDir),attenuation); \n\t};\n}\nvoid main() {\n   calculatePointLight(materialSource);\n}\n",
            positionEndPass_fs: "varying vec4 varying_position ;\nvoid main(){\n     outColor = vec4(varying_position.xyz,1.0);\n}",
            positionEndPass_vs: "varying vec4 varying_position ;\nvoid main(){\n\t\toutPosition = uniform_ProjectionMatrix * outPosition ; \n\t\tvarying_position = outPosition.xyzw; \n}",
            rimlight_fs: "uniform float uniform_rimData[6] ;\nvoid main(){\n    float rim = 1.0 - clamp(dot (vec3(0.0,0.0,1.0), normal ) ,0.0,1.0);  \n    vec3 emission = vec3(uniform_rimData[0],uniform_rimData[1],uniform_rimData[2]) * pow(rim, uniform_rimData[4]);  \n    outColor.xyz += emission * uniform_rimData[3] * uniform_rimData[5] ;\n}",
            secondaryUV_vs: "attribute vec2 attribute_uv1;\nvarying vec2 varying_uv1 ;\nvoid main(void){\n\tvarying_uv1 = attribute_uv1 ; \n}",
            shadowMapping_fs: "uniform sampler2D shadowMapTexture;\nuniform vec4 uniform_ShadowColor;\nvarying vec4 varying_ShadowCoord;\nfloat unpackDepth(vec4 rgbaDepth){\n    vec4 bitShift = vec4( 1.0 , 1.0/256.0 , 1.0/(256.0*256.0) , 1.0/(256.0*256.0*256.0) );\n    float depth = dot(rgbaDepth,bitShift);\n    return depth ;\n}\nvoid main() {\n\tvec3 shadowColor = vec3(1.0,1.0,1.0); \n\tfloat offset = uniform_ShadowColor.w; \n\tvec2 sample = varying_ShadowCoord.xy / varying_ShadowCoord.w * 0.5 + 0.5; \n\tif (sample.x >=0.0 && sample.x <= 1.0 && sample.y >=0.0 && sample.y <= 1.0) {\n\t\tvec4 sampleDepth = texture2D(shadowMapTexture, sample).xyzw; \n\t\tfloat depth = varying_ShadowCoord.z;\n\t\n\t\tif (sampleDepth.z != 0.0) {\n\t\t\tif( sampleDepth.z < depth - offset) { \n\t\t\t\tshadowColor = uniform_ShadowColor.xyz; \n\t\t\t}\n\t\t}\n\t}\n\tdiffuseColor.xyz = diffuseColor.xyz * shadowColor; \n}\n",
            shadowMapping_vs: "uniform mat4 uniform_ShadowMatrix;\nuniform mat4 uniform_ModelMatrix;\nvarying vec4 varying_ShadowCoord;\nvoid main() {\n\tvarying_ShadowCoord = uniform_ShadowMatrix * uniform_ModelMatrix * vec4(e_position, 1.0);\n}",
            shadowPass_fs: "uniform sampler2D diffuseTexture;\nvec4 diffuseColor ;\nvarying vec2 varying_uv0;\nvarying vec4 varying_color;\nvarying vec4 varying_pos;\nfloat unpackDepth(vec4 rgbaDepth){\n    vec4 bitShift = vec4( 1.0 , 1.0/256.0 , 1.0/(256.0*256.0) , 1.0/(256.0*256.0*256.0) );\n    float depth = dot(rgbaDepth,bitShift);\n    return depth ;\n}\nvoid main() {\n\tdiffuseColor = varying_color ;\n    if( diffuseColor.w == 0.0 ){\n\t\tdiscard;\n\t}\n\tdiffuseColor = texture2D(diffuseTexture , varying_uv0 );\n    if( diffuseColor.w <= 0.3 ){\n\t\t\tdiscard;\n\t}\n    gl_FragColor = vec4(varying_pos.zzz, 1.0);\n}\n",
            shadowPass_skeleton_vs: "attribute vec3 attribute_position;\nattribute vec3 attribute_normal;\nattribute vec4 attribute_color;\nattribute vec2 attribute_uv0;\nattribute vec4 attribute_boneIndex;\nattribute vec4 attribute_boneWeight;\nuniform mat4 uniform_ModelMatrix ;\nuniform mat4 uniform_ViewMatrix ;\nuniform mat4 uniform_ProjectionMatrix ;\nvec3 e_position = vec3(0.0, 0.0, 0.0);\nvec4 e_boneIndex = vec4(0.0, 0.0, 0.0, 0.0);\nvec4 e_boneWeight = vec4(0.0, 0.0, 0.0, 0.0);\nvec4 outPosition = vec4(0.0, 0.0, 0.0, 0.0);\nconst int bonesNumber = 0;\nuniform vec4 uniform_PoseMatrix[bonesNumber];\nvarying vec2 varying_uv0;\nvarying vec4 varying_color;\nvarying vec4 varying_pos;\nmat4 buildMat4(int index){\n  vec4 quat = uniform_PoseMatrix[index * 2 + 0];\n  vec4 translation = uniform_PoseMatrix[index * 2 + 1];\n  float xy2 = 2.0 * quat.x * quat.y;\n  float xz2 = 2.0 * quat.x * quat.z;\n  float xw2 = 2.0 * quat.x * quat.w;\n  float yz2 = 2.0 * quat.y * quat.z;\n  float yw2 = 2.0 * quat.y * quat.w;\n  float zw2 = 2.0 * quat.z * quat.w;\n  float xx = quat.x * quat.x;\n  float yy = quat.y * quat.y;\n  float zz = quat.z * quat.z;\n  float ww = quat.w * quat.w;\n  mat4 matrix = mat4(\n\t   xx - yy - zz + ww, xy2 + zw2, xz2 - yw2, 0,\n\t   xy2 - zw2, -xx + yy - zz + ww, yz2 + xw2, 0,\n\t   xz2 + yw2, yz2 - xw2, -xx - yy + zz + ww, 0,\n\t   translation.x, translation.y, translation.z, 1\n   );\n   return matrix;\n}\nvoid main(void){\n\te_boneIndex = attribute_boneIndex;\n\te_boneWeight = attribute_boneWeight;\n\tvec4 temp_position = vec4(attribute_position, 1.0) ;\n\tmat4 m0 = buildMat4(int(e_boneIndex.x));\n\tmat4 m1 = buildMat4(int(e_boneIndex.y));\n\tmat4 m2 = buildMat4(int(e_boneIndex.z));\n\tmat4 m3 = buildMat4(int(e_boneIndex.w));\n\toutPosition = m0 * temp_position * e_boneWeight.x;\n\toutPosition += m1 * temp_position * e_boneWeight.y;\n\toutPosition += m2 * temp_position * e_boneWeight.z;\n\toutPosition += m3 * temp_position * e_boneWeight.w;\n\te_position = outPosition.xyz;\n\t\n    mat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix); \n    \n\tvarying_color = attribute_color; \n\tvarying_uv0 = attribute_uv0 ;\n\tvarying_pos = uniform_ProjectionMatrix * uniform_ViewMatrix * uniform_ModelMatrix * vec4(e_position, 1.0);\n\tgl_Position = varying_pos;\n}",
            shadowPass_vs: "attribute vec3 attribute_position;\nattribute vec4 attribute_color;\nattribute vec2 attribute_uv0;\nuniform mat4 uniform_ModelMatrix ;\nuniform mat4 uniform_ViewMatrix ;\nuniform mat4 uniform_ProjectionMatrix ;\nvarying vec2 varying_uv0;\nvarying vec4 varying_color;\nvarying vec4 varying_pos;\nvoid main(void){\n\tmat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix); \n\tvarying_color = attribute_color; \n\tvarying_uv0 = attribute_uv0 ;\n\tvarying_pos = uniform_ProjectionMatrix * uniform_ViewMatrix * uniform_ModelMatrix * vec4(attribute_position, 1.0);\n\tgl_Position = varying_pos;\n}",
            skeletonShadowPass_vs: "attribute vec4 attribute_boneIndex;\nattribute vec4 attribute_boneWeight;\nattribute vec4 attribute_color;\nvec4 e_boneIndex = vec4(0.0, 0.0, 0.0, 0.0);\nvec4 e_boneWeight = vec4(0.0, 0.0, 0.0, 0.0);\nconst int bonesNumber = 0;\nuniform vec4 uniform_PoseMatrix[bonesNumber];\nmat4 buildMat4(int index){\n  vec4 quat = uniform_PoseMatrix[index * 2 + 0];\n  vec4 translation = uniform_PoseMatrix[index * 2 + 1];\n  float xx = quat.x * quat.x;\n  float xy = quat.x * quat.y;\n  float xz = quat.x * quat.z;\n  float xw = quat.x * quat.w;\n  float yy = quat.y * quat.y;\n  float yz = quat.y * quat.z;\n  float yw = quat.y * quat.w;\n  float zz = quat.z * quat.z;\n  float zw = quat.z * quat.w;\n   return mat4(\n\t   1.0 - 2.0 * (yy + zz),\t\t2.0 * (xy + zw),\t\t2.0 * (xz - yw),\t\t0,\n\t   2.0 * (xy - zw),\t\t\t\t1.0 - 2.0 * (xx + zz),\t2.0 * (yz + xw),\t\t0,\n\t   2.0 * (xz + yw),\t\t\t\t2.0 * (yz - xw),\t\t1.0 - 2.0 * (xx + yy),\t0,\n\t   translation.x,\t\t\t\ttranslation.y,\t\t\ttranslation.z,\t\t\t1\n   );\n}\nvoid main(void){\n\tvarying_color = attribute_color; \n\te_boneIndex = attribute_boneIndex;\n\te_boneWeight = attribute_boneWeight;\n\tvec4 temp_position = vec4(attribute_position, 1.0) ;\n\tmat4 m0 = buildMat4(int(e_boneIndex.x));\n\tmat4 m1 = buildMat4(int(e_boneIndex.y));\n\tmat4 m2 = buildMat4(int(e_boneIndex.z));\n\tmat4 m3 = buildMat4(int(e_boneIndex.w));\n\toutPosition = m0 * temp_position * e_boneWeight.x;\n\toutPosition += m1 * temp_position * e_boneWeight.y;\n\toutPosition += m2 * temp_position * e_boneWeight.z;\n\toutPosition += m3 * temp_position * e_boneWeight.w;\n\t\n\te_position = outPosition.xyz;\n\toutPosition = uniform_ModelMatrix * uniform_ViewMatrix *  outPosition; \n    \n}",
            skeleton_vs: "attribute vec4 attribute_boneIndex;\nattribute vec4 attribute_boneWeight;\nattribute vec3 attribute_normal;\nattribute vec4 attribute_color;\nvec4 e_boneIndex = vec4(0.0, 0.0, 0.0, 0.0);\nvec4 e_boneWeight = vec4(0.0, 0.0, 0.0, 0.0);\nconst int bonesNumber = 0;\nuniform vec4 uniform_PoseMatrix[bonesNumber];\nvarying vec4 varying_mvPose  ;\nmat4 buildMat4(int index){\n  vec4 quat = uniform_PoseMatrix[index * 2 + 0];\n  vec4 translation = uniform_PoseMatrix[index * 2 + 1];\n  float xy2 = 2.0 * quat.x * quat.y;\n  float xz2 = 2.0 * quat.x * quat.z;\n  float xw2 = 2.0 * quat.x * quat.w;\n  float yz2 = 2.0 * quat.y * quat.z;\n  float yw2 = 2.0 * quat.y * quat.w;\n  float zw2 = 2.0 * quat.z * quat.w;\n  float xx = quat.x * quat.x;\n  float yy = quat.y * quat.y;\n  float zz = quat.z * quat.z;\n  float ww = quat.w * quat.w;\n  mat4 matrix = mat4(\n\t   xx - yy - zz + ww, xy2 + zw2, xz2 - yw2, 0,\n\t   xy2 - zw2, -xx + yy - zz + ww, yz2 + xw2, 0,\n\t   xz2 + yw2, yz2 - xw2, -xx - yy + zz + ww, 0,\n\t   translation.x, translation.y, translation.z, 1\n   );\n   return matrix;\n}\nvoid main(void){\n\te_boneIndex = attribute_boneIndex;\n\te_boneWeight = attribute_boneWeight;\n\tvec4 temp_position = vec4(attribute_position, 1.0) ;\n\tvec4 temp_normal = vec4(attribute_normal, 0.0) ;\n\tmat4 m0 = buildMat4(int(e_boneIndex.x));\n\tmat4 m1 = buildMat4(int(e_boneIndex.y));\n\tmat4 m2 = buildMat4(int(e_boneIndex.z));\n\tmat4 m3 = buildMat4(int(e_boneIndex.w));\n\toutPosition = m0 * temp_position * e_boneWeight.x;\n\toutPosition += m1 * temp_position * e_boneWeight.y;\n\toutPosition += m2 * temp_position * e_boneWeight.z;\n\toutPosition += m3 * temp_position * e_boneWeight.w;\n\te_position = outPosition.xyz;\n\tvec4 temp_n ;\n\ttemp_n  = m0 * temp_normal * e_boneWeight.x;\n\ttemp_n += m1 * temp_normal * e_boneWeight.y;\n\ttemp_n += m2 * temp_normal * e_boneWeight.z;\n\ttemp_n += m3 * temp_normal * e_boneWeight.w;\n\t\n    mat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix); \n    varying_mvPose = mvMatrix * vec4( e_position , 1.0 ) ; \n    \n    mat4 normalMatrix = inverse(mvMatrix) ;\n    normalMatrix = transpose(normalMatrix); \n    \n    varying_eyeNormal = mat3(normalMatrix) * -temp_n.xyz ; \n    \n    outPosition.xyzw = varying_mvPose.xyzw ; \n    varying_color = attribute_color; \n}",
            specularMap_fragment: "uniform sampler2D specularTexture;\nvoid main(void){\n   \ts.Specular = texture2D(specularTexture, uv_0).xyzx ;\n}\n",
            tangent_vs: "attribute vec3 attribute_tangent;\nvoid main(void){\n} ",
            terrainRGBA_fragment: "uniform sampler2D blendMaskTexture ;\nuniform sampler2D splat_0Tex ;\nuniform sampler2D splat_1Tex ;\nuniform sampler2D splat_2Tex ;\nuniform sampler2D splat_3Tex ;\nuniform float uvs[8];\nvoid main() {\n\tmaterialSource.refraction = 3.0 ;\n\tvec4 splat_control = texture2D ( blendMaskTexture , varying_uv0 );\n\tvec4 cc = vec4(0.0,0.0,0.0,1.0);\n\tvec2 uv = varying_uv0 ;\n\tcc.xyz = splat_control.x * texture2D (splat_0Tex, uv * vec2(uvs[0],uvs[1])).xyz ;\n\tcc.xyz += splat_control.y * texture2D (splat_1Tex, uv * vec2(uvs[2],uvs[3]) ).xyz;\n\tcc.xyz += splat_control.z * vec4(texture2D (splat_2Tex, uv* vec2(uvs[4],uvs[5]))).xyz;\n\tcc.xyz += (1.0-splat_control.w) * vec4(texture2D (splat_3Tex, uv* vec2(uvs[6],uvs[7]))).xyz; \n\ts.Albedo.xyz = cc.xyz ; \n\toutColor.xyz = s.Albedo.xyz;\n\toutColor.w = 1.0;\n}\n",
            uvRoll_fs: "uniform float uvRoll[2] ;\nuniform sampler2D diffuseTexture;\nvec4 diffuseColor ;\nvoid main() {\n    uv_0.xy += vec2(uvRoll[0],uvRoll[1]);\n\tdiffuseColor = texture2D(diffuseTexture , uv_0 );\n}",
            uvSpriteSheet_fs: "uniform float uvSpriteSheet[4] ;\nuniform sampler2D diffuseTexture;\nvec4 diffuseColor ;\nvoid main() {\n    uv_0.xy *= vec2(uvSpriteSheet[2],uvSpriteSheet[3]);\n    uv_0.xy += vec2(uvSpriteSheet[0],uvSpriteSheet[1]);\n\tdiffuseColor = texture2D(diffuseTexture , uv_0 );\n}",
            uvStreamerRoll_fs: "uniform float uvRoll[3] ;\nuniform sampler2D diffuseTexture;\nuniform sampler2D streamerTexture;\nvec4 diffuseColor ;\nvoid main() {\n    \n\tdiffuseColor = texture2D(diffuseTexture , varying_uv0 );\n    \n    vec2 rollUV = varying_uv0 + vec2(uvRoll[0],uvRoll[1]) + vec2(normal.xz) * 0.5 ;\n\tdiffuseColor.xyz += texture2D(streamerTexture , rollUV ).xyz * uvRoll[2] ;\n    \n}",
            varyingViewDir_vs: "varying vec3 varying_ViewDir; \nuniform vec3 uniform_eyepos; \nvoid main(void){ \n    varying_ViewDir = (uniform_eyepos.xyz - e_position) ; \n}",
            vertexPos_vs: "uniform mat4 uniform_ModelMatrix;\nuniform mat4 uniform_ViewMatrix;\nvarying vec4 varying_mvPose;\nvoid main() {\n       varying_mvPose = uniform_ViewMatrix * uniform_ModelMatrix * vec4(e_position, 1.0) ; \n}\n                      ",
            waterBump_fs: "uniform vec2 waterNormalData[4];\nuniform vec4 horizonColor;\nuniform float time ;\nuniform sampler2D bumpTexture;\nuniform sampler2D colorControlTexture;\nvarying vec2 varying_uv0        ;\nvarying vec2 varying_uv0        ;\nvec4 UnpackNormal( vec4 nT ){\n    vec4 t ;\n    t.xyzw = nT.xyzw * 2.0 - 1.0 ;\n    return t ;\n}\nmat3 TBN ;\nmat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) {\n    vec3 dp1 = dFdx(p);\n    vec3 dp2 = dFdy(p);\n    vec2 duv1 = dFdx(uv);\n    vec2 duv2 = dFdy(uv);\n    vec3 dp2perp = cross(dp2, N);\n    vec3 dp1perp = cross(N, dp1);\n    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n    float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));\n    return mat3(T * invmax, B * invmax, N);\n}\nvoid main(void){\n    float tempTime = mod(time,10000000.0); \n    vec2 uvA = uv_0 * waterNormalData[3].x + waterNormalData[0] * tempTime ; \n    vec2 uvB = uv_0 * waterNormalData[3].y + waterNormalData[1] * tempTime  ; \n    TBN = cotangentFrame(normal,varying_mvPose.xyz, varying_uv0) ;\n    vec3 viewDir = normalize(varying_mvPose.xyz/varying_mvPose.w) ;\n    vec3 bump1 = UnpackNormal(texture2D( bumpTexture, uvA )).rgb;\n\tvec3 bump2 = UnpackNormal(texture2D( bumpTexture, uvB )).rgb;\n\tvec3 bump = (bump1 + bump2) * 0.5;\n    normal = TBN * bump ;\n\t\n\tfloat fresnel = dot( viewDir, bump );\n\tvec4 water = texture2D( colorControlTexture, vec2(fresnel,fresnel) );\n\t\n\tvec4 col;\n\tdiffuseColor.rgb = mix( water.rgb, horizonColor.rgb, water.a );\n\tdiffuseColor.a = horizonColor.a;\n}",
            waterDiffuse_fs: "uniform sampler2D diffuseTexture;\nvec4 diffuseColor ;\nvoid main() {\n\t\t\tdiffuseColor.xyz *= diffuseColor.w ;\n}\n",
            waterNormal_fs: "uniform vec2 waterNormalData[4];\nuniform float time ;\nuniform sampler2D normalTextureA;\nuniform sampler2D normalTextureB;\nvarying vec4 varying_mvPose;\nvarying vec2 varying_uv0;\nmat3 TBN ;\nmat3 cotangentFrame(vec3 N, vec3 p, vec2 uv) {\n    vec3 dp1 = dFdx(p);\n    vec3 dp2 = dFdy(p);\n    vec2 duv1 = dFdx(uv);\n    vec2 duv2 = dFdy(uv);\n    vec3 dp2perp = cross(dp2, N);\n    vec3 dp1perp = cross(N, dp1);\n    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n    float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));\n    return mat3(T * invmax, B * invmax, N);\n}\nvec3 tbn(vec3 map, vec3 N, vec3 V, vec2 texcoord) {\n    mat3 TBN = cotangentFrame(N, -V, texcoord);\n    return normalize(TBN * map);\n}\nvoid main(void){\n    TBN = cotangentFrame(normal,varying_mvPose.xyz, varying_uv0) ;\n    float tempTime = mod(time,100000.0); \n    vec2 uvA = uv_0 * waterNormalData[3].x + waterNormalData[0] * tempTime ; \n    vec2 uvB = uv_0 * waterNormalData[3].y + waterNormalData[1] * tempTime  ; \n    vec3 bump1 = texture2D( normalTextureA, uvA ).rgb * 2.0-1.0 ; \n    bump1.y *= -1.0;\n    bump1.xyz = TBN * bump1 ; \n    normal.xyz = bump1.xyz ;\n    \n    vec3 bump2 = texture2D( normalTextureB, uvB ).rgb * 2.0-1.0 ; \n    bump2.y *= -1.0;\n    bump2.xyz = TBN * bump2 ; \n    normal.xyz = (normal.xyz + bump2.xyz)*0.5 ;\n    \n} ",
            wave_fs: "uniform sampler2D diffuseTexture;\nuniform vec3 uniform_eyepos; \nuniform vec4 waveFSData[2]; \nvarying vec4 varying_mvPose;\nvec4 diffuseColor ;\nvoid main(void){\n    vec3 viewDir = normalize(varying_mvPose.xyz/varying_mvPose.w); \n    diffuseColor.xyz = vec3(1.0,1.0,1.0) ; \n    vec3 shallowWaterColor = waveFSData[0].xyz * waveFSData[0].w ;\n    vec3 deepWaterColor = waveFSData[1].xyz * waveFSData[1].w;\n    float facing = clamp(dot( -normalize(viewDir),normal),0.0,1.0);\n    vec3 waterColor = mix(shallowWaterColor,deepWaterColor,facing);\n    diffuseColor.xyz *= waterColor ;\n} ",
            wave_vs: "#define VERTEX_TEXTURES\nattribute vec3 attribute_normal;\nattribute vec4 attribute_color;\nuniform mat4 uniform_ModelMatrix;\nuniform mat4 uniform_ViewMatrix;\nvarying vec4 varying_mvPose;\nuniform vec3 waveVSData[4];\nuniform float time ;\nstruct wave{\n    vec3 wave_xyz_intensity_0 ;\n    vec3 wave_xyz_intensity_1 ;\n    vec3 wave_xyz_speed_0 ;\n    vec3 wave_xyz_speed_1 ;\n};\nconst float pi = 3.14 ;\nvec3 calcWave2( float t , vec3 x, float amplitude, float waveLength ,float angularVelocity ,  vec3 waveDir ){\n  \n   angularVelocity = angularVelocity * 0.1;\n   vec3 waveVector = waveDir ;\n   float waveNumber = pi / waveLength;\n   waveVector *= waveNumber ;\n  \n  vec3 temp ; \n   float kDotX0SubWt = dot(waveVector , x ) - angularVelocity * t  * 0.001;\n   float A = amplitude * sin(kDotX0SubWt) ;\n   temp.xz = waveDir.xz * A ;\n   temp.y += amplitude * cos(kDotX0SubWt);\n   temp = x - temp ;\n   return temp ;\n}\nvoid main(void){\n   wave wa ; \n    wa.wave_xyz_intensity_0 = vec3(waveVSData[0]) ; \n    wa.wave_xyz_intensity_1 = vec3(waveVSData[1]) ; \n    wa.wave_xyz_speed_0 = vec3(waveVSData[2]) ; \n    wa.wave_xyz_speed_1 = vec3(waveVSData[3]) ; \n    \n    float tempTime = mod( time , 1000000.0 ); \n\tvec3 newPose1 = calcWave2(tempTime,e_position,40.0, 20.0, 10.0,vec3(1.0,0.0,1.0)); \n\tnewPose1 += calcWave2(tempTime,e_position,20.0, 10.0, 10.0,vec3(1.0,0.0,-0.5)); \n\tnewPose1 += calcWave2(tempTime,e_position,1.0, 1.0, 10.0,vec3(1.0,0.0,-1.5)); \n    e_position = newPose1 ; \n    \n    mat4 mvMatrix = mat4(uniform_ViewMatrix * uniform_ModelMatrix); \n    \n    varying_mvPose = mvMatrix * vec4( e_position , 1.0 )  ; \n    \n    mat4 normalMatrix = inverse(mvMatrix) ;\n    normalMatrix = transpose(normalMatrix); \n    \n    varying_eyeNormal = mat3(normalMatrix) * -attribute_normal ; \n    \n    outPosition = varying_mvPose ; \n    varying_color = attribute_color; \n} ",
        };
        return ShaderLib;
    }());
    egret3d.ShaderLib = ShaderLib;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ShaderPool = (function () {
        function ShaderPool() {
        }
        ShaderPool.register = function (context) {
            this.context = context;
        };
        ShaderPool.getGPUShader = function (shaderType, shaderID, source) {
            var shader = this.vsShaderHashMap.getValue(shaderID);
            if (!shader) {
                shader = this.fsShaderHashMap.getValue(shaderID);
            }
            if (!shader) {
                if (shaderType == egret3d.Shader.vertex) {
                    shader = this.context.creatVertexShader(source);
                    shader.id = shaderID;
                    this.vsShaderHashMap.add(shaderID, shader);
                }
                else if (shaderType == egret3d.Shader.fragment) {
                    shader = this.context.creatFragmentShader(source);
                    shader.id = shaderID;
                    this.fsShaderHashMap.add(shaderID, shader);
                }
            }
            return shader;
            //if (shaderType == Shader.vertex) {
            //    return this.context.creatVertexShader(source);
            //}
            //return this.context.creatFragmentShader(source);
        };
        ShaderPool.getProgram = function (vs_shaderID, fs_shaderID) {
            var vsShader = this.vsShaderHashMap.getValue(vs_shaderID);
            var fsShader = this.fsShaderHashMap.getValue(fs_shaderID);
            var name = vsShader.id + "_" + fsShader.id;
            var program3D;
            if (this.programlib.isHas(name)) {
                program3D = this.programlib.getValue(name);
            }
            else {
                program3D = this.registerProgram(vsShader, fsShader);
                this.programlib.add(name, program3D);
            }
            return this.programlib.getValue(name);
        };
        ShaderPool.unRegisterShader = function (list) {
            //to delet shader
        };
        ShaderPool.registerProgram = function (vsShader, fsShader) {
            var program3D = this.context.creatProgram(vsShader, fsShader);
            return program3D;
        };
        ShaderPool.unRegisterProgram = function (vsKey, fsKey) {
            //to delet program
        };
        //总shader的map容器
        ShaderPool.programlib = new egret3d.HashMap();
        ShaderPool.vsShaderHashMap = new egret3d.HashMap();
        ShaderPool.fsShaderHashMap = new egret3d.HashMap();
        return ShaderPool;
    }());
    egret3d.ShaderPool = ShaderPool;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.ShaderContent
        * @classdesc
        * shader文件解析后的数据内容
        * 每种变量类型都进行了规类
        * 用相应的列表进行存储，这样可以便于shader文件进行合并
        * @version Egret 3.0
        * @platform Web,Native
        */
        var ShaderContent = (function () {
            function ShaderContent() {
                /**
                * @private
                * shader文件名
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.name = "";
                this.source = "";
                this.funcNames = new Array();
                this.funcDict = {};
                /**
                * @private
                * 结构体列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.structDict = {};
                this.structNames = new Array();
                /**
                * @private
                * attribute列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.attributeList = new Array();
                /**
                * @private
                * varying列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.varyingList = new Array();
                /**
                * @private
                * uniform列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.uniformList = new Array();
                /**
                * @private
                * const列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.constList = new Array();
                /**
                * @private
                * 临时变量列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.tempList = new Array();
                /**
                * @private
                * sampler2D列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.sampler2DList = new Array();
                /**
                * @private
                * sampler3D列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.sampler3DList = new Array();
                this.extensionList = new Array();
                this.defineList = new Array();
            }
            /**
            * @private
            * 增加一个变量对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            ShaderContent.prototype.addVar = function (sVar) {
                if (sVar.key == "attribute") {
                    this.attributeList.push(sVar);
                }
                else if (sVar.key == "varying") {
                    this.varyingList.push(sVar);
                }
                else if (sVar.key == "uniform") {
                    this.uniformList.push(sVar);
                }
                else if (sVar.key == "const") {
                    this.constList.push(sVar);
                }
                else if (sVar.key == "sampler2D") {
                    this.sampler2DList.push(sVar);
                }
                else if (sVar.key == "samplerCube") {
                    this.sampler3DList.push(sVar);
                }
                else if (sVar.key == "#extension") {
                    this.extensionList.push(sVar);
                }
                else if (sVar.key == "#define") {
                    this.defineList.push(sVar);
                }
                else {
                    this.tempList.push(sVar);
                }
            };
            /**
            * @private
            * 增加一个函数
            * @version Egret 3.0
            * @platform Web,Native
            */
            ShaderContent.prototype.addFunc = function (name, func) {
                if (!this.funcDict[name]) {
                    this.funcDict[name] = func;
                    this.funcNames.push(name);
                }
                else {
                    // if (name == "main") {
                    var newfunc = this.mergeMainFunc(this.funcDict[name], func);
                    this.funcDict[name] = newfunc;
                }
                if (this.funcDict["main"]) {
                    var index = this.funcNames.indexOf("main");
                    this.funcNames.splice(index, 1);
                    this.funcNames.push("main");
                }
            };
            /**
            * @private
            * 增加一个结构体
            * @version Egret 3.0
            * @platform Web,Native
            */
            ShaderContent.prototype.addStruct = function (name, structStr) {
                if (!this.structDict[name]) {
                    this.structDict[name] = structStr;
                    this.structNames.push(name);
                }
                else {
                    console.log("<" + name + ">" + "struct重复");
                }
            };
            /**
            * @private
            * 合并一个shader内容
            * @version Egret 3.0
            * @platform Web,Native
            */
            ShaderContent.prototype.addContent = function (otherContent) {
                for (var i = 0; i < otherContent.structNames.length; ++i) {
                    this.addStruct(otherContent.structNames[i], otherContent.structDict[otherContent.structNames[i]]);
                }
                for (var i = 0; i < otherContent.funcNames.length; ++i) {
                    this.addFunc(otherContent.funcNames[i], otherContent.funcDict[otherContent.funcNames[i]]);
                }
                for (var i = 0; i < otherContent.attributeList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.attributeList.length; ++j) {
                        if (otherContent.attributeList[i].name == this.attributeList[j].name) {
                            if (otherContent.attributeList[i].valueType != this.attributeList[j].valueType ||
                                otherContent.attributeList[i].key != this.attributeList[j].key) {
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.attributeList.push(otherContent.attributeList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.varyingList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.varyingList.length; ++j) {
                        if (otherContent.varyingList[i].name == this.varyingList[j].name) {
                            if (otherContent.varyingList[i].valueType != this.varyingList[j].valueType ||
                                otherContent.varyingList[i].key != this.varyingList[j].key) {
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.varyingList.push(otherContent.varyingList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.uniformList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.uniformList.length; ++j) {
                        if (otherContent.uniformList[i].name == this.uniformList[j].name) {
                            if (otherContent.uniformList[i].valueType != this.uniformList[j].valueType ||
                                otherContent.uniformList[i].key != this.uniformList[j].key) {
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.uniformList.push(otherContent.uniformList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.constList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.constList.length; ++j) {
                        if (otherContent.constList[i].name == this.constList[j].name) {
                            if (otherContent.constList[i].valueType != this.constList[j].valueType ||
                                otherContent.constList[i].key != this.constList[j].key) {
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.constList.push(otherContent.constList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.tempList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.tempList.length; ++j) {
                        if (otherContent.tempList[i].name == this.tempList[j].name) {
                            if (otherContent.tempList[i].valueType != this.tempList[j].valueType ||
                                otherContent.tempList[i].key != this.tempList[j].key) {
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.tempList.push(otherContent.tempList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.sampler2DList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.sampler2DList.length; ++j) {
                        if (otherContent.sampler2DList[i].name == this.sampler2DList[j].name) {
                            if (otherContent.sampler2DList[i].valueType != this.sampler2DList[j].valueType ||
                                otherContent.sampler2DList[i].key != this.sampler2DList[j].key) {
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.sampler2DList.push(otherContent.sampler2DList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.sampler3DList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.sampler3DList.length; ++j) {
                        if (otherContent.sampler3DList[i].name == this.sampler3DList[j].name) {
                            if (otherContent.sampler2DList[i].valueType != this.sampler3DList[j].valueType ||
                                otherContent.sampler3DList[i].key != this.sampler3DList[j].key) {
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.sampler3DList.push(otherContent.sampler3DList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.extensionList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.extensionList.length; ++j) {
                        if (otherContent.extensionList[i].name == this.extensionList[j].name) {
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.extensionList.push(otherContent.extensionList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.defineList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.defineList.length; ++j) {
                        if (otherContent.defineList[i].name == this.defineList[j].name) {
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.defineList.push(otherContent.defineList[i].clone());
                    }
                }
            };
            ShaderContent.prototype.mergeMainFunc = function (func1, func2) {
                var ret = func1;
                var func = "";
                var s_pos = func2.indexOf("{");
                var e_pos = func2.lastIndexOf("}");
                s_pos++;
                func = func2.slice(s_pos, e_pos);
                s_pos = ret.lastIndexOf("}");
                var f_func = ret.substr(0, s_pos);
                var s_func = ret.substr(s_pos, ret.length - s_pos);
                ret = f_func;
                ret += func;
                var temp = "";
                var line = "";
                var old = ret;
                ret += line;
                ret += s_func;
                return ret;
            };
            ShaderContent.prototype.clone = function () {
                var content = new ShaderContent();
                content.name = this.name;
                content.source = this.source;
                for (var i = 0; i < this.funcNames.length; ++i) {
                    content.funcNames.push(this.funcNames[i]);
                }
                for (var key in this.funcDict) {
                    content.funcDict[key] = this.funcDict[key];
                }
                for (var i = 0; i < this.structNames.length; ++i) {
                    content.structNames.push(this.structNames[i]);
                }
                for (var key in this.structDict) {
                    content.structDict[key] = this.structDict[key];
                }
                for (var i = 0; i < this.attributeList.length; ++i) {
                    content.attributeList.push(this.attributeList[i].clone());
                }
                for (var i = 0; i < this.varyingList.length; ++i) {
                    content.varyingList.push(this.varyingList[i].clone());
                }
                for (var i = 0; i < this.uniformList.length; ++i) {
                    content.uniformList.push(this.uniformList[i].clone());
                }
                for (var i = 0; i < this.constList.length; ++i) {
                    content.constList.push(this.constList[i].clone());
                }
                for (var i = 0; i < this.tempList.length; ++i) {
                    content.tempList.push(this.tempList[i].clone());
                }
                for (var i = 0; i < this.sampler2DList.length; ++i) {
                    content.sampler2DList.push(this.sampler2DList[i].clone());
                }
                for (var i = 0; i < this.sampler3DList.length; ++i) {
                    content.sampler3DList.push(this.sampler3DList[i].clone());
                }
                for (var i = 0; i < this.attributeList.length; ++i) {
                    content.attributeList.push(this.attributeList[i].clone());
                }
                for (var i = 0; i < this.extensionList.length; ++i) {
                    content.extensionList.push(this.extensionList[i].clone());
                }
                for (var i = 0; i < this.defineList.length; ++i) {
                    content.defineList.push(this.defineList[i].clone());
                }
                return content;
            };
            return ShaderContent;
        }());
        GLSL.ShaderContent = ShaderContent;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.FuncData
    * @classdesc
    * shader系统工具类，管理所有要用到的shader文件
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ShaderUtil = (function () {
        function ShaderUtil() {
            this._shaderContentDict = [];
            this.vs_begin = "##define vs begin##";
            this.vs_end = "##define vs end##";
            this.fs_begin = "##define fs begin##";
            this.fs_end = "##define fs end##";
        }
        Object.defineProperty(ShaderUtil, "instance", {
            /**
            * @language zh_CN
            *
            * 单例
            */
            get: function () {
                if (!this._instance) {
                    this._instance = new ShaderUtil();
                }
                return this._instance;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * @private
        * 加载shader文件
        */
        ShaderUtil.prototype.load = function () {
            var del = [];
            var add = [];
            for (var key in egret3d.ShaderLib.lib) {
                var s_pos = egret3d.ShaderLib.lib[key].indexOf(this.vs_begin);
                var e_pos = egret3d.ShaderLib.lib[key].indexOf(this.vs_end);
                var isDel = false;
                if (s_pos != -1) {
                    isDel = true;
                    s_pos += this.vs_begin.length;
                    del.push(key);
                    add[key + "vs"] = egret3d.ShaderLib.lib[key].substr(s_pos, e_pos - s_pos);
                }
                s_pos = egret3d.ShaderLib.lib[key].indexOf(this.fs_begin);
                e_pos = egret3d.ShaderLib.lib[key].indexOf(this.fs_end);
                if (s_pos != -1) {
                    s_pos += this.fs_begin.length;
                    if (isDel) {
                        del.push(key);
                    }
                    add[key + "fs"] = egret3d.ShaderLib.lib[key].substr(s_pos, e_pos - s_pos);
                }
            }
            for (var key in del) {
                delete egret3d.ShaderLib.lib[del[key]];
            }
            for (var key in add) {
                egret3d.ShaderLib.lib[key] = add[key];
            }
            for (var key in egret3d.ShaderLib.lib) {
                var content = this.readShader(egret3d.ShaderLib.lib[key]);
                this._shaderContentDict[key] = content;
                content.name = key;
            }
        };
        ShaderUtil.prototype.readShader = function (str) {
            var content = new egret3d.GLSL.ShaderContent();
            var shaderStr = egret3d.StringUtil.processShaderFile(str);
            var source = egret3d.StringUtil.parseContent(shaderStr);
            var shaderLine = source.concat();
            while (shaderLine.length > 0) {
                var line = shaderLine[0];
                shaderLine.shift();
                var ret = egret3d.StringUtil.getLineType(line);
                var index = -1;
                index = ret.indexOf("struct");
                if (index != -1) {
                    var tempArray = ret.split(" ");
                    var structStr = line;
                    content.addStruct(tempArray[1], structStr);
                    egret3d.StringUtil.processStruct(tempArray[1], structStr, content);
                    continue;
                }
                index = ret.indexOf("function");
                if (index != -1) {
                    var tempArray = ret.split(" ");
                    var func = line;
                    content.addFunc(tempArray[1], func);
                    continue;
                }
                index = ret.indexOf("unknown");
                if (index != -1) {
                    var tempArray = egret3d.StringUtil.parseLines(line);
                    var key = egret3d.StringUtil.getVarKey(tempArray);
                    var valueType = egret3d.StringUtil.getVarType(tempArray);
                    if (valueType == "sampler2D") {
                        var sampler2D = egret3d.StringUtil.getSampler2D(line);
                        if (sampler2D)
                            content.addVar(sampler2D);
                    }
                    else if (valueType == "samplerCube") {
                        var sampler3D = egret3d.StringUtil.getSampler3D(line);
                        if (sampler3D)
                            content.addVar(sampler3D);
                    }
                    else {
                        if (key == "attribute") {
                            var att = egret3d.StringUtil.getAttribute(line);
                            if (att)
                                content.addVar(att);
                        }
                        else if (key == "varying") {
                            var varying = egret3d.StringUtil.getVarying(line);
                            if (varying)
                                content.addVar(varying);
                        }
                        else if (key == "uniform") {
                            var uniform = egret3d.StringUtil.getUniform(line);
                            if (uniform)
                                content.addVar(uniform);
                        }
                        else if (key == "const") {
                            var ConstVar = egret3d.StringUtil.getConst(line);
                            if (ConstVar)
                                content.addVar(ConstVar);
                        }
                        else if (key == "#extension") {
                            var extension = egret3d.StringUtil.getExtension(line);
                            if (extension)
                                content.addVar(extension);
                        }
                        else if (key == "#define") {
                            var def = egret3d.StringUtil.getDefine(line);
                            if (def)
                                content.addVar(def);
                        }
                        else {
                            content.addVar(egret3d.StringUtil.getTemper(line));
                        }
                    }
                    continue;
                }
            }
            return content;
        };
        /**
        * @language zh_CN
        * 返回组合shader后的内容
        * @param shaderNameList 要组合的shader名字列表
        * @param usage
        * @returns shader 内容
        */
        ShaderUtil.prototype.fillShaderContent = function (shaderBase, shaderNameList, usage) {
            var shaderContent;
            var i = 0;
            var varName = "";
            for (i = 0; i < shaderNameList.length; ++i) {
                if (varName != "") {
                    varName += "/";
                }
                varName += shaderNameList[i];
            }
            varName += "/d" + usage.maxDirectLight;
            varName += "/s" + usage.maxSpotLight;
            varName += "/p" + usage.maxPointLight;
            varName += "/b" + usage.maxBone;
            if (!this._shaderContentDict[varName]) {
                shaderContent = new egret3d.GLSL.ShaderContent();
                shaderContent.name = varName;
                for (i = 0; i < shaderNameList.length; ++i) {
                    var tempContent = this._shaderContentDict[shaderNameList[i]];
                    shaderContent.addContent(tempContent);
                }
            }
            else {
                shaderContent = this._shaderContentDict[varName].clone();
            }
            for (i = 0; i < shaderContent.attributeList.length; i++) {
                varName = shaderContent.attributeList[i].varName;
                usage[varName] = shaderContent.attributeList[i];
            }
            for (i = 0; i < shaderContent.varyingList.length; i++) {
                varName = shaderContent.varyingList[i].varName;
                if (!usage[varName]) {
                    usage[varName] = shaderContent.varyingList[i];
                }
            }
            for (i = 0; i < shaderContent.tempList.length; i++) {
                varName = shaderContent.tempList[i].varName;
                usage[varName] = shaderContent.tempList[i];
            }
            for (i = 0; i < shaderContent.uniformList.length; i++) {
                varName = shaderContent.uniformList[i].varName;
                usage[varName] = shaderContent.uniformList[i];
            }
            var constR;
            for (i = 0; i < shaderContent.constList.length; i++) {
                varName = shaderContent.constList[i].varName;
                constR = shaderContent.constList[i];
                usage[varName] = constR;
                switch (varName) {
                    case "max_directLight":
                        constR.value = usage.maxDirectLight;
                        break;
                    case "max_spotLight":
                        constR.value = usage.maxSpotLight;
                        break;
                    case "max_pointLight":
                        constR.value = usage.maxPointLight;
                        break;
                    case "bonesNumber":
                        shaderBase.maxBone = usage.maxBone;
                        constR.value = usage.maxBone;
                        break;
                }
            }
            ///sampler
            for (i = 0; i < shaderContent.sampler2DList.length; i++) {
                var sampler2D = shaderContent.sampler2DList[i];
                sampler2D.index = i;
                usage.sampler2DList.push(sampler2D);
                sampler2D.activeTextureIndex = ShaderUtil.getTexture2DIndex(i);
            }
            //for (i = 0; i < usage.sampler2DList.length; i++) {
            //    var sampler2D: GLSL.Sampler2D = usage.sampler2DList[i];
            //    sampler2D.index = i;
            //}
            ///sampler
            for (i = 0; i < shaderContent.sampler3DList.length; i++) {
                var sampler3D = shaderContent.sampler3DList[i];
                sampler3D.activeTextureIndex = ShaderUtil.getTexture2DIndex(shaderContent.sampler2DList.length + i);
                sampler3D.index = shaderContent.sampler2DList.length + i;
                usage.sampler3DList.push(sampler3D);
            }
            //usage.sampler3DList = shaderContent.sampler3DList;
            this.synthesisShader(shaderContent, shaderBase);
            return egret3d.ShaderPool.getGPUShader(shaderBase.shaderType, shaderContent.name, shaderContent.source);
        };
        ShaderUtil.prototype.synthesisShader = function (content, shaderBase) {
            var i;
            var source = "";
            for (i = 0; i < content.extensionList.length; i++) {
                source += ShaderUtil.connectExtension(content.extensionList[i]);
            }
            source += "precision highp float;            \t\n";
            for (i = 0; i < content.defineList.length; i++) {
                source += ShaderUtil.connectDefine(content.defineList[i]);
            }
            ///var attribute
            for (i = 0; i < content.attributeList.length; i++) {
                source += ShaderUtil.connectAtt(content.attributeList[i]);
            }
            ///var struct
            for (i = 0; i < content.structNames.length; i++) {
                source += ShaderUtil.connectStruct(content.structDict[content.structNames[i]]);
            }
            ///var varying
            for (i = 0; i < content.varyingList.length; i++) {
                source += ShaderUtil.connectVarying(content.varyingList[i]);
            }
            ///temp
            for (i = 0; i < content.tempList.length; i++) {
                source += ShaderUtil.connectTemp(content.tempList[i]);
            }
            ///const
            for (i = 0; i < content.constList.length; i++) {
                source += ShaderUtil.connectConst(content.constList[i]);
            }
            ///uniform
            for (i = 0; i < content.uniformList.length; i++) {
                source += ShaderUtil.connectUniform(content.uniformList[i]);
            }
            ///sampler
            for (i = 0; i < content.sampler2DList.length; i++) {
                var sampler2D = content.sampler2DList[i];
                source += ShaderUtil.connectSampler(sampler2D);
            }
            ///sampler
            for (i = 0; i < content.sampler3DList.length; i++) {
                var sampler3D = content.sampler3DList[i];
                source += ShaderUtil.connectSampler3D(sampler3D);
            }
            ///---------------------------------------------------------------------------------
            ///---------------------------------------------------------------------------------
            for (i = 0; i < content.funcNames.length; i++) {
                source += content.funcDict[content.funcNames[i]];
            }
            content.source = source;
        };
        //----------------------------------------------------------------------------------------------------------------
        //----------------------------------------------------------------------------------------------------------------
        //----------------------------------------------------------------------------------------------------------------
        //----------------------------------------------------------------------------------------------------------------
        //----------------------------------------------------------------------------------------------------------------
        /**
        * @language zh_CN
        *
        * @param att
        */
        ShaderUtil.connectAtt = function (att) {
            return "attribute " + att.valueType + " " + att.name + "; \r\n";
        };
        /**
        * @language zh_CN
        *
        * @param tempVar
        */
        ShaderUtil.connectTemp = function (tempVar) {
            if (tempVar.value != "") {
                return tempVar.valueType + " " + tempVar.name + " = " + tempVar.value + "; \r\n";
            }
            return tempVar.valueType + " " + tempVar.name + "; \r\n";
        };
        /**
        * @language zh_CN
        *
        * @param struct
        */
        ShaderUtil.connectStruct = function (struct) {
            return struct + " \r\n";
        };
        /**
        * @language zh_CN
        *
        * @param constVar
        */
        ShaderUtil.connectConst = function (constVar) {
            return "const " + constVar.valueType + " " + constVar.name + " = " + constVar.value + "; \r\n";
        };
        /**
        * @language zh_CN
        *
        * @param varying
        */
        ShaderUtil.connectVarying = function (varying) {
            return "varying " + varying.valueType + " " + varying.name + "; \r\n";
        };
        /**
        * @language zh_CN
        *
        * @param unifrom
        */
        ShaderUtil.connectUniform = function (unifrom) {
            return "uniform " + unifrom.valueType + " " + unifrom.name + "; \r\n";
        };
        /**
        * @language zh_CN
        *
        * @param sampler
        */
        ShaderUtil.connectSampler = function (sampler) {
            return "uniform sampler2D " + sampler.name + "; \r\n";
        };
        ShaderUtil.connectSampler3D = function (sampler) {
            return "uniform samplerCube " + sampler.name + "; \r\n";
        };
        ShaderUtil.connectExtension = function (extension) {
            return "#extension " + extension.name + ":" + extension.value + "\r\n";
        };
        ShaderUtil.connectDefine = function (def) {
            return def.key + " " + def.name + " " + def.value + "\r\n";
        };
        ShaderUtil.getTexture2DIndex = function (i) {
            switch (i) {
                case 0:
                    return egret3d.ContextSamplerType.TEXTURE_0;
                case 1:
                    return egret3d.ContextSamplerType.TEXTURE_1;
                case 2:
                    return egret3d.ContextSamplerType.TEXTURE_2;
                case 3:
                    return egret3d.ContextSamplerType.TEXTURE_3;
                case 4:
                    return egret3d.ContextSamplerType.TEXTURE_4;
                case 5:
                    return egret3d.ContextSamplerType.TEXTURE_5;
                case 6:
                    return egret3d.ContextSamplerType.TEXTURE_6;
                case 7:
                    return egret3d.ContextSamplerType.TEXTURE_7;
                case 8:
                    return egret3d.ContextSamplerType.TEXTURE_8;
            }
            throw new Error("texture not big then 8");
        };
        ShaderUtil._shaderLibs = {};
        ShaderUtil._methodLibs = {};
        return ShaderUtil;
    }());
    egret3d.ShaderUtil = ShaderUtil;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var KDData = (function () {
        function KDData(location, data) {
            this.location = location;
            this.data = data;
        }
        return KDData;
    }());
    egret3d.KDData = KDData;
    var KDTree = (function () {
        function KDTree() {
        }
        KDTree.prototype.buildTree = function (data) {
            var points = data.map(function (d) {
                var point = [d.location[0], d.location[1]];
                point["datum"] = d;
                return point;
            });
            this.root = this.treeify(points, 0);
        };
        KDTree.prototype.treeify = function (points, depth) {
            try {
                var k = points[0].length;
            }
            catch (e) {
                return null;
            }
            // Select axis based on depth so that axis cycles through all valid values
            var axis = depth % k;
            // TODO: To speed up, consider splitting points based on approximation of
            //       median; take median of random sample of points (perhaps of 1/10th 
            //       of the points)
            // Sort point list and choose median as pivot element
            points.sort(function (a, b) { return a[axis] - b[axis]; });
            var i_median = Math.floor(points.length / 2);
            // Create node and construct subtrees
            var point = points[i_median], left_points = points.slice(0, i_median), right_points = points.slice(i_median + 1);
            return new KDNode(point, axis, [this.treeify(left_points, depth + 1), this.treeify(right_points, depth + 1)], point["datum"]);
        };
        return KDTree;
    }());
    egret3d.KDTree = KDTree;
    var KDNode = (function () {
        function KDNode(location, axis, subnodes, datum) {
            this.location = location;
            this.axis = axis;
            this.subnodes = subnodes; // = children nodes = [left child, right child]
            this.datum = datum;
        }
        KDNode.prototype.find = function (target, count) {
            count = count || 1;
            var queue = new BPQ(count);
            search(this);
            return queue.values;
            // k-NN algorithm outlined here:
            // http://web.stanford.edu/class/cs106l/handouts/assignment-3-kdtree.pdf
            function search(node) {
                if (node === null)
                    return;
                var distance = KDNode.distance(node.location, target);
                // Add current point to BPQ
                queue.add(node, distance);
                // Recursively search the half of the tree that contains the test point
                if (target[node.axis] < node.location[node.axis]) {
                    // Check left
                    search(node.subnodes[0]);
                    var otherNode = node.subnodes[1];
                }
                else {
                    // Check right
                    search(node.subnodes[1]);
                    var otherNode = node.subnodes[0];
                }
                // If candidate hypersphere crosses this splitting plane, look on the
                // other side of the plane by examining the other subtree
                var delta = Math.abs(node.location[node.axis] - target[node.axis]);
                if (!queue.isFull() || delta < queue.maxPriority()) {
                    search(otherNode);
                }
            }
        };
        KDNode.distance = function (p0, p1) {
            return Math.sqrt(Math.pow(p1[0] - p0[0], 2) + Math.pow(p1[1] - p0[1], 2));
        };
        return KDNode;
    }());
    egret3d.KDNode = KDNode;
    var BPQ = (function () {
        function BPQ(capacity) {
            this.capacity = capacity;
            this.elements = [];
        }
        BPQ.prototype.isFull = function () {
            return this.elements.length === this.capacity;
        };
        BPQ.prototype.isEmpty = function () {
            return this.elements.length === 0;
        };
        ;
        BPQ.prototype.maxPriority = function () {
            return this.elements[this.elements.length - 1].priority;
        };
        ;
        Object.defineProperty(BPQ.prototype, "values", {
            get: function () {
                return this.elements.map(function (d) { return d.value; });
            },
            enumerable: true,
            configurable: true
        });
        BPQ.prototype.add = function (value, priority) {
            var q = this.elements, d = { value: value, priority: priority };
            if (this.isEmpty()) {
                q.push(d);
            }
            else {
                for (var i = 0; i < q.length; i++) {
                    if (priority < q[i].priority) {
                        q.splice(i, 0, d);
                        break;
                    }
                    else if ((i == q.length - 1) && !this.isFull()) {
                        q.push(d);
                    }
                }
            }
            this.elements = q.slice(0, this.capacity);
        };
        return BPQ;
    }());
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.AnimationNode
    * @classdesc
    * 动画效果节点
    * @version Egret 3.0
    * @platform Web,Native
    */
    var AnimationNode = (function () {
        function AnimationNode() {
            /**
            * @language zh_CN
            * 顶点着色器文件名
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.vertex_ShaderName = {};
            /**
            * @language zh_CN
            * 片断着色器文件名
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.fragment_ShaderName = {};
            /**
            * @language zh_CN
            * shader attribute 变量列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.attributes = new Array();
        }
        /**
        * @private
        * 构建结束后需要清理掉临时数据
        */
        AnimationNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        * 强制更新了时间之后，follow数据需要更新
        */
        AnimationNode.prototype.onAnimTimeChange = function () {
        };
        /**
        * @private
        * 导入需要用到的glsl
        */
        AnimationNode.prototype.importShader = function (isVertex, phase, name) {
            var shader = isVertex ? this.vertex_ShaderName : this.fragment_ShaderName;
            var list = shader[phase] = shader[phase] || [];
            if (list.indexOf(name) == -1) {
                list.push(name);
            }
        };
        /**
        * @private
        */
        AnimationNode.prototype.afterBuild = function () {
        };
        /**
        * @private
        */
        AnimationNode.prototype.initNode = function (data, arg) {
        };
        /**
        * @private
        */
        AnimationNode.prototype.update = function (animTime, delay, geometry) {
        };
        /**
        * @private
        */
        AnimationNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
        };
        /**
        * @private
        */
        AnimationNode.prototype.upload = function () {
        };
        /**
        * @private
        */
        AnimationNode.prototype.dispose = function () {
        };
        return AnimationNode;
    }());
    egret3d.AnimationNode = AnimationNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.AnimationCurve
    * @classdesc
    * 具有单一属性的 关键帧动画
    * 通过预计算后，动画信息将会缓存
    * @version Egret 3.0
    * @platform Web,Native
    */
    var AnimationCurve = (function () {
        function AnimationCurve() {
        }
        return AnimationCurve;
    }());
    egret3d.AnimationCurve = AnimationCurve;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var TimerAxis = (function (_super) {
        __extends(TimerAxis, _super);
        function TimerAxis() {
            _super.call(this);
            this._timeEvent = new egret3d.Event3D();
            this._times = new Array();
            this._processTimes = new Array();
            this._timer = 0;
            this._start = false;
        }
        TimerAxis.prototype.start = function () {
            this._timer = 0;
            this._start = true;
            this._processTimes.length = 0;
            for (var i = 0; i < this._times.length; ++i) {
                this._processTimes[i] = this._times[i];
            }
        };
        TimerAxis.prototype.addTimerAxis = function (time) {
            this._times.push(time);
        };
        TimerAxis.prototype.clearTimerAxis = function () {
            this._times.length = 0;
            this._processTimes.length = 0;
        };
        TimerAxis.prototype.reset = function () {
            this._processTimes.length = 0;
            this._timer = 0;
            this._start = false;
            for (var i = 0; i < this._times.length; ++i) {
                this._processTimes[i] = this._times[i];
            }
        };
        TimerAxis.prototype.update = function (delay, time) {
            if (!this._start) {
                return;
            }
            this._timer += delay;
            console.log(this._timer + "update");
            for (var i = 0; i < this._processTimes.length; ++i) {
                if (this._timer >= this._processTimes[i]) {
                    this._timeEvent.eventType = TimerAxis.TIME_EVENT;
                    this._timeEvent.data = this._processTimes[i];
                    this.dispatchEvent(this._timeEvent);
                    this._processTimes.splice(i, 1);
                    break;
                }
            }
        };
        TimerAxis.TIME_EVENT = "TimeEvent";
        return TimerAxis;
    }(egret3d.EventDispatcher));
    egret3d.TimerAxis = TimerAxis;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.CurveType
    * @classdesc
    * 曲线的类型
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (CurveType) {
        /**
        * @language zh_CN
        * 普通的线  直线
        * @version Egret 3.0
        * @platform Web,Native
        */
        CurveType[CurveType["Line"] = 0] = "Line";
        /**
        * @language zh_CN
        * 贝塞尔曲线
        * @version Egret 3.0
        * @platform Web,Native
        */
        CurveType[CurveType["BesselCurve"] = 1] = "BesselCurve";
    })(egret3d.CurveType || (egret3d.CurveType = {}));
    var CurveType = egret3d.CurveType;
    ;
    /**
    * @language zh_CN
    * @class egret3d.AnimCurve
    * @classdesc
    * AnimCurve 类为动画曲线，其中包含该曲线的类型，起始结束时刻以及参数
    *
    * @includeExample anim/PropertyAnimation/AnimCurve.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var AnimCurve = (function () {
        function AnimCurve() {
            /**
            * @language zh_CN
            * start.x - end.x 之间 插值y值 使用哪种类型
            * @see egret3d.CurveType
            * @see egret3d.AnimCurve.start
            * @see egret3d.AnimCurve.end
            *
            * @see egret3d.Point
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.type = CurveType.Line;
            this.frame = 0;
            this.value = 0;
        }
        return AnimCurve;
    }());
    egret3d.AnimCurve = AnimCurve;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.PropertyAnim
    * @classdesc
    * PropertyAnim 类为曲线动画驱动器，类中保存了各个属性对应的数值曲线数据，通过时间计算某个属性在某时刻的属性数值
    *
    * @includeExample anim/PropertyAnimation/PropertyAnim.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PropertyAnim = (function () {
        function PropertyAnim() {
            this.frameRate = 16;
            /**
            * @language zh_CN
            * 播放速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.speed = 1;
            /**
            * @language zh_CN
            * 是否循环
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.isLoop = true;
            /**
            * @language zh_CN
            * 动画名字
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.name = "";
            this._propertyArray = [];
            this._play = false;
            this._totalTime = 0;
            this._changeFrameTime = 0;
            this._oldFrameIndex = 0;
            this.totalTime = 0;
        }
        /**
        * @language zh_CN
        * 是否存在某个属性的曲线动画
        * @returns boolean 是否存在
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.IsExist = function (property) {
            for (var i = 0; i < this._propertyArray.length; i++) {
                if (this._propertyArray[i].property == property) {
                    return true;
                }
            }
            return false;
        };
        /**
        * @language zh_CN
        * 添加曲线动画数据
        * @param property 属性名  控制 Object3D对象的属性
        * @param keyFrames 曲线动画帧
        * @returns boolean 是否成功
        * @see egret3d.Object3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.addAnimCurve = function (property, keyFrames) {
            if (this.IsExist(property)) {
                return false;
            }
            if (null == keyFrames || keyFrames.length <= 0) {
                return false;
            }
            var propertyData = new PropertyData();
            propertyData.keyFrames = keyFrames;
            propertyData.property = property;
            propertyData.target = this._target;
            propertyData.isLoop = true;
            propertyData.timePosition = 0;
            propertyData.totalFrame = keyFrames[keyFrames.length - 1].frame;
            propertyData.totalTime = propertyData.totalFrame * this.frameRate;
            this.totalTime = Math.max(this.totalTime, propertyData.totalTime);
            this._propertyArray.push(propertyData);
            this.updateBindData(propertyData);
        };
        /**
        * @language zh_CN
        * 移除曲线动画数据
        * @param property 属性名
        * @returns AnimCurve[] 曲线动画帧
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.removeAnimCurve = function (property) {
            var propertyData = null;
            for (var i = 0; i < this._propertyArray.length; i++) {
                if (this._propertyArray[i].property == property) {
                    propertyData = this._propertyArray[i];
                    this._propertyArray.splice(i, 1);
                    return propertyData.keyFrames;
                }
            }
        };
        /**
        * @language zh_CN
        * 设置属性是否循环播放
        * @param property 属性名
        * @param isLoop 是否循环播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.setPropertyLoop = function (property, isLoop) {
            var propertyData = null;
            for (var i = 0; i < this._propertyArray.length; i++) {
                if (this._propertyArray[i].property == property) {
                    propertyData = this._propertyArray[i];
                    propertyData.isLoop = isLoop;
                    break;
                }
            }
        };
        /**
        * @language zh_CN
        * 绑定需要驱动的Object3D对象
        * @param target Object3D对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.bindObject3D = function (target) {
            this._target = target;
            for (var i = 0; i < this._propertyArray.length; i++) {
                this.updateBindData(this._propertyArray[i]);
            }
        };
        PropertyAnim.prototype.updateBindData = function (propertyData) {
            if (!this._target) {
                return;
            }
            propertyData.target = this._target;
            var strArray = propertyData.property.split('.');
            for (var i = 0; i < strArray.length - 1; i++) {
                propertyData.target = propertyData.target[strArray[i]];
            }
            propertyData.name = strArray[strArray.length - 1];
        };
        /**
        * @language zh_CN
        * 播放属性动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.play = function (speed, reset) {
            if (this._play && reset) {
                return;
            }
            for (var i = 0; i < this._propertyArray.length; i++) {
                this._propertyArray[i].play(speed, reset);
            }
            this._play = true;
        };
        /**
        * @language zh_CN
        * 停止播放属性动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.stop = function () {
            this._play = false;
        };
        /**
        * @language zh_CN
        * 设置时间位置
        * @version Egret 3.0
        * @platform Web,Native
        */
        //public set timePosition(value: number) {
        //    if (value == this._timePosition) {
        //        return;
        //    }
        //    var delay: number = value - this._timePosition;
        //    this._timePosition = value;
        //    if (this.isLoop) {
        //        if (this.proAnimController) {
        //            if (this.name == this.proAnimController.currentAnimName) {
        //                if (this.speed < 0 && this._timePosition < 0) {
        //                    this.proAnimController.doEvent(AnimationEvent3D.EVENT_PLAY_COMPLETE, this);
        //                }
        //                else if (this.speed > 0 && this._timePosition > this.totalTime) {
        //                    this.proAnimController.doEvent(AnimationEvent3D.EVENT_PLAY_COMPLETE, this);
        //                }
        //            }
        //        }
        //        this._timePosition = value % this._totalTime;
        //        if (this._timePosition < 0) {
        //            this._timePosition += this._totalTime;
        //        }
        //    }
        //    else {
        //        if (this._timePosition < 0) {
        //            this._timePosition = 0;
        //            if (this.proAnimController) {
        //                this.proAnimController.doEvent(AnimationEvent3D.EVENT_PLAY_COMPLETE, this);
        //            }
        //            this.stop();
        //        }
        //        else if (this._timePosition > this._totalTime) {
        //            this._timePosition = this._totalTime;
        //            if (this.proAnimController) {
        //                this.proAnimController.doEvent(AnimationEvent3D.EVENT_PLAY_COMPLETE, this);
        //            }
        //            this.stop();
        //        }
        //    }
        //    if (!this._target) {
        //        return;
        //    }
        //    var propertyData: PropertyData;
        //    var keyFrames: AnimCurve[];
        //    for (var i:number = 0, countI:number = this._propertyArray.length; i < countI; i++) {
        //        propertyData = this._propertyArray[i];
        //        keyFrames = propertyData.keyFrames;
        //        var valueTime = propertyData.timePosition + delay;
        //        if (valueTime == propertyData.timePosition) {
        //            continue;
        //        }
        //        var timeLength: number = keyFrames[keyFrames.length - 1].end.x;
        //        propertyData.timePosition = valueTime;
        //        if (propertyData.isLoop) {
        //            propertyData.timePosition = value % timeLength;
        //            if (propertyData.timePosition < 0) {
        //                propertyData.timePosition += timeLength;
        //            }
        //        }
        //        else {
        //            if (propertyData.timePosition < 0) {
        //                propertyData.timePosition = 0;
        //                continue;
        //            }
        //            else if (propertyData.timePosition > timeLength) {
        //                propertyData.timePosition = timeLength;
        //                continue;
        //            }
        //        }
        //        for (var j:number = 0, countJ:number = keyFrames.length; j < countJ; j++) {
        //            if (keyFrames[j].start.x <= propertyData.timePosition && keyFrames[j].end.x > propertyData.timePosition) {
        //                propertyData.target[propertyData.name] = keyFrames[j].calculateValue(propertyData.timePosition);
        //                break;
        //            }
        //        }
        //    }
        //}
        /**
        * @language zh_CN
        * 获取时间位置
        * @returns number 当前时间
        * @version Egret 3.0
        * @platform Web,Native
        //*/
        //public get timePosition(): number {
        //    return this._timePosition;
        //}
        ///**
        //* @language zh_CN
        //* 获取动画总时间
        //* @returns number 动画总时间
        //* @version Egret 3.0
        //* @platform Web,Native
        //*/
        //public get totalTime(): number {
        //    return this._totalTime;
        //}
        /**
        * @language zh_CN
        * 更新动画数据
        * @param delay 延迟时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.update = function (delay) {
            if (!this._play || !this._target) {
                return;
            }
            for (var i = 0; i < this._propertyArray.length; i++) {
                this._propertyArray[i].update(0, delay);
            }
            //var beginTime: number = this.timePosition;
            //this.timePosition += delay * this.speed;
            //if (this.timePosition < beginTime) {
            //    if (this.proAnimController) {
            //        this.proAnimController.doEvent(AnimationEvent3D.EVENT_PLAY_COMPLETE, this);
            //    }
            //}
        };
        /**
        * @language zh_CN
        * 克隆属性动画对象
        * @returns PropertyAnim 新的属性动画对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnim.prototype.clone = function () {
            var pro = new PropertyAnim();
            pro._propertyArray = this._propertyArray;
            pro._totalTime = this._totalTime;
            pro.isLoop = this.isLoop;
            pro.speed = this.speed;
            pro.name = this.name;
            return pro;
        };
        return PropertyAnim;
    }());
    egret3d.PropertyAnim = PropertyAnim;
    /**
    * @private
    * @language zh_CN
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PropertyData = (function () {
        function PropertyData() {
            this.totalFrame = 0;
            this.totalTime = 0;
            this.frameRate = 16;
            this.time = 0;
            this.offset = 0;
            this._time = 0;
            this._frame = 0;
            //private _nextframe: number = 0;
            this._weight = 0;
            this._frameTime = 0;
            this._speed = 1;
            this._change = false;
        }
        PropertyData.prototype.play = function (speed, reset) {
            this._change = reset;
            this._speed = speed;
            if (reset) {
                this._time = 0;
            }
        };
        PropertyData.prototype.update = function (time, delay) {
            var self = this;
            if (this._change) {
                this._change = false;
                this.offset = self._time;
            }
            self._time = self._time - this.offset;
            self.time = self._time % self.totalTime;
            self._frameTime = self.time / this.frameRate;
            self._frame = Math.floor(self._frameTime);
            self._weight = (self._frameTime - self._frame);
            //self._nextframe = self._frame + 1;
            //if (self._nextframe >= self.totalFrame) {
            //    self._nextframe = 0;
            //}
            if (self.keyFrames[self._frame])
                self.target[self.name] = self.keyFrames[self._frame].value;
            self._time += delay * this._speed;
        };
        return PropertyData;
    }());
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.PropertyAnimController
    * @classdesc
    * 属性动画控制器 管理 多个 PropertyAnim
    * @see egret3d.PropertyAnim
    * @see egret3d.EventDispatcher
    * @see egret3d.IAnimation
    *
    * @includeExample anim/PropertyAnimation/PropertyAnim.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PropertyAnimController = (function (_super) {
        __extends(PropertyAnimController, _super);
        /**
        * @language zh_CN
        * 构造函数，创建一个属性动画控制器
        * @param target 控制器的目标对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function PropertyAnimController(target) {
            if (target === void 0) { target = null; }
            _super.call(this);
            this._animTime = 0;
            /**
            * @language zh_CN
            * 播放速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.speed = 1;
            /**
            * @language zh_CN
            * 一个完整的动画播放时间周期
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.loopTime = 0;
            /**
            * @language zh_CN
            * 当前动画名字
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.currentAnimName = "";
            this._proAnimDict = {};
            this._event3D = new egret3d.AnimationEvent3D();
            this._target = target;
        }
        Object.defineProperty(PropertyAnimController.prototype, "target", {
            /**
            * @language zh_CN
            * 动画时间
            * @param value 动画时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public set animTime(value: number) {
            //    this._animTime = value;
            //    if (this.current) {
            //        this.current.timePosition = value;
            //    }
            //}
            /**
            * @language zh_CN
            *  绑定目标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._target;
            },
            /**
            * @language zh_CN
            *  绑定目标
            * @param tar 目标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (tar) {
                this._target = tar;
                if (tar) {
                    for (var key in this._proAnimDict) {
                        this._proAnimDict[key].bindObject3D(this._target);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PropertyAnimController.prototype, "animTime", {
            /**
            * @language zh_CN
            * 动画时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._animTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PropertyAnimController.prototype, "propertyAnimController", {
            /**
            * @language zh_CN
            * 只有属性动画对象才有此接口
            * @returns PropertyAnimController 动画控制器
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 是否正在播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnimController.prototype.isPlay = function () {
            return true;
        };
        /**
        * @language zh_CN
        * 播放骨骼动画
        * @param animName 动画名称
        * @param speed 播放速度
        * @param reset 是否重置
        * @param prewarm 是否预热
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnimController.prototype.play = function (animName, speed, reset, prewarm) {
            if (animName === void 0) { animName = ""; }
            if (speed === void 0) { speed = 1; }
            if (reset === void 0) { reset = true; }
            if (prewarm === void 0) { prewarm = true; }
            this.current = this._proAnimDict[animName];
            if (!this.current) {
                for (var key in this._proAnimDict) {
                    this.current = this._proAnimDict[key];
                    break;
                }
            }
            this.speed = speed;
            if (this.current) {
                this.current.speed = this.speed;
                if (this.target) {
                    this.current.bindObject3D(this.target);
                }
                //this.current.timePosition = this._animTime;
                this.currentAnimName = this.current.name;
                this.current.play(speed, reset);
            }
        };
        /**
        * @language zh_CN
        * 停止骨骼动画播放（停留在第一帧）
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnimController.prototype.stop = function () {
            if (this.current) {
                this.current.stop();
            }
            this.current = null;
        };
        /**
        * @language zh_CN
        * 更新骨骼动画
        * @param time 总时间
        * @param delay 延迟时间
        * @param geometry 该值无效
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnimController.prototype.update = function (time, delay, geometry) {
            if (this.current) {
                this.current.update(delay);
            }
        };
        /**
        * @private
        */
        PropertyAnimController.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        /**
        * @language zh_CN
        * 克隆骨骼动画对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnimController.prototype.clone = function () {
            var pro = new PropertyAnimController();
            for (var key in this._proAnimDict) {
                pro.addPropertyAnim(this._proAnimDict[key].clone());
            }
            return pro;
        };
        Object.defineProperty(PropertyAnimController.prototype, "animStateNames", {
            /**
            * @language zh_CN
            * 动画名列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PropertyAnimController.prototype, "animStates", {
            /**
            * @language zh_CN
            * 动画状态对象列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return null;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        */
        PropertyAnimController.prototype.addAnimState = function (animState) {
        };
        /**
        * @private
        */
        PropertyAnimController.prototype.removeAnimState = function (animState) {
        };
        /**
        * @language zh_CN
        * 添加动画属性对象
        * @param proAnim 动画属性对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnimController.prototype.addPropertyAnim = function (proAnim) {
            this._proAnimDict[proAnim.name] = proAnim;
            proAnim.proAnimController = this;
            if (this.target) {
                proAnim.bindObject3D(this.target);
            }
            this.loopTime = Math.max(this.loopTime, proAnim.totalTime);
            if (proAnim.isLoop == false) {
                this.isLoop = proAnim.isLoop;
            }
        };
        /**
        * @language zh_CN
        * 移除动画属性对象
        * @param proAnim 动画对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        PropertyAnimController.prototype.removePropertyAnim = function (proAnim) {
            delete this._proAnimDict[proAnim.name];
        };
        /**
        * @private
        */
        PropertyAnimController.prototype.doEvent = function (event, target) {
            this._event3D.eventType = event;
            this._event3D.target = target;
            this.dispatchEvent(this._event3D);
        };
        return PropertyAnimController;
    }(egret3d.EventDispatcher));
    egret3d.PropertyAnimController = PropertyAnimController;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Joint
    * @classdesc
    * Joint 类表示骨骼关节，属于骨架类的组成部分， Joint类属于骨架实现的内部类，无需直接实例化。
    *
    * @version Egret 3.0
    * @platform Web,Native
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Joint = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Joint() {
            /**
            * @language zh_CN
            * 父骨骼名称
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.parent = null;
            /**
            * @language zh_CN
            * 骨骼名称index
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.index = 0;
            this.parentIndex = -1;
            this.scale = new egret3d.Vector3D(1, 1, 1);
            this.orientation = new egret3d.Quaternion();
            this.translation = new egret3d.Vector3D();
            this.localMatrix; // = new Matrix4_4();
            this.worldMatrix; //= new Matrix4_4();
            this.worldMatrixValid = false;
        }
        ///**
        //* @language zh_CN
        //* 克隆新骨骼对象
        //* @returns Joint 新骨骼对象
        //* @version Egret 3.0
        //* @platform Web,Native
        //*/
        //public clone(): Joint {
        //    var joint: Joint = new Joint();
        //    joint.name = this.name;
        //    joint.parent = this.parent;
        //    joint.index = this.index;
        //    joint.parentIndex = this.parentIndex;
        //    joint.scale.copyFrom(this.scale);
        //    joint.orientation.copyFrom(this.orientation);
        //    joint.translation.copyFrom(this.translation);
        //    joint.localMatrix.copyFrom(this.localMatrix);
        //    joint.worldMatrixValid = this.worldMatrixValid;
        //    return joint;
        //}
        /**
        * @language zh_CN
        * 构建骨骼本地矩阵
        * @param scale Vector3D 缩放值
        * @param rotation Vector3D或者Quaternion，旋转数据
        * @param translation Vector3D 位移对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Joint.prototype.buildLocalMatrix = function (scale, rotation, translation) {
            this.scale.copyFrom(scale);
            this.translation.copyFrom(translation);
            if (rotation instanceof egret3d.Vector3D) {
                this.orientation.fromEulerAngles(rotation.x, rotation.y, rotation.z);
            }
            else {
                this.orientation.copyFrom(rotation);
            }
            //this.localMatrix.makeTransform(this.translation, this.scale, this.orientation);
            this.worldMatrixValid = false;
        };
        /**
        * @language zh_CN
        * 构建骨骼逆矩阵
        * @param scale Vector3D 缩放值
        * @param rotation Vector3D或者Quaternion，旋转数据
        * @param translation Vector3D 位移对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Joint.prototype.buildInverseMatrix = function (scale, rotation, translation) {
            if (!this.inverseMatrix) {
                this.inverseMatrix = new egret3d.Matrix4_4();
            }
            if (rotation instanceof egret3d.Vector3D) {
                this.inverseMatrix.recompose([translation, rotation, scale]);
            }
            else {
                this.inverseMatrix.makeTransform(translation, scale, rotation);
            }
        };
        /**
         * @language zh_CN
         * 将此骨骼的信息 赋值给目标
         * @param scale Vector3D 缩放值
         * @param rotation Vector3D或者Quaternion，旋转数据
         * @param translation Vector3D 位移对象
         * @version Egret 3.0
         * @platform Web,Native
         */
        Joint.prototype.copyTo = function (node, type) {
            if (type === void 0) { type = egret3d.BindAnimType.all; }
            switch (type) {
                case egret3d.BindAnimType.all:
                    node.localMatrix = this.worldMatrix;
                    break;
            }
        };
        return Joint;
    }());
    egret3d.Joint = Joint;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Skeleton
    * @classdesc
    * Skeleton 类表示骨架类，其中包含若干个 Joint（骨骼关节） 对象。
    *
    * @version Egret 3.0
    * @platform Web,Native
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Skeleton = (function () {
        /**
        * @language zh_CN
        * 构造函数，创建一套骨骼
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Skeleton() {
            /**
            * @language zh_CN
            * 骨架包含的骨骼
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.joints = [];
        }
        Object.defineProperty(Skeleton.prototype, "jointNum", {
            ///**
            //* @language zh_CN
            //* 克隆新骨架对象
            //* @returns Skeleton 新骨架对象
            //* @version Egret 3.0
            //* @platform Web,Native
            //*/
            //public clone(): Skeleton {
            //    var skeleton: Skeleton = new Skeleton();
            //    for (var i: number = 0; i < this.joints.length; i++) {
            //        skeleton.joints.push(this.joints[i].clone());
            //    }
            //    return skeleton;
            //}
            /**
            * @language zh_CN
            * 骨骼数量
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.joints.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 通过名称查找指定骨骼
        * @param name 骨骼名称
        * @returns 骨骼对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Skeleton.prototype.findJoint = function (name) {
            for (var i = 0; i < this.joints.length; i++) {
                if (this.joints[i].name == name)
                    return this.joints[i];
            }
            return null;
        };
        /**
        * @language zh_CN
        * 通过名称查找骨骼索引编号
        * @param name 骨骼名称
        * @returns number 骨骼索引编号
        * @version Egret 3.0
        * @platform Web,Native
        */
        Skeleton.prototype.findJointIndex = function (name) {
            for (var i = 0; i < this.joints.length; i++) {
                if (this.joints[i].name == name)
                    return i;
            }
            return -1;
        };
        return Skeleton;
    }());
    egret3d.Skeleton = Skeleton;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.SkeletonPose
    * @classdesc
    * SkeletonPose 类为单帧骨架动画数据，若干个SkeletonPose组合成SkeletonAnimationClip， 做为骨骼骨架序列数据
    *
    * @version Egret 3.0
    * @platform Web,Native
    */
    var SkeletonPose = (function () {
        function SkeletonPose() {
            /**
            * @language zh_CN
            * 骨架包含的骨骼
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.joints = [];
        }
        //private static _temp_matrixDecomposeB: Vector3D[] = [new Vector3D(), new Vector3D(), new Vector3D()];
        /**
        * @language zh_CN
        * @private
        * 计算当前骨架内所有骨骼的世界矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.calculateJointWorldMatrix = function () {
            var joints = this.joints;
            var len = joints.length;
            var i = 0;
            for (i; i < len; ++i) {
                this.calculateAbsoluteMatrix(joints[i], joints);
            }
        };
        //递归函数，用于计算骨骼世界矩阵
        SkeletonPose.prototype.calculateAbsoluteMatrix = function (joint, joints) {
            if (joint.parentIndex >= 0) {
                this.calculateAbsoluteMatrix(joints[joint.parentIndex], joints);
            }
            if (!joint.worldMatrixValid) {
                if (!joint.worldMatrix)
                    joint.worldMatrix = new egret3d.Matrix4_4();
                joint.localMatrix = joint.localMatrix || new egret3d.Matrix4_4();
                joint.localMatrix.makeTransform(joint.translation, joint.scale, joint.orientation);
                joint.worldMatrix.copyFrom(joint.localMatrix);
                if (joint.parentIndex >= 0) {
                    joint.worldMatrix.append(joints[joint.parentIndex].worldMatrix);
                }
                joint.worldMatrixValid = true;
            }
        };
        /**
        * @language zh_CN
        * @private
        * 更新GPU所需的骨骼缓存数据
        * @param skeleton 蒙皮骨骼骨架
        * @returns Float32Array 缓存数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.updateGPUData = function (skeleton, skeletonMatrixData, offset) {
            var skeletonJoints = skeleton.joints;
            var skeletonTotalJoint = skeletonJoints.length;
            var joints = this.joints;
            var jointLen = joints.length;
            var boneNameArray = this.boneNameArray;
            for (var i = 0; i < skeletonTotalJoint; ++i) {
                for (var j = 0; j < jointLen; ++j) {
                    if (skeletonJoints[i].name != boneNameArray[j])
                        continue;
                    egret3d.Matrix4_4.helpMatrix.copyFrom(skeletonJoints[i].inverseMatrix);
                    egret3d.Matrix4_4.helpMatrix.append(joints[j].worldMatrix);
                    var test = egret3d.Matrix4_4.helpMatrix.decompose(egret3d.Orientation3D.QUATERNION);
                    skeletonMatrixData[i * 8 + 0] = test[1].x;
                    skeletonMatrixData[i * 8 + 1] = test[1].y;
                    skeletonMatrixData[i * 8 + 2] = test[1].z;
                    skeletonMatrixData[i * 8 + 3] = test[1].w;
                    skeletonMatrixData[i * 8 + 4] = test[0].x - offset.x;
                    skeletonMatrixData[i * 8 + 5] = test[0].y - offset.y;
                    skeletonMatrixData[i * 8 + 6] = test[0].z - offset.z;
                    skeletonMatrixData[i * 8 + 7] = 1;
                    break;
                }
            }
            return skeletonMatrixData;
        };
        /**
        * @language zh_CN
        * 通过名称查找指定骨骼
        * @param name 骨骼名称
        * @returns Joint 骨骼对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.findJoint = function (name) {
            var index = this.findJointIndex(name);
            if (index >= 0) {
                return this.joints[index];
            }
            return null;
        };
        /**
        * @language zh_CN
        * 通过名称查找骨骼索引编号
        * @param name 骨骼名称
        * @returns number 骨骼索引编号
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.findJointIndex = function (name) {
            if ("" == name)
                return -1;
            for (var i = 0; i < this.boneNameArray.length; i++) {
                if (this.boneNameArray[i] == name)
                    return i;
            }
            return -1;
        };
        /**
        * @language zh_CN
        * @private
        * 重置骨骼世界矩阵;
        * @param name 骨骼名称
        * @returns number 骨骼索引编号
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.resetWorldMatrix = function () {
            var joins = this.joints;
            var len = joins.length;
            for (var i = 0; i < len; i++) {
                joins[i].worldMatrixValid = false;
            }
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.getLerpSkeletonPose = function (frame, nextFrame, weight, clip, skeltonPose) {
            var a;
            var b;
            a = clip.poseArray[frame];
            b = clip.poseArray[nextFrame];
            skeltonPose.mixAnim(a, b, weight, skeltonPose);
        };
        //function stopWorker() {
        //    w.terminate();
        //}
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.mixAnim = function (a, b, weight, targetPos) {
            var aJoint;
            var bJoint;
            var tjoins = targetPos.joints;
            for (var i = 0; i < a.joints.length; i++) {
                aJoint = a.joints[i];
                bJoint = b.joints[i];
                tjoins[i].translation.lerp(aJoint.translation, bJoint.translation, weight);
                tjoins[i].orientation.lerp(aJoint.orientation, bJoint.orientation, weight);
                tjoins[i].worldMatrixValid = false;
            }
            targetPos.calculateJointWorldMatrix();
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.copySkeletonPose = function (source, targetPos) {
            var tjoints = targetPos.joints;
            var sourcejoints = source.joints;
            var len = sourcejoints.length;
            for (var i = 0; i < len; i++) {
                tjoints[i].translation = sourcejoints[i].translation;
                tjoints[i].orientation = sourcejoints[i].orientation;
                tjoints[i].scale = sourcejoints[i].scale;
                tjoints[i].worldMatrixValid = false;
            }
            targetPos.calculateJointWorldMatrix();
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonPose.prototype.initSkeletonPose = function (a, target) {
            target.joints = target.joints || [];
            target.jointsDictionary = target.jointsDictionary || {};
            target.boneNameArray = a.boneNameArray;
            for (var i = 0; i < a.joints.length; i++) {
                var joint = new egret3d.Joint();
                target.joints.push(joint);
                target.jointsDictionary[a.boneNameArray[i]] = joint; //初始化字典
                joint.parentIndex = a.joints[i].parentIndex;
                joint.index = a.joints[i].index;
                joint.worldMatrix = joint.worldMatrix || new egret3d.Matrix4_4();
            }
        };
        //private static _temp_v0: Vector3D = new Vector3D();
        //private static _temp_v1: Vector3D = new Vector3D();
        //private static _temp_v2: Vector3D = new Vector3D();
        //private static _temp_q0: Quaternion = new Quaternion();
        //private static _temp_q1: Quaternion = new Quaternion();
        //private static _temp_q2: Quaternion = new Quaternion();
        SkeletonPose._temp_jointMatrix = new egret3d.Matrix4_4();
        SkeletonPose._temp_matrixDecomposeA = [new egret3d.Vector3D(), new egret3d.Vector3D(), new egret3d.Vector3D()];
        return SkeletonPose;
    }());
    egret3d.SkeletonPose = SkeletonPose;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.SkeletonAnimationClip
    * @classdesc
    * 骨骼动画剪辑
    * 每个骨骼动画的数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var SkeletonAnimationClip = (function () {
        function SkeletonAnimationClip() {
            /**
            * @language zh_CN
            * 每帧的SkeletonPose
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.poseArray = [];
            /**
            * @language zh_CN
            * 骨骼名字列表，
            * 可以根据名字列表得到骨骼索引
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.boneNameArray = [];
            /**
            * @language zh_CN
            * 动画名字
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.animationName = "";
            /**
            * @language zh_CN
            * 是否循环
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.isLoop = false;
            /**
            * @language zh_CN
            * @private
            * 流数据解析测试;
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.sampling = 0;
            /**
            * @language zh_CN
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.boneCount = 0;
            /**
            * @language zh_CN
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.frameDataOffset = 0;
            /*
            * @private
            */
            this.totalFrame = 0;
            /*
            * @private
            */
            this.totalTime = 0;
            /*
            * @private
            */
            this.frameRate = 33; // 30 fps
            /*
            * @private
            */
            this.loopPose = false;
            /*
            * @private
            */
            this.cycleOffset = 0;
            /**
            * @language zh_CN
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.sourceData = null;
            this._skeletonPose = null;
            this._temp_scale = new egret3d.Vector3D();
            this._temp_translation = new egret3d.Vector3D();
            this._temp_orientation = new egret3d.Quaternion();
            this._cacheAnimationClip = null;
        }
        Object.defineProperty(SkeletonAnimationClip.prototype, "currentSkeletonPose", {
            /**
            * @language zh_CN
            * 获取当前播放帧的Pose数据
            * @returns SkeletonPose 当前播放帧的Pose数据
            * @see egret3d.SkeletonPose
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._skeletonPose;
            },
            enumerable: true,
            configurable: true
        });
        ///**
        //* @language zh_CN
        //* 获取缓存的骨骼动画Clip
        //* @returns SkeletonAnimationClip对象;
        //* @version Egret 3.0
        //* @platform Web,Native
        //*/
        //public get cacheAnimationClip(): SkeletonAnimationClip {
        //    if (!this._cacheAnimationClip) {
        //        if (this.sourceData) {
        //            this._cacheAnimationClip = this;
        //        }
        //        else {
        //            this._cacheAnimationClip = new SkeletonAnimationClip();
        //            if (this.poseArray.length < 2) {
        //                this._cacheAnimationClip.poseArray = this.poseArray;
        //            }
        //            else {
        //                var skeletonPoseA: SkeletonPose = this.poseArray[0];
        //                var skeletonPoseB: SkeletonPose = this.poseArray[1];
        //                var nCount: number = Math.round((skeletonPoseB.frameTime - skeletonPoseA.frameTime) / SkeletonAnimation.fps);
        //                if (nCount <= 1) {
        //                    this._cacheAnimationClip.poseArray = this.poseArray;
        //                }
        //                else for (var i: number = 1; i < this.poseArray.length; ++i) {
        //                    skeletonPoseA = this.poseArray[i - 1];
        //                    skeletonPoseB = this.poseArray[i];
        //                    for (var j: number = 0; j < nCount; j++) {
        //                        var skeletonPose: SkeletonPose = new SkeletonPose();
        //                        skeletonPose.boneNameArray = this.boneNameArray;
        //                        skeletonPose.lerp(skeletonPoseA, skeletonPoseB, j / nCount);
        //                        this._cacheAnimationClip.poseArray.push(skeletonPose);
        //                    }
        //                }
        //                this._cacheAnimationClip.poseArray.push(this.poseArray[this.poseArray.length - 1].clone());
        //            }
        //        }
        //    }
        //    return this._cacheAnimationClip;
        //}
        /**
        * @language zh_CN
        * 用骨头名字查找骨头索引
        * @param name 骨头名字
        * @returns number 骨头索引
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimationClip.prototype.findJointIndex = function (name) {
            if (!this._skeletonPose) {
                if (this.poseArray.length <= 0) {
                    return -1;
                }
                return this.poseArray[0].findJointIndex(name);
            }
            return this._skeletonPose.findJointIndex(name);
        };
        /**
        * @language zh_CN
        * @private
        * 增加Pose
        * @param skeletonPose Pose
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimationClip.prototype.addSkeletonPose = function (skeletonPose) {
            this.poseArray.push(skeletonPose);
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimationClip.prototype.buildInitialSkeleton = function (boneNameArray, parentBoneNameArray, frameCount) {
            if (this._skeletonPose) {
                return;
            }
            this._skeletonPose = new egret3d.SkeletonPose();
            this._skeletonPose.boneNameArray = boneNameArray;
            for (var j = 0; j < this.boneCount; j++) {
                var jointPose = new egret3d.Joint();
                //jointPose.name = boneNameArray[j];
                //jointPose.parent = parentBoneNameArray[j];
                //jointPose.parentIndex = this._skeletonPose.findJointIndex(jointPose.parent);
                jointPose.index = j;
                jointPose.parentIndex = egret3d.EAMVersion.findNameIndex(boneNameArray, parentBoneNameArray[j]);
                this._skeletonPose.joints.push(jointPose);
            }
            //this.sourceData.position = this.frameDataOffset + (40 * this.boneCount + 4) * (this.frameCount - 1);
            //this._timeLength = this.sourceData.readInt() / 60 / 80 * 1000;
        };
        /**
        * @language zh_CN
        * @private
        * 获取骨骼Pose帧
        * @param index 帧索引
        * @returns SkeletonPose 骨骼Pose帧
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimationClip.prototype.getSkeletonPose = function (index) {
            if (this.poseArray.length > 0 && this.poseArray.length > index) {
                return this.poseArray[index];
            }
            return null;
        };
        SkeletonAnimationClip.prototype.readSkeletonPose = function (index, skeletonPose) {
            this.sourceData.position = this.frameDataOffset + (40 * this.boneCount + 4) * index; //每帧数据需要40 * 骨骼数 + 4字节;
            skeletonPose.frameTime = this.sourceData.readInt() / 60 / 80 * 1000;
            for (var j = 0; j < this.boneCount; j++) {
                //读取旋转四元数分量;
                this._temp_orientation.x = this.sourceData.readFloat();
                this._temp_orientation.y = this.sourceData.readFloat();
                this._temp_orientation.z = this.sourceData.readFloat();
                this._temp_orientation.w = this.sourceData.readFloat();
                //读取缩放分量;
                this._temp_scale.x = this.sourceData.readFloat();
                this._temp_scale.y = this.sourceData.readFloat();
                this._temp_scale.z = this.sourceData.readFloat();
                //读取平移分量;
                this._temp_translation.x = this.sourceData.readFloat();
                this._temp_translation.y = this.sourceData.readFloat();
                this._temp_translation.z = this.sourceData.readFloat();
                skeletonPose.joints[j].worldMatrixValid = false;
                skeletonPose.joints[j].buildLocalMatrix(this._temp_scale, this._temp_orientation, this._temp_translation);
            }
            skeletonPose.calculateJointWorldMatrix();
            return skeletonPose;
        };
        Object.defineProperty(SkeletonAnimationClip.prototype, "jointNum", {
            /**
            * @language zh_CN
            * 骨骼数量
            * @returns number 骨骼数量
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this.poseArray.length > 0) {
                    return this.poseArray[0].joints.length;
                }
                return this.boneCount;
            },
            enumerable: true,
            configurable: true
        });
        return SkeletonAnimationClip;
    }());
    egret3d.SkeletonAnimationClip = SkeletonAnimationClip;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var AnimClipState = (function () {
        function AnimClipState(clip) {
            this.time = 0;
            this.offset = 0;
            this.speed = 1;
            this.loop = true;
            this._frameTime = 0;
            this._frame = 0;
            this._time = 0;
            this._nextframe = 0;
            this._lastframe = 0;
            this._weight = 0;
            this._reStart = false;
            this._end = false;
            this.cycleTime = 0;
            this.clip = clip;
            this.loop = this.clip.isLoop;
            //临时参数
            this.totalFrame = clip.totalFrame;
            this.totalTime = clip.totalTime;
        }
        AnimClipState.prototype.reset = function (time) {
            //this.offset = time;
            this._reStart = true;
            this._time = 0;
            this._lastframe = 0;
            this._end = false;
        };
        AnimClipState.prototype.reStart = function () {
            this._reStart = true;
        };
        AnimClipState.prototype.update = function (delay, pose) {
            if (this._reStart) {
                this._reStart = false;
                this.offset = this._time;
            }
            this.time = this._time - this.offset;
            this.time = this.time % this.totalTime;
            this._frameTime = this.time / this.clip.frameRate;
            this._frame = Math.floor(this._frameTime);
            this._weight = (this._frameTime - this._frame);
            this._nextframe = this._frame + 1;
            if (this._nextframe >= this.totalFrame) {
                this._nextframe = 0;
            }
            if (!this._end) {
                // 根据播放速度计算出最后一帧
                var endFrame = this.speed < 0 ? 0 : this.totalFrame - 1;
                if (this._frame == endFrame && this._frame != this._lastframe) {
                    if (this.loop) {
                        this.animation.dispatchCycle();
                    }
                    else {
                        this._frame = this._nextframe = this.speed < 0 ? 0 : this.totalFrame - 1;
                        this._end = true;
                        this.animation.dispatchComplete();
                    }
                }
            }
            else {
                this._frame = this._nextframe = this.speed < 0 ? 0 : this.totalFrame - 1;
            }
            this._lastframe = this._frame;
            if (egret3d.Egret3DPolicy.useAnimPoseInterpolation) {
                pose.getLerpSkeletonPose(this._frame, this._nextframe, this._weight, this.clip, pose);
            }
            else {
                pose.copySkeletonPose(this.clip.getSkeletonPose(this._frame), pose);
            }
            this._time += delay * this.speed;
            if (this._time < 0) {
                this._time = this._time % this.totalTime;
                this._time = this.totalTime + this._time;
            }
        };
        return AnimClipState;
    }());
    egret3d.AnimClipState = AnimClipState;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var CrossFadeNode = (function () {
        function CrossFadeNode() {
            //-------
            this.nextName = "";
            //-------
            this.crossA = "";
            //-------
            this.crossB = "";
            //-------
            this.blend_startFrame = 0;
            //-------
            this.blend_endFrame = 0;
            //-------
            this.crossB_startFrame = 0;
            this.blendTime = 0;
            this.blendStartTime = 0;
            this.totalTime = 0;
        }
        return CrossFadeNode;
    }());
    egret3d.CrossFadeNode = CrossFadeNode;
    /*
    * @private
    */
    var CrossFade = (function () {
        function CrossFade() {
            this._frameTime = 0;
            this._frame = 0;
            this._nextFrame = 0;
            this._weight = 0;
            this._offset = 0;
            this._time = 0;
            this._crossFades = {};
        }
        CrossFade.prototype.addCrossFadeNode = function (fade) {
            this._crossFades[fade.crossA + fade.crossB] = fade;
        };
        CrossFade.prototype.getNextAnim = function () {
            var anyState = this._crossFades["base"];
            if (anyState) {
                return "base";
            }
            else {
                if (this._currentCrossFadeNode) {
                    if (this._currentCrossFadeNode.nextName != "") {
                        return this._currentCrossFadeNode.nextName;
                    }
                    else if (this._currentCrossFadeNode.nextName == "") {
                        if (this._currentCrossFadeNode.crossB_state.clip.isLoop) {
                            return this._currentCrossFadeNode.crossB;
                        }
                    }
                }
                else {
                    console.warn("CrossFade: miss _currentCrossFadeNode!");
                }
            }
            return "";
        };
        CrossFade.prototype.checkCrossFade = function (currentName, lastName, anim) {
            this._currentCrossFadeNode = this._crossFades[currentName + lastName];
            if (this._currentCrossFadeNode) {
                var a = anim[this._currentCrossFadeNode.crossA];
                var b = anim[this._currentCrossFadeNode.crossB];
                b.reStart();
                this._currentCrossFadeNode.crossA_state = a;
                this._currentCrossFadeNode.crossB_state = b;
                this._currentCrossFadeNode.blendTime = (this._currentCrossFadeNode.blend_endFrame - this._currentCrossFadeNode.blend_startFrame) * 33;
                this._currentCrossFadeNode.blendStartTime = this._currentCrossFadeNode.blend_startFrame * 33;
                this._currentCrossFadeNode.totalTime = Math.max(a.totalFrame, this._currentCrossFadeNode.crossB_startFrame + b.totalFrame) * a.clip.frameRate;
            }
            return this._currentCrossFadeNode;
        };
        CrossFade.prototype.update = function (time) {
        };
        return CrossFade;
    }());
    egret3d.CrossFade = CrossFade;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.SkeletonAnimationState
    * @classdesc
    * 骨骼动画状态机对象
    * 处理骨骼动画的状态切换
    * @see egret3d.IAnimationState
    *
    * @version Egret 3.0
    * @platform Web,Native
    */
    var SkeletonAnimationState = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * 创建一个骨骼动画状态机对象
        * @param name 状态名字
        * @version Egret 3.0
        * @platform Web,Native
        */
        function SkeletonAnimationState() {
            this._canTransitionToSelf = false;
            this._atomic = true;
            this._time = 0;
            this._weight = 0;
            /**
            * @language zh_CN
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.gpuSkeletonPose = null;
            /**
            * @language zh_CN
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.currentAnimName = "";
            /**
            * @language zh_CN
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.nextAnimName = "";
            this._reset = false;
            this._offset = 0;
            this._defaultFade = new egret3d.CrossFadeNode;
            this._animState = {};
        }
        /*
        * @private
        */
        SkeletonAnimationState.prototype.addCrossFadeNode = function (fade) {
            if (fade)
                this._crossFade = this._crossFade || new egret3d.CrossFade();
            this._crossFade.addCrossFadeNode(fade);
        };
        /**
        * @language zh_CN
        * 添加 SkeletonAnimationClip 对象
        * @param animationClip 添加的动画剪辑对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimationState.prototype.addAnimClip = function (clip) {
            if (clip.animationName) {
                var animState = new egret3d.AnimClipState(clip);
                animState.animation = this.animation;
                this._animState[clip.animationName] = animState;
                this._currentState = animState;
            }
        };
        Object.defineProperty(SkeletonAnimationState.prototype, "animClip", {
            /*
            * @private
            */
            get: function () {
                return this._animState;
            },
            enumerable: true,
            configurable: true
        });
        /*
        * @private
        */
        SkeletonAnimationState.prototype.getCurrentState = function () {
            return this._currentState;
        };
        /**
        * @language zh_CN
        * 播放骨骼动画
        * @param name 动画名称
        * @param speed 播放速度
        * @param reset 是否重置
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimationState.prototype.play = function (name, speed, reset) {
            if (reset === void 0) { reset = false; }
            if (this.currentAnimName == name && !reset)
                return;
            //let gpuSkeletonPose = this.gpuSkeletonPose;
            var currentCrossFadeNode = this._currentCrossFadeNode;
            var a; //= this._currentCrossFadeNode.crossA_state;
            var b; // this._currentCrossFadeNode.crossB_state;
            var defaultFade = this._defaultFade; // this._currentCrossFadeNode.crossB_state;
            this._currentCrossFadeNode = null;
            if (this._crossFade) {
                this._currentCrossFadeNode = this._crossFade.checkCrossFade(this.currentAnimName, name, this._animState);
            }
            if (!this._currentCrossFadeNode && !reset) {
                a = this._animState[this.currentAnimName];
                b = this._animState[name];
                if (a && b) {
                    this._currentCrossFadeNode = defaultFade;
                    defaultFade.crossA = this.currentAnimName;
                    defaultFade.crossB = name;
                    defaultFade.crossA_state = a;
                    defaultFade.crossB_state = b;
                    var defaultMixTime = 300;
                    defaultFade.blend_startFrame = Math.floor((a.totalTime - defaultMixTime) / a.clip.frameRate);
                    defaultFade.blend_endFrame = a.totalFrame;
                    defaultFade.crossB_startFrame = defaultFade.blend_startFrame;
                    defaultFade.blendTime = defaultMixTime;
                    defaultFade.blendStartTime = defaultFade.blend_startFrame * a.clip.frameRate;
                    defaultFade.totalTime = defaultFade.blendStartTime + b.totalTime;
                }
            }
            this.currentAnimName = name;
            if (this._animState[name]) {
                this._currentState = this._animState[name];
                this._currentState.speed = speed;
            }
            else {
                return;
            }
            this._reset = true;
            //-------初始化
            if (!this.gpuSkeletonPose) {
                this.gpuSkeletonPose = new egret3d.SkeletonPose();
                this.gpuSkeletonPose.initSkeletonPose(this._animState[name].clip.getSkeletonPose(0), this.gpuSkeletonPose);
            }
            if (egret3d.Egret3DPolicy.useAnimMixInterpolation && !this._lerpAPose) {
                this._lerpAPose = new egret3d.SkeletonPose();
                this.gpuSkeletonPose.initSkeletonPose(this._animState[name].clip.getSkeletonPose(0), this._lerpAPose);
            }
            if (egret3d.Egret3DPolicy.useAnimMixInterpolation && !this._lerpBPose) {
                this._lerpBPose = new egret3d.SkeletonPose();
                this.gpuSkeletonPose.initSkeletonPose(this._animState[name].clip.getSkeletonPose(0), this._lerpBPose);
            }
        };
        //先算出交换动作后的时间起始点
        //获取融合时间轴上的 指定时间的 a clip
        //获取融合时间轴上的 指定时间的 b clip
        //计算 A/B 的融合
        //获取最终的clip
        /*
        * @private
        */
        SkeletonAnimationState.prototype.update = function (time, delay) {
            if (this._reset) {
                this._reset = false;
                this._offset = time;
                this._currentState.reset(time);
            }
            if (egret3d.Egret3DPolicy.useAnimMixInterpolation && this._currentCrossFadeNode) {
                this.mixUpdate(time, delay);
            }
            else {
                if (this._currentState) {
                    this._currentState.update(delay, this.gpuSkeletonPose);
                }
            }
            if (this.bindList) {
                for (var node in this.bindList) {
                    var joint = this.gpuSkeletonPose.jointsDictionary[node];
                    joint.copyTo(this.bindList[node].node, this.bindList[node].type);
                }
            }
        };
        SkeletonAnimationState.prototype.mixUpdate = function (time, delay) {
            var _lerpAPose = this._lerpAPose;
            var _lerpBPose = this._lerpBPose;
            var gpuSkeletonPose = this.gpuSkeletonPose;
            var currentCrossFadeNode = this._currentCrossFadeNode;
            var a = currentCrossFadeNode.crossA_state || this._animState[currentCrossFadeNode.crossA];
            var b = currentCrossFadeNode.crossB_state || this._animState[currentCrossFadeNode.crossB];
            var hasA = false;
            var hasB = false;
            var mix = false;
            this._time = time - this._offset + currentCrossFadeNode.blendStartTime;
            if (this._time <= currentCrossFadeNode.totalTime) {
                //动作A 部分
                if (this._time < (currentCrossFadeNode.blendStartTime + currentCrossFadeNode.blendTime)) {
                    hasA = true;
                }
                //动作B 部分
                if (this._time >= currentCrossFadeNode.crossB_startFrame * 33 && this._time <= currentCrossFadeNode.crossB_startFrame * 33 + b.totalTime) {
                    hasB = true;
                }
                //融合部分
                if (this._time <= (currentCrossFadeNode.blendStartTime + currentCrossFadeNode.blendTime)) {
                    mix = true;
                }
                if (mix) {
                    this._weight = (this._time - currentCrossFadeNode.blendStartTime) / currentCrossFadeNode.blendTime;
                    if (this._weight > 1) {
                        this._weight = 1;
                    }
                    a.update(delay, _lerpAPose);
                    b.update(delay, _lerpBPose);
                    gpuSkeletonPose.mixAnim(_lerpAPose, _lerpBPose, this._weight, gpuSkeletonPose);
                }
                else {
                    if (hasA && !hasB) {
                        a.update(delay, gpuSkeletonPose);
                    }
                    else if (hasB && !hasA) {
                        b.update(delay, gpuSkeletonPose);
                    }
                }
            }
            else {
                if (this._crossFade) {
                    this.play(this._crossFade.getNextAnim(), 1);
                }
                this._currentCrossFadeNode = null;
            }
        };
        /*
        * @private
        */
        SkeletonAnimationState.prototype.clone = function () {
            var animationState = new SkeletonAnimationState();
            var animState;
            for (var n in this._animState) {
                animationState.addAnimClip(this._animState[n].clip);
            }
            animationState._crossFade = this._crossFade;
            return animationState;
        };
        return SkeletonAnimationState;
    }());
    egret3d.SkeletonAnimationState = SkeletonAnimationState;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    (function (BindAnimType) {
        BindAnimType[BindAnimType["translate"] = 0] = "translate";
        BindAnimType[BindAnimType["rotation"] = 1] = "rotation";
        BindAnimType[BindAnimType["scale"] = 2] = "scale";
        BindAnimType[BindAnimType["translate_rotation"] = 3] = "translate_rotation";
        BindAnimType[BindAnimType["translate_scale"] = 4] = "translate_scale";
        BindAnimType[BindAnimType["all"] = 5] = "all";
    })(egret3d.BindAnimType || (egret3d.BindAnimType = {}));
    var BindAnimType = egret3d.BindAnimType;
    /**
    * @language zh_CN
    * @class egret3d.SkeletonAnimation
    * @classdesc
    * SkeletonAnimation 类表示骨骼动画控制类
    *
    * 骨骼动画控制类中管理若干个 SkeletonAnimationClip（骨骼动画） 对象，每个SkeletonAnimationClip对象，都是对*.eam 文件的实例。
    * 此对象会触发 SkeletonAnimationEvent3D 事件
    * @see egret3d.SkeletonAnimationClip
    * @see egret3d.EventDispatcher
    * @see egret3d.IAnimation
    * @see egret3d.SkeletonAnimationEvent3D
    * @includeExample anim/skeletonAnimation/SkeletonAnimation.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var SkeletonAnimation = (function (_super) {
        __extends(SkeletonAnimation, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function SkeletonAnimation(state) {
            if (state === void 0) { state = null; }
            _super.call(this);
            /**
            * @language zh_CN
            * 一个完整的动画播放时间周期
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.loopTime = 0;
            /**
            * @language zh_CN
            * 总时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.animTime = 0;
            /**
            * @language zh_CN
            * 播放速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.speed = 1;
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.event3D = new egret3d.AnimationEvent3D();
            /**
            * @language zh_CN
            * 是否循环
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.isLoop = true;
            /**
            * @private
            * @language zh_CN
            * 一个完整的动画播放时间周期
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._loopTime = 1;
            this._isPlay = false;
            //private _fpsDelay: number = 30;
            //private _numberFrameTime: number = 0;
            //private _frame: number = 0;
            //private _nextFrame: number = 0;
            //private _weight: number = 0;
            this._time = 0;
            this._cacheTime = 0;
            this._cycleEvent = new egret3d.Event3D(egret3d.AnimationEvent3D.CYCLE);
            this._completeEvent = new egret3d.Event3D(egret3d.AnimationEvent3D.COMPLETE);
            this._isPlay = false;
            this._skeletonAnimationState = state || new egret3d.SkeletonAnimationState();
            state.animation = this;
            this._movePosition = new egret3d.Vector3D();
        }
        Object.defineProperty(SkeletonAnimation.prototype, "skeletonAnimationController", {
            /**
            * @language zh_CN
            * 骨骼动画对象
            * @returns SkeletonAnimation  骨骼动画对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimation.prototype, "state", {
            /**
            * @language zh_CN
            * 骨骼动画状态
            * @returns SkeletonAnimationState  骨骼动画状态
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._skeletonAnimationState;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 挂载 基于 Object3D 的物体到指定的骨骼或虚拟提上
        * @param nodeName 节点的名字
        * @param type egret3d.BindAnimType
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.bindToJointPose = function (nodeName, node, type) {
            if (type === void 0) { type = BindAnimType.all; }
            this._skeletonAnimationState.bindList = this._skeletonAnimationState.bindList || {};
            this._skeletonAnimationState.bindList[nodeName] = { node: node, type: type };
        };
        /**
        * @language zh_CN
        * 播放骨骼动画
        * @param animName 动画名称
        * @param speed 播放速度
        * @param reset 是否重置
        * @param prewarm 是否预热
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.play = function (animName, speed, reset, prewarm) {
            if (speed === void 0) { speed = 1; }
            if (reset === void 0) { reset = false; }
            if (prewarm === void 0) { prewarm = true; }
            this._skeletonAnimationState.play(animName, speed, reset);
            this._isPlay = true;
            return true;
        };
        /**
        * @language zh_CN
        * 暂停骨骼动画播放（停留在当前帧）
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.pause = function () {
            this._isPlay = false;
        };
        /**
        * @language zh_CN
        * 停止骨骼动画播放（停留在第一帧）
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.stop = function () {
            this._isPlay = false;
        };
        /**
        * @language zh_CN
        * 更新骨骼动画
        * @param time 总时间
        * @param delay 延迟时间
        * @param geometry 该值无效
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.update = function (time, delay, geometry) {
            if (!this._isPlay)
                return;
            if (this._cacheTime != time) {
                this._cacheTime = time; // 标记不重复
                this.time += delay;
                this._skeletonAnimationState.update(this.time, delay);
            }
        };
        Object.defineProperty(SkeletonAnimation.prototype, "time", {
            /*
            * @private
            */
            get: function () {
                return this._time;
            },
            /*
            * @private
            */
            set: function (value) {
                this._time = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * 将骨骼信息更新给GPU
        * @param time 当前时间
        * @param delay 当前帧时间
        * @param usage PassUsage
        * @param geometry 子几何信息
        * @param context3DProxy 上下文信息
        * @param modeltransform 模型矩阵
        * @param camera3D 相机
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            var state = this._skeletonAnimationState;
            if (state && state.gpuSkeletonPose) {
                state.gpuSkeletonPose.updateGPUData(geometry.geometry.skeleton, geometry.geometry.skeletonGPUData, this._movePosition);
            }
            if (usage.uniform_time) {
                context3DProxy.uniform1f(usage.uniform_time.uniformIndex, time);
            }
            if (usage.uniform_PoseMatrix)
                context3DProxy.uniform4fv(usage.uniform_PoseMatrix.uniformIndex, geometry.geometry.skeletonGPUData);
        };
        Object.defineProperty(SkeletonAnimation.prototype, "jointNum", {
            /**
            * @language zh_CN
            * 骨架骨骼数量
            * @returns number 骨架骨骼数量，当前默认为48
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return 48;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 当前动画是否正在播放
        * @returns 是否在播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.isPlay = function () {
            return this._isPlay;
        };
        /**
        * @language zh_CN
        * 克隆当前骨骼动画
        * @returns IAnimation 骨骼动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.clone = function () {
            var cloneSkeletonAnimation = new SkeletonAnimation(this._skeletonAnimationState.clone());
            for (var s in cloneSkeletonAnimation.state.animClip) {
                cloneSkeletonAnimation.state.animClip[s].animation = cloneSkeletonAnimation;
            }
            return cloneSkeletonAnimation;
        };
        /**
        * @language zh_CN
        * 添加 SkeletonAnimationClip 对象
        * @param animationClip 添加的动画剪辑对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.prototype.addSkeletonAnimationClip = function (clip) {
            this.state.addAnimClip(clip);
        };
        /*
        * @private
        */
        SkeletonAnimation.prototype.addAnimState = function (animState) { };
        ;
        /*
        * @private
        */
        SkeletonAnimation.prototype.removeAnimState = function (animState) { };
        ;
        /*
        * @private
        */
        SkeletonAnimation.prototype.addAnim = function (clip) { };
        /*
        * @private
        */
        SkeletonAnimation.prototype.dispatchCycle = function () {
            this.dispatchEvent(this._cycleEvent);
        };
        /*
        * @private
        */
        SkeletonAnimation.prototype.dispatchComplete = function () {
            this.dispatchEvent(this._completeEvent);
        };
        /**
        * @language zh_CN
        * 动画速率
        * @version Egret 3.0
        * @platform Web,Native
        */
        SkeletonAnimation.fps = 1000 / 60;
        return SkeletonAnimation;
    }(egret3d.EventDispatcher));
    egret3d.SkeletonAnimation = SkeletonAnimation;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Channel
     * @classdesc
     * Channel 类控制应用程序中的声音，对声音执行更精细的控制。每个声音均分配给一个声道，而且应用程序可以具有混合在一起的多个声道。
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Channel = (function () {
        /**
        * @language zh_CN
        * 创建一个新的 Channel 对象。
        * @param sound {Sound} Sound 对象 音频的数据源。
        * @param {Object} options {any} ["volume":1,"loop":true volume] 回放音量, 0 到 1 ， loop 是否循环播放。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Channel(sound, options) {
            /**
            * @language zh_CN
            * 音量，范围从 0（静音）至 1（最大幅度）。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.volume = 1.0;
            /**
            * @language zh_CN
            * 是否循环播放 使声音播放结束时重新开始播放。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.loop = false;
            /**
            * @language zh_CN
            * 当前播放速度。1.0 正常速度。0.5 半速（更慢）。2.0 倍速（更快）。-1.0 向后。正常速度。-0.5 向后，半速。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.pitch = 1.0;
            options = options || {};
            if (options.volume)
                this.volume = options.volume;
            if (options.loop)
                this.loop = options.loop;
            if (options.pitch)
                this.pitch = options.pitch;
            this.sound = sound;
            this.paused = false;
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                this.context = egret3d.AudioManager.instance.context;
                this.startTime = 0;
                this.startOffset = 0;
                this.source = null;
                this.gain = this.context.createGain();
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.sound.audio) {
                    this.source = this.sound.audio.cloneNode(false);
                    this.source.pause();
                }
            }
        }
        /**
        * @language zh_CN
        * 开始在该声道中播放声音。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.play = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    throw new Error("Call stop() before calling play()");
                }
                this.createSource();
                if (!this.source) {
                    return;
                }
                this.startTime = this.context.currentTime;
                this.source.start(0, this.startOffset % this.source.buffer.duration);
            }
            else if (egret3d.AudioManager.instance.hasAudio) {
                this.paused = false;
                this.source.play();
            }
            this.setVolume(this.volume);
            this.setLoop(this.loop);
            this.setPitch(this.pitch);
        };
        /**
        * @language zh_CN
        * 暂停在该声道中播放声音。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.pause = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    this.startOffset += this.context.currentTime - this.startTime;
                    this.source.stop(0);
                    this.source = null;
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.source) {
                    this.source.pause();
                }
            }
            this.paused = true;
        };
        /**
        * @language zh_CN
        * 从暂停的位置继续在该声道中播放声音。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.unpause = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source || !this.paused) {
                    throw new Error('Call pause() before unpausing.');
                }
                this.createSource();
                if (!this.source) {
                    return;
                }
                this.startTime = this.context.currentTime;
                this.source.start(0, this.startOffset % this.source.buffer.duration);
                // Initialize volume and loop
                this.setVolume(this.volume);
                this.setLoop(this.loop);
                this.setPitch(this.pitch);
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                this.source.play();
            }
            this.paused = false;
        };
        /**
        * @language zh_CN
        * 停止在该声道中播放声音。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.stop = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    this.source.stop(0);
                    this.startOffset = 0;
                    this.source = null;
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.source) {
                    this.source.pause();
                    this.source.currentTime = 0;
                }
            }
        };
        Channel.prototype.setLoop = function (value) {
            if (this.source) {
                this.source.loop = value;
            }
        };
        Channel.prototype.setVolume = function (value) {
            if (this.gain) {
                this.gain.gain.value = value * egret3d.AudioManager.instance.volume;
            }
            else if (this.source) {
                this.source.volume = value * egret3d.AudioManager.instance.volume;
            }
        };
        Channel.prototype.setPitch = function (value) {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    this.source.playbackRate.value = value;
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.source) {
                    this.source.playbackRate = value;
                }
            }
        };
        /**
        * @language zh_CN
        * 是否正在播放。
        * @returns {boolean}
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.isPlaying = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                return (!this.paused);
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                return (!this.source.paused);
            }
        };
        /**
        * @language zh_CN
        * 获取音频持续时间。
        * @returns {number}
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.getDuration = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    return this.source.buffer.duration;
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.source) {
                    var d = this.source.duration;
                    if (d === d) {
                        return d;
                    }
                }
            }
            return 0;
        };
        Channel.prototype.createSource = function () {
            var _this = this;
            if (this.sound.buffer) {
                this.source = this.context.createBufferSource();
                this.source.buffer = this.sound.buffer;
                this.source.connect(this.gain);
                this.gain.connect(this.context.destination);
                if (this.loop) {
                    this.source.onended = function () { return _this.play(); };
                }
            }
        };
        return Channel;
    }());
    egret3d.Channel = Channel;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Channel3d
     * @classdesc
     * Channel3d 类控制应用程序中 在三维空间中播放的声音。每个声音均分配给一个声道，而且应用程序可以具有混合在一起的多个声道。
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Channel3d = (function (_super) {
        __extends(Channel3d, _super);
        /**
        * @language zh_CN
        * 构造函数
        * 创建一个新的 Channel3d 对象。
        * @param sound {Sound} Sound 对象 音频的数据源。
        * @param {Object} options {any} ["volume":1,"loop":true volume] 回放音量, 0 到 1 ， loop 是否循环播放。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Channel3d(sound, options) {
            _super.call(this, sound, options);
            this._position = new egret3d.Vector3D();
            this._velocity = new egret3d.Vector3D();
            if (egret3d.AudioManager.instance.hasAudioContext())
                this._panner = this.context.createPanner();
            this._maxDistance = 10000; // default maxDistance
            this._minDistance = 1;
            this._rollOffFactor = 1;
            this._listener = new egret3d.Vector3D();
        }
        Object.defineProperty(Channel3d.prototype, "listener", {
            /**
            * @language zh_CN
            * 返回监听者位置。
            * @returns Vector3D 监听者位置。
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._listener;
            },
            /**
            * @language zh_CN
            * 设置监听者位置。
            * @param value Vector3D监听者位置。
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._listener.copyFrom(value);
                if (egret3d.AudioManager.instance.hasAudio()) {
                    if (this.source) {
                        var factor = this.fallOff(this._listener, this.position, this.minDistance, this.maxDistance, this.rollOffFactor);
                        this.source.volume = this.volume * factor;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "position", {
            /**
            * @language zh_CN
            * 三维空间中的位置。
            * @returns {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._position;
            },
            /**
            * @language zh_CN
            * 三维空间中的位置。
            * @param opsition {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (position) {
                this._position.copyFrom(position);
                if (egret3d.AudioManager.instance.hasAudioContext()) {
                    this._panner.setPosition(position.x, position.y, position.z);
                }
                if (egret3d.AudioManager.instance.hasAudio()) {
                    if (this.source) {
                        var factor = this.fallOff(this._listener, this.position, this.minDistance, this.maxDistance, this.rollOffFactor);
                        this.source.volume = this.volume * factor;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "velocity", {
            /**
            * @language zh_CN
            * 传播方向。
            * @returns {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._velocity;
            },
            /**
            * @language zh_CN
            * 传播方向。
            * @param velocity {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (velocity) {
                this._velocity.copyFrom(velocity);
                if (egret3d.AudioManager.instance.hasAudioContext())
                    this._panner.setVelocity(velocity.x, velocity.y, velocity.z);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "maxDistance", {
            /**
            * @language zh_CN
            * 最大距离。
            * @returns {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._maxDistance;
            },
            /**
            * @language zh_CN
            * 最大距离，超出这个距离会听不见声音
            * @param max{Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (max) {
                this._maxDistance = max;
                if (egret3d.AudioManager.instance.hasAudioContext())
                    this._panner.maxDistance = max;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "minDistance", {
            /**
            * @language zh_CN
            * 最小距离。
            * @returns {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._minDistance;
            },
            /**
            * @language zh_CN
            * 最小距离。
            * @param min{Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (min) {
                this._minDistance = min;
                if (egret3d.AudioManager.instance.hasAudioContext())
                    this._panner.refDistance = min;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "rollOffFactor", {
            /**
            * @language zh_CN
            * rollOff 系数。
            * @returns {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rollOffFactor;
            },
            /**
            * @language zh_CN
            * rollOff 系数。
            * @param factor {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (factor) {
                this._rollOffFactor = factor;
                if (this._panner)
                    this._panner.rolloffFactor = factor;
            },
            enumerable: true,
            configurable: true
        });
        Channel3d.prototype.createSource = function () {
            if (this.sound.buffer) {
                this.source = this.context.createBufferSource();
                this.source.buffer = this.sound.buffer;
                // Connect up the nodes
                this.source.connect(this._panner);
                this._panner.connect(this.gain);
                this.gain.connect(this.context.destination);
            }
        };
        // Fall off function which should be the same as the one in the Web Audio API,
        // taken from OpenAL
        Channel3d.prototype.fallOff = function (posOne, posTwo, refDistance, maxDistance, rolloffFactor) {
            var distance = egret3d.Vector3D.distance(posOne, posTwo);
            if (distance < refDistance) {
                return 1;
            }
            else if (distance > maxDistance) {
                return 0;
            }
            else {
                //var numerator = refDistance + (rolloffFactor * (distance - refDistance));
                //if (numerator !== 0) {
                //    return refDistance / numerator;
                //} else {
                //    return 1;
                //}
                return 1 - distance / (maxDistance - refDistance);
            }
        };
        return Channel3d;
    }(egret3d.Channel));
    egret3d.Channel3d = Channel3d;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Sound
     * @classdesc
     * Sound 类允许您在应用程序中使用声音。</p>
     * 使用 Sound 类可以创建 Sound 对象、将外部 MP3 文件加载到该对象并播放该文件、关闭声音流，以及访问有关声音的数据，如有关流中字节数和 ID3 元数据的信息。</p>
     * 可通过以下项对声音执行更精细的控制：声音源（声音的 Channel 和 Channel3d）用于控制向计算机扬声器输出声音的属性。  </p>
     * @see egret3d.EventDispatcher
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Sound = (function (_super) {
        __extends(Sound, _super);
        /**
        * @language zh_CN
        * 创建一个新的 Sound 对象。一旦某个 Sound 对象加载完成声音文件，就不能再将另一个声音文件加载到该 Sound 对象中。要加载另一个声音文件，请创建新的 Sound 对象。
        * @param {String}   指向外部音频文件的 URL。
        * @param {Function} 一个可选的音频文件加载成功的事件处理函数。
        * @param {Function} 一个可选的音频文件加载失败的事件处理函数。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Sound(url, success, error) {
            var _this = this;
            if (success === void 0) { success = null; }
            if (error === void 0) { error = null; }
            _super.call(this);
            /**
            * @language zh_CN
            * HTML音频 数据源。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.audio = null;
            this._event = new egret3d.Event3D();
            this._success = success;
            this._error = error;
            this.isLoaded = false;
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (!egret3d.AudioManager.instance.isSupported(url, this.audio)) {
                    console.warn('Audio format not supported');
                    this._event.eventType = Sound.SOUND_ERROR;
                    this._event.target = this;
                    this.dispatchEvent(this._event);
                    error(this);
                }
                else {
                    if (egret3d.AudioManager.instance.context) {
                        this.loadAudioFile(url);
                    }
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                try {
                    this.audio = new Audio();
                }
                catch (e) {
                    console.warn("No support for Audio element");
                    this._event.eventType = Sound.SOUND_ERROR;
                    this._event.target = this;
                    this.dispatchEvent(this._event);
                    if (error)
                        error(this);
                    return;
                }
                if (!egret3d.AudioManager.instance.isSupported(url, this.audio)) {
                    console.warn('Audio format not supported');
                    this._event.eventType = Sound.SOUND_ERROR;
                    this._event.target = this;
                    this.dispatchEvent(this._event);
                    if (error)
                        error(this);
                }
                else {
                    this.audio.src = url;
                    this.audio.addEventListener("canplaythrough", function (ev) { return _this.oncanplaythrough(ev); });
                    this.audio.addEventListener("ended", function (ev) { return _this.onended(ev); });
                    this.audio.load();
                }
            }
        }
        Object.defineProperty(Sound.prototype, "buffer", {
            /**
            * @language zh_CN
            * Web音频 数据源。
            * @returns {AudioBuffer}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._buffer;
            },
            enumerable: true,
            configurable: true
        });
        Sound.prototype.loadAudioFile = function (url) {
            var _this = this;
            if (this.xhr == null)
                this.xhr = new XMLHttpRequest(); //通过XHR下载音频文件
            this.xhr.open('GET', url, true);
            this.xhr.responseType = 'arraybuffer';
            this.xhr.onload = function (e) { return _this.audioLoadend(e); };
            this.xhr.send();
        };
        Sound.prototype.audioLoadend = function (e) {
            var _this = this;
            egret3d.AudioManager.instance.context.decodeAudioData(this.xhr.response, function (buffer) { return _this.decodeSuccessCallback(buffer); });
        };
        Sound.prototype.decodeSuccessCallback = function (buffer) {
            this._buffer = buffer;
            this._event.eventType = Sound.SOUND_SUCCESS;
            this._event.target = this;
            this._event.data = buffer;
            this.dispatchEvent(this._event);
            if (this._success) {
                this._success(this);
            }
        };
        Sound.prototype.onended = function (ev) {
        };
        Sound.prototype.oncanplaythrough = function (ev) {
            if (!this.isLoaded) {
                this.isLoaded = true;
                this._event.eventType = Sound.SOUND_SUCCESS;
                this._event.target = this;
                this._event.data = ev;
                this.dispatchEvent(this._event);
                if (this._success) {
                    this._success(this);
                }
            }
        };
        /**
        * @language zh_CN
        * Sound 加載成功事件
        * @version Egret 3.0
        * @platform Web,Native
        */
        Sound.SOUND_SUCCESS = "SoundSuccess";
        /**
        * @language zh_CN
        * Sound 加載失敗事件
        * @version Egret 3.0
        * @platform Web,Native
        */
        Sound.SOUND_ERROR = "SoundError";
        return Sound;
    }(egret3d.EventDispatcher));
    egret3d.Sound = Sound;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.AudioManager
    * @classdesc
    * AudioManager 类允许您在应用程序中 播放 HTML5 Audio 和 Web Audio。
    * @includeExample audio/AudioManager.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var AudioManager = (function () {
        /**
        * @language zh_CN
        * 创建一个新的 AudioManager 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function AudioManager() {
            /**
            * @language zh_CN
            * 音量，范围从 0（静音）至 1（最大幅度）。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.volume = 1;
            this.codecs = null;
            if (this.hasAudioContext()) {
                if (typeof AudioContext !== 'undefined') {
                    this.context = new AudioContext();
                }
            }
        }
        /**
        * @language zh_CN
        * 是否支持 HTML5 Audio tag API。
        * @returns {boolean}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.hasAudio = function () {
            return (typeof Audio !== 'undefined');
        };
        /**
        * @language zh_CN
        * 是否支持 Web Audio API。
        * @returns {boolean}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.hasAudioContext = function () {
            return !!(typeof AudioContext !== 'undefined');
        };
        /**
        * @language zh_CN
        * 浏览器是否可以播放这种音频类型。
        * @param url 指向外部音频文件的 URL。
        * @param audio {HTMLAudioElement} HTMLAudio元素
        * @returns {boolean}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.isSupported = function (url, audio) {
            if (this.codecs == null) {
                if (audio == null)
                    audio = new Audio();
                this.codecs = {
                    mp3: !!audio.canPlayType('audio/mpeg;').replace(/^no$/, ''),
                    opus: !!audio.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
                    ogg: !!audio.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
                    wav: !!audio.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
                    aac: !!audio.canPlayType('audio/aac;').replace(/^no$/, ''),
                    m4a: !!(audio.canPlayType('audio/x-m4a;') || audio.canPlayType('audio/m4a;') || audio.canPlayType('audio/aac;')).replace(/^no$/, ''),
                    mp4: !!(audio.canPlayType('audio/x-mp4;') || audio.canPlayType('audio/mp4;') || audio.canPlayType('audio/aac;')).replace(/^no$/, ''),
                    weba: !!audio.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')
                };
            }
            var ext = url.match(/^data:audio\/([^;,]+);/i);
            if (!ext) {
                ext = url.split('?', 1)[0].match(/\.([^.]+)$/);
            }
            if (ext) {
                ext = ext[1].toLowerCase();
            }
            return this.codecs[ext];
        };
        /**
        * @language zh_CN
        * 生成一个新的 Sound 对象 ，将声音数据加载到 Sound 对象中。
        * @param url {String}   指向外部音频文件的 URL。
        * @param success {Function} 一个可选的音频文件加载成功的事件处理函数。
        * @param error {Function} 一个可选的音频文件加载失败的事件处理函数。
        * @returns {Sound}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.createSound = function (url, success, error) {
            if (success === void 0) { success = null; }
            if (error === void 0) { error = null; }
            return new egret3d.Sound(url, success, error);
        };
        /**
        * @language zh_CN
        * 生成一个新的 Channel 对象来播放该声音。此方法返回 Channel 对象，访问该对象可停止声音并监控音量。
        * @param sound{Sound} 要播放的声音数据。
        * @param options{any}   ["volume":1,"loop":true volume] 回放音量, 0 到 1 ， loop 是否循环播放。
        * @returns {Channel}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.playSound = function (sound, options) {
            options = options || {};
            var channel = new egret3d.Channel(sound, options);
            channel.play();
            return channel;
        };
        /**
        * @language zh_CN
        * 生成一个新的 Channel3d 对象来播放该声音。此方法返回 Channel3d 对象，访问该对象可停止声音并监控音量。
        * @param sound {Sound}  要播放的声音数据。
        * @param position {Vector3D} 在三维空间中播放的位置。
        * @param options {any} ["volume":1,"loop":true volume] 回放音量, 0 到 1 ， loop 是否循环播放。
        * @returns {Channel}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.playSound3d = function (sound, position, options) {
            options = options || {};
            var channel = new egret3d.Channel3d(sound, options);
            channel.position = position;
            if (options.volume) {
                channel.volume = options.volume;
            }
            if (options.loop) {
                channel.loop = options.loop;
            }
            if (options.maxDistance) {
                channel.maxDistance = options.maxDistance;
            }
            if (options.minDistance) {
                channel.minDistance = options.minDistance;
            }
            if (options.rollOffFactor) {
                channel.rollOffFactor = options.rollOffFactor;
            }
            channel.play();
            return channel;
        };
        Object.defineProperty(AudioManager, "instance", {
            /**
            * @language zh_CN
            * AudioManager类的单例模式，返回一个 AudioManager 对象。
            * @returns AudioManager
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._instance == null) {
                    this._instance = new AudioManager();
                }
                return this._instance;
            },
            enumerable: true,
            configurable: true
        });
        return AudioManager;
    }());
    egret3d.AudioManager = AudioManager;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.ControllerBase
    * @classdesc
    * 控制器 基类, 抽象控制器的一些数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ControllerBase = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @param targetObject 控制的目标
        * @param lookAtObject 观察的目标
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ControllerBase(targetObject, lookAtObject) {
            if (targetObject === void 0) { targetObject = null; }
            if (lookAtObject === void 0) { lookAtObject = null; }
            this._autoUpdate = true;
            this._origin = new egret3d.Vector3D(0.0, 0.0, 0.0);
            this._speed = 300;
            this._target = targetObject;
            this._lookAtObject = lookAtObject;
        }
        Object.defineProperty(ControllerBase.prototype, "target", {
            /**
            * @language zh_CN
            * 获取当前的目标
            * @returns Object3D 返回当前的目标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._target;
            },
            /**
            * @language zh_CN
            * 设置当前的目标
            * @param val 当前的目标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._target == val)
                    return;
                this._target = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ControllerBase.prototype, "lookAtObject", {
            /**
            * @language zh_CN
            * 设置获取当前的观察目标
            * @returns Object3D 观察目标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._lookAtObject;
            },
            /**
            * @language zh_CN
            * 获取当前的观察目标
            * @param val 观察目标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._lookAtObject == val)
                    return;
                this._lookAtObject = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ControllerBase.prototype, "speed", {
            /**
            * @language zh_CN
            * 获取移动速度
            * @returns number 移动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._speed;
            },
            /**
            * @language zh_CN
            * 设置移动速度
            * @param val 移动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                this._speed = val;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 数据更新
        * @version Egret 3.0
        * @platform Web,Native
        */
        ControllerBase.prototype.update = function () {
        };
        return ControllerBase;
    }());
    egret3d.ControllerBase = ControllerBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.LookAtController
    * @classdesc
    * look at 摄像机控制器 。</p>
    * 指定摄像机看向的目标对象。</p>
    * 1.按下鼠标左键并移动鼠标可以使摄像机绕着目标进行旋转。</p>
    * 2.按下键盘的(w s a d) 可以摄像机(上 下 左 右)移动。</p>
    * 3.滑动鼠标滚轮可以控制摄像机的视距。</p>
    *
    * @includeExample controller/ctl/LookAtController.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var LookAtController = (function (_super) {
        __extends(LookAtController, _super);
        /**
        * @language zh_CN
        * 控制的目标相机，目标对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function LookAtController(targetObject, lookAtObject, needCtl, needAlt) {
            if (targetObject === void 0) { targetObject = null; }
            if (lookAtObject === void 0) { lookAtObject = null; }
            if (needCtl === void 0) { needCtl = false; }
            if (needAlt === void 0) { needAlt = false; }
            _super.call(this, targetObject);
            this._origin = new egret3d.Vector3D(0.0, 0.0, 0.0);
            this._lookAtPosition = new egret3d.Vector3D();
            this._eyesPos = new egret3d.Vector3D();
            this._up = egret3d.Vector3D.Y_AXIS;
            this._eyesLength = 100;
            this._rotaEyesLine = new egret3d.Vector3D(0, 0, 1);
            this._rotaAngle = new egret3d.Vector3D();
            this._matRot = new egret3d.Matrix4_4();
            this._quaRot = new egret3d.Quaternion();
            this._tempVec = new egret3d.Vector3D();
            this._matTemp = new egret3d.Matrix4_4();
            this._mouseDown = false;
            this._mouseRightDown = false;
            this._screenMoveStartDetail = new egret3d.Point();
            this._screenMoveDelay = new egret3d.Point();
            this._isUpdate = false;
            this._elapsed = 0;
            this._xAngle = 0;
            this._ctl = false;
            this._alt = false;
            this._shift = false;
            this._needctl = false;
            this._needalt = false;
            this._needshift = false;
            this._keyArray = new Array();
            /**
            * @language zh_CN
            * 目标点偏移
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lookAtOffset = new egret3d.Vector3D(0, 0, 0);
            /**
            * @language zh_CN
            * 是否第一人称相机
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.firstCamera = false;
            this._needctl = needCtl;
            this._needalt = needAlt;
            if (lookAtObject)
                this.lookAtObject = lookAtObject;
            else
                this.lookAtPosition = new egret3d.Vector3D();
            this._eyesPos.copyFrom(targetObject.position);
            this._lookAtPosition.copyFrom(lookAtObject.position.add(this.lookAtOffset, egret3d.MathUtil.CALCULATION_VECTOR3D));
            this._target.lookAt(this._eyesPos, this._lookAtPosition);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_MOVE, this.mouseMove, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_WHEEL, this.mouseWheel, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.mouseUp, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_DOWN, this.mouseDown, this);
            egret3d.Input.addEventListener(egret3d.KeyEvent3D.KEY_UP, this.keyUp, this);
            egret3d.Input.addEventListener(egret3d.KeyEvent3D.KEY_DOWN, this.keyDown, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_END, this.touchUp, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_START, this.touchDown, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_MOVE, this.touchMove, this);
        }
        LookAtController.prototype.mouseMove = function (m) {
            if (this._mouseDown && (this._needctl ? this._ctl : true)) {
                this._rotaAngle.y += egret3d.Input.mouseOffsetX;
                this._rotaAngle.x += egret3d.Input.mouseOffsetY;
                this._rotaAngle.y %= 360;
                this._rotaAngle.x %= 360;
            }
        };
        LookAtController.prototype.mouseWheel = function (m) {
            if (!this._target) {
                return;
            }
            var camera = this._target;
            if (!camera) {
                return;
            }
            var value = egret3d.Input.wheelDelta * 0.1;
            var viewPort = camera.viewPort;
            switch (camera.cameraType) {
                case egret3d.CameraType.orthogonal:
                    var w = viewPort.width - value;
                    var h = viewPort.height - value;
                    camera.updateViewport(0, 0, w, h);
                    break;
                case egret3d.CameraType.orthogonalToCenter:
                    var x = viewPort.x - value;
                    var y = viewPort.y - value;
                    var w = viewPort.width - value;
                    var h = viewPort.height - value;
                    camera.updateViewport(x, y, w, h);
                    break;
                case egret3d.CameraType.perspective:
                    this.distance = this._eyesLength - value;
                    break;
            }
        };
        LookAtController.prototype.mouseUp = function (m) {
            switch (m.mouseCode) {
                case egret3d.MouseCode.Mouse_Left:
                    this._mouseDown = false;
                    break;
                case egret3d.MouseCode.Mouse_Right:
                    this._mouseRightDown = false;
                    break;
            }
        };
        LookAtController.prototype.mouseDown = function (m) {
            switch (m.mouseCode) {
                case egret3d.MouseCode.Mouse_Left:
                    this._mouseDown = true;
                    break;
                case egret3d.MouseCode.Mouse_Right:
                    this._mouseRightDown = true;
                    break;
            }
        };
        LookAtController.prototype.touchMove = function (t) {
            if (t.targetTouches.length == 1) {
                this.mouseMove(null);
            }
            else {
                this.mouseWheel(null);
            }
        };
        LookAtController.prototype.touchUp = function (m) {
            this._mouseDown = false;
        };
        LookAtController.prototype.touchDown = function (m) {
            this._mouseDown = true;
        };
        LookAtController.prototype.keyDown = function (key) {
            switch (key.keyCode) {
                case egret3d.KeyCode.Key_W:
                    this._keyArray[0] = true;
                    break;
                case egret3d.KeyCode.Key_A:
                    this._keyArray[1] = true;
                    break;
                case egret3d.KeyCode.Key_S:
                    this._keyArray[2] = true;
                    break;
                case egret3d.KeyCode.Key_D:
                    this._keyArray[3] = true;
                    break;
                case egret3d.KeyCode.Key_Q:
                    this._keyArray[4] = true;
                    break;
                case egret3d.KeyCode.Key_E:
                    this._keyArray[5] = true;
                    break;
                case egret3d.KeyCode.Key_Control_L:
                    this._ctl = true;
                    break;
                case egret3d.KeyCode.Key_Alt_L:
                    this._alt = true;
                    break;
            }
        };
        LookAtController.prototype.keyUp = function (key) {
            switch (key.keyCode) {
                case egret3d.KeyCode.Key_W:
                    this._keyArray[0] = false;
                    break;
                case egret3d.KeyCode.Key_A:
                    this._keyArray[1] = false;
                    break;
                case egret3d.KeyCode.Key_S:
                    this._keyArray[2] = false;
                    break;
                case egret3d.KeyCode.Key_D:
                    this._keyArray[3] = false;
                    break;
                case egret3d.KeyCode.Key_Q:
                    this._keyArray[4] = false;
                    break;
                case egret3d.KeyCode.Key_E:
                    this._keyArray[5] = false;
                    break;
                case egret3d.KeyCode.Key_Control_L:
                    this._ctl = false;
                    break;
                case egret3d.KeyCode.Key_Alt_L:
                    this._alt = false;
                    break;
            }
        };
        Object.defineProperty(LookAtController.prototype, "lookAtPosition", {
            /**
            * @language zh_CN
            * 返回目标的位置
            *
            * @returns 目标的位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._lookAtPosition;
            },
            /**
            * @language zh_CN
            * 设置目标坐标
            *
            * @param val 摄像机看向的目标点
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._lookAtObject)
                    this._lookAtObject = null;
                this._lookAtPosition.copyFrom(val.add(this.lookAtOffset, egret3d.MathUtil.CALCULATION_VECTOR3D));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "distance", {
            /**
            * @language zh_CN
            * 得到目标和相机的距离
            * @returns number 距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._eyesLength;
            },
            /**
            * @language zh_CN
            * 设置目标和相机的距离
            * @param length 距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (length) {
                this._eyesLength = length;
                if (this._eyesLength < 1) {
                    this._eyesLength = 1;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "rotationX", {
            /**
            * @language zh_CN
            * 得到相机x轴旋转
            * @returns x 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rotaAngle.x;
            },
            /**
            * @language zh_CN
            * 设置相机x轴旋转
            * @param x 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (x) {
                this._rotaAngle.x = x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "rotationY", {
            /**
            * @language zh_CN
            * 得到相机x轴旋转
            * @returns y 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rotaAngle.y;
            },
            /**
            * @language zh_CN
            * 设置相机y轴旋转
            * @param y 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (y) {
                this._rotaAngle.y = y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "rotationZ", {
            /**
            * @language zh_CN
            * 得到相机x轴旋转
            * @returns z 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rotaAngle.z;
            },
            /**
            * @language zh_CN
            * 设置相机z轴旋转
            * @param z 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (z) {
                this._rotaAngle.z = z;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 控制器数据更新
        * @param delay 帧间隔
        * @param time 当前时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        LookAtController.prototype.update = function (delay, time) {
            if (delay === void 0) { delay = 16.6; }
            if (time === void 0) { time = 0; }
            if (this._target) {
                if (this._target.isController == false) {
                    return;
                }
                var speed = this._speed * (delay / 1000);
                this._quaRot.fromEulerAngles(this._rotaAngle.x, this._rotaAngle.y, 0);
                this._rotaEyesLine.copyFrom(this._quaRot.transformVector(egret3d.Vector3D.Z_AXIS, egret3d.MathUtil.CALCULATION_VECTOR3D));
                this._rotaEyesLine.normalize();
                if (this._keyArray[0]) {
                    this._tempVec.copyFrom(this._rotaEyesLine);
                    this._tempVec.y = 0;
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.add(this._tempVec, egret3d.MathUtil.CALCULATION_VECTOR3D));
                    this._lookAtObject.position = this._tempVec;
                }
                if (this._keyArray[1]) {
                    this._tempVec.copyFrom(this._rotaEyesLine);
                    this._matTemp.identity();
                    this._matTemp.createByRotation(90, egret3d.Vector3D.Y_AXIS);
                    this._tempVec.copyFrom(this._matTemp.transformVector(this._tempVec, egret3d.MathUtil.CALCULATION_VECTOR3D));
                    this._tempVec.y = 0;
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.subtract(this._tempVec, egret3d.MathUtil.CALCULATION_VECTOR3D));
                    this._lookAtObject.position = this._tempVec;
                }
                if (this._keyArray[2]) {
                    this._tempVec.copyFrom(this._rotaEyesLine);
                    this._tempVec.y = 0;
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.subtract(this._tempVec, egret3d.MathUtil.CALCULATION_VECTOR3D));
                    this._lookAtObject.position = this._tempVec;
                }
                if (this._keyArray[3]) {
                    this._tempVec.copyFrom(this._rotaEyesLine);
                    this._matTemp.identity();
                    this._matTemp.createByRotation(90, egret3d.Vector3D.Y_AXIS);
                    this._tempVec.copyFrom(this._matTemp.transformVector(this._tempVec, egret3d.MathUtil.CALCULATION_VECTOR3D));
                    this._tempVec.y = 0;
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.add(this._tempVec, egret3d.MathUtil.CALCULATION_VECTOR3D));
                    this._lookAtObject.position = this._tempVec;
                }
                if (this._keyArray[4]) {
                    this._quaRot.fromEulerAngles(this._rotaAngle.x, this._rotaAngle.y, 0);
                    this._tempVec.copyFrom(this._quaRot.transformVector(egret3d.Vector3D.Y_AXIS, egret3d.MathUtil.CALCULATION_VECTOR3D));
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.add(this._tempVec, egret3d.MathUtil.CALCULATION_VECTOR3D));
                    this._lookAtObject.position = this._tempVec;
                }
                if (this._keyArray[5]) {
                    this._quaRot.fromEulerAngles(this._rotaAngle.x, this._rotaAngle.y, 0);
                    this._tempVec.copyFrom(this._quaRot.transformVector(egret3d.Vector3D.Y_AXIS, egret3d.MathUtil.CALCULATION_VECTOR3D));
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.subtract(this._tempVec, egret3d.MathUtil.CALCULATION_VECTOR3D));
                    this._lookAtObject.position = this._tempVec;
                }
                this._lookAtPosition.copyFrom(this._lookAtObject.position);
                this._tempVec.copyFrom(this._rotaEyesLine);
                this._tempVec.scaleBy(this._eyesLength);
                this._eyesPos.copyFrom(this._lookAtPosition.subtract(this._tempVec, egret3d.MathUtil.CALCULATION_VECTOR3D));
                if (this._lookAtObject) {
                    this._lookAtPosition.copyFrom(this._lookAtObject.position.add(this.lookAtOffset, egret3d.MathUtil.CALCULATION_VECTOR3D));
                }
                this._quaRot.fromEulerAngles(this._rotaAngle.x, this._rotaAngle.y, this._rotaAngle.z);
                this._tempVec.copyFrom(this._up);
                this._tempVec.copyFrom(this._quaRot.transformVector(this._tempVec, egret3d.MathUtil.CALCULATION_VECTOR3D));
                this._tempVec.normalize();
                if (this.firstCamera) {
                    this._lookAtObject.rotationY = this._rotaAngle.y;
                    this._lookAtObject.rotationX = this._rotaAngle.x;
                }
                this._target.lookAt(this._eyesPos, this._lookAtPosition, this._tempVec);
            }
        };
        return LookAtController;
    }(egret3d.ControllerBase));
    egret3d.LookAtController = LookAtController;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.HoverController
    * @classdesc
    * 摄像机控制器 ,实现摄像机平滑移动
    * 指定摄像机看向的目标对象
    * 1.按下鼠标左键并移动鼠标(或手机手指滑动)可以使摄像机绕着目标进行旋转.
    * 2.滑动鼠标滚轮(或双指滑动)可以控制摄像机的视距.
    *
    * 示例:
    * @includeExample controller/ctl/HoverController.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var HoverController = (function (_super) {
        __extends(HoverController, _super);
        /**
        * @language zh_CN
        * @param targetObject 控制的目标相机，目标对象
        * @param lookAtObject 相机看向的对象
        * @param panAngle y轴旋转
        * @param tiltAngle x轴旋转
        * @param distance 相机距离
        * @param minTiltAngle 最小x轴旋转
        * @param maxTiltAngle 最大x轴旋转
        * @param minPanAngle 最小y轴旋转
        * @param maxPanAngle 最大y轴旋转
        * @param steps 平滑时分为几步
        * @param yFactor 旋转时Y轴的一个相对变化值
        * @param wrapPanAngle 是否开启 PanAngle 角度限制
        * @version Egret 3.0
        * @platform Web,Native
        */
        function HoverController(targetObject, lookAtObject, panAngle, tiltAngle, distance, minTiltAngle, maxTiltAngle, minPanAngle, maxPanAngle, steps, yFactor, wrapPanAngle) {
            if (targetObject === void 0) { targetObject = null; }
            if (lookAtObject === void 0) { lookAtObject = null; }
            if (panAngle === void 0) { panAngle = 0; }
            if (tiltAngle === void 0) { tiltAngle = 90; }
            if (distance === void 0) { distance = 100; }
            if (minTiltAngle === void 0) { minTiltAngle = -90; }
            if (maxTiltAngle === void 0) { maxTiltAngle = 90; }
            if (minPanAngle === void 0) { minPanAngle = NaN; }
            if (maxPanAngle === void 0) { maxPanAngle = NaN; }
            if (steps === void 0) { steps = 8; }
            if (yFactor === void 0) { yFactor = 2; }
            if (wrapPanAngle === void 0) { wrapPanAngle = false; }
            _super.call(this, targetObject, lookAtObject);
            this._currentPanAngle = 0;
            this._currentTiltAngle = 90;
            this._panAngle = 0;
            this._tiltAngle = 90;
            this._distance = 1000;
            this._minPanAngle = -Infinity;
            this._maxPanAngle = Infinity;
            this._minTiltAngle = -90;
            this._maxTiltAngle = 90;
            this._maxDistance = 5000;
            this._minDistance = -5000;
            this._steps = 8;
            this._yFactor = 2;
            this._wrapPanAngle = false;
            this._lookAtPosition = new egret3d.Vector3D(0.0, 0.0, 0.0);
            this._mouseDown = false;
            this._mouseRightDown = false;
            this._keyArray = new Array();
            this.distance = distance;
            this.panAngle = panAngle;
            this.tiltAngle = tiltAngle;
            this.minPanAngle = minPanAngle || -Infinity;
            this.maxPanAngle = maxPanAngle || Infinity;
            this.minTiltAngle = minTiltAngle;
            this.maxTiltAngle = maxTiltAngle;
            this.steps = steps;
            this.yFactor = yFactor;
            this.wrapPanAngle = wrapPanAngle;
            //values passed in contrustor are applied immediately
            this._currentPanAngle = this._panAngle;
            this._currentTiltAngle = this._tiltAngle;
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_MOVE, this.mouseMove, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_WHEEL, this.mouseWheel, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.mouseUp, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_DOWN, this.mouseDown, this);
            egret3d.Input.addEventListener(egret3d.KeyEvent3D.KEY_UP, this.keyUp, this);
            egret3d.Input.addEventListener(egret3d.KeyEvent3D.KEY_DOWN, this.keyDown, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_END, this.touchUp, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_START, this.touchDown, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_MOVE, this.touchMove, this);
        }
        HoverController.prototype.mouseMove = function (m) {
            if (this._mouseDown) {
                this._tiltAngle += egret3d.Input.mouseOffsetY * 0.1;
                this._tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
                this._panAngle += egret3d.Input.mouseOffsetX * 0.1;
                this._panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
            }
        };
        HoverController.prototype.mouseWheel = function (m) {
            var camera = this._target;
            if (!camera) {
                return;
            }
            var value = egret3d.Input.wheelDelta * 0.1;
            var viewPort = camera.viewPort;
            switch (camera.cameraType) {
                case egret3d.CameraType.orthogonal:
                    var w = viewPort.width - value;
                    var h = viewPort.height - value;
                    camera.updateViewport(0, 0, w, h);
                    break;
                case egret3d.CameraType.orthogonalToCenter:
                    var x = viewPort.x - value;
                    var y = viewPort.y - value;
                    var w = viewPort.width - value;
                    var h = viewPort.height - value;
                    camera.updateViewport(x, y, w, h);
                    break;
                case egret3d.CameraType.perspective:
                    this._distance -= value;
                    this._distance = Math.max(this._minDistance, Math.min(this._maxDistance, this._distance));
                    break;
            }
        };
        HoverController.prototype.mouseUp = function (m) {
            switch (m.mouseCode) {
                case egret3d.MouseCode.Mouse_Left:
                    this._mouseDown = false;
                    break;
                case egret3d.MouseCode.Mouse_Right:
                    this._mouseRightDown = false;
                    break;
            }
        };
        HoverController.prototype.mouseDown = function (m) {
            switch (m.mouseCode) {
                case egret3d.MouseCode.Mouse_Left:
                    this._mouseDown = true;
                    break;
                case egret3d.MouseCode.Mouse_Right:
                    this._mouseRightDown = true;
                    break;
            }
        };
        HoverController.prototype.touchMove = function (t) {
            if (t.targetTouches.length == 1) {
                this.mouseMove(null);
            }
            else {
                this.mouseWheel(null);
            }
        };
        HoverController.prototype.touchUp = function (m) {
            this._mouseDown = false;
        };
        HoverController.prototype.touchDown = function (m) {
            this._mouseDown = true;
        };
        HoverController.prototype.keyDown = function (key) {
            switch (key.keyCode) {
                case egret3d.KeyCode.Key_W:
                    this._keyArray[0] = true;
                    break;
                case egret3d.KeyCode.Key_A:
                    this._keyArray[1] = true;
                    break;
                case egret3d.KeyCode.Key_S:
                    this._keyArray[2] = true;
                    break;
                case egret3d.KeyCode.Key_D:
                    this._keyArray[3] = true;
                    break;
            }
        };
        HoverController.prototype.keyUp = function (key) {
            switch (key.keyCode) {
                case egret3d.KeyCode.Key_W:
                    this._keyArray[0] = false;
                    break;
                case egret3d.KeyCode.Key_A:
                    this._keyArray[1] = false;
                    break;
                case egret3d.KeyCode.Key_S:
                    this._keyArray[2] = false;
                    break;
                case egret3d.KeyCode.Key_D:
                    this._keyArray[3] = false;
                    break;
            }
        };
        Object.defineProperty(HoverController.prototype, "lookAtPosition", {
            /**
            * @language zh_CN
            * 返回目标的位置
            *
            * @returns 目标的位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._lookAtPosition;
            },
            /**
            * @language zh_CN
            * 设置目标坐标
            *
            * @param val 摄像机看向的目标点
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                this._lookAtPosition = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "steps", {
            /**
            * @private
            */
            get: function () {
                return this._steps;
            },
            /**
            * @private
            */
            set: function (val) {
                val = (val < 1) ? 1 : val;
                if (this._steps == val)
                    return;
                this._steps = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "panAngle", {
            /**
            * @language zh_CN
            * 得到相机y轴旋转角度
            * @returns 相机y轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._panAngle;
            },
            /**
            * @language zh_CN
            * 设置相机y轴旋转
            * @param val 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                val = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, val));
                if (this._panAngle == val)
                    return;
                this._panAngle = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "tiltAngle", {
            /**
            * @language zh_CN
            * 得到相机x轴旋转角度
            * @returns 相机x轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._tiltAngle;
            },
            /**
            * @language zh_CN
            * 设置相机x轴旋转
            * @param val 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                val = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, val));
                if (this._tiltAngle == val)
                    return;
                this._tiltAngle = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "distance", {
            /**
            * @language zh_CN
            * 得到目标和相机的距离
            * @returns 目标和相机的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._distance;
            },
            /**
            * @language zh_CN
            * 设置目标和相机的距离
            * @param val 距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._distance == val)
                    return;
                this._distance = this._distance = Math.max(this._minDistance, Math.min(this._maxDistance, val));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "minPanAngle", {
            /**
            * @language zh_CN
            * 得到相机最小y轴旋转角度
            * @returns 相机最小x轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._minPanAngle;
            },
            /**
            * @language zh_CN
            * 设置相机最小y轴旋转角度
            * @param val 相机最小x轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._minPanAngle == val)
                    return;
                this._minPanAngle = val;
                this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "maxPanAngle", {
            /**
            * @language zh_CN
            * 得到相机最大y轴旋转角度
            * @returns 相机最大y轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._maxPanAngle;
            },
            /**
            * @language zh_CN
            * 设置相机最大y轴旋转角度
            * @param val 相机最大y轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._maxPanAngle == val)
                    return;
                this._maxPanAngle = val;
                this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "minTiltAngle", {
            /**
            * @language zh_CN
            * 得到相机最小x轴旋转角度
            * @returns 相机最小x轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._minTiltAngle;
            },
            /**
            * @language zh_CN
            * 设置相机最小x轴旋转角度
            * @param val 相机最小x轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._minTiltAngle == val)
                    return;
                this._minTiltAngle = val;
                this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "maxTiltAngle", {
            /**
            * @language zh_CN
            * 得到相机最大x轴旋转角度
            * @returns 相机最大x轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._maxTiltAngle;
            },
            /**
            * @language zh_CN
            * 设置相机最大x轴旋转角度
            * @param val 相机最大x轴旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._maxTiltAngle == val)
                    return;
                this._maxTiltAngle = val;
                this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "maxDistance", {
            /**
            * @language zh_CN
            * 得到相机和目标最大的距离
            * @returns 相机和目标最大的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._maxDistance;
            },
            /**
            * @language zh_CN
            * 设置相机和目标最大的距离
            * @param val 相机和目标最大的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._maxDistance == val)
                    return;
                this._maxDistance = val;
                this._distance = Math.max(this._minDistance, Math.min(this._maxDistance, this._distance));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "minDistance", {
            /**
            * @language zh_CN
            * 得到相机和目标最小的距离
            * @returns 相机和目标最小的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._maxDistance;
            },
            /**
            * @language zh_CN
            * 设置相机和目标最小的距离
            * @param val 相机和目标最小的距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._minDistance == val)
                    return;
                this._minDistance = val;
                this._distance = Math.max(this._minDistance, Math.min(this._maxDistance, this._distance));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "yFactor", {
            /**
            * @private
            */
            get: function () {
                return this._yFactor;
            },
            /**
            * @private
            */
            set: function (val) {
                if (this._yFactor == val)
                    return;
                this._yFactor = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "wrapPanAngle", {
            /**
            * @private
            */
            get: function () {
                return this._wrapPanAngle;
            },
            /**
            * @private
            */
            set: function (val) {
                if (this._wrapPanAngle == val)
                    return;
                this._wrapPanAngle = val;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 控制器数据更新
        * @param interpolate
        * @version Egret 3.0
        * @platform Web,Native
        */
        HoverController.prototype.update = function (interpolate) {
            if (interpolate === void 0) { interpolate = true; }
            if (this._tiltAngle != this._currentTiltAngle || this._panAngle != this._currentPanAngle) {
                if (this._wrapPanAngle) {
                    if (this._panAngle < 0)
                        this._panAngle = (this._panAngle % 360) + 360;
                    else
                        this._panAngle = this._panAngle % 360;
                    if (this._panAngle - this._currentPanAngle < -180)
                        this._currentPanAngle -= 360;
                    else if (this._panAngle - this._currentPanAngle > 180)
                        this._currentPanAngle += 360;
                }
                if (interpolate) {
                    this._currentTiltAngle += (this._tiltAngle - this._currentTiltAngle) / (this.steps + 1);
                    this._currentPanAngle += (this._panAngle - this._currentPanAngle) / (this.steps + 1);
                }
                else {
                    this._currentPanAngle = this._panAngle;
                    this._currentTiltAngle = this._tiltAngle;
                }
                //snap coords if angle differences are close
                if ((Math.abs(this._tiltAngle - this._currentTiltAngle) < 0.01) && (Math.abs(this._panAngle - this._currentPanAngle) < 0.01)) {
                    this._currentTiltAngle = this._tiltAngle;
                    this._currentPanAngle = this._panAngle;
                }
            }
            var pos = (this._lookAtObject) ? this._lookAtObject.position : (this._lookAtPosition) ? this._lookAtPosition : this._origin;
            var p = new egret3d.Vector3D();
            p.x = pos.x + this.distance * Math.sin(this._currentPanAngle * egret3d.MathUtil.DEGREES_TO_RADIANS) * Math.cos(this._currentTiltAngle * egret3d.MathUtil.DEGREES_TO_RADIANS);
            p.z = pos.z + this.distance * Math.cos(this._currentPanAngle * egret3d.MathUtil.DEGREES_TO_RADIANS) * Math.cos(this._currentTiltAngle * egret3d.MathUtil.DEGREES_TO_RADIANS);
            p.y = pos.y + this.distance * Math.sin(this._currentTiltAngle * egret3d.MathUtil.DEGREES_TO_RADIANS) * this.yFactor;
            if (this._target) {
                if (this._lookAtPosition)
                    this._target.lookAt(p, this._lookAtPosition);
            }
        };
        return HoverController;
    }(egret3d.ControllerBase));
    egret3d.HoverController = HoverController;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.LookAtController
    * @classdesc
    * 自由 摄像机控制器 。</p>
    * 指定摄像机看向的目标对象。</p>
    * 1.按下鼠标左键并移动鼠标可以使摄像机绕着目标进行旋转。</p>
    * 2.按下键盘的(w s a d) 可以摄像机(上 下 左 右)移动。</p>
    * 3.滑动鼠标滚轮可以控制摄像机的视距。</p>
    *
    * @version Egret 3.0
    * @platform Web,Native
    */
    var FreeController = (function (_super) {
        __extends(FreeController, _super);
        function FreeController(target) {
            if (target === void 0) { target = null; }
            _super.call(this, target, null);
            this.dir = new egret3d.Vector3D();
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_MOVE, this.mouseMove, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_WHEEL, this.mouseWheel, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_MOVE, this.touchMove, this);
        }
        FreeController.prototype.touchMove = function (t) {
            if (t.targetTouches.length == 1) {
                this.mouseMove(null);
            }
            else {
                this.mouseWheel(null);
            }
        };
        FreeController.prototype.mouseWheel = function (m) {
            if (!this._target) {
                return;
            }
            var camera = this._target;
            if (!camera) {
                return;
            }
            var value = egret3d.Input.wheelDelta * 0.1;
            var viewPort = camera.viewPort;
            switch (camera.cameraType) {
                case egret3d.CameraType.orthogonal:
                    var w = viewPort.width - value;
                    var h = viewPort.height - value;
                    camera.updateViewport(0, 0, w, h);
                    break;
                case egret3d.CameraType.orthogonalToCenter:
                    var x = viewPort.x - value;
                    var y = viewPort.y - value;
                    var w = viewPort.width - value;
                    var h = viewPort.height - value;
                    camera.updateViewport(x, y, w, h);
                    break;
                case egret3d.CameraType.perspective:
                    this.target.globalOrientation.transformVector(egret3d.Vector3D.Z_AXIS, this.dir);
                    this.dir.normalize();
                    FreeController.v0.copyFrom(this.dir);
                    FreeController.v0.scaleBy(value);
                    this.target.globalPosition.add(FreeController.v0, FreeController.v0);
                    this.target.globalPosition = FreeController.v0;
                    break;
            }
        };
        FreeController.prototype.mouseMove = function (m) {
            if (egret3d.Input.getMousePress(egret3d.MouseCode.Mouse_Left)) {
                this.target.rotationY += egret3d.Input.mouseOffsetX;
                this.target.rotationX += egret3d.Input.mouseOffsetY;
            }
        };
        /**
        * @language zh_CN
        * 控制器数据更新
        * @param delay 帧间隔
        * @param time 当前时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        FreeController.prototype.update = function (delay, time) {
            if (delay === void 0) { delay = 16.6; }
            if (time === void 0) { time = 0; }
            if (!this.target) {
                return;
            }
            var speed = this.speed * delay / 1000;
            if (egret3d.Input.getKeyPress(egret3d.KeyCode.Key_W)) {
                this.target.globalOrientation.transformVector(egret3d.Vector3D.Z_AXIS, this.dir);
                this.dir.normalize();
                FreeController.v0.copyFrom(this.dir);
                FreeController.v0.scaleBy(speed);
                this.target.globalPosition.add(FreeController.v0, FreeController.v0);
                this.target.globalPosition = FreeController.v0;
            }
            if (egret3d.Input.getKeyPress(egret3d.KeyCode.Key_S)) {
                this.target.globalOrientation.transformVector(egret3d.Vector3D.Z_AXIS, this.dir);
                this.dir.normalize();
                FreeController.v0.copyFrom(this.dir);
                FreeController.v0.scaleBy(speed);
                this.target.globalPosition.subtract(FreeController.v0, FreeController.v0);
                this.target.globalPosition = FreeController.v0;
            }
            if (egret3d.Input.getKeyPress(egret3d.KeyCode.Key_A)) {
                this.target.globalOrientation.transformVector(egret3d.Vector3D.X_AXIS, this.dir);
                this.dir.normalize();
                FreeController.v0.copyFrom(this.dir);
                FreeController.v0.scaleBy(speed);
                this.target.globalPosition.subtract(FreeController.v0, FreeController.v0);
                this.target.globalPosition = FreeController.v0;
            }
            if (egret3d.Input.getKeyPress(egret3d.KeyCode.Key_D)) {
                this.target.globalOrientation.transformVector(egret3d.Vector3D.X_AXIS, this.dir);
                this.dir.normalize();
                FreeController.v0.copyFrom(this.dir);
                FreeController.v0.scaleBy(speed);
                this.target.globalPosition.add(FreeController.v0, FreeController.v0);
                this.target.globalPosition = FreeController.v0;
            }
        };
        FreeController.v0 = new egret3d.Vector3D();
        return FreeController;
    }(egret3d.ControllerBase));
    egret3d.FreeController = FreeController;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.HoverController
    * @classdesc
    * 摄像机控制器 ,实现摄像机平滑移动
    * 指定摄像机看向的目标对象
    * 1.按下鼠标左键并移动鼠标(或手机手指滑动)可以使摄像机绕着目标进行旋转.
    * 2.滑动鼠标滚轮(或双指滑动)可以控制摄像机的视距.
    *
    * 示例:
    * @includeExample controller/ctl/HoverController.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PanController = (function (_super) {
        __extends(PanController, _super);
        /**
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        function PanController(view, targe) {
            _super.call(this, null, null);
            this._step = 5.0;
            this._panAngle = 0;
            this._down = false;
            this._startVec3D = new egret3d.Vector3D();
            this._endVec3D = new egret3d.Vector3D();
            this._currentVec3D = new egret3d.Vector3D();
            this._fixinterpolate = new egret3d.Vector3D();
            this._fix = new egret3d.Vector3D();
            this._final = new egret3d.Vector3D();
            this._rotaAngle = new egret3d.Vector3D();
            this._looat = new egret3d.Vector3D();
            this._dir = new egret3d.Vector3D();
            this._up = new egret3d.Vector3D();
            this._pos = new egret3d.Vector3D();
            this._maxFov = 90;
            this._minFov = 30;
            this._calQua = new egret3d.Quaternion();
            this._useCompass = false;
            this._gyroCtrlloer = new egret3d.OrientationController();
            this._gyroCtrlloer.start();
            this._target = targe;
            this._view = view;
            this._currentVec3D.z = this._final.z = view.camera3D.fieldOfView;
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_MOVE, this.mouseMove, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_WHEEL, this.mouseWheel, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.mouseUp, this);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_DOWN, this.mouseDown, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_END, this.touchUp, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_START, this.touchDown, this);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_MOVE, this.touchMove, this);
            this.useCompass(true);
        }
        PanController.prototype.mouseDown = function (e) {
            this._down = true;
        };
        PanController.prototype.mouseUp = function (e) {
            this._down = false;
        };
        PanController.prototype.mouseMove = function (e) {
            if (this._down) {
                //angle
                this._final.x -= egret3d.Input.mouseOffsetX / (this._step * this._step);
                this._final.y -= egret3d.Input.mouseOffsetY / (this._step * this._step);
            }
            this.useCompass(false);
        };
        PanController.prototype.touchDown = function (e) {
            this._down = true;
        };
        PanController.prototype.touchUp = function (e) {
            this._down = false;
        };
        PanController.prototype.touchMove = function (e) {
            if (e.targetTouches.length == 1) {
                if (this._down) {
                    //angle
                    this._final.x -= egret3d.Input.mouseOffsetX / (this._step * this._step);
                    this._final.y -= egret3d.Input.mouseOffsetY / (this._step * this._step);
                }
            }
            else {
                this.mouseWheel(null);
            }
            this.useCompass(false);
        };
        PanController.prototype.mouseWheel = function (e) {
            this._final.z -= egret3d.Input.wheelDelta / (this._step * this._step);
        };
        PanController.prototype.useCompass = function (flag) {
            if (flag && flag != this._useCompass) {
                this._useCompass = true;
                this._target.rotationX = 270;
            }
            else if (!flag && flag != this._useCompass) {
                this._useCompass = false;
                this._target.rotationX = 0;
            }
        };
        /**
        * @language zh_CN
        * 控制器数据更新
        * @param interpolate
        * @version Egret 3.0
        * @platform Web,Native
        */
        PanController.prototype.update = function (interpolate) {
            if (interpolate === void 0) { interpolate = true; }
            if (this._useCompass) {
                this._gyroCtrlloer.update(this._view);
            }
            else {
                this._fix.x = this._final.x - this._currentVec3D.y;
                this._fix.y = this._final.y - this._currentVec3D.x;
                this._fix.z = this._final.z - this._currentVec3D.z;
                this._currentVec3D.y += this._fix.x / this._step;
                this._currentVec3D.x += this._fix.y / this._step;
                //this._target.rotationX = this._currentVec3D.x;
                //this._target.childs[0].rotationY = this._currentVec3D.y;
                this._rotaAngle.x = this._currentVec3D.x;
                this._rotaAngle.y = this._currentVec3D.y;
                this._calQua.fromEulerAngles(this._rotaAngle.x, this._rotaAngle.y, 0);
                this._calQua.transformVector(egret3d.Vector3D.Z_AXIS, this._dir);
                this._calQua.fromEulerAngles(this._rotaAngle.x, this._rotaAngle.y, this._rotaAngle.z);
                this._calQua.transformVector(egret3d.Vector3D.Y_AXIS, this._up);
                this._view.camera3D.lookAt(this._pos, this._dir, this._up);
                //this._view.camera3D.lookAt(new Vector3D(), new Vector3D(0, 0, 10), Vector3D.Y_AXIS);
                var tmp = this._currentVec3D.z + this._fix.z / this._step;
                ;
                if (this._maxFov > tmp && tmp > this._minFov)
                    this._currentVec3D.z = tmp;
                else
                    this._final.z = this._currentVec3D.z;
                this._view.camera3D.fieldOfView = this._currentVec3D.z;
            }
        };
        return PanController;
    }(egret3d.ControllerBase));
    egret3d.PanController = PanController;
})(egret3d || (egret3d = {}));
//this._fix.x = this._final.x - this._view.camera3D.globalRotationY;
//this._fix.y = this._final.y - this._view.camera3D.globalRotationX;
//this._view.camera3D.globalRotationY += this._fix.x / this._step;
//this._view.camera3D.globalRotationX += this._fix.y / this._step; 
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.CameraAnimationController
    * @classdesc
    * 摄像机动画控制器。
    * 每个摄像机动画绑定一个摄像机，控制摄像机的行为
    * 可以更换绑定的摄像机
    * @see egret3d.Camera3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CameraAnimationController = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @param camera 需要一个摄像机对象来创建摄像机动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        function CameraAnimationController(camera) {
            if (camera === void 0) { camera = null; }
            /**
            * @language zh_CN
            * 相机动画每帧数据列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cameraAnimationFrames = [];
            this._playing = false;
            this._playTime = 0;
            this._currentFrameIndex = 0;
            this._loop = true;
            this._smooth = true;
            this._cameraAnimationFrame = new CameraAnimationFrame();
            this._event = new egret3d.Event3D();
            this._quatCurrentFrame = new egret3d.Quaternion();
            this._quatnNextFrame = new egret3d.Quaternion();
            this._quatn = new egret3d.Quaternion();
            this._camera = camera;
            this._cameraAnimationFrame.fov = 45;
            this._cameraAnimationFrame.rotation = new egret3d.Vector3D();
            this._cameraAnimationFrame.translation = new egret3d.Vector3D();
        }
        /**
        * @language zh_CN
        * 绑定动画控制的相机
        * @param camera
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraAnimationController.prototype.bindCamera = function (camera) {
            this._camera = camera;
        };
        /**
        * @language zh_CN
        * 播放相机动画 是否循环
        * @param isLoop 是否循环播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraAnimationController.prototype.play = function (isLoop) {
            if (this.cameraAnimationFrames.length <= 0)
                return;
            this._loop = isLoop;
            this._playTime = 0;
            this._camera.isController = false;
            this._playing = true;
        };
        /**
        * @language zh_CN
        * 停止播放相机动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraAnimationController.prototype.stop = function () {
            this._camera.isController = true;
            this._playing = false;
        };
        /**
        * @private
        * @language zh_CN
        * 数据更新
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraAnimationController.prototype.update = function (time, delay) {
            if (!this._playing)
                return;
            this._playTime += delay * 5;
            var Tnow = this._playTime % ((this.cameraAnimationFrames[this.cameraAnimationFrames.length - 1].time - this.cameraAnimationFrames[0].time) + (160));
            var currentFrameIndex = Math.floor(Tnow / (160)) % this.cameraAnimationFrames.length;
            if (this._currentFrameIndex > currentFrameIndex) {
                if (!this._loop) {
                    this._playing = false;
                    this._camera.isController = true;
                }
                if (this._camera) {
                    this._event.eventType = CameraAnimationController.EVENT_CAMERA_COMPLETE;
                    this._camera.dispatchEvent(this._event);
                }
            }
            this._currentFrameIndex = currentFrameIndex;
            var currentFrame = this.cameraAnimationFrames[currentFrameIndex];
            if (this._smooth) {
                var nextFrameIndex = (currentFrameIndex + 1) % this.cameraAnimationFrames.length;
                var nextFrame = this.cameraAnimationFrames[nextFrameIndex];
                var t = (Tnow - currentFrame.time) / Math.abs(nextFrame.time - currentFrame.time);
                ///(v1.x - v0.x) * t + v0.x;
                this._cameraAnimationFrame.fov = (nextFrame.fov - currentFrame.fov) * t + currentFrame.fov;
                this._quatCurrentFrame.fromEulerAngles(currentFrame.rotation.x, currentFrame.rotation.y, currentFrame.rotation.z);
                this._quatnNextFrame.fromEulerAngles(nextFrame.rotation.x, nextFrame.rotation.y, nextFrame.rotation.z);
                this._quatn.lerp(this._quatCurrentFrame, this._quatnNextFrame, t);
                this._quatn.toEulerAngles(this._cameraAnimationFrame.rotation);
                this._cameraAnimationFrame.translation.lerp(currentFrame.translation, nextFrame.translation, t);
            }
            else {
                this._cameraAnimationFrame.fov = currentFrame.fov;
                this._cameraAnimationFrame.rotation.copyFrom(currentFrame.rotation);
                this._cameraAnimationFrame.translation.copyFrom(currentFrame.translation);
            }
            //this._camera.fieldOfView = this._cameraAnimationFrame.fov;
            this._camera.rotation = this._cameraAnimationFrame.rotation;
            this._camera.position = this._cameraAnimationFrame.translation;
        };
        /**
        * @language zh_CN
        * 动画播放完一个周期的事件
        */
        CameraAnimationController.EVENT_CAMERA_COMPLETE = "event_camera_complete";
        return CameraAnimationController;
    }());
    egret3d.CameraAnimationController = CameraAnimationController;
    /**
    * @class egret3d.CameraAnimationFrame
    * @private
    * @classdesc
    * 摄像机动画每帧数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CameraAnimationFrame = (function () {
        function CameraAnimationFrame() {
        }
        return CameraAnimationFrame;
    }());
    egret3d.CameraAnimationFrame = CameraAnimationFrame;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var Reference = (function () {
        function Reference() {
            this.count = 0;
        }
        Reference.prototype.incRef = function () {
            this.count++;
        };
        Reference.prototype.decRef = function () {
            if (this.count - 1 >= 0) {
                this.count--;
            }
        };
        Object.defineProperty(Reference.prototype, "isDispose", {
            get: function () {
                return this.count <= 0;
            },
            enumerable: true,
            configurable: true
        });
        return Reference;
    }());
    egret3d.Reference = Reference;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Context3DProxy
    * @classdesc
    * Context3DProxy 类提供了用于呈现几何定义图形的上下文。</p>
    *
    * 渲染上下文包括一个绘图表面及其关联的资源和状态。</p>
    * Context3DProxy 渲染上下文是一个可编程的管道，基于OpenGL ES 2.0规范。</p>
    * 您可以通过提供适当的顶点和像素片段程序来创建 2D/3D渲染器，不同的平台有不同的硬件限制，对于移动端限制要求比较大。</p>
    * 一个canvas 只能申请一个Context3DProxy。</p>
    *
    * @see egret3d.Program3D
    * @see egret3d.IndexBuffer3D
    * @see egret3d.VertexBuffer3D
    * @see egret3d.Texture2D
    * @see egret3d.Shader
    * @see egret3d.CubeTexture
    * @includeExample core/context/Context3DProxy.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Context3DProxy = (function () {
        function Context3DProxy() {
            /**
            * @language zh_CN
            * @private
            */
            this.version = "3.2.2";
            /**
            * @language zh_CN
            * @private
            * 渲染3D 的驱动设备是否存在，或者丢失。
            * 一般情况下，当切换程序的时候，设备将会丢失，
            * 这个时候就需要快速重新申请设备，并将相应的资源buffer，texture重新提交至显卡
            */
            this.isLost = false;
            //-------cache-------
            this.DEPTH_TEST = false;
            this.CULL_FACE = false;
            this.BLEND = false;
            this.blend_Factors_src = -1;
            this.blend_Factors_dst = -1;
            this.cullingMode = -1;
            this.depthCompareMode = -1;
            this.cacheVertexPoint = [];
            this.cacheVertexFormat = 0;
        }
        //--------------
        /**
        * @private
        * @language zh_CN
        * reset
        * 重置缓存的状态
        */
        Context3DProxy.prototype.reset = function () {
            this.DEPTH_TEST = false;
            this.CULL_FACE = false;
            this.BLEND = false;
            this.blend_Factors_src = -1;
            this.blend_Factors_dst = -1;
            this.cullingMode = -1;
            this.depthCompareMode = -1;
            this.program = undefined;
            this.programChange = undefined;
        };
        /**
        * @private
        * @language zh_CN
        * get GPU Context3DProxy
        * 注册并初始化相关 GPU 参数配置信息
        * 用于设置显卡的相关参数
        */
        Context3DProxy.prototype.register = function () {
            var extension;
            Context3DProxy.gl.getExtension('WEBGL_depth_texture') || Context3DProxy.gl.getExtension('MOZ_WEBGL_depth_texture') || Context3DProxy.gl.getExtension('WEBKIT_WEBGL_depth_texture');
            Context3DProxy.gl.getExtension('EXT_texture_filter_anisotropic') || Context3DProxy.gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || Context3DProxy.gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
            Context3DProxy.gl.getExtension('WEBGL_compressed_texture_pvrtc') || Context3DProxy.gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
            Context3DProxy.gl.getExtension('WEBGL_compressed_texture_etc1');
            Context3DProxy.gl.getExtension('OES_element_index_uint');
            Context3DProxy.gl.getExtension("OES_texture_float_linear");
            extension = Context3DProxy.gl.getExtension("OES_texture_float");
            //alert(extension);
            extension = Context3DProxy.gl.getExtension("OES_texture_half_float");
            //alert(extension);
            Context3DProxy.gl.getExtension("OES_texture_half_float_linear");
            Context3DProxy.gl.getExtension("OES_standard_derivatives");
            Context3DProxy.gl.getExtension("GL_OES_standard_derivatives");
            Context3DProxy.gl.getExtension("WEBGL_draw_buffers");
            Context3DProxy.gl.getExtension("WEBGL_depth_texture");
            Context3DProxy.gl.getExtension("WEBGL_lose_context");
            extension = Context3DProxy.gl.getExtension('WEBGL_compressed_texture_s3tc') || Context3DProxy.gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || Context3DProxy.gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
            if (extension) {
                egret3d.ContextConfig.ColorFormat_DXT1_RGB = extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                egret3d.ContextConfig.ColorFormat_DXT1_RGBA = extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                egret3d.ContextConfig.ColorFormat_DXT3_RGBA = extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                egret3d.ContextConfig.ColorFormat_DXT5_RGBA = extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
            //WEBGL_color_buffer_float
            //EXT_color_buffer_half_float
            //EXT_texture_filter_anisotropic
            //EXT_frag_depth
            //EXT_shader_texture_lod
            egret3d.ContextConfig.BLEND = Context3DProxy.gl.BLEND;
            egret3d.DrawMode.TRIANGLES = Context3DProxy.gl.TRIANGLES;
            egret3d.DrawMode.POINTS = Context3DProxy.gl.POINTS;
            egret3d.DrawMode.LINES = Context3DProxy.gl.LINES;
            egret3d.DrawMode.LINE_STRIP = Context3DProxy.gl.LINE_STRIP;
            egret3d.ContextConfig.FLOAT = Context3DProxy.gl.FLOAT;
            egret3d.ContextConfig.UNSIGNED_BYTE = Context3DProxy.gl.UNSIGNED_BYTE;
            egret3d.ContextConfig.VERTEX_SHADER = Context3DProxy.gl.VERTEX_SHADER;
            egret3d.ContextConfig.FRAGMENT_SHADER = Context3DProxy.gl.FRAGMENT_SHADER;
            egret3d.ContextConfig.FRONT = Context3DProxy.gl.FRONT;
            egret3d.ContextConfig.BACK = Context3DProxy.gl.BACK;
            egret3d.ContextConfig.FRONT_AND_BACK = Context3DProxy.gl.FRONT_AND_BACK;
            egret3d.ContextConfig.DEPTH_BUFFER_BIT = Context3DProxy.gl.DEPTH_BUFFER_BIT;
            egret3d.ContextConfig.ELEMENT_ARRAY_BUFFER = Context3DProxy.gl.ELEMENT_ARRAY_BUFFER;
            egret3d.ContextConfig.UNSIGNED_SHORT = Context3DProxy.gl.UNSIGNED_SHORT;
            egret3d.ContextConfig.NEAREST = Context3DProxy.gl.NEAREST;
            egret3d.ContextConfig.REPEAT = Context3DProxy.gl.REPEAT;
            egret3d.ContextConfig.ONE = Context3DProxy.gl.ONE;
            egret3d.ContextConfig.ZERO = Context3DProxy.gl.ZERO;
            egret3d.ContextConfig.SRC_ALPHA = Context3DProxy.gl.SRC_ALPHA;
            egret3d.ContextConfig.ONE_MINUS_SRC_ALPHA = Context3DProxy.gl.ONE_MINUS_SRC_ALPHA;
            egret3d.ContextConfig.SRC_COLOR = Context3DProxy.gl.SRC_COLOR;
            egret3d.ContextConfig.ONE_MINUS_SRC_COLOR = Context3DProxy.gl.ONE_MINUS_SRC_COLOR;
            ;
            egret3d.ContextConfig.ColorFormat_RGB565 = Context3DProxy.gl.RGB565;
            egret3d.ContextConfig.ColorFormat_RGBA5551 = Context3DProxy.gl.RGB5_A1;
            egret3d.ContextConfig.ColorFormat_RGBA4444 = Context3DProxy.gl.RGBA4;
            egret3d.ContextConfig.ColorFormat_RGBA8888 = Context3DProxy.gl.RGBA;
            egret3d.ContextConfig.ColorFormat_RGB888 = Context3DProxy.gl.RGB;
            egret3d.ContextConfig.DEPTH_TEST = Context3DProxy.gl.DEPTH_TEST;
            egret3d.ContextConfig.CULL_FACE = Context3DProxy.gl.CULL_FACE;
            egret3d.ContextConfig.BLEND = Context3DProxy.gl.BLEND;
            egret3d.ContextConfig.LEQUAL = Context3DProxy.gl.LEQUAL;
            egret3d.ContextSamplerType.TEXTURE_0 = Context3DProxy.gl.TEXTURE0;
            egret3d.ContextSamplerType.TEXTURE_1 = Context3DProxy.gl.TEXTURE1;
            egret3d.ContextSamplerType.TEXTURE_2 = Context3DProxy.gl.TEXTURE2;
            egret3d.ContextSamplerType.TEXTURE_3 = Context3DProxy.gl.TEXTURE3;
            egret3d.ContextSamplerType.TEXTURE_4 = Context3DProxy.gl.TEXTURE4;
            egret3d.ContextSamplerType.TEXTURE_5 = Context3DProxy.gl.TEXTURE5;
            egret3d.ContextSamplerType.TEXTURE_6 = Context3DProxy.gl.TEXTURE6;
            egret3d.ContextSamplerType.TEXTURE_7 = Context3DProxy.gl.TEXTURE7;
            egret3d.ContextSamplerType.TEXTURE_8 = Context3DProxy.gl.TEXTURE8;
            console.log("requst GPU Config", Context3DProxy.gl);
            egret3d.ShaderPool.register(this);
        };
        //public creatBackBuffer(x: number, y: number, width: number, height: number) {
        //    this._canvas.style.left = x.toString();
        //    this._canvas.style.top = y.toString();
        //    this._canvas.width = width;
        //    this._canvas.height = height;
        //    this.viewPort(x, y, width, height);
        //}
        /**
        * @language zh_CN
        * 视口设置定义，用来确定我们定义的视口在canvas中的所在位置
        * @param x 屏幕坐标 X
        * @param y 屏幕坐标 Y
        * @param width  宽度
        * @param height 高度
        * @see egret3d.Egret3DCanvas
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.viewPort = function (x, y, width, height) {
            Context3DProxy.gl.viewport(x, egret3d.ContextConfig.canvasRectangle.height - height - y, width, height);
        };
        /**
        * @language zh_CN
        * 创建 显卡程序
        * @param vsShader
        * @param fsShader
        * @returns Program3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.creatProgram = function (vsShader, fsShader) {
            var shaderProgram = Context3DProxy.gl.createProgram();
            Context3DProxy.gl.attachShader(shaderProgram, vsShader.shader);
            Context3DProxy.gl.attachShader(shaderProgram, fsShader.shader);
            Context3DProxy.gl.linkProgram(shaderProgram);
            var p = Context3DProxy.gl.getProgramParameter(shaderProgram, Context3DProxy.gl.LINK_STATUS);
            if (!p) {
                console.log("vsShader error" + Context3DProxy.gl.getShaderInfoLog(vsShader.shader));
                console.log("fsShader error" + Context3DProxy.gl.getShaderInfoLog(fsShader.shader));
                console.log("program error" + Context3DProxy.gl.getProgramInfoLog(shaderProgram));
            }
            var program = new egret3d.Program3D(shaderProgram);
            return program;
        };
        /**
        * @language zh_CN
        * 创建 顶点索引流
        * @param indexData
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.creatIndexBuffer = function (indexData) {
            var indexBuffer = Context3DProxy.gl.createBuffer();
            Context3DProxy.gl.bindBuffer(Context3DProxy.gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            Context3DProxy.gl.bufferData(Context3DProxy.gl.ELEMENT_ARRAY_BUFFER, indexData, Context3DProxy.gl.STATIC_DRAW);
            var ib = new egret3d.IndexBuffer3D(indexBuffer);
            ib.arrayBuffer = indexData;
            return ib;
        };
        /**
        * @language zh_CN
        * 提交索引数据
        * @param indexBuffer3D 索引buffer
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uploadIndexBuffer = function (indexBuffer3D) {
            Context3DProxy.gl.bindBuffer(Context3DProxy.gl.ELEMENT_ARRAY_BUFFER, indexBuffer3D.buffer);
            Context3DProxy.gl.bufferData(Context3DProxy.gl.ELEMENT_ARRAY_BUFFER, indexBuffer3D.arrayBuffer, Context3DProxy.gl.DYNAMIC_DRAW);
        };
        /**
        * @language zh_CN
        * 创建 顶点数据流
        * @param vertexData
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.creatVertexBuffer = function (vertexData, dawType) {
            if (dawType === void 0) { dawType = Context3DProxy.gl.STATIC_DRAW; }
            var vertexBuffer = Context3DProxy.gl.createBuffer();
            Context3DProxy.gl.bindBuffer(Context3DProxy.gl.ARRAY_BUFFER, vertexBuffer);
            Context3DProxy.gl.bufferData(Context3DProxy.gl.ARRAY_BUFFER, vertexData, dawType);
            var vb = new egret3d.VertexBuffer3D(vertexBuffer);
            vb.arrayBuffer = vertexData;
            // vertexData.splice(0, vertexData.length);
            //vertexData.splice(0, vertexData.length);
            return vb;
        };
        /**
        * @language zh_CN
        * 提交顶点数据
        * @param vertexBuffer3D 顶点buffer
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uploadVertexBuffer = function (vertexBuffer3D) {
            Context3DProxy.gl.bindBuffer(Context3DProxy.gl.ARRAY_BUFFER, vertexBuffer3D.buffer);
            Context3DProxy.gl.bufferData(Context3DProxy.gl.ARRAY_BUFFER, vertexBuffer3D.arrayBuffer, Context3DProxy.gl.DYNAMIC_DRAW);
        };
        /**
        * @language zh_CN
        * 设置2D纹理状态 来确定贴图的采样方式
        * @param target 指定活动纹理单元的目标纹理
        * @param pname 指定单值纹理参数的标记名
        * @param param 指定 pname 的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.texParameteri = function (target, pname, param) {
            Context3DProxy.gl.texParameteri(target, pname, param);
        };
        /**
        * @language zh_CN
        * 提交2D纹理
        * @param mipLevel
        * @param texture
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.upLoadTextureData = function (mipLevel, texture) {
            Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_2D, texture.texture2D.textureBuffer);
            if (texture.texture2D.internalFormat == egret3d.InternalFormat.ImageData) {
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_2D, 0, Context3DProxy.gl.RGBA, Context3DProxy.gl.RGBA, texture.texture2D.dataFormat, texture.texture2D.imageData);
            }
            else if (texture.texture2D.internalFormat == egret3d.InternalFormat.CompressData) {
                this.upLoadCompressedTexture2D(mipLevel, texture.texture2D);
            }
            else if (texture.texture2D.internalFormat == egret3d.InternalFormat.PixelArray) {
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_2D, mipLevel, texture.texture2D.colorFormat, texture.texture2D.mimapData[mipLevel].width, texture.texture2D.mimapData[mipLevel].height, texture.texture2D.border, texture.texture2D.colorFormat, texture.texture2D.dataFormat, texture.texture2D.mimapData[mipLevel].data);
            }
            if (texture.useMipmap)
                Context3DProxy.gl.generateMipmap(Context3DProxy.gl.TEXTURE_2D);
            //texture.activeState( this );
        };
        /**
        * @language zh_CN
        * 提交2D压缩纹理，用硬件来解析dds贴图
        * @param mipLevel
        * @param texture
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.upLoadCompressedTexture2D = function (mipLevel, texture) {
            Context3DProxy.gl.compressedTexImage2D(Context3DProxy.gl.TEXTURE_2D, mipLevel, texture.colorFormat, texture.mimapData[mipLevel].width, texture.mimapData[mipLevel].height, texture.border, texture.mimapData[mipLevel].data);
        };
        /**
        * @language zh_CN
        * 创建 2维贴图 向显卡提交buffer申请 并创建Texture2D对象
        * @returns 创建的Texture2D对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.creatTexture = function () {
            return Context3DProxy.gl.createTexture();
        };
        ///**
        //* @language zh_CN
        //* 创建 Cube贴图 向显卡提交buffer申请 并创建Texture3D对象
        //* @version Egret 3.0
        //* @platform Web,Native
        //*/
        //public creatCubeTexture(): ContextTexture3D {
        //    var texture: ContextTexture3D = new ContextTexture3D();
        //    texture.texture = Context3DProxy.gl.createTexture();
        //    return texture;
        //}
        /**
        * @language zh_CN
        * @private
        * @param tex
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uploadCubetexture = function (tex) {
            /// 创建纹理并绑定纹理数据
            Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_CUBE_MAP, tex.texture);
            if (tex.image_right.mimapData && tex.image_right.mimapData.length > 0)
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, Context3DProxy.gl.RGB, tex.image_right.mimapData[0].width, tex.image_right.mimapData[0].height, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_right.mimapData[0].data);
            else
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_right.imageData);
            if (tex.image_left.mimapData && tex.image_left.mimapData.length > 0)
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, Context3DProxy.gl.RGB, tex.image_right.mimapData[0].width, tex.image_right.mimapData[0].height, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_right.mimapData[0].data);
            else
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_left.imageData);
            if (tex.image_left.mimapData && tex.image_left.mimapData.length > 0)
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, Context3DProxy.gl.RGB, tex.image_up.mimapData[0].width, tex.image_up.mimapData[0].height, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_up.mimapData[0].data);
            else
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_up.imageData);
            if (tex.image_left.mimapData && tex.image_left.mimapData.length > 0)
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, Context3DProxy.gl.RGB, tex.image_down.mimapData[0].width, tex.image_down.mimapData[0].height, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_down.mimapData[0].data);
            else
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_down.imageData);
            if (tex.image_left.mimapData && tex.image_left.mimapData.length > 0)
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, Context3DProxy.gl.RGB, tex.image_back.mimapData[0].width, tex.image_back.mimapData[0].height, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_back.mimapData[0].data);
            else
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_back.imageData);
            if (tex.image_left.mimapData && tex.image_left.mimapData.length > 0)
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, Context3DProxy.gl.RGB, tex.image_front.mimapData[0].width, tex.image_front.mimapData[0].height, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_front.mimapData[0].data);
            else
                Context3DProxy.gl.texImage2D(Context3DProxy.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, Context3DProxy.gl.RGB, Context3DProxy.gl.RGB, Context3DProxy.gl.UNSIGNED_BYTE, tex.image_front.imageData);
            ///Context3DProxy.gl.generateMipmap(Context3DProxy.gl.TEXTURE_CUBE_MAP);
            ///gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
            ///Context3DProxy.gl.texParameterf(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_MAG_FILTER, Context3DProxy.gl.LINEAR_MIPMAP_NEAREST);
            ///Context3DProxy.gl.texParameterf(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_MIN_FILTER, Context3DProxy.gl.LINEAR_MIPMAP_NEAREST);
            ///Context3DProxy.gl.texParameterf(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_WRAP_S, Context3DProxy.gl.CLAMP_TO_EDGE);
            ///Context3DProxy.gl.texParameterf(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_WRAP_T, Context3DProxy.gl.CLAMP_TO_EDGE);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_MAG_FILTER, Context3DProxy.gl.LINEAR);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_MIN_FILTER, Context3DProxy.gl.LINEAR);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_WRAP_S, Context3DProxy.gl.CLAMP_TO_EDGE);
            Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_CUBE_MAP, Context3DProxy.gl.TEXTURE_WRAP_T, Context3DProxy.gl.CLAMP_TO_EDGE);
            ///Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_MIN_FILTER, min_filter);
            ///Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_MAG_FILTER, mag_filter);
            ///Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_WRAP_S, wrap_u_filter);
            ///Context3DProxy.gl.texParameteri(Context3DProxy.gl.TEXTURE_2D, Context3DProxy.gl.TEXTURE_WRAP_T, wrap_v_filter);
        };
        /**
        * @language zh_CN
        * @private
        * @param width
        * @param height
        * @param format
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.createFramebuffer = function (width, height, format, needDepth) {
            var gl = Context3DProxy.gl;
            var renderbuffer = gl.createRenderbuffer();
            var colorTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, colorTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            //var depthTexture = gl.createTexture();
            //gl.bindTexture(gl.TEXTURE_2D, depthTexture);
            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            //gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, width, height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_BYTE, null);
            var framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTexture, 0);
            //gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
            var texture2D = new egret3d.ContextTexture2D();
            texture2D.width = width;
            texture2D.height = height;
            texture2D.textureBuffer = colorTexture;
            //texture2D.depthBuffer = depthTexture ;
            texture2D.frameBuffer = framebuffer;
            texture2D.renderbuffer = renderbuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            return texture2D;
        };
        /**
        * @language zh_CN
        * @private
        * @param texture
        * @param enableDepthAndStencil
        * @param surfaceSelector
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setRenderToTexture = function (texture, clean, enableDepthAndStencil, surfaceSelector) {
            if (clean === void 0) { clean = false; }
            if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
            if (surfaceSelector === void 0) { surfaceSelector = 0; }
            var gl = Context3DProxy.gl;
            Context3DProxy.gl.viewport(0, 0, texture.width, texture.height);
            Context3DProxy.gl.scissor(0, 0, texture.width, texture.height);
            gl.bindFramebuffer(Context3DProxy.gl.FRAMEBUFFER, texture.frameBuffer);
            gl.framebufferTexture2D(Context3DProxy.gl.FRAMEBUFFER, Context3DProxy.gl.COLOR_ATTACHMENT0, Context3DProxy.gl.TEXTURE_2D, texture.textureBuffer, 0);
            if (clean) {
                gl.clearColor(0, 0, 0, 0);
                gl.clear(Context3DProxy.gl.COLOR_BUFFER_BIT | Context3DProxy.gl.DEPTH_BUFFER_BIT);
            }
        };
        /**
        * @language zh_CN
        * 设置渲染缓冲为屏幕
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setRenderToBackBuffer = function () {
            Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_2D, null);
            Context3DProxy.gl.bindFramebuffer(Context3DProxy.gl.FRAMEBUFFER, null);
            // Context3DProxy.gl.bindRenderbuffer(Context3DProxy.gl.RENDERBUFFER, null);
        };
        /**
        * @language zh_CN
        * 向显卡请求创建顶点shader对象
        * @param source shader代码内容
        * @returns Shader shader对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.creatVertexShader = function (source) {
            var shader = Context3DProxy.gl.createShader(Context3DProxy.gl.VERTEX_SHADER);
            Context3DProxy.gl.shaderSource(shader, source);
            Context3DProxy.gl.compileShader(shader);
            var tmpShader = new egret3d.Shader(shader);
            tmpShader.id = (egret3d.Shader.ID_COUNT++).toString();
            return tmpShader;
        };
        /**
        * @language zh_CN
        * 向显卡请求创建片段shader对象
        * @param source shader代码内容
        * @returns Shader shader对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.creatFragmentShader = function (source) {
            var shader = Context3DProxy.gl.createShader(Context3DProxy.gl.FRAGMENT_SHADER);
            Context3DProxy.gl.shaderSource(shader, source);
            Context3DProxy.gl.compileShader(shader);
            var tmpShader = new egret3d.Shader(shader);
            tmpShader.id = (egret3d.Shader.ID_COUNT++).toString();
            return tmpShader;
        };
        /**
        * @language zh_CN
        * 清除渲染buffer
        * @param BUFFER_BIT
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.clear = function (BUFFER_BIT) {
            Context3DProxy.gl.clear(BUFFER_BIT);
        };
        /**
        * @language zh_CN
        * 清除渲染区域的颜色 深度
        * @param r 红色值
        * @param g 绿色值
        * @param b 蓝色值
        * @param a alpha值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.clearColor = function (r, g, b, a) {
            Context3DProxy.gl.clearColor(r, g, b, a);
        };
        ///**
        //* @language zh_CN
        //* 清除渲染区域的 深度
        //* @param depth
        //*/
        //public clearDepth(depth: number=1.0) {
        //    Context3DProxy.gl.clearDepth(depth);
        //    Context3DProxy.gl.clear(Context3DProxy.gl.DEPTH_BUFFER_BIT);
        //}
        /**
        * @language zh_CN
        * 清除渲染区域的 模板
        * @param stencil 模板值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.clearStencil = function (stencil) {
            Context3DProxy.gl.clearStencil(stencil);
        };
        /**
        * @language zh_CN
        * 使用显卡着色器
        * @param program 设置当学显卡当前渲染程序
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setProgram = function (program) {
            this.programChange = false;
            if (this.program == program) {
                return;
            }
            ;
            this.programChange = true;
            this.program = program;
            Context3DProxy.gl.useProgram(program.program);
        };
        /**
        * @language zh_CN
        * 获取矩阵变量ID
        * @param program
        * @param name
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.getUniformLocation = function (programe3D, name) {
            return Context3DProxy.gl.getUniformLocation(programe3D.program, name);
        };
        /**
        * @language zh_CN
        * 传值给shader一个float
        * @param location 指明要更改的uniform变量
        * @param x  uniform变量变量值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform1f = function (location, x) {
            Context3DProxy.gl.uniform1f(location, x);
        };
        /**
        * @language zh_CN
        * 传值给shader 一个vec3(float, float, float) 也可以是一个vec3数组
        * @param location 指明要更改的uniform变量
        * @param v uniform变量变量值Float32Array[3]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform1fv = function (location, v) {
            Context3DProxy.gl.uniform1fv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader一个int
        * @param location 指明要更改的uniform变量
        * @param x uniform变量变量值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform1i = function (location, x) {
            Context3DProxy.gl.uniform1i(location, x);
        };
        /**
        * @language zh_CN
        * 传值给shader一个int数组
        * @param location 指明要更改的uniform变量
        * @param v int数组的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform1iv = function (location, v) {
            Context3DProxy.gl.uniform1iv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader两个float
        * @param location 指明要更改的uniform变量
        * @param x float x 的值
        * @param y float y 的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform2f = function (location, x, y) {
            Context3DProxy.gl.uniform2f(location, x, y);
        };
        /**
        * @language zh_CN
        * 传值给shader vec(float, float)
        * @param location 指明要更改的uniform变量
        * @param v Float32Array[2]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform2fv = function (location, v) {
            Context3DProxy.gl.uniform2fv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader 两个int值
        * @param location 指明要更改的uniform变量
        * @param x number x 的值
        * @param y number y 的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform2i = function (location, x, y) {
            Context3DProxy.gl.uniform2i(location, x, y);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location 指明要更改的uniform变量
        * @param v
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform2iv = function (location, v) {
            Context3DProxy.gl.uniform2iv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader 3个float
        * @param location 指明要更改的uniform变量
        * @param x
        * @param y
        * @param z
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform3f = function (location, x, y, z) {
            Context3DProxy.gl.uniform3f(location, x, y, z);
        };
        /**
        * @language zh_CN
        * 传值给shader vec3(float, float, float)
        * @param location 指明要更改的uniform变量
        * @param v Float32Array[3]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform3fv = function (location, v) {
            Context3DProxy.gl.uniform3fv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader 3个int
        * @param location 指明要更改的uniform变量
        * @param x
        * @param y
        * @param z
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform3i = function (location, x, y, z) {
            Context3DProxy.gl.uniform3i(location, x, y, z);
        };
        /**
        * @language zh_CN
        * 传值给shader vec3(int, int, int)
        * @param location 指明要更改的uniform变量
        * @param v Int32Array[3]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform3iv = function (location, v) {
            Context3DProxy.gl.uniform3iv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader 4个float值
        * @param location 指明要更改的uniform变量
        * @param x
        * @param y
        * @param z
        * @param w
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform4f = function (location, x, y, z, w) {
            Context3DProxy.gl.uniform4f(location, x, y, z, w);
        };
        /**
        * @language zh_CN
        * 传值给shader vec(float, float, float, float)
        * @param location 指明要更改的uniform变量
        * @param v Float32Array[4]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform4fv = function (location, v) {
            Context3DProxy.gl.uniform4fv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader 4个int值
        * @param location 指明要更改的uniform变量
        * @param x
        * @param y
        * @param z
        * @param w
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniform4i = function (location, x, y, z, w) {
            Context3DProxy.gl.uniform4i(location, x, y, z, w);
        };
        /**
        * @language zh_CN
        * 传值给shader vec4(int, int, int, int)
        * @param location 指明要更改的uniform变量
        * @param v Int32Array[4]
        */
        Context3DProxy.prototype.uniform4iv = function (location, v) {
            Context3DProxy.gl.uniform4iv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader 2 * 2矩阵
        * @param location 指明要更改的uniform变量
        * @param transpose 是否转置
        * @param value 矩阵值 Float32Array[4]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniformMatrix2fv = function (location, transpose, value) {
            Context3DProxy.gl.uniformMatrix2fv(location, transpose, value);
        };
        /**
        * @language zh_CN
        * 传值给shader 3 * 3矩阵
        * @param location 指明要更改的uniform变量
        * @param transpose 是否转置
        * @param value 矩阵值 Float32Array[9]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniformMatrix3fv = function (location, transpose, value) {
            Context3DProxy.gl.uniformMatrix3fv(location, transpose, value);
        };
        /**
        * @language zh_CN
        * 传值给shader 4 * 4矩阵
        * @param location 指明要更改的uniform变量
        * @param transpose 是否转置
        * @param value 矩阵值 Float32Array[16]
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.uniformMatrix4fv = function (location, transpose, value) {
            Context3DProxy.gl.uniformMatrix4fv(location, transpose, value);
        };
        /**
        * @language zh_CN
        * 设置 绘制混合模式
        * @param src
        * @param dst
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setBlendFactors = function (src, dst) {
            if (this.blend_Factors_src == src && this.blend_Factors_dst == dst)
                return;
            this.blend_Factors_src = src;
            this.blend_Factors_dst = dst;
            Context3DProxy.gl.blendFunc(src, dst);
        };
        /**
        * @language zh_CN
        * 设置 绘制剔除模式
        * @param mode
        * @see egret3d.ContextConfig.FRONT
        * @see egret3d.ContextConfig.BACK
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setCulling = function (mode) {
            if (this.cullingMode == mode)
                return;
            this.cullingMode = mode;
            Context3DProxy.gl.cullFace(mode);
        };
        /**
        * @language zh_CN
        * 开启 深度测试模式
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.enableDepth = function () {
            if (this.DEPTH_TEST)
                return;
            this.DEPTH_TEST = true;
            Context3DProxy.gl.enable(egret3d.ContextConfig.DEPTH_TEST);
        };
        /**
        * @language zh_CN
        * 关闭 深度测试模式
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.disableDepth = function () {
            if (!this.DEPTH_TEST)
                return;
            this.DEPTH_TEST = false;
            Context3DProxy.gl.disable(egret3d.ContextConfig.DEPTH_TEST);
        };
        /**
        * @language zh_CN
        * 开启 剔除面模式
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.enableCullFace = function () {
            if (this.CULL_FACE)
                return;
            this.CULL_FACE = true;
            Context3DProxy.gl.enable(egret3d.ContextConfig.CULL_FACE);
        };
        /**
        * @language zh_CN
        * 关闭 剔除面模式
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.disableCullFace = function () {
            if (!this.CULL_FACE)
                return;
            this.CULL_FACE = false;
            Context3DProxy.gl.disable(egret3d.ContextConfig.CULL_FACE);
        };
        /**
        * @language zh_CN
        * 开启 混合模式
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.enableBlend = function () {
            if (this.BLEND)
                return;
            this.BLEND = true;
            Context3DProxy.gl.enable(egret3d.ContextConfig.BLEND);
        };
        /**
        * @language zh_CN
        * 关闭 混合模式
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.disableBlend = function () {
            if (!this.BLEND)
                return;
            this.BLEND = false;
            Context3DProxy.gl.disable(egret3d.ContextConfig.BLEND);
        };
        ///**
        // * @language zh_CN
        // * 开启 绘制模式
        // * @param cap
        // * @version Egret 3.0
        // * @platform Web,Native
        // */
        //public enable(cap: number) {
        //    Context3DProxy.gl.enable(cap);
        //}
        ///**
        //* @language zh_CN
        //* 关闭 绘制模式
        //* @param cap
        //* @version Egret 3.0
        //* @platform Web,Native
        //*/
        //public disable(cap: number) {
        //    Context3DProxy.gl.disable(cap);
        //}
        /**
        * @language zh_CN
        * 开启 深度模式 及 深度测试比较模式
        * @param flag
        * @param compareMode
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.depthFunc = function (compareMode) {
            if (compareMode === void 0) { compareMode = 0; }
            if (this.depthCompareMode == compareMode)
                return;
            this.depthCompareMode = compareMode;
            Context3DProxy.gl.depthFunc(compareMode);
        };
        /**
        * @language zh_CN
        * 开启 深度模式 及 深度测试比较模式
        * @param flag
        * @param compareMode
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.enableDepthTest = function (flag, compareMode) {
            if (compareMode === void 0) { compareMode = 0; }
            if (flag)
                Context3DProxy.gl.enable(Context3DProxy.gl.DEPTH_TEST);
        };
        /**
        * @language zh_CN
        * 获取顶点着色器变量 索引
        * @param programe
        * @param attribName
        * @returns 着色器变量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.getShaderAttribLocation = function (programe, attribName) {
            return Context3DProxy.gl.getAttribLocation(programe.program, attribName);
        };
        /**
        * @language zh_CN
        * 指定顶点着色器变量索引及结构
        * @param index 变量索引
        * @param size  数据个数
        * @param dataType  数据类型
        * @param normalized 是否单位化
        * @param stride 字节数
        * @param offset 当前变量字节偏移
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.vertexAttribPointer = function (index, size, dataType, normalized, stride, offset) {
            Context3DProxy.gl.vertexAttribPointer(index, size, dataType, normalized, stride, offset);
            Context3DProxy.gl.enableVertexAttribArray(index);
        };
        ///**
        //* @language zh_CN
        //* 激活的顶点结构
        //* @version Egret 3.0
        //* @platform Web,Native
        //*/
        //public activeVertexFormat(format: number){
        //    this.vertexFormat = format;
        //}
        /**
        * @language zh_CN
        * 要激活着色器上的顶点信息
        * @param vertexFormat 顶点格式
        * @param formatLen 顶点要激活的长度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.activeAttribPointer = function (vertexFormat, formatLen) {
            //if (this.cacheVertexFormat != vertexFormat) {
            for (var j = 0; j < 8; j++) {
            }
            this.cacheVertexFormat = vertexFormat;
            //for (var j: number = 0; j < formatLen; j++) {
            //Context3DProxy.gl.enableVertexAttribArray(j);
            // }
            //  }
            return this.cacheVertexFormat == vertexFormat;
        };
        Context3DProxy.prototype.disAttribPointer = function () {
            for (var j = 0; j < 8; j++) {
                Context3DProxy.gl.disableVertexAttribArray(j);
            }
        };
        /**
        * @language zh_CN
        * @private
        * 实时传入显卡顶点着色器变量数组数据
        * @param floats
        * @param offest
        * @param numLen
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setVertexShaderConstData = function (floats, offest, numLen) {
            Context3DProxy.gl.vertexAttrib4fv(offest, floats.subarray(offest, numLen));
        };
        /**
        * @language zh_CN
        * @private
        * 实时传入显卡片段着色器变量数组数据
        * @param floats
        * @param offest
        * @param numLen
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setFragmentShaderConstData = function (floats, offest, numLen) {
        };
        /**
        * @language zh_CN
        * 设置贴图采样 第一个参数并不是类型
        * @param samplerIndex  ContextSamplerType
        * @param uniLocation
        * @param index
        * @param texture
        * @see egret3d.ContextSamplerType
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setTexture2DAt = function (samplerIndex, uniLocation, index, texture) {
            Context3DProxy.gl.activeTexture(samplerIndex);
            Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_2D, texture.textureBuffer);
            Context3DProxy.gl.uniform1i(uniLocation, index);
        };
        Context3DProxy.prototype.disableTexture2DAt = function (samplerIndex, uniLocation, index) {
            //Context3DProxy.gl.activeTexture(samplerIndex);
            //Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_2D, null );
            //Context3DProxy.gl.uniform1i(uniLocation, index);
        };
        /**
        * @language zh_CN
        * 设置贴图采样 第一个参数并不是类型
        * @param samplerIndex  ContextSamplerType
        * @param uniLocation
        * @param index
        * @param texture
        * @see egret3d.ContextSamplerType
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setCubeTextureAt = function (samplerIndex, uniLocation, index, texture) {
            if (!texture) {
                return;
            }
            Context3DProxy.gl.activeTexture(samplerIndex);
            Context3DProxy.gl.bindTexture(Context3DProxy.gl.TEXTURE_CUBE_MAP, texture.texture);
            Context3DProxy.gl.uniform1i(uniLocation, index);
        };
        /**
        * @language zh_CN
        * @private
        * 设置矩形裁切区域
        * @param rectangle
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setScissorRectangle = function (x, y, width, height) {
            Context3DProxy.gl.scissor(x, egret3d.ContextConfig.canvasRectangle.height - height - y, width, height);
        };
        /**
        * @language zh_CN
        * @private
        * 设置模板测试
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setStencilReferenceValue = function () {
        };
        /**
        * @language zh_CN
        * @private
        * 设置模板测试
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.setStencilActions = function (triangleFace, compareMode, actionOnBothPass, actionOnDepthFail, actionOnDepthPassStencilFail) {
        };
        /**
        * @language zh_CN
        * 绑定顶点Buffer
        * @param vertexBuffer
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.bindVertexBuffer = function (vertexBuffer) {
            Context3DProxy.gl.bindBuffer(Context3DProxy.gl.ARRAY_BUFFER, vertexBuffer.buffer);
        };
        /**
       * @language zh_CN
       * 绑定顶点索引Buffer
       * @param vertexBuffer
       * @version Egret 3.0
       * @platform Web,Native
       */
        Context3DProxy.prototype.bindIndexBuffer = function (indexBuffer) {
            Context3DProxy.gl.bindBuffer(Context3DProxy.gl.ELEMENT_ARRAY_BUFFER, indexBuffer.buffer);
        };
        /**
        * @language zh_CN
        * 绘制模型元素
        * @param type 图元类型
        * @param first 第一个顶点索引
        * @param length 顶点个数
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.drawArrays = function (type, first, length) {
            Context3DProxy.gl.drawArrays(type, first, length);
        };
        /**
        * @language zh_CN
        * 绘制模型元素
        * @param type 图元类型
        * @param indexBuffer 索引数据
        * @param offset 顶点索引偏移 (字节数)
        * @param length 顶点个数
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.drawElement = function (type, offset, length) {
            Context3DProxy.gl.drawElements(type, length, Context3DProxy.gl.UNSIGNED_SHORT, offset);
        };
        /**
        * @language zh_CN
        * @private
        * 绘制提交
        * @version Egret 3.0
        * @platform Web,Native
        */
        Context3DProxy.prototype.flush = function () {
            Context3DProxy.gl.flush();
        };
        return Context3DProxy;
    }());
    egret3d.Context3DProxy = Context3DProxy;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.FrameBuffer
    * @classdesc
    * FrameBuffer 类提供了用于呈现几何定义图形的上下文的帧缓冲对象。</p>
    *
    * 渲染上下文包括一个绘图表面及其关联的资源帧缓冲对象。</p>
    * 通过context creatFrameBuffer 来创建，不能直接使用 new 的方式实例化。</p>
    * @see egret3d.Program3D
    * @see egret3d.IndexBuffer3D
    * @see egret3d.VertexBuffer3D
    * @see egret3d.Texture2D
    * @see egret3d.Shader
    * @see egret3d.CubeTexture
    * @version Egret 3.0
    * @platform Web,Native
    */
    var FrameBuffer = (function () {
        function FrameBuffer() {
        }
        return FrameBuffer;
    }());
    egret3d.FrameBuffer = FrameBuffer;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.IndexBuffer3D
    * @classdesc
    * IndexBuffer3D 用于表示顶点索引列表，由图形子系统保留的图形元素构成。</p>
    *
    * 定义一个立方图纹理，以便在渲染期间使用。立方体贴图可用于多种渲染技术，例如环境图、skyboxes 和 skylight 光照。</p>
    * 不能直接创建 CubeTexture 对象，而应使用 Context3DProxy createCubeTexture()。</p>
    *
    * 由 IndexBuffer3D 对象管理的索引可用于从顶点流中选择顶点。索引为 16 位无符号整数。所允许的最大索引值为 65535 (0xffff)。图形子系统不会保留对提供给此对象的顶点的引用。修改或丢弃上载到此对象中的数据不会影响已存储的值。</p>

    * 无法直接实例化 IndexBuffer3D。使用 Context3DProxy.CreateIndexBuffer() 可创建实例。</p>
    * @see egret3d.Context3DProxy
    * @see egret3d.CubeTexture
    * @version Egret 3.0
    * @platform Web,Native
    */
    var IndexBuffer3D = (function () {
        /**
        * @language zh_CN
        * 构造
        * @param buffer webglbuffer
        * @version Egret 3.0
        * @platform Web,Native
        */
        function IndexBuffer3D(buffer) {
            this.buffer = buffer;
        }
        /**
        * @language zh_CN
        * 释放接口
        */
        IndexBuffer3D.prototype.dispose = function () {
            if (this.buffer) {
                egret3d.Context3DProxy.gl.deleteBuffer(this.buffer);
                this.buffer = null;
            }
            if (this.arrayBuffer) {
                delete this.arrayBuffer;
                this.arrayBuffer = null;
            }
        };
        return IndexBuffer3D;
    }());
    egret3d.IndexBuffer3D = IndexBuffer3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.IndexBuffer3D
    * @classdesc
    * IndexBuffer3D 用于表示顶点索引列表，由图形子系统保留的图形元素构成。</p>
    * VertexBuffer3D 类表示上载到渲染上下文的一组顶点数据。</p>
    * 使用 VertexBuffer3D 对象定义与一组顶点中每个点相关联的数据。</p>
    * 您可以从 Vector 数组或 ByteArray 上载顶点数据。（上载完成后，将不再引用原始数组中的数据；更改或放弃源数组不会更改顶点数据。）</p>
    * 与每个顶点相关联的数据采用应用程序定义的格式，并用作顶点着色器程序的输入。</p>
    * 使用 Context3DProxy.vertexAttribPointer  函数标识哪些值属于哪个顶点程序输入。</p>
    * 一个顶点程序最多可以使用 8 个输入（也称为顶点属性寄存器）。</p>
    * 每个输入可能需要 1 到 4 个 32 位值。</p>
    * 例如，一个顶点的 [x,y,z] 位置坐标可以作为包含 3 个 32 位值的矢量传递到顶点程序。</p>
    * 您最多可以为每个点提供 64 个 32 位值（256 字节）数据（但在这种情况下，单个顶点着色器无法使用所有数据）。</p>
    * 注意：由于现在索引是Uint16 所以顶点个数不能超过65535
    * @see egret3d.Context3DProxy
    * @see egret3d.CubeTexture
    * @see egret3d.IndexBuffer3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var VertexBuffer3D = (function () {
        /**
        * @language zh_CN
        * 构造
        * @param buffer WebGLBuffer
        * @version Egret 3.0
        * @platform Web,Native
        */
        function VertexBuffer3D(buffer) {
            this.buffer = buffer;
        }
        /**
        * @language zh_CN
        * 释放接口
        */
        VertexBuffer3D.prototype.dispose = function () {
            if (this.buffer) {
                egret3d.Context3DProxy.gl.deleteBuffer(this.buffer);
                this.buffer = null;
            }
            if (this.arrayBuffer) {
                delete this.arrayBuffer;
                this.arrayBuffer = null;
            }
        };
        return VertexBuffer3D;
    }());
    egret3d.VertexBuffer3D = VertexBuffer3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.MipmapData
    * @classdesc
    * 一个贴图的不同LOD层级数据。</p>
    * 生成 mipmap 可以使用 TextureUtil.generateMipMaps() 来制作lod mipmapdata。</p>
    *
    *
    * @see egret3d.openGLES.Program3D
    * @see egret3d.openGLES.IndexBuffer3D
    * @see egret3d.openGLES.VertexBuffer3D
    * @see egret3d.openGLES.Texture2D
    * @see egret3d.openGLES.Shader
    * @see egret3d.openGLES.CubeTexture
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MipmapData = (function () {
        /**
        * @language zh_CN
        * 创建一个MipmapData 对象
        * @param data 数据内容
        * @param width 宽度
        * @param height 高度
        * @version Egret 3.0
        * @platform Web,Native
        */
        function MipmapData(data, width, height) {
            this.data = data;
            this.width = width;
            this.height = height;
        }
        return MipmapData;
    }());
    egret3d.MipmapData = MipmapData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Program3D
    * @classdesc
    * Program3D 类表示上载到渲染上下文的一对渲染程序（也称为“编译后的着色器”）。</p>
    *
    * 由 Program3D 对象管理的程序控制 drawTriangles 调用期间的整个三角形渲染。使用 upload 方法将二进制字节码上载到渲染上下文。（上载完成后，将不再引用原始字节数组中的数据；更改或放弃源字节数组不会更改该程序。）。</p>
    * 这些程序始终由两个相互关联的部分组成：顶点程序和片段程序。</p>
    * 顶点程序会操作 VertexBuffer3D 中定义的数据，负责将顶点投影到剪辑空间，并将任何所需的顶点数据（例如颜色）传递到片段着色器。</p>
    * 片段着色器会操作顶点程序传递给它的属性，并为三角形的每个栅格化片段生成颜色，最终形成像素颜色。请注意，片段程序在 3D 编程文献中具有多个名称，包括片段着色器和像素着色器。</p>
    * 通过将相应 Program3D 实例传递到 Context3DProxy setProgram() 方法，指定后续渲染操作要使用的程序对。</p>
    * 您无法直接创建 Program3D 对象；请改用 Context3DProxy createProgram() 方法。</p>
    *
    * @see egret3d.Program3D
    * @see egret3d.IndexBuffer3D
    * @see egret3d.VertexBuffer3D
    * @see egret3d.Texture2D
    * @see egret3d.Shader
    * @see egret3d.CubeTexture
    * @includeExample core/context/Program3D.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Program3D = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @param pg3D WebGLProgram对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Program3D(pg3D) {
            this.program = pg3D;
        }
        /**
        * @language zh_CN
        * 释放接口
        * @version Egret 3.0
        * @platform Web,Native
        */
        Program3D.prototype.dispose = function () {
            if (this.program) {
                egret3d.Context3DProxy.gl.deleteProgram(this.program);
                this.program = null;
            }
        };
        return Program3D;
    }());
    egret3d.Program3D = Program3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Shader
    * @classdesc
    * Shader 类表示上载到渲染上下文的一对渲染程序中的 顶点找色shader，或片段着色的shader 。</p>
    *
    * shader 是基于 opengl es 2.0 标准 也就是webgl版本的shader着色器。</p>
    *
    * @see egret3d.Program3D
    * @see egret3d.IndexBuffer3D
    * @see egret3d.VertexBuffer3D
    * @see egret3d.Texture2D
    * @see egret3d.Shader
    * @see egret3d.CubeTexture
    * @includeExample core/context/Shader.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Shader = (function () {
        /**
        * @language zh_CN
        * 构造
        * @param shader WebGLShader对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Shader(shader) {
            this._shader = shader;
        }
        Object.defineProperty(Shader.prototype, "shader", {
            /**
            * @language zh_CN
            * @private
            * WebGLShader 的引用
            */
            get: function () {
                return this._shader;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 释放接口
        * @version Egret 3.0
        * @platform Web,Native
        */
        Shader.prototype.dispose = function () {
            if (this._shader) {
                egret3d.Context3DProxy.gl.deleteShader(this._shader);
                this._shader = null;
            }
        };
        /**
        * @language zh_CN
        * @private
        * 声明 shader 为顶点 类型
        * @see egret3d.ShaderPool
        */
        Shader.vertex = 0;
        /**
        * @language zh_CN
        * @private
        * 声明 shader 为片段 类型
        * @see egret3d.ShaderPool
        */
        Shader.fragment = 1;
        /**
       * @language zh_CN
       * @private
       * 获取已经有的shader 的ID
       */
        Shader.ID_COUNT = 0;
        return Shader;
    }());
    egret3d.Shader = Shader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.ContextTexture2D
    * @classdesc
    * Texture 类表示上载到渲染上下文的二维纹理。</p>
    *
    * 定义一个 2D 纹理，以便在渲染期间使用。</p>
    * 无法直接实例化 Texture。使用 Context3DProxy createTexture() 方法创建实例。</p>
    * @see egret3d.Program3D
    * @see egret3d.IndexBuffer3D
    * @see egret3d.VertexBuffer3D
    * @see egret3d.Shader
    * @see egret3d.CubeTexture
    * @see egret3d.Context3DProxy
    * @includeExample core/context/ContextTexture2D.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ContextTexture2D = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ContextTexture2D() {
            this.border = 0;
            this.imageData = null;
            //this.colorFormat = ContextConfig.ColorFormat_RGBA8888;
            //this.dataFormat = Context3DProxy.gl.UNSIGNED_BYTE;
            //this.internalFormat = InternalFormat.PixelArray;
            //this.mimapData = new Array<MipmapData>();
        }
        /**
        * @language zh_CN
        * 释放接口
        * @version Egret 3.0
        * @platform Web,Native
        */
        ContextTexture2D.prototype.dispose = function () {
            if (this.textureBuffer) {
                egret3d.Context3DProxy.gl.deleteTexture(this.textureBuffer);
                this.textureBuffer = null;
            }
            if (this.frameBuffer) {
                egret3d.Context3DProxy.gl.deleteFramebuffer(this.frameBuffer);
                this.frameBuffer = null;
            }
            if (this.renderbuffer) {
                egret3d.Context3DProxy.gl.deleteRenderbuffer(this.renderbuffer);
                this.renderbuffer = null;
            }
        };
        return ContextTexture2D;
    }());
    egret3d.ContextTexture2D = ContextTexture2D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.ContextTexture3D
    * @classdesc
    * 由6加Texture2D 组成
    * 可以使一个6面体上贴出不同的贴图
    * @see egret3d.Program3D
    * @see egret3d.IndexBuffer3D
    * @see egret3d.VertexBuffer3D
    * @see egret3d.ContextTexture2D
    * @see egret3d.Shader
    * @see egret3d.CubeTexture
    * @includeExample core/context/ContextTexture3D.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ContextTexture3D = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ContextTexture3D() {
            this.border = 0;
            this.useMipmap = true;
            this.colorformat = egret3d.ContextConfig.ColorFormat_RGBA8888;
            this.internalformat = egret3d.InternalFormat.PixelArray;
            this.mimapData = new Array();
        }
        /**
        * @language zh_CN
        * 释放接口
        * @version Egret 3.0
        * @platform Web,Native
        */
        ContextTexture3D.prototype.dispose = function () {
            if (this.texture) {
                egret3d.Context3DProxy.gl.deleteTexture(this.texture);
                this.texture = null;
            }
            if (this.image_front) {
                this.image_front.dispose();
                this.image_front = null;
            }
            if (this.image_back) {
                this.image_back.dispose();
                this.image_back = null;
            }
            if (this.image_left) {
                this.image_left.dispose();
                this.image_left = null;
            }
            if (this.image_right) {
                this.image_right.dispose();
                this.image_right = null;
            }
            if (this.image_up) {
                this.image_up.dispose();
                this.image_up = null;
            }
            if (this.image_down) {
                this.image_down.dispose();
                this.image_down = null;
            }
        };
        return ContextTexture3D;
    }());
    egret3d.ContextTexture3D = ContextTexture3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Object3D
    * @classdesc
    * 拣选类型，拣选时可以分为，包围盒拣选、模型拣选返回模型拣选到的位置、模型拣选返回模型拣选到的UV坐标
    * 这几种拣选方式
    * 设置鼠标拣选的类型，鼠标拣选不同的类型有不同的效果作用，还有性能
    * 需要的拣选精度越高，性能要求就越高，反之亦然
    *
    * @see egret3d.Picker
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (PickType) {
        /**
        * @language zh_CN
        * 包围盒拣选
        * @version Egret 3.0
        * @platform Web,Native
        */
        PickType[PickType["BoundPick"] = 0] = "BoundPick";
        /**
        * @language zh_CN
        * 模型拣选返回模型拣选到的位置
        * @version Egret 3.0
        * @platform Web,Native
        */
        PickType[PickType["PositionPick"] = 1] = "PositionPick";
        /**
        * @language zh_CN
        * 模型拣选返回模型拣选到的UV坐标
        * @version Egret 3.0
        * @platform Web,Native
        */
        PickType[PickType["UVPick"] = 2] = "UVPick";
    })(egret3d.PickType || (egret3d.PickType = {}));
    var PickType = egret3d.PickType;
    ;
    /**
    * @language zh_CN
    * @private
    * @class egret3d.BillboardType
    * @classdesc
    * billboard类型
    * @see egret3d.Camera3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (BillboardType) {
        /**
        * @language zh_CN
        * 非billboard类型
        * @version Egret 3.0
        * @platform Web,Native
        */
        BillboardType[BillboardType["DISABLE"] = 0] = "DISABLE";
        /**
        * @language zh_CN
        * 只允许绕x轴旋转
        * @version Egret 3.0
        * @platform Web,Native
        */
        BillboardType[BillboardType["X_AXIS"] = 1] = "X_AXIS";
        /**
        * @language zh_CN
        * 只允许绕y轴旋转
        * @version Egret 3.0
        * @platform Web,Native
        */
        BillboardType[BillboardType["Y_AXIS"] = 2] = "Y_AXIS";
        /**
        * @language zh_CN
        * 只允许绕z轴旋转
        * @version Egret 3.0
        * @platform Web,Native
        */
        BillboardType[BillboardType["Z_AXIS"] = 3] = "Z_AXIS";
        /**
        * @language zh_CN
        * 标准的billboard
        * @version Egret 3.0
        * @platform Web,Native
        */
        BillboardType[BillboardType["STANDARD"] = 4] = "STANDARD";
    })(egret3d.BillboardType || (egret3d.BillboardType = {}));
    var BillboardType = egret3d.BillboardType;
    ;
    /**
    * @language zh_CN
    * @class egret3d.Object3D
    * @classdesc
    * 3d空间中的实体对象。
    * 场景图中的Object3D对象是一个树型结构，对象中包含了变换信息.
    * 这些变换信息应用于所有的子对象,子对象也有自己的变换信息,最终
    * 的变换信息要结合父对象的变换信息
    * 每个Object3D对象在生成时会创建一个包围盒
    *
    * @see egret3d.Vector3D
    * @see egret3d.Matrix4_4
    * @see egret3d.Quaternion
    * @see egret3d.Bound
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Object3D = (function (_super) {
        __extends(Object3D, _super);
        /**
        * @language zh_CN
        * 如果直接实例化这个类，就会生成一个空的3D容器，可以往里添加3D显示对象，作为对象的父级，但是本身没有渲染属性。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Object3D() {
            _super.call(this);
            this._modelMatrix3D = new egret3d.Matrix4_4();
            this._localMatrix3D = new egret3d.Matrix4_4();
            this._transformChange = true;
            this._pos = new egret3d.Vector3D();
            this._rot = new egret3d.Vector3D();
            this._sca = new egret3d.Vector3D(1, 1, 1);
            this._orientation = new egret3d.Quaternion();
            this._axis = new egret3d.Vector3D();
            this._angle = 0;
            this._globalPos = new egret3d.Vector3D();
            this._globalRot = new egret3d.Vector3D();
            this._globalSca = new egret3d.Vector3D(1, 1, 1);
            this._globalOrientation = new egret3d.Quaternion();
            this._qut = new egret3d.Quaternion();
            this._vec = new egret3d.Vector3D();
            this._active = false;
            this._isRoot = true;
            this.inFrustum = false;
            /**
            * @language zh_CN
            * @private
            * 该对象所使用的面向相机模式，默认为关闭状态
            * @see egret3d.BillboardType
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.billboard = BillboardType.DISABLE;
            /**
            * @language zh_CN
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.renderLayer = 0;
            /**
            * @language zh_CN
            * 当前对象名
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.name = "";
            /**
            * @language zh_CN
            * 当前对象id
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.id = 0;
            /**
            * @language zh_CN
            * 渲染层级 。</p>
            * 渲染时分组进行依次渲染 前16位表示tag,后16位表示layer。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.layer = 0x00000000;
            /**
            * @language zh_CN
            * 渲染层级分类标签
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.tag = new egret3d.Tag();
            /**
            * @language zh_CN
            * 父亲节点
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.parent = null;
            /**
            * @language zh_CN
            * 子对象列表。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.childs = new Array();
            /**
            * @language zh_CN
            * 是否控制，当摄像机被绑定摄像机动画时，这个值为false.
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.isController = true;
            /**
            * @language zh_CN
            * 是否可见
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.visible = true;
            /**
            * @language zh_CN
            * 鼠标拣选类型。</p>
            * 设置鼠标的拣选类型，可通过 PickType来进行设置。</p>
            * 快速拣选默认使用 正方形包围盒子。</p>
            * 高精度型需要 PositionPick ， uv pick 等。</p>
            * @see egret3d.PickType
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.pickType = PickType.BoundPick;
            /**
            * @language zh_CN
            * 鼠标检测数据
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.pickResult = new egret3d.PickResult();
            /**
            * @language zh_CN
            * 是否开启拣选检测。</p>
            * 设定这个物件是否具有 鼠标交互能力的开关。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.enablePick = false;
            /**
            * @language zh_CN
            * 是否开启检测LOD盒子，每个物体的碰撞盒子中有一个小的盒子，当开启这个盒子后，
            * 鼠标检测就是用的这个小盒子来进行检测
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.mouseChildren = false;
            /**
            * @language zh_CN
            * 是否开启相机视锥裁剪 默认为true
            * 设定这个物件是否具有 视锥体裁剪功能，为否的话，将永远不参加场景渲染剔除树，无论是否在显示范围内都会进行相关的渲染逻辑运算。</p>
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.enableCulling = true;
            this.id = ++Object3D.s_id;
            this._modelMatrix3D.identity();
        }
        Object.defineProperty(Object3D.prototype, "proAnimation", {
            /**
            * @language zh_CN
            * 属性动画对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._proAnimation;
            },
            /**
            * @language zh_CN
            * 属性动画对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (animation) {
                this.setProAnimation(animation);
            },
            enumerable: true,
            configurable: true
        });
        Object3D.prototype.setProAnimation = function (animation) {
            this._proAnimation = animation;
            if (this._proAnimation) {
                this._proAnimation.propertyAnimController.target = this;
            }
        };
        Object.defineProperty(Object3D.prototype, "bound", {
            /**
            * @language zh_CN
            * 獲取对象模型包围盒。</p>
            * 每个场景物件都需要有的 包围盒子，可以自定义包围盒形状大小，也可以根据模型本身生成。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._bound;
            },
            /**
            * @language zh_CN
            * 設置对象模型包围盒。</p>
            * 每个场景物件都需要有的 包围盒子，可以自定义包围盒形状大小，也可以根据模型本身生成。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (bound) {
                if (this._bound == bound) {
                    return;
                }
                if (this._bound) {
                    this._bound.dispose();
                }
                this._bound = bound;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "currentBound", {
            /**
            * @language zh_CN
            * 对象模型当前使用包围盒。
            * @see mouseChilder 根据这个值取不同的包围盒为true取大包围盒 false取子包围盒
            *
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this.mouseChildren) {
                    return this.bound.childBound;
                }
                return this.bound;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "position", {
            /**
            * @language zh_CN
            * 返回位移。</p> （本地）
            * 获取容器的坐标位置，基于父节点的位置坐标。</p>
            * @returns 位移
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos;
            },
            /**
            * @language zh_CN
            * 设置位移。</p> （本地）
            * 设置基于父节点的位置坐标，当父容器发生变化时，子节点也会变化。</p>
            * @param vec 位移
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (vec) {
                if (this._pos.x == vec.x && this._pos.y == vec.y && this._pos.z == vec.z) {
                    return;
                }
                this.updateTransformChange(true);
                this._pos.copyFrom(vec);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotation", {
            /**
            * @language zh_CN
            * 返回旋转。</p> （本地）
            * 获取容器的旋转信息，基于父节点的旋转信息 欧拉角信息。</p>
            * @returns 旋转 欧拉角信息
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot;
            },
            /**
            * @language zh_CN
            * 设置旋转 。</p> （本地）
            * 设置基于父节点的旋转信息 欧拉角信息，当父容器发生变化时，子节点也会变化。</p>
            * @param vec 旋转 欧拉角信息
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._rot.x == value.x && this._rot.y == value.y && this._rot.z == value.z) {
                    return;
                }
                this._rot.x = value.x;
                this._rot.y = value.y;
                this._rot.z = value.z;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "orientation", {
            /**
            * @language zh_CN
            * 返回旋转。</p> （本地）
            * 返回 基于四元素的旋转信息。</p>
            * @returns 旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._orientation;
            },
            /**
            * @language zh_CN
            * 设置旋转。</p> （本地）
            * 设置旋转 基于四元素 旋转信息，当父容器发生变化时，子节点也会变化。</p>
            * @param value 旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._orientation.x == value.x &&
                    this._orientation.y == value.y &&
                    this._orientation.z == value.z &&
                    this._orientation.w == value.w) {
                    return;
                }
                this._orientation.copyFrom(value);
                this._orientation.toEulerAngles(this._rot);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "orientationX", {
            /**
            * @language zh_CN
            * 设置旋转 分量x （本地）
            * @param value 分量x
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._orientation.x == value) {
                    return;
                }
                this._orientation.x = value;
                this._orientation.toEulerAngles(this._rot);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "orientationY", {
            /**
            * @language zh_CN
            * 设置旋转 分量y （本地）
            * @param value 分量y
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._orientation.y == value) {
                    return;
                }
                this._orientation.y = value;
                this._orientation.toEulerAngles(this._rot);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "orientationZ", {
            /**
            * @language zh_CN
            * 设置旋转 分量z （本地）
            * @param value 分量z
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._orientation.z == value) {
                    return;
                }
                this._orientation.z = value;
                this._orientation.toEulerAngles(this._rot);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "orientationW", {
            /**
            * @language zh_CN
            * 设置旋转 分量w （本地）
            * @param value 分量w
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._orientation.w == value) {
                    return;
                }
                this._orientation.w = value;
                this._orientation.toEulerAngles(this._rot);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scale", {
            /**
            * @language zh_CN
            * 返回缩放。</p> （本地）
            * 返回基于父容器的缩放信息。</p>
            * @returns 缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca;
            },
            /**
            * @language zh_CN
            * 设置缩放。</p> （本地）
            * 设置基于父容器的缩放信息，当父容器发生变化时，子节点也会变化。</p>
            * @param vec 缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._sca.x == val.x &&
                    this._sca.y == val.y &&
                    this._sca.z == val.z) {
                    return;
                }
                this.updateTransformChange(true);
                this._sca = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "x", {
            /**
            * @language zh_CN
            * 返回x坐标 （本地）
            * 返回基于父容器的位置坐标信息值
            * @returns x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos.x;
            },
            /**
            * @language zh_CN
            * 设置x坐标。</p> （本地）
            * 设置基于父容器的位置信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._pos.x == value)
                    return;
                this._pos.x = value;
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "y", {
            /**
            * @language zh_CN
            * 返回y坐标 （本地）
            *
            * 返回基于父容器的位置坐标信息值
            * @returns y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos.y;
            },
            /**
            * @language zh_CN
            * 设置y坐标。</p> （本地）
            * 设置基于父容器的位置信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._pos.y == value)
                    return;
                this._pos.y = value;
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "z", {
            /**
            * @language zh_CN
            * 返回z坐标 （本地）
            *
            * 返回基于父容器的位置坐标信息值
            * @returns z坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos.z;
            },
            /**
            * @language zh_CN
            * 设置z坐标。</p> （本地）
            * 设置基于父容器的位置信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value z坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._pos.z == value)
                    return;
                this._pos.z = value;
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotationX", {
            /**
            * @language zh_CN
            * 返回x旋转 （本地）
            *
            * 返回基于父容器的位置旋转信息值
            * @returns x旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot.x;
            },
            /**
            * @language zh_CN
            * 设置x轴旋转。</p> （本地）
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value x轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._rot.x == value)
                    return;
                this._rot.x = value;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotationY", {
            /**
            * @language zh_CN
            * 返回y旋转 （本地）
            *
            * 返回基于父容器的位置旋转信息值
            * @returns y旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot.y;
            },
            /**
            * @language zh_CN
            * 设置y轴旋转。</p> （本地）
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value y轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._rot.y == value)
                    return;
                this._rot.y = value;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotationZ", {
            /**
            * @language zh_CN
            * 返回z旋转 （本地）
            *
            * 返回基于父容器的位置旋转信息值
            * @returns z旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot.z;
            },
            /**
            * @language zh_CN
            * 设置z轴旋转。</p> （本地）
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value z轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._rot.z == value)
                    return;
                this._rot.z = value;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleX", {
            /**
            * @language zh_CN
            * 返回x缩放 （本地）
            * 返回基于父容器的缩放信息值
            * @returns x缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca.x;
            },
            /**
            * @language zh_CN
            * 设置x轴缩放。</p> （本地）
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value x轴缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._sca.x == value)
                    return;
                this._sca.x = value;
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleY", {
            /**
            * @language zh_CN
            * 返回y缩放 （本地）
            * 返回基于父容器的缩放信息值
            * @returns y缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca.y;
            },
            /**
            * @language zh_CN
            * 设置y轴缩放 （本地）
            *
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value y轴缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._sca.y == value)
                    return;
                this._sca.y = value;
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleZ", {
            /**
            * @language zh_CN
            * 返回z缩放 （本地）
            * 返回基于父容器的缩放信息值
            * @returns z缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca.z;
            },
            /**
            * @language zh_CN
            * 设置z轴缩放 （本地）
            *
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value z轴缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._sca.z == value)
                    return;
                this._sca.z = value;
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 以axis轴为中心进行旋转
        * 设置基于父容器的旋转信息，数值通过axis的角度进行设置。当父容器发生变化时，子节点也会变化，值不变
        * @param axis 中心轴
        * @param angle 旋转的角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.setRotationFromAxisAngle = function (axis, angle) {
            axis.normalize();
            this.updateTransformChange(true);
            this._orientation.fromAxisAngle(axis, angle);
            this._orientation.toEulerAngles(this._rot);
            this._axis.copyFrom(axis);
            this._angle = angle;
        };
        Object.defineProperty(Object3D.prototype, "modelMatrix", {
            /**
            * @language zh_CN
            * 返回 object在世界中的渲染矩阵 （全局）
            * @returns Matrix4_4 世界渲染矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.updateModelMatrix();
                }
                return this._modelMatrix3D;
            },
            /**
            * @language zh_CN
            * 设置 object在世界中的渲染矩阵 （全局）
            * @param matrix 世界矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (matrix) {
                var tas = matrix.decompose(egret3d.Orientation3D.QUATERNION);
                this.globalPosition = tas[0];
                egret3d.MathUtil.CALCULATION_QUATERNION.x = tas[1].x;
                egret3d.MathUtil.CALCULATION_QUATERNION.y = tas[1].y;
                egret3d.MathUtil.CALCULATION_QUATERNION.z = tas[1].z;
                egret3d.MathUtil.CALCULATION_QUATERNION.w = tas[1].w;
                this.globalOrientation = egret3d.MathUtil.CALCULATION_QUATERNION;
                this.globalScale = tas[2];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "localMatrix", {
            /**
            * @language zh_CN
            * 返回 object在本地空间中的矩阵 （本地）
            * @returns Matrix4_4 本地空间矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                this.modelMatrix;
                return this._localMatrix3D;
            },
            /**
            * @language zh_CN
            * 设置 object在本地空间中的矩阵 （本地）
            * @param matrix 本地空间矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (matrix) {
                var tas = matrix.decompose(egret3d.Orientation3D.QUATERNION);
                this.position = tas[0];
                Object3D.qua0.setTo(tas[1].x, tas[1].y, tas[1].z, tas[1].w);
                this.orientation = Object3D.qua0;
                this.scale = tas[2];
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * @private
        * @platform Web,Native
        */
        Object3D.prototype.updateModelMatrix = function () {
            if (this.parent != null) {
                var parentOrientation = this.parent.globalOrientation;
                this._globalOrientation.multiply(parentOrientation, this._orientation);
                this._globalOrientation.toEulerAngles(this._globalRot);
                var parentScale = this.parent.globalScale;
                this._globalSca.copyFrom(parentScale.multiply(this._sca, Object3D.v0));
                parentOrientation.transformVector(parentScale.multiply(this._pos, Object3D.v0), this._globalPos);
                this._globalPos.copyFrom(this._globalPos.add(this.parent.globalPosition, Object3D.v0));
            }
            else {
                this._globalOrientation.copyFrom(this._orientation);
                this._globalPos.copyFrom(this._pos);
                this._globalSca.copyFrom(this._sca);
                this._globalRot.copyFrom(this._rot);
            }
            this.onMakeTransform();
            this._transformChange = false;
            this.onUpdateTransform();
        };
        Object3D.prototype.onUpdateTransform = function () {
        };
        Object3D.prototype.onMakeTransform = function () {
            this._localMatrix3D.makeTransform(this._pos, this._sca, this._orientation);
            this._modelMatrix3D.makeTransform(this._globalPos, this._globalSca, this._globalOrientation);
        };
        Object.defineProperty(Object3D.prototype, "globalX", {
            /**
            * @language zh_CN
            * 返回 object 世界位置 x (全局)
            * @returns object 世界位置x
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalPosition.x;
            },
            /**
            * @language zh_CN
            * 设置 object 世界位置 x (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalPosition);
                this._vec.x = value;
                this.globalPosition = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalY", {
            /**
            * @language zh_CN
            * 返回 object 世界位置 y (全局)
            * @returns object 世界位置 y
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalPosition.y;
            },
            /**
            * @language zh_CN
            * 设置 object 世界位置 y (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalPosition);
                this._vec.y = value;
                this.globalPosition = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalZ", {
            /**
            * @language zh_CN
            * 返回 object 世界位置 z (全局)
            * @returns object 世界位置 z
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalPosition.z;
            },
            /**
            * @language zh_CN
            * 设置 object 世界位置 z (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalPosition);
                this._vec.z = value;
                this.globalPosition = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalPosition", {
            /**
            * @language zh_CN
            * 返回 object 世界位置 （全局）
            * 返回世界坐标系的 全局位置坐标
            * @returns object 世界位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._globalPos;
            },
            /**
            * @language zh_CN
            * 设置 object 世界位置 （全局）
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (pos) {
                if (this.parent) {
                    this.parent.globalOrientation.inverse(this._qut);
                    pos.subtract(this.parent.globalPosition, this._vec);
                    this._qut.transformVector(this._vec, this._vec);
                    this._vec.divided(this.parent.globalScale, this._vec);
                    this.position = this._vec;
                }
                else {
                    this.position = pos;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalRotationX", {
            /**
            * @language zh_CN
            * 返回 object 世界旋转x (全局)
            * @returns object 世界旋转x
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalRotation.x;
            },
            /**
            * @language zh_CN
            * 设置 object 世界旋转 x (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalRotation);
                this._vec.x = value;
                this.globalRotation = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalRotationY", {
            /**
            * @language zh_CN
            * 返回 object 世界旋转y (全局)
            * @returns object 世界旋转y
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalRotation.y;
            },
            /**
            * @language zh_CN
            * 设置 object 世界旋转 y (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalRotation);
                this._vec.y = value;
                this.globalRotation = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalRotationZ", {
            /**
            * @language zh_CN
            * 返回 object 世界旋转z (全局)
            * @returns object 世界旋转z
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalRotation.z;
            },
            /**
            * @language zh_CN
            * 设置 object 世界旋转 z (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalRotation);
                this._vec.z = value;
                this.globalRotation = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalRotation", {
            /**
            * @language zh_CN
            * 返回 object 世界旋转 (全局)
            * 返回世界坐标系的 全局旋转信息
            * @returns object 世界旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._globalRot;
            },
            /**
            * @language zh_CN
            * 设置 object 世界旋转 (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (rot) {
                egret3d.MathUtil.CALCULATION_QUATERNION.fromEulerAngles(rot.x, rot.y, rot.z);
                this.globalOrientation = egret3d.MathUtil.CALCULATION_QUATERNION;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalScale", {
            /**
            * @language zh_CN
            * 返回 object 世界缩放 (全局)
            * 返回世界坐标系的 全局缩放信息
            * @returns object 世界缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._globalSca;
            },
            /**
            * @language zh_CN
            * 设置 object 世界缩放 (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (sca) {
                if (this.parent) {
                    sca.divided(this.parent.globalScale, this._vec);
                    this.scale = this._vec;
                }
                else {
                    this.scale = sca;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalScaleX", {
            /**
            * @language zh_CN
            * 获取 object 世界缩放 x (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalScale.x;
            },
            /**
            * @language zh_CN
            * 设置 object 世界缩放 x (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalScale);
                this._vec.x = value;
                this.globalScale = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalScaleY", {
            /**
            * @language zh_CN
            * 获取 object 世界缩放 y (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalScale.y;
            },
            /**
            * @language zh_CN
            * 设置 object 世界缩放 y (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalScale);
                this._vec.y = value;
                this.globalScale = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalScaleZ", {
            /**
            * @language zh_CN
            * 获取 object 世界缩放 z (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalScale.z;
            },
            /**
            * @language zh_CN
            * 设置 object 世界缩放 z (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._vec.copyFrom(this.globalScale);
                this._vec.z = value;
                this.globalScale = this._vec;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalOrientation", {
            /**
            * @language zh_CN
            * 返回 object 世界旋转 四元数 (全局)
            * 返回世界坐标系的 全局旋转信息，数据类型是 四元数
            * @returns object 世界旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._globalOrientation;
            },
            /**
            * @language zh_CN
            * 设置 object 世界旋转 四元数 (全局)
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (ori) {
                if (this.parent) {
                    this.parent.globalOrientation.inverse(this._qut);
                    this._qut.multiply(this._qut, ori);
                    this.orientation = this._qut;
                }
                else {
                    this.orientation = ori;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 增加一个子对象,并返回当前子对象。
        * 如果child 本身有父节点 会先进行移除父节点。
        * 在容器中添加子对象，如果有显示接口的，将会放到场景显示树种进行渲染逻辑运算，及渲染
        * @param child 增加的子对象
        * @returns 子对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.addChild = function (child) {
            if (child.parent) {
                child.parent.removeChild(child);
            }
            if (this.childs.indexOf(child) >= 0) {
                this.removeChild(child);
            }
            this.childs.push(child);
            child.parent = this;
            child._isRoot = false;
            child.updateTransformChange(true);
            return child;
        };
        /**
        * @language zh_CN
        * 增加一个子对象,并返回当前子对象
        * 在容器中添加子对象，如果有显示接口的，将会放到场景显示树种进行渲染逻辑运算，及渲染
        * @param child 增加的子对象
        * @param index 子对象的下标
        * @returns 子对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.addChildAt = function (child, index) {
            if (index < 0) {
                this.childs.splice(0, 0, child);
            }
            else if (index >= this.childs.length) {
                this.childs.push(child);
            }
            else {
                this.childs.splice(index, 0, child);
            }
            child.parent = this;
            child.updateTransformChange(true);
            return child;
        };
        /**
        * @language zh_CN
        * 返回下标为index的子对象
        * @param index 子对象下标
        * @returns 如果有就返回子对象,否则就返回null.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.getChildAt = function (index) {
            if (index < 0 || index >= this.childs.length)
                return null;
            return this.childs[index];
        };
        /**
        * @language zh_CN
        * 将一个2D GPU UI对象位置与该3d对象在屏幕位置投射位置相绑定
        * @param ui 需要绑定的2d对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.addFollowUI = function (ui) {
            this._displayList = this._displayList || [];
            var index = this._displayList.indexOf(ui);
            if (index == -1)
                this._displayList.push(ui);
        };
        /**
        * @language zh_CN
        * 解除一个2D GPU UI对象位置与该3d对象在屏幕位置投射位置相绑定
        * @param ui 需要解除绑定的2d对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.removeFollowUI = function (ui) {
            if (!this._displayList) {
                return;
            }
            var index = this._displayList.indexOf(ui);
            if (index >= 0)
                this._displayList.splice(index, 1);
        };
        /**
        * @language zh_CN
        * 返回子对象child的下标
        * @param child 子对象
        * @returns 如果有就返回子对象的下标,否则就返回-1.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.getChildIndex = function (child) {
            for (var index = 0; index < this.childs.length; ++index) {
                if (this.childs[index] != child) {
                    continue;
                }
                return index;
            }
            return -1;
        };
        /**
        * @language zh_CN
        * 返回子对象
        * @param index 索引
        * @returns Object3D 子对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.getChild = function (index) {
            if (index >= 0 && index < this.childs.length) {
                return this.childs[index];
            }
            return null;
        };
        /**
        * @language zh_CN
        * 移除child子对象 并返回
        * 移除显示列表中的指定对象，如果为空将会返回
        * @param child 子对象
        * @returns Object3D 如果成功就返回child,否则返回null
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.removeChild = function (child) {
            var index = this.childs.indexOf(child);
            if (index < 0) {
                return null;
            }
            child.parent = null;
            this.childs.splice(index, 1);
            child.updateTransformChange(true);
            return child;
        };
        /**
        * @language zh_CN
        * 移除下标为index的子对象 并返回
        * @param index 子对象的下标
        * @returns 如果成功就返回child,否则返回null
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.removeChildAt = function (index) {
            if (index < 0 || index >= this.childs.length)
                return null;
            var object3D = this.childs[index];
            object3D.parent = null;
            this.childs.splice(index, 1);
            object3D.updateTransformChange(true);
            return object3D;
        };
        /**
        * @language zh_CN
        * 移除全部child子对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.removeAllChild = function () {
            while (this.childs.length > 0) {
                this.removeChild(this.childs[0]);
            }
        };
        /**
        * @language zh_CN
        * 设置子对象的下标
        * @private
        * @param child 子对象
        * @param index 子对象的下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.setChildIndex = function (child, index) {
            for (var i = 0; i < this.childs.length; ++i) {
                if (this.childs[i] != child) {
                    continue;
                }
                if (i == index) {
                    return;
                }
                else if (index > i) {
                    for (var m = i; m > index; --m) {
                        this.childs[m] = this.childs[m - 1];
                    }
                }
                else if (index < i) {
                    for (var m = i; m < index; ++m) {
                        this.childs[m] = this.childs[m + 1];
                    }
                }
                this.childs[index] = child;
                return;
            }
        };
        /**
        * @language zh_CN
        * @private
        * 交换对象
        * @param other 交换中的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.swapObject = function (other) {
            var parent = other.parent;
            if (this.parent) {
                var index = this.parent.getChildIndex(this);
                var thisParent = this.parent;
                thisParent.removeChildAt(index);
                thisParent.addChildAt(other, index);
            }
            var childs = [];
            while (this.childs.length > 0) {
                childs.push(this.childs[0]);
                this.removeChild(this.childs[0]);
            }
            for (var i = 0; i < childs.length; ++i) {
                other.addChild(childs[i]);
            }
            this.updateTransformChange(true);
            other.updateTransformChange(true);
        };
        /**
        * @language zh_CN
        * @private
        * 交换对象 包括子节点
        * @param other 交换中的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.swapObjectAndChilds = function (other) {
            var parent = other.parent;
            var childs = new Array();
            for (var i = 0; i < other.childs.length; ++i) {
                childs[i] = other.childs[i];
            }
            if (this.parent) {
                var index = this.parent.getChildIndex(this);
                this.parent.childs[index] = other;
            }
            if (other.parent) {
                var index = other.parent.getChildIndex(other);
                other.parent.childs[index] = this;
            }
            other.parent = this.parent;
            this.parent = parent;
            other.childs.length = 0;
            for (var i = 0; i < this.childs.length; ++i) {
                other.childs[i] = this.childs[i];
                other.childs[i].parent = other;
            }
            this.childs.length = 0;
            for (var i = 0; i < childs.length; ++i) {
                this.childs[i] = childs[i];
                this.childs[i].parent = this;
            }
            this.updateTransformChange(true);
            other.updateTransformChange(true);
        };
        /**
        * @language zh_CN
        * @private
        * 交换子对象的位置
        * @param child1 子对象1
        * @param child2 子对象2
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.swapChildren = function (child1, child2) {
            var index1 = 0, index2 = 0;
            for (; index1 < this.childs.length; ++index1) {
                if (this.childs[index1] != child1) {
                    continue;
                }
                for (; index2 < this.childs.length; ++index2) {
                    if (this.childs[index2] != child2) {
                        continue;
                    }
                    var tmp = this.childs[index1];
                    this.childs[index1] = this.childs[index2];
                    this.childs[index2] = tmp;
                    break;
                }
                return;
            }
        };
        /**
        * @language zh_CN
        * @private
        * 交换子对象的位置
        * @param index1 子对象1下标
        * @param index2 子对象2下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.swapChildrenAt = function (index1, index2) {
            if (index1 < 0 || index1 >= this.childs.length)
                return;
            if (index2 < 0 || index2 >= this.childs.length)
                return;
            var tmp = this.childs[index1];
            this.childs[index1] = this.childs[index2];
            this.childs[index2] = tmp;
        };
        /**
        * @language zh_CN
        * 当前对象对视位置 （全局） (修改的是自身的全局变换)
        * @param pos 自身的位置 （全局）
        * @param target 目标的位置 （全局）
        * @param up 向上的方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.lookAt = function (pos, target, up) {
            if (up === void 0) { up = egret3d.Vector3D.Y_AXIS; }
            this.globalPosition = pos;
            egret3d.MathUtil.CALCULATION_MATRIX.lookAt(pos, target, up);
            egret3d.MathUtil.CALCULATION_MATRIX.invert();
            var prs = egret3d.MathUtil.CALCULATION_MATRIX.decompose(egret3d.Orientation3D.QUATERNION);
            egret3d.MathUtil.CALCULATION_QUATERNION.x = prs[1].x;
            egret3d.MathUtil.CALCULATION_QUATERNION.y = prs[1].y;
            egret3d.MathUtil.CALCULATION_QUATERNION.z = prs[1].z;
            egret3d.MathUtil.CALCULATION_QUATERNION.w = prs[1].w;
            this.globalOrientation = egret3d.MathUtil.CALCULATION_QUATERNION;
        };
        /**
        * @language zh_CN
        * 当前对象对视位置 （本地） (修改的是自身的本地变换)
        * @param pos 自身的位置 （本地）
        * @param target 目标的位置 （本地）
        * @param up 向上的方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.lookAtLocal = function (pos, target, up) {
            if (up === void 0) { up = egret3d.Vector3D.Y_AXIS; }
            this.position = pos;
            egret3d.MathUtil.CALCULATION_MATRIX.lookAt(pos, target, up);
            egret3d.MathUtil.CALCULATION_MATRIX.invert();
            var prs = egret3d.MathUtil.CALCULATION_MATRIX.decompose(egret3d.Orientation3D.QUATERNION);
            egret3d.MathUtil.CALCULATION_QUATERNION.x = prs[1].x;
            egret3d.MathUtil.CALCULATION_QUATERNION.y = prs[1].y;
            egret3d.MathUtil.CALCULATION_QUATERNION.z = prs[1].z;
            egret3d.MathUtil.CALCULATION_QUATERNION.w = prs[1].w;
            this.orientation = egret3d.MathUtil.CALCULATION_QUATERNION;
        };
        /**
        * @language zh_CN
        * 看向目标  (会根据目标对象的全局坐标进行改变) (修改的是自身的全局变换)
        * @param target 目标对象 (会根据目标对象的全局坐标进行改变)
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.lookAtTarget = function (target) {
            egret3d.MathUtil.CALCULATION_MATRIX.lookAt(this.globalPosition, target.globalPosition, egret3d.Vector3D.Y_AXIS);
            egret3d.MathUtil.CALCULATION_MATRIX.invert();
            var prs = egret3d.MathUtil.CALCULATION_MATRIX.decompose(egret3d.Orientation3D.QUATERNION);
            egret3d.MathUtil.CALCULATION_QUATERNION.x = prs[1].x;
            egret3d.MathUtil.CALCULATION_QUATERNION.y = prs[1].y;
            egret3d.MathUtil.CALCULATION_QUATERNION.z = prs[1].z;
            egret3d.MathUtil.CALCULATION_QUATERNION.w = prs[1].w;
            this.globalOrientation = egret3d.MathUtil.CALCULATION_QUATERNION;
        };
        /**
        * @language zh_CN
        * 看向目标 (会根据目标对象的本地坐标进行改变) (修改的是自身的本地变换)
        * @param target 目标对象 (会根据目标对象的本地坐标进行改变)
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.lookAtTargetLocal = function (target) {
            egret3d.MathUtil.CALCULATION_MATRIX.lookAt(this.position, target.position, egret3d.Vector3D.Y_AXIS);
            egret3d.MathUtil.CALCULATION_MATRIX.invert();
            var prs = egret3d.MathUtil.CALCULATION_MATRIX.decompose(egret3d.Orientation3D.QUATERNION);
            egret3d.MathUtil.CALCULATION_QUATERNION.x = prs[1].x;
            egret3d.MathUtil.CALCULATION_QUATERNION.y = prs[1].y;
            egret3d.MathUtil.CALCULATION_QUATERNION.z = prs[1].z;
            egret3d.MathUtil.CALCULATION_QUATERNION.w = prs[1].w;
            this.orientation = egret3d.MathUtil.CALCULATION_QUATERNION;
        };
        /**
        * @language zh_CN
        * 以Object3D name 来查找Object3D
        * @param name Object3D名字
        * @returns Object3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.findObject3D = function (name) {
            var object3d = null;
            for (var i = 0; i < this.childs.length; ++i) {
                if (this.childs[i].name == name) {
                    object3d = this.childs[i];
                    return object3d;
                }
                object3d = this.childs[i].findObject3D(name);
                if (object3d) {
                    return object3d;
                }
            }
            return object3d;
        };
        /**
        * @language zh_CN
        * 以Object3D id 来查找Object3D
        * @param id Object3D id
        * @returns Object3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.findObject3DToID = function (id) {
            var object3d = null;
            for (var i = 0; i < this.childs.length; ++i) {
                if (this.childs[i].id == id) {
                    object3d = this.childs[i];
                    return object3d;
                }
                object3d = this.childs[i].findObject3DToID(id);
                if (object3d) {
                    return object3d;
                }
            }
            return object3d;
        };
        Object3D.prototype.updateTransformChange = function (change) {
            this._transformChange = change;
            ///Octree.getInstance().checkObject3D(obj);
            for (var i = 0; i < this.childs.length; ++i) {
                this.childs[i].updateTransformChange(change);
            }
        };
        /**
        * @language zh_CN
        * 当前对象数据更新
        * @private
        * @param camera 当前渲染的摄相机
        * @param time 当前时间
        * @param delay 每帧时间间隔
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.update = function (time, delay, camera) {
            if (this.inFrustum) {
                if (this.proAnimation) {
                    this.proAnimation.update(time, delay, null);
                }
            }
            if (this._displayList) {
                for (var i = 0; i < this._displayList.length; i++) {
                    camera.object3DToScreenRay(this.globalPosition, egret3d.Vector3D.HELP_0);
                    this._displayList[i].x = egret3d.Vector3D.HELP_0.x;
                    this._displayList[i].y = egret3d.Vector3D.HELP_0.y;
                }
            }
        };
        /**
        * @language zh_CN
        * 释放所有数据
        * 是否内存中的相关数据连接引用，移除逻辑运算，从主渲染刘表中挪出
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            for (var i = 0; i < this.childs.length; i++) {
                this.childs[i].dispose();
            }
            this.removeAllChild();
        };
        Object.defineProperty(Object3D.prototype, "root", {
            /**
            * @language zh_CN
            * 获取当前节点的根节点
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (!this.parent) {
                    return this;
                }
                return this.parent.root;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.copy = function (other) {
            this.position = other.position;
            this.rotation = other.rotation;
            this.scale = other.scale;
            this.visible = other.visible;
            this.name = other.name;
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.clone = function () {
            var newObject = new Object3D();
            newObject.copy(this);
            return newObject;
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.deepClone = function () {
            var newObject = this.clone();
            for (var i = 0; i < this.childs.length; ++i) {
                newObject.addChild(this.childs[i].deepClone());
            }
            return newObject;
        };
        /**
        * @private
        * @language zh_CN
        * 当前对象名
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.s_id = 0;
        //public awayInFrustum: boolean = false;
        Object3D.qua0 = new egret3d.Quaternion();
        Object3D.mat0 = new egret3d.Matrix4_4();
        Object3D.v0 = new egret3d.Vector3D();
        Object3D.v1 = new egret3d.Vector3D();
        Object3D.v2 = new egret3d.Vector3D();
        return Object3D;
    }(egret3d.EventDispatcher));
    egret3d.Object3D = Object3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.IRender
    * @classdesc
    * 场景中的可见物体，可渲染的对象。
    * 在渲染之前会将渲染树中对象进行筛选.
    * 只有IRender对象才会进入渲染管线
    * @see egret3d.Object3D
    * @see egret3d.Geometry
    * @version Egret 3.0
    * @platform Web,Native
    */
    var IRender = (function (_super) {
        __extends(IRender, _super);
        ///**
        //* @private
        //* 需要进行alpha 排序
        //* @language zh_CN
        //* @version Egret 3.0
        //* @platform Web,Native
        //*/
        //public alphaBlend: boolean = false ;
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function IRender() {
            _super.call(this);
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.zIndex = -1;
            /**
            * @language zh_CN
            * 对象类型。</p>
            * @see egret3d.IRender.TYPE_MESH
            * @see egret3d.IRender.TYPE_PARTICLE_EMIT
            * @see egret3d.IRender.TYPE_WIREFRAME
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.type = "";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._multiMaterial = {};
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._materialCount = 0;
            /**
            * @language zh_CN
            * 动作对象，控制骨骼动画/特效动画等。</p>
            * 可拓展的动画功能属性，动画功能的驱动类总接口。</p>
            * @see egret3d.IAnimation
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.animation = null;
        }
        Object.defineProperty(IRender.prototype, "geometry", {
            /**
            * @language zh_CN
            * 获取网格信息。</p>
            * geometry 为渲染对象的网格信息 ，渲染对象需要 vertexBuffer  和 indexBuffer 信息 及顶点着色器shade。</p>
            * @returns Geometry 网格信息
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._geometry;
            },
            /**
            * @language zh_CN
            * 设置网格信息。</p>
            * @param value 网格信息
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._geometry == value) {
                    return;
                }
                if (value) {
                    value.incRef();
                }
                if (this._geometry) {
                    this._geometry.dispose();
                }
                this._geometry = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IRender.prototype, "drawOrder", {
            /**
            * @language zh_CN
            * 渲染排序的参数，数值越大，先渲染</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IRender.prototype, "lightGroup", {
            /**
            * @language zh_CN
            * 获取材质 lightGroup 。
            * @returns LightGroup 灯光组
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._lightGroup;
            },
            /**
            * @language zh_CN
            * 设置材质 lightGroup 。
            * 设置材质球接受的灯光组。
            * @param lightGroup LightGroup
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (lightGroup) {
                this._lightGroup = lightGroup;
                for (var id in this.multiMaterial) {
                    this.multiMaterial[id].lightGroup = this._lightGroup;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 增加一个材质
        * @param id 材质id
        * @param material 模型材质
        * @version Egret 3.0
        * @platform Web,Native
        */
        IRender.prototype.addSubMaterial = function (id, material) {
            if (!this._multiMaterial[id]) {
                this._materialCount++;
            }
            this.setSubMaterial(id, material);
        };
        /**
        * @language zh_CN
        * 设置材质
        * @param id 材质id
        * @param material 模型材质
        * @version Egret 3.0
        * @platform Web,Native
        */
        IRender.prototype.setSubMaterial = function (id, material) {
            this._multiMaterial[id] = material;
            if (!material) {
                this.removeSubMaterial(id);
            }
            if (id == 0) {
                this._material = material;
            }
            if (material) {
                material.lightGroup = this._lightGroup;
            }
        };
        /**
        * @language zh_CN
        * 删除一个材质
        * @param id 材质id
        * @version Egret 3.0
        * @platform Web,Native
        */
        IRender.prototype.removeSubMaterial = function (id) {
            if (this._multiMaterial[id]) {
                delete this._multiMaterial[id];
                this._materialCount--;
            }
        };
        /**
        * @language zh_CN
        * 根据id获取对应的材质
        * @param id 材质id
        * @returns MaterialBase 材质信息对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        IRender.prototype.getMaterial = function (id) {
            return this._multiMaterial[id];
        };
        Object.defineProperty(IRender.prototype, "materialCount", {
            /**
            * @language zh_CN
            * 得到所有材质的个数
            * @returns number 个数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._materialCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IRender.prototype, "material", {
            /**
            * @language zh_CN
            * 获取材质
            * @returns MaterialBase 材质
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._material;
            },
            /**
            * @language zh_CN
            * 设置材质
            * @param mat 材质
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (mat) {
                this._material = mat;
                if (this._multiMaterial[0]) {
                    this.setSubMaterial(0, mat);
                }
                else {
                    this.addSubMaterial(0, mat);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IRender.prototype, "multiMaterial", {
            /**
            * @language zh_CN
            * 获取多材质
            * @returns { [matID: number]: MaterialBase } 多个材质
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._multiMaterial;
            },
            /**
            * @language zh_CN
            * 设置多材质
            * @param multiMat 多个材质
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (multiMat) {
                this._multiMaterial = multiMat;
                this._materialCount = 0;
                for (var key in multiMat) {
                    this._materialCount++;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        IRender.prototype.update = function (time, delay, camera) {
            _super.prototype.update.call(this, time, delay, camera);
            if (this.inFrustum) {
                if (this.animation) {
                    this.animation.update(time, delay, this.geometry);
                }
            }
            if (this.geometry.subGeometrys.length <= 0) {
                this.geometry.buildDefaultSubGeometry();
            }
        };
        /**
        * @language zh_CN
        * 释放所有数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        IRender.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this._bound) {
                this._bound.dispose();
                this._bound = null;
            }
            this.geometry = null;
            //for (var key in this.multiMaterial) {
            //    this.multiMaterial[key].dispose();
            //}
            this.multiMaterial = {};
        };
        /**
        * @language zh_CN
        * IRender Mesh 类型
        * @version Egret 3.0
        * @platform Web,Native
        */
        IRender.TYPE_MESH = "mesh";
        /**
        * @language zh_CN
        * IRender Particle 类型
        * @version Egret 3.0
        * @platform Web,Native
        */
        IRender.TYPE_PARTICLE_EMIT = "particleEmit";
        /**
        * @language zh_CN
        * IRender Wireframe 类型
        * @version Egret 3.0
        * @platform Web,Native
        */
        IRender.TYPE_WIREFRAME = "wireframe";
        return IRender;
    }(egret3d.Object3D));
    egret3d.IRender = IRender;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.Entity
    * @classdesc
    * 3d空间中的实体对象 extends Object3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Entity = (function (_super) {
        __extends(Entity, _super);
        /**
        * @language zh_CN
        * constructor
        */
        function Entity() {
            _super.call(this);
        }
        return Entity;
    }(egret3d.Object3D));
    egret3d.Entity = Entity;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Mesh
    * @classdesc
    * 3d模型网格 生成渲染模型
    * 创建一个Mesh网格数据和材质数据是必需的，如果是动态模型就加上动画数据
    * 继承Object3D对象，场景中实体渲染对象
    *
    * @see egret3d.Object3D
    * @see egret3d.Geometry
    * @see egret3d.MaterialBase
    * @see egret3d.IAnimation
    * @see egret3d.SkeletonAnimation
    *
    * 示例:
    * @includeExample core/node/Mesh.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Mesh = (function (_super) {
        __extends(Mesh, _super);
        /**
        * @language zh_CN
        * 构建一个Mesh对象
        * @param geometry 模型数据
        * @param material 模型材质 默认为null 为null做自动创建一个TextureMaterial
        * @param animation 模型动画 默认为null 没有动画可以不指定
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Mesh(geometry, material, animation) {
            if (material === void 0) { material = null; }
            if (animation === void 0) { animation = null; }
            _super.call(this);
            this.type = egret3d.IRender.TYPE_MESH;
            this.geometry = geometry;
            if (animation) {
                this.animation = animation;
            }
            else {
                if (geometry) {
                    if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_SKIN) {
                        this.animation = new egret3d.SkeletonAnimation(new egret3d.SkeletonAnimationState());
                    }
                }
            }
            this.material = material ? material : new egret3d.TextureMaterial();
            this.addSubMaterial(0, this.material);
            this.bound = this.buildBoundBox();
        }
        Object.defineProperty(Mesh.prototype, "aabb", {
            /**
            * @private
            */
            get: function () {
                return this._aabbBox;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        */
        Mesh.prototype.initAABB = function () {
            this._aabbBox = new egret3d.QuadAABB();
            this.calcGlobalQuadAABB();
        };
        /**
        * @private
        * 更新绑定盒的全局数据，适用于静态物体
        */
        Mesh.prototype.calcGlobalQuadAABB = function () {
            var box = this.bound;
            var mtx = this.modelMatrix;
            Mesh.AABB_BL_2.setTo(box.min.x, box.min.y, box.min.z);
            Mesh.AABB_BR_2.setTo(box.max.x, box.min.y, box.min.z);
            Mesh.AABB_TL_2.setTo(box.min.x, box.max.y, box.min.z);
            Mesh.AABB_TR_2.setTo(box.max.x, box.max.y, box.min.z);
            Mesh.AABB_BL_1.setTo(box.min.x, box.min.y, box.max.z);
            Mesh.AABB_BR_1.setTo(box.max.x, box.min.y, box.max.z);
            Mesh.AABB_TL_1.setTo(box.min.x, box.max.y, box.max.z);
            Mesh.AABB_TR_1.setTo(box.max.x, box.max.y, box.max.z);
            mtx.transformVector(Mesh.AABB_BL_2, Mesh.AABB_BL_2);
            mtx.transformVector(Mesh.AABB_BR_2, Mesh.AABB_BR_2);
            mtx.transformVector(Mesh.AABB_TL_2, Mesh.AABB_TL_2);
            mtx.transformVector(Mesh.AABB_TR_2, Mesh.AABB_TR_2);
            mtx.transformVector(Mesh.AABB_BL_1, Mesh.AABB_BL_1);
            mtx.transformVector(Mesh.AABB_BR_1, Mesh.AABB_BR_1);
            mtx.transformVector(Mesh.AABB_TL_1, Mesh.AABB_TL_1);
            mtx.transformVector(Mesh.AABB_TR_1, Mesh.AABB_TR_1);
            this._aabbBox.maxPosX = Math.max(Mesh.AABB_TL_2.x, Mesh.AABB_TR_2.x, Mesh.AABB_BL_2.x, Mesh.AABB_BR_2.x, Mesh.AABB_TL_1.x, Mesh.AABB_TR_1.x, Mesh.AABB_BL_1.x, Mesh.AABB_BR_1.x);
            this._aabbBox.maxPosY = Math.max(Mesh.AABB_TL_2.y, Mesh.AABB_TR_2.y, Mesh.AABB_BL_2.y, Mesh.AABB_BR_2.y, Mesh.AABB_TL_1.y, Mesh.AABB_TR_1.y, Mesh.AABB_BL_1.y, Mesh.AABB_BR_1.y);
            this._aabbBox.minPosX = Math.min(Mesh.AABB_TL_2.x, Mesh.AABB_TR_2.x, Mesh.AABB_BL_2.x, Mesh.AABB_BR_2.x, Mesh.AABB_TL_1.x, Mesh.AABB_TR_1.x, Mesh.AABB_BL_1.x, Mesh.AABB_BR_1.x);
            this._aabbBox.minPosY = Math.min(Mesh.AABB_TL_2.y, Mesh.AABB_TR_2.y, Mesh.AABB_BL_2.y, Mesh.AABB_BR_2.y, Mesh.AABB_TL_1.y, Mesh.AABB_TR_1.y, Mesh.AABB_BL_1.y, Mesh.AABB_BR_1.y);
        };
        Object.defineProperty(Mesh.prototype, "isTriangle", {
            /**
            * @private
            */
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Mesh.prototype.onUpdateTransform = function () {
            this._aabbBox.setOffset(this._pos);
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        Mesh.prototype.copy = function (other) {
            _super.prototype.copy.call(this, other);
            for (var key in other.multiMaterial) {
                if (key == "0") {
                    continue;
                }
                this._multiMaterial[key] = other.multiMaterial[key];
            }
            this._materialCount = other.materialCount;
        };
        /**
        * @language zh_CN
        * 克隆一个模型
        * @returns 克隆后的模型
        * @version Egret 3.0
        * @platform Web,Native
        */
        Mesh.prototype.clone = function () {
            var ani = null;
            if (this.animation) {
                ani = this.animation.clone();
            }
            var cloneMesh = new Mesh(this.geometry, this.material, ani);
            cloneMesh.copy(this);
            return cloneMesh;
        };
        /**
        * @language zh_CN
        * @private
        * 生成包围盒
        */
        Mesh.prototype.buildBoundBox = function () {
            var bound = new egret3d.BoundBox(this);
            if (this.geometry && this.geometry.vertexArray) {
                bound.min.copyFrom(new egret3d.Vector3D(egret3d.MathUtil.MAX_VALUE, egret3d.MathUtil.MAX_VALUE, egret3d.MathUtil.MAX_VALUE));
                bound.max.copyFrom(new egret3d.Vector3D(-egret3d.MathUtil.MAX_VALUE, -egret3d.MathUtil.MAX_VALUE, -egret3d.MathUtil.MAX_VALUE));
                for (var i = 0; i < this.geometry.vertexArray.length; i += this.geometry.vertexAttLength) {
                    if (bound.max.x < this.geometry.vertexArray[i]) {
                        bound.max.x = this.geometry.vertexArray[i];
                    }
                    if (bound.max.y < this.geometry.vertexArray[i + 1]) {
                        bound.max.y = this.geometry.vertexArray[i + 1];
                    }
                    if (bound.max.z < this.geometry.vertexArray[i + 2]) {
                        bound.max.z = this.geometry.vertexArray[i + 2];
                    }
                    if (bound.min.x > this.geometry.vertexArray[i]) {
                        bound.min.x = this.geometry.vertexArray[i];
                    }
                    if (bound.min.y > this.geometry.vertexArray[i + 1]) {
                        bound.min.y = this.geometry.vertexArray[i + 1];
                    }
                    if (bound.min.z > this.geometry.vertexArray[i + 2]) {
                        bound.min.z = this.geometry.vertexArray[i + 2];
                    }
                }
            }
            bound.fillBox(bound.min, bound.max);
            bound.createChild();
            this.bound = bound;
            this.initAABB();
            return bound;
        };
        Mesh.AABB_TL_1 = new egret3d.Vector3D();
        Mesh.AABB_TR_1 = new egret3d.Vector3D();
        Mesh.AABB_BL_1 = new egret3d.Vector3D();
        Mesh.AABB_BR_1 = new egret3d.Vector3D();
        Mesh.AABB_TL_2 = new egret3d.Vector3D();
        Mesh.AABB_TR_2 = new egret3d.Vector3D();
        Mesh.AABB_BL_2 = new egret3d.Vector3D();
        Mesh.AABB_BR_2 = new egret3d.Vector3D();
        return Mesh;
    }(egret3d.IRender));
    egret3d.Mesh = Mesh;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Billboard
    * @classdesc
    * 公告板渲染对象 始终面朝摄像机的面板
    * @includeExample core/node/BilllBoard.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Billboard = (function (_super) {
        __extends(Billboard, _super);
        /**
        * @language zh_CN
        * 指定材质，和公告板宽、高，构建一个公告板
        * @param material 渲染材质
        * @param geometry 几何数据，默认参数为null 为null会在内部创建一个PlaneGeometry  自定义PlaneGeometry的时候 请注意创建面的朝向
        * @param width 公告板宽度 默认参数为 100
        * @param height 公告板高度 默认参数为 100
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Billboard(material, geometry, width, height) {
            if (geometry === void 0) { geometry = null; }
            if (width === void 0) { width = 100; }
            if (height === void 0) { height = 100; }
            if (geometry == null) {
                geometry = new egret3d.PlaneGeometry(width, height, 1, 1, 1, 1, egret3d.Vector3D.Z_AXIS);
            }
            _super.call(this, geometry, material);
            this.width = width;
            this.height = height;
            if (!this.bound) {
                this.bound = this.buildBoundBox();
            }
        }
        /**
        * @private
        * @language zh_CN
        * 数据更新，不前对象的旋转和摄像机的旋转一致
        * @param camera 当前渲染的摄相机
        * @param time 当前时间
        * @param delay 间隔时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        Billboard.prototype.update = function (time, delay, camera) {
            _super.prototype.update.call(this, time, delay, camera);
            this.globalOrientation = camera.globalOrientation;
        };
        /**
        * @language zh_CN
        * @private
        * @param other copy对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Billboard.prototype.copy = function (other) {
            _super.prototype.copy.call(this, other);
        };
        /**
        * @language zh_CN
        * 克隆当前公告板
        * @returns Billboard 克隆后的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Billboard.prototype.clone = function () {
            var cloneMesh = new Billboard(this.material, this.geometry, this.width, this.height);
            cloneMesh.copy(this);
            return cloneMesh;
        };
        return Billboard;
    }(egret3d.Mesh));
    egret3d.Billboard = Billboard;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Sky
    * @classdesc
    * 天空可由任意几何图形构成天空。
    * 场景中天空。
    * 可以是6面体cube，以6张无缝结合的贴图构成.
    *
    * @see egret3d.CubeTexture
    * @see egret3d.CubeTextureMaterial
    *
    * 示例:
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample core/node/Sky.ts
    */
    var Sky = (function (_super) {
        __extends(Sky, _super);
        /**
        * @language zh_CN
        * 构建一个天空盒子对象
        * @param geometry 天空模型数据
        * @param material 天空材质
        * @param camera 天空渲染相机
        * @default null
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Sky(geometry, material, camera) {
            if (camera === void 0) { camera = null; }
            _super.call(this, geometry, material);
            this.camera = camera;
            if (!this.bound) {
                this.bound = this.buildBoundBox();
            }
        }
        /**
        * @language zh_CN
        * 当前对象数据更新，只有在视锥内的对象才会执行此更新
        * @param camera 当前渲染的摄相机
        * @param time 当前时间
        * @param delay 每帧时间间隔
        * @version Egret 3.0
        * @platform Web,Native
        */
        Sky.prototype.update = function (time, delay, camera) {
            _super.prototype.update.call(this, time, delay, camera);
            if (this.camera) {
                this.globalPosition = this.camera.globalPosition;
            }
        };
        /**
        * @language zh_CN
        * @private
        * @param other copy对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Sky.prototype.copy = function (other) {
            _super.prototype.copy.call(this, other);
        };
        /**
        * @language zh_CN
        * 克隆当前Sky
        * @returns Sky 克隆后的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Sky.prototype.clone = function () {
            var cloneObject = new Sky(this.geometry, this.material, this.camera);
            cloneObject.copy(this);
            return cloneObject;
        };
        return Sky;
    }(egret3d.Mesh));
    egret3d.Sky = Sky;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Wireframe
    * @classdesc
    * 渲染线框 以线的形式渲染顶点。
    * 使用LINES的模式进行渲染。
    * 会使用两个索引来进行渲染一个线段。
    * 实例化一个Wireframe对象之后需要把geometry顶点数据和索引数据填充
    * @see egret3d.Geometry.setVerticesForIndex
    * @see egret3d.Geometry.indexData
    * @see egret3d.Geometry
    * @includeExample core/node/Wireframe.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Wireframe = (function (_super) {
        __extends(Wireframe, _super);
        /**
        * @language zh_CN
        * 构造函数，输入一个模型，拷贝这个模型的顶点数据，创建一个只绘制边框的渲染对象
        * @param src  画线顶点数据列表 默认为null 没有设置数据 可以调用 this.fromVertexs 或 this.fromGeometry设置数据
        * @param vf 画线顶点数据格式 默认为 VertexFormat.VF_POSITION (x, y, z) 可以加上颜色 VertexFormat.VF_COLOR (r, g, b, a)
        * 每个顶点数据格式必须统一
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Wireframe(src, vf) {
            if (src === void 0) { src = null; }
            if (vf === void 0) { vf = egret3d.VertexFormat.VF_POSITION; }
            _super.call(this);
            this.type = egret3d.IRender.TYPE_WIREFRAME;
            this.geometry = new egret3d.Geometry();
            this.material = new egret3d.ColorMaterial(0xffffff);
            this.addSubMaterial(0, this.material);
            this.material.drawMode = egret3d.DrawMode.LINES;
            this.geometry.vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0;
            this.fromVertexs(src, vf);
        }
        /**
        * @language zh_CN
        * 设置画线顶点数据 规则是把传入的所有点依次连接
        * @param src  画线顶点数据列表
        * @param vf 画线顶点数据格式 默认为 VertexFormat.VF_POSITION (x, y, z) 可以加上颜色 VertexFormat.VF_COLOR (r, g, b, a)
        * 每个顶点数据格式必须统一
        * @version Egret 3.0
        * @platform Web,Native
        */
        Wireframe.prototype.fromVertexs = function (src, vf) {
            if (vf === void 0) { vf = egret3d.VertexFormat.VF_POSITION; }
            if (src) {
                this.geometry.setVerticesForIndex(0, vf, src, src.length / egret3d.GeometryUtil.fromVertexFormatToLength(vf));
                this.geometry.indexCount = (this.geometry.vertexCount - 1) * 2;
                for (var i = 0; i < this.geometry.vertexCount - 1; ++i) {
                    this.geometry.indexArray[i * 2 + 0] = i;
                    this.geometry.indexArray[i * 2 + 1] = i + 1;
                }
            }
        };
        /**
       * @language zh_CN
       * 设置画线顶点数据 规则是把传入的点两两相连
       * @param src  画线顶点数据列表
       * @param vf 画线顶点数据格式 默认为 VertexFormat.VF_POSITION (x, y, z) 可以加上颜色 VertexFormat.VF_COLOR (r, g, b, a)
       * 每个顶点数据格式必须统一
       * @version Egret 3.0
       * @platform Web,Native
       */
        Wireframe.prototype.fromVertexsEx = function (src, vf) {
            if (vf === void 0) { vf = egret3d.VertexFormat.VF_POSITION; }
            if (src) {
                this.geometry.setVerticesForIndex(0, vf, src, src.length / egret3d.GeometryUtil.fromVertexFormatToLength(vf));
                this.geometry.indexCount = this.geometry.vertexCount;
                for (var i = 0; i < this.geometry.vertexCount; ++i) {
                    this.geometry.indexArray[i] = i;
                }
            }
        };
        /**
        * @language zh_CN
        * 设置画线顶点数据来源为Geometry 规则是按面连接
        * @param geo  画线顶点数据来源 只会用到Geometry 和坐标数据和颜色数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        Wireframe.prototype.fromGeometry = function (geo) {
            var target = [];
            geo.getVertexForIndex(0, egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_COLOR, target, geo.vertexCount);
            this.geometry.setVerticesForIndex(0, egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_COLOR, target, geo.vertexCount);
            this.geometry.indexCount = geo.faceCount * 6;
            for (var i = 0; i < geo.faceCount; ++i) {
                var _0 = geo.indexArray[i * 3 + 0];
                var _1 = geo.indexArray[i * 3 + 1];
                var _2 = geo.indexArray[i * 3 + 2];
                this.geometry.indexArray[i * 6 + 0] = _0;
                this.geometry.indexArray[i * 6 + 1] = _1;
                this.geometry.indexArray[i * 6 + 2] = _1;
                this.geometry.indexArray[i * 6 + 3] = _2;
                this.geometry.indexArray[i * 6 + 4] = _2;
                this.geometry.indexArray[i * 6 + 5] = _0;
            }
        };
        /**
        * @language zh_CN
        * @private
        * @param other copy对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Wireframe.prototype.copy = function (other) {
            _super.prototype.copy.call(this, other);
            this.geometry = other.geometry;
            this.material = other.material;
        };
        /**
        * @language zh_CN
        * @private
        * 克隆当前Wireframe
        * @returns Wireframe 克隆后的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Wireframe.prototype.clone = function () {
            var cloneObject = new Wireframe();
            cloneObject.copy(this);
            return cloneObject;
        };
        return Wireframe;
    }(egret3d.IRender));
    egret3d.Wireframe = Wireframe;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.Wireframe
    * @classdesc
    * 使用该类实现指定路径画3D线条。
    * 颜色会在起点和终点之间进行平滑插值
    * @see egret3d.Wireframe
    * @includeExample core/node/WireframeLine.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var WireframeLine = (function (_super) {
        __extends(WireframeLine, _super);
        /**
        * @language zh_CN
        * 输入起点和终点，创建一个绘制线段的渲染对象
        * @param start 设置线条的起点
        * @param end 设置线条的终点
        * @startColor 设置起始颜色
        * @endColor 设置终点颜色
        * @version Egret 3.0
        * @platform Web,Native
        */
        function WireframeLine(start, end, startColor, endColor) {
            if (startColor === void 0) { startColor = 0xff00ff00; }
            if (endColor === void 0) { endColor = 0xff0000ff; }
            _super.call(this);
            this._startColor = 0xff00ff00;
            this._endColor = 0xff0000ff;
            this._vb = new Array();
            this._ib = new Array();
            this.material.diffuseColor = 0xffffffff;
            this.setStartAndEndPosition(start, end);
            this.setStartAndEndColor(startColor, endColor);
        }
        /**
        * @language zh_CN
        * 设置线段的起点/终点坐标
        * @param start 设置线条的起点
        * @param end 设置线条的终点
        * @version Egret 3.0
        * @platform Web,Native
        */
        WireframeLine.prototype.setStartAndEndPosition = function (start, end) {
            this._start = start;
            this._end = end;
            this.updateLine();
        };
        /**
        * @language zh_CN
        * 设置线段的起点/终点的颜色

        * @startColor 设置线条的起始颜色
        * @endColor 设置终点的颜色
        * @version Egret 3.0
        * @platform Web,Native
        */
        WireframeLine.prototype.setStartAndEndColor = function (startColor, endColor) {
            this._startColor = startColor;
            this._endColor = endColor;
            this.updateLine();
        };
        WireframeLine.prototype.updateLine = function () {
            this._vb.length = 0;
            this._ib.length = 0;
            var a = egret3d.Color.getColor(this._startColor);
            var b = egret3d.Color.getColor(this._endColor);
            this._vb.push(this._start.x, this._start.y, this._start.z, a.x, a.y, a.z, a.w);
            this._vb.push(this._end.x, this._end.y, this._end.z, b.x, b.y, b.z, b.w);
            for (var i = 0; i < this._vb.length / 3; ++i) {
                this._ib.push(i);
            }
            this.geometry.setVerticesForIndex(0, egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_COLOR, this._vb, this._vb.length / 7);
            this.geometry.setVertexIndices(0, this._ib);
        };
        return WireframeLine;
    }(egret3d.Wireframe));
    egret3d.WireframeLine = WireframeLine;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.LODNode
    * @classdesc
    *
    * @version Egret 3.0
    * @platform Web,Native
    */
    var LODNode = (function () {
        function LODNode(parent, lodQuadTree, x, z) {
            if (parent === void 0) { parent = null; }
            if (lodQuadTree === void 0) { lodQuadTree = null; }
            if (x === void 0) { x = 0; }
            if (z === void 0) { z = 0; }
            this.lt = 0;
            this.rt = 0;
            this.lb = 0;
            this.rb = 0;
            this.tc = 0;
            this.bc = 0;
            this.lc = 0;
            this.rc = 0;
            this.oc = 0;
            this.center = new egret3d.Vector3D();
            this.center_0 = new egret3d.Vector3D();
            this.radius = 0;
            this.dh0 = 0;
            this.dh1 = 0;
            this.dh2 = 0;
            this.dh3 = 0;
            this.dh4 = 0;
            this.dh5 = 0;
            this.minDH = 0;
            this.maxDH = 0;
            this.d = 0;
            this.childs = [];
            this.level = 0;
            this.isRender = false;
            this.parent = parent;
            this.lodQuadTree = lodQuadTree;
            if (this.parent) {
                this.level = this.parent.level + 1;
            }
            if (x != 0 && z != 0) {
                this.createNode(0, x, (z + 1) * x, (z + 1) * (x + 1) - 1);
            }
            if (!this.parent) {
                this.findNeighbour(this, x, z);
            }
        }
        LODNode.prototype.calculateHeightDiff = function () {
            LODNode.v0.length = 0;
            LODNode.v1.length = 0;
            LODNode.v2.length = 0;
            LODNode.v3.length = 0;
            LODNode.v4.length = 0;
            LODNode.v5.length = 0;
            LODNode.v6.length = 0;
            LODNode.v7.length = 0;
            LODNode.v8.length = 0;
            LODNode.getVertex(this.lt, LODNode.v0, this.lodQuadTree.vertexDatas);
            LODNode.getVertex(this.rt, LODNode.v1, this.lodQuadTree.vertexDatas);
            LODNode.getVertex(this.lb, LODNode.v2, this.lodQuadTree.vertexDatas);
            LODNode.getVertex(this.rb, LODNode.v3, this.lodQuadTree.vertexDatas);
            var tc = (this.lt + this.rt) / 2;
            var bc = (this.lb + this.rb) / 2;
            var lc = (this.lt + this.lb) / 2;
            var rc = (this.rt + this.rb) / 2;
            var oc = (this.lt + this.rb) / 2;
            LODNode.getVertex(tc, LODNode.v4, this.lodQuadTree.vertexDatas);
            LODNode.getVertex(bc, LODNode.v5, this.lodQuadTree.vertexDatas);
            LODNode.getVertex(lc, LODNode.v6, this.lodQuadTree.vertexDatas);
            LODNode.getVertex(rc, LODNode.v7, this.lodQuadTree.vertexDatas);
            LODNode.getVertex(oc, LODNode.v8, this.lodQuadTree.vertexDatas);
            this.dh0 = (LODNode.v0[2] + LODNode.v1[2]) / 2 - LODNode.v4[2];
            this.dh1 = (LODNode.v2[2] + LODNode.v3[2]) / 2 - LODNode.v5[2];
            this.dh2 = (LODNode.v0[2] + LODNode.v2[2]) / 2 - LODNode.v6[2];
            this.dh3 = (LODNode.v1[2] + LODNode.v3[2]) / 2 - LODNode.v7[2];
            this.dh4 = (LODNode.v0[2] + LODNode.v3[2]) / 2 - LODNode.v8[2];
            this.dh5 = (LODNode.v1[2] + LODNode.v2[2]) / 2 - LODNode.v8[2];
            this.minDH = Math.max(this.dh0, this.dh1);
            this.minDH = Math.max(this.minDH, this.dh2);
            this.minDH = Math.max(this.minDH, this.dh3);
            this.minDH = Math.max(this.minDH, this.dh4);
            this.minDH = Math.max(this.minDH, this.dh5);
            this.maxDH = Math.max(this.dh0, this.dh1);
            this.maxDH = Math.max(this.maxDH, this.dh2);
            this.maxDH = Math.max(this.maxDH, this.dh3);
            this.maxDH = Math.max(this.maxDH, this.dh4);
            this.maxDH = Math.max(this.maxDH, this.dh5);
            this.maxDH = Math.max(this.maxDH, 1);
            var x = LODNode.v1[0] - LODNode.v0[0];
            var y = LODNode.v1[1] - LODNode.v0[1];
            var z = LODNode.v1[2] - LODNode.v0[2];
            this.d = Math.sqrt(x * x + y * y + z * z);
        };
        LODNode.prototype.createNode = function (lt, rt, lb, rb) {
            this.lt = lt;
            this.rt = rt;
            this.lb = lb;
            this.rb = rb;
            if (this.lodQuadTree.vertexDatas) {
                this.createBoundSphere();
            }
            if (this.rt - lt > 1) {
                this.calculateHeightDiff();
                var quad = null;
                var tc = (lt + rt) / 2;
                var bc = (lb + rb) / 2;
                var lc = (lt + lb) / 2;
                var rc = (rt + rb) / 2;
                var oc = (lt + rb) / 2;
                this.tc = tc;
                this.bc = bc;
                this.lc = lc;
                this.rc = rc;
                this.oc = oc;
                quad = new LODNode(this, this.lodQuadTree);
                this.childs[0] = quad;
                quad.createNode(lt, tc, lc, oc);
                quad = new LODNode(this, this.lodQuadTree);
                this.childs[1] = quad;
                quad.createNode(tc, rt, oc, rc);
                quad = new LODNode(this, this.lodQuadTree);
                this.childs[2] = quad;
                quad.createNode(lc, oc, lb, bc);
                quad = new LODNode(this, this.lodQuadTree);
                this.childs[3] = quad;
                quad.createNode(oc, rc, bc, rb);
            }
        };
        LODNode.prototype.createBoundSphere = function () {
            LODNode.v0.length = 0;
            LODNode.v1.length = 0;
            LODNode.v2.length = 0;
            LODNode.v3.length = 0;
            LODNode.getVertex(this.lt, LODNode.v0, this.lodQuadTree.vertexDatas);
            LODNode.getVertex(this.rt, LODNode.v1, this.lodQuadTree.vertexDatas);
            LODNode.getVertex(this.lb, LODNode.v2, this.lodQuadTree.vertexDatas);
            LODNode.getVertex(this.rb, LODNode.v3, this.lodQuadTree.vertexDatas);
            LODNode.v4[0] = Math.min(LODNode.v0[0], LODNode.v1[0]);
            LODNode.v4[0] = Math.min(LODNode.v4[0], LODNode.v2[0]);
            LODNode.v4[0] = Math.min(LODNode.v4[0], LODNode.v3[0]);
            LODNode.v4[1] = Math.min(LODNode.v0[1], LODNode.v1[1]);
            LODNode.v4[1] = Math.min(LODNode.v4[1], LODNode.v2[1]);
            LODNode.v4[1] = Math.min(LODNode.v4[1], LODNode.v3[1]);
            LODNode.v4[2] = Math.min(LODNode.v0[2], LODNode.v1[2]);
            LODNode.v4[2] = Math.min(LODNode.v4[2], LODNode.v2[2]);
            LODNode.v4[2] = Math.min(LODNode.v4[2], LODNode.v3[2]);
            LODNode.v5[0] = Math.max(LODNode.v0[0], LODNode.v1[0]);
            LODNode.v5[0] = Math.max(LODNode.v5[0], LODNode.v2[0]);
            LODNode.v5[0] = Math.max(LODNode.v5[0], LODNode.v3[0]);
            LODNode.v5[1] = Math.max(LODNode.v0[1], LODNode.v1[1]);
            LODNode.v5[1] = Math.max(LODNode.v5[1], LODNode.v2[1]);
            LODNode.v5[1] = Math.max(LODNode.v5[1], LODNode.v3[1]);
            LODNode.v5[2] = Math.max(LODNode.v0[2], LODNode.v1[2]);
            LODNode.v5[2] = Math.max(LODNode.v5[2], LODNode.v2[2]);
            LODNode.v5[2] = Math.max(LODNode.v5[2], LODNode.v3[2]);
            var x = LODNode.v5[0] - LODNode.v4[0];
            var y = LODNode.v5[1] - LODNode.v4[1];
            var z = LODNode.v5[2] - LODNode.v4[2];
            this.radius = Math.sqrt(x * x + y * y + z * z) / 2;
            this.center.x = LODNode.v4[0] + x / 2;
            this.center.y = LODNode.v4[1] + y / 2;
            this.center.z = LODNode.v4[2] + z / 2;
            this.center_0.copyFrom(this.center);
        };
        LODNode.getVertex = function (index, data, vertexDatas) {
            data[0] = vertexDatas[index * 3 + 0];
            data[1] = vertexDatas[index * 3 + 1];
            data[2] = vertexDatas[index * 3 + 2];
        };
        LODNode.prototype.isNeighbour = function (lt, rt, lb, rb) {
            if (this.lt == lt &&
                this.rt == rt &&
                this.lb == lb &&
                this.rb == rb) {
                return this;
            }
            if (this.childs[0]) {
                var oc = (lt + rt + lb + rb) / 4;
                LODNode.v0.length = 0;
                LODNode.getVertex(oc, LODNode.v0, this.lodQuadTree.vertexDatas);
                LODNode.v1.length = 0;
                LODNode.v2.length = 0;
                LODNode.getVertex(this.childs[0].lt, LODNode.v1, this.lodQuadTree.vertexDatas);
                LODNode.getVertex(this.childs[0].rb, LODNode.v2, this.lodQuadTree.vertexDatas);
                if (egret3d.Rectangle.pointInRect(LODNode.v0[0], LODNode.v0[2], LODNode.v1[0], LODNode.v1[2], LODNode.v2[0], LODNode.v2[2])) {
                    return this.childs[0].isNeighbour(lt, rt, lb, rb);
                }
                LODNode.v1.length = 0;
                LODNode.v2.length = 0;
                LODNode.getVertex(this.childs[1].lt, LODNode.v1, this.lodQuadTree.vertexDatas);
                LODNode.getVertex(this.childs[1].rb, LODNode.v2, this.lodQuadTree.vertexDatas);
                if (egret3d.Rectangle.pointInRect(LODNode.v0[0], LODNode.v0[2], LODNode.v1[0], LODNode.v1[2], LODNode.v2[0], LODNode.v2[2])) {
                    return this.childs[1].isNeighbour(lt, rt, lb, rb);
                }
                LODNode.v1.length = 0;
                LODNode.v2.length = 0;
                LODNode.getVertex(this.childs[2].lt, LODNode.v1, this.lodQuadTree.vertexDatas);
                LODNode.getVertex(this.childs[2].rb, LODNode.v2, this.lodQuadTree.vertexDatas);
                if (egret3d.Rectangle.pointInRect(LODNode.v0[0], LODNode.v0[2], LODNode.v1[0], LODNode.v1[2], LODNode.v2[0], LODNode.v2[2])) {
                    return this.childs[2].isNeighbour(lt, rt, lb, rb);
                }
                LODNode.v1.length = 0;
                LODNode.v2.length = 0;
                LODNode.getVertex(this.childs[3].lt, LODNode.v1, this.lodQuadTree.vertexDatas);
                LODNode.getVertex(this.childs[3].rb, LODNode.v2, this.lodQuadTree.vertexDatas);
                if (egret3d.Rectangle.pointInRect(LODNode.v0[0], LODNode.v0[2], LODNode.v1[0], LODNode.v1[2], LODNode.v2[0], LODNode.v2[2])) {
                    return this.childs[3].isNeighbour(lt, rt, lb, rb);
                }
            }
            return null;
        };
        LODNode.prototype.findNeighbour = function (root, x, z) {
            var g = this.rt - this.lt;
            if (g <= 1) {
                return;
            }
            var _0 = 0;
            var _1 = 0;
            var _2 = 0;
            var _3 = 0;
            var n = 0;
            if (this.lt == 16350 && this.rt == 16352 &&
                this.lb == 16608 && this.rb == 16610) {
                var sss = 0;
            }
            for (var i = 0; i < 4; ++i) {
                switch (i) {
                    case 0:
                        _0 = this.lt - g * (x + 1);
                        _1 = this.rt - g * (x + 1);
                        _2 = this.lt;
                        _3 = this.rt;
                        break;
                    case 1:
                        _0 = this.lb;
                        _1 = this.rb;
                        _2 = this.lb + g * (x + 1);
                        _3 = this.rb + g * (x + 1);
                        break;
                    case 2:
                        _0 = this.lt - g;
                        _1 = this.lt;
                        _2 = this.lb - g;
                        _3 = this.lb;
                        break;
                    case 3:
                        _0 = this.rt;
                        _1 = this.rt + g;
                        _2 = this.rb;
                        _3 = this.rb + g;
                        break;
                }
                n = (_0 + _1 + _2 + _3) / 4;
                if (n >= 0 && n <= ((x + 1) * (z + 1) - 1)) {
                    this.childs[i + 4] = root.isNeighbour(_0, _1, _2, _3);
                }
            }
            if (this.childs[0]) {
                this.childs[0].findNeighbour(root, x, z);
                this.childs[1].findNeighbour(root, x, z);
                this.childs[2].findNeighbour(root, x, z);
                this.childs[3].findNeighbour(root, x, z);
            }
        };
        LODNode.prototype.isDivide = function (camera, lod) {
            LODNode.v0.length = 0;
            LODNode.getVertex(this.oc, LODNode.v0, this.lodQuadTree.vertexDatas_0);
            //MathUtil.CALCULATION_VECTOR3D.setTo(LODNode.v0[0], LODNode.v0[1], LODNode.v0[2]);
            //object3d.modelMatrix.transformVector(MathUtil.CALCULATION_VECTOR3D, MathUtil.CALCULATION_VECTOR3D);
            //var x: number = camera.globalX - MathUtil.CALCULATION_VECTOR3D.x;
            //var y: number = camera.globalY - MathUtil.CALCULATION_VECTOR3D.y;
            //var z: number = camera.globalZ - MathUtil.CALCULATION_VECTOR3D.z;
            var x = camera.globalX - LODNode.v0[0];
            var y = camera.globalY - LODNode.v0[1];
            var z = camera.globalZ - LODNode.v0[2];
            var l = Math.sqrt(x * x + y * y + z * z);
            if (l / (this.d * lod * this.maxDH) < 1) {
                return true;
            }
            return false;
        };
        LODNode.prototype.setIsRender = function (value) {
            this.isRender = value;
            if (this.childs[0]) {
                this.childs[0].setIsRender(value);
                this.childs[1].setIsRender(value);
                this.childs[2].setIsRender(value);
                this.childs[3].setIsRender(value);
            }
        };
        LODNode.v0 = [];
        LODNode.v1 = [];
        LODNode.v2 = [];
        LODNode.v3 = [];
        LODNode.v4 = [];
        LODNode.v5 = [];
        LODNode.v6 = [];
        LODNode.v7 = [];
        LODNode.v8 = [];
        return LODNode;
    }());
    egret3d.LODNode = LODNode;
    /**
    * @private
    * @class egret3d.LODNode
    * @classdesc
    *
    * @version Egret 3.0
    * @platform Web,Native
    */
    var LODQuadTree = (function () {
        /**
        * @language zh_CN
        * 构造
        * @param vertex 地形顶点列表
        * @param size 地形格子 行列格子
        * @version Egret 3.0
        * @platform Web,Native
        */
        function LODQuadTree(vertex, size) {
            /**
            * @language zh_CN
            * lod微调值
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lodValue = 16;
            /**
            * @language zh_CN
            * 每个节点的包围球半径偏移
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.offset = 200;
            /**
            * @language zh_CN
            * 每个节点的层级
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.level = 7;
            /**
            * @language zh_CN
            * 格子行数
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.row = 128;
            /**
            * @language zh_CN
            * 格子列数
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.col = 128;
            this.enable = true;
            this.currentNodes = [];
            this.nextNodes = [];
            this.v0 = new egret3d.Vector3D();
            this.v1 = new egret3d.Vector3D();
            this.row = size;
            this.col = size;
            this.vertexDatas = vertex;
            this.vertexDatas_0 = [];
            for (var i = 0; i < vertex.length; ++i) {
                this.vertexDatas_0[0] = vertex[i];
            }
            this.level = LODQuadTree.getOrder(size);
            this.root = new LODNode(null, this, this.row, this.col);
        }
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        LODQuadTree.getOrder = function (size) {
            var order = 0;
            size = (size - 1) >> (0);
            do {
                size >>= 1;
                order++;
            } while (size);
            return order;
        };
        LODQuadTree.prototype.build = function (index, indexBuffer, camera) {
            this.currentNodes.length = 0;
            this.nextNodes.length = 0;
            this.currentNodes.push(this.root);
            var node;
            this.root.setIsRender(false);
            for (var i = this.level; i >= 0; --i) {
                for (var j = 0; j < this.currentNodes.length; ++j) {
                    node = this.currentNodes[j];
                    if (!camera.frustum.inSphere(node.center_0, node.radius + this.offset)) {
                        continue;
                    }
                    if (node.rt - node.lt <= 1) {
                        indexBuffer[index++] = node.lt;
                        indexBuffer[index++] = node.rb;
                        indexBuffer[index++] = node.lb;
                        indexBuffer[index++] = node.lt;
                        indexBuffer[index++] = node.rt;
                        indexBuffer[index++] = node.rb;
                        node.isRender = true;
                        continue;
                    }
                    if (this.enable) {
                        if (node.isDivide(camera, this.lodValue)) {
                            this.nextNodes.push(node.childs[0]);
                            this.nextNodes.push(node.childs[1]);
                            this.nextNodes.push(node.childs[2]);
                            this.nextNodes.push(node.childs[3]);
                        }
                        else {
                            node.setIsRender(true);
                        }
                    }
                    else {
                        this.nextNodes.push(node.childs[0]);
                        this.nextNodes.push(node.childs[1]);
                        this.nextNodes.push(node.childs[2]);
                        this.nextNodes.push(node.childs[3]);
                    }
                }
                var currentNodes = this.currentNodes;
                this.currentNodes = this.nextNodes;
                this.nextNodes = currentNodes;
                this.nextNodes.length = 0;
            }
            this.currentNodes.length = 0;
            this.nextNodes.length = 0;
            this.currentNodes.push(this.root);
            for (var i = this.level; i >= 0; --i) {
                for (var j = 0; j < this.currentNodes.length; ++j) {
                    node = this.currentNodes[j];
                    if (node.isRender && (node.rt - node.lt) > 1) {
                        var b0 = false;
                        var b1 = false;
                        var b2 = false;
                        var b3 = false;
                        if (node.childs[4]) {
                            b0 = node.childs[4].isRender;
                        }
                        else {
                            b0 = true;
                        }
                        if (node.childs[5]) {
                            b1 = node.childs[5].isRender;
                        }
                        else {
                            b1 = true;
                        }
                        if (node.childs[6]) {
                            b2 = node.childs[6].isRender;
                        }
                        else {
                            b2 = true;
                        }
                        if (node.childs[7]) {
                            b3 = node.childs[7].isRender;
                        }
                        else {
                            b3 = true;
                        }
                        if (b0 && b1 && b2 && b3) {
                            indexBuffer[index++] = node.lt;
                            indexBuffer[index++] = node.rb;
                            indexBuffer[index++] = node.lb;
                            indexBuffer[index++] = node.lt;
                            indexBuffer[index++] = node.rt;
                            indexBuffer[index++] = node.rb;
                            continue;
                        }
                        if (b0 || !node.childs[4]) {
                            indexBuffer[index++] = node.oc;
                            indexBuffer[index++] = node.lt;
                            indexBuffer[index++] = node.rt;
                        }
                        else {
                            index = this.mendCracks(index, indexBuffer, node, node.childs[4].childs[2], 4);
                            index = this.mendCracks(index, indexBuffer, node, node.childs[4].childs[3], 4);
                        }
                        if (b1 || !node.childs[5]) {
                            indexBuffer[index++] = node.lb;
                            indexBuffer[index++] = node.oc;
                            indexBuffer[index++] = node.rb;
                        }
                        else {
                            index = this.mendCracks(index, indexBuffer, node, node.childs[5].childs[0], 5);
                            index = this.mendCracks(index, indexBuffer, node, node.childs[5].childs[1], 5);
                        }
                        if (b2 || !node.childs[6]) {
                            indexBuffer[index++] = node.lt;
                            indexBuffer[index++] = node.oc;
                            indexBuffer[index++] = node.lb;
                        }
                        else {
                            index = this.mendCracks(index, indexBuffer, node, node.childs[6].childs[1], 6);
                            index = this.mendCracks(index, indexBuffer, node, node.childs[6].childs[3], 6);
                        }
                        if (b3 || !node.childs[7]) {
                            indexBuffer[index++] = node.oc;
                            indexBuffer[index++] = node.rt;
                            indexBuffer[index++] = node.rb;
                        }
                        else {
                            index = this.mendCracks(index, indexBuffer, node, node.childs[7].childs[0], 7);
                            index = this.mendCracks(index, indexBuffer, node, node.childs[7].childs[2], 7);
                        }
                    }
                    else {
                        if (node.childs[0]) {
                            this.nextNodes.push(node.childs[0]);
                            this.nextNodes.push(node.childs[1]);
                            this.nextNodes.push(node.childs[2]);
                            this.nextNodes.push(node.childs[3]);
                        }
                    }
                }
                var currentNodes = this.currentNodes;
                this.currentNodes = this.nextNodes;
                this.nextNodes = currentNodes;
                this.nextNodes.length = 0;
            }
            return index;
        };
        LODQuadTree.prototype.mendCracks = function (index, indexBuffer, node, node_0, dir) {
            if (!node_0) {
                return index;
            }
            switch (dir) {
                case 4:
                    if (node_0) {
                        if (node_0.isRender) {
                            indexBuffer[index++] = node.oc;
                            indexBuffer[index++] = node_0.lb;
                            indexBuffer[index++] = node_0.rb;
                        }
                        else {
                            index = this.mendCracks(index, indexBuffer, node, node_0.childs[2], 4);
                            index = this.mendCracks(index, indexBuffer, node, node_0.childs[3], 4);
                        }
                    }
                    break;
                case 5:
                    if (node_0) {
                        if (node_0.isRender) {
                            indexBuffer[index++] = node_0.lt;
                            indexBuffer[index++] = node.oc;
                            indexBuffer[index++] = node_0.rt;
                        }
                        else {
                            index = this.mendCracks(index, indexBuffer, node, node_0.childs[0], 5);
                            index = this.mendCracks(index, indexBuffer, node, node_0.childs[1], 5);
                        }
                    }
                    break;
                case 6:
                    if (node_0) {
                        if (node_0.isRender) {
                            indexBuffer[index++] = node.oc;
                            indexBuffer[index++] = node_0.rb;
                            indexBuffer[index++] = node_0.rt;
                        }
                        else {
                            index = this.mendCracks(index, indexBuffer, node, node_0.childs[1], 6);
                            index = this.mendCracks(index, indexBuffer, node, node_0.childs[3], 6);
                        }
                    }
                    break;
                case 7:
                    if (node_0) {
                        if (node_0.isRender) {
                            indexBuffer[index++] = node.oc;
                            indexBuffer[index++] = node_0.lt;
                            indexBuffer[index++] = node_0.lb;
                        }
                        else {
                            index = this.mendCracks(index, indexBuffer, node, node_0.childs[0], 7);
                            index = this.mendCracks(index, indexBuffer, node, node_0.childs[2], 7);
                        }
                    }
                    break;
            }
            return index;
        };
        LODQuadTree.prototype.onUpdate = function (modle) {
            this.currentNodes.length = 0;
            this.nextNodes.length = 0;
            this.currentNodes.push(this.root);
            var node;
            for (var i = this.level; i >= 0; --i) {
                for (var j = 0; j < this.currentNodes.length; ++j) {
                    node = this.currentNodes[j];
                    modle.transformVector(node.center, node.center_0);
                    this.nextNodes.push(node.childs[0]);
                    this.nextNodes.push(node.childs[1]);
                    this.nextNodes.push(node.childs[2]);
                    this.nextNodes.push(node.childs[3]);
                }
                var currentNodes = this.currentNodes;
                this.currentNodes = this.nextNodes;
                this.nextNodes = currentNodes;
                this.nextNodes.length = 0;
            }
            for (var i = 0; i < this.vertexDatas.length / 3; ++i) {
                this.v0.setTo(this.vertexDatas[i * 3 + 0], this.vertexDatas[i * 3 + 1], this.vertexDatas[i * 3 + 2]);
                modle.transformVector(this.v0, this.v0);
                this.vertexDatas_0[i * 3 + 0] = this.v0.x;
                this.vertexDatas_0[i * 3 + 1] = this.v0.y;
                this.vertexDatas_0[i * 3 + 2] = this.v0.z;
            }
        };
        return LODQuadTree;
    }());
    egret3d.LODQuadTree = LODQuadTree;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Terrain
    * @classdesc
    * 地形网格创建
    * 使用地形高度图,生成地形。
    * 通过读取草数据，主要有草密度/宽度/高度/颜色/使用贴图等属性，结合高度图组装成一片草。
    * @see egret3d.ElevationGeometry
    * @see egret3d.ImageTexture
    * @see egret3d.Mesh
    * @includeExample core/node/terrain/Terrain.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Terrain = (function (_super) {
        __extends(Terrain, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param heightmap 高度图
        * @param width 地形宽度 默认1000
        * @param height 地形主度 默认100
        * @param depth 地形长度 默认1000
        * @param segmentsW 格子列 默认128
        * @param segmentsH 格子行 默认128
        * @param useLod 是否使用lod  如果使用lod segmentsW和segmentsH必须相等并且是2的n次方
        * @param mat 材质 默认为null
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Terrain(heightmap, width, height, depth, segmentsW, segmentsH, useLod, mat) {
            if (width === void 0) { width = 1000; }
            if (height === void 0) { height = 100; }
            if (depth === void 0) { depth = 1000; }
            if (segmentsW === void 0) { segmentsW = 128; }
            if (segmentsH === void 0) { segmentsH = 128; }
            if (useLod === void 0) { useLod = false; }
            if (mat === void 0) { mat = null; }
            _super.call(this, new egret3d.ElevationGeometry(heightmap, width, height, depth, segmentsW, segmentsH), mat);
            this.useLod = useLod;
            if (useLod) {
                if (segmentsW == segmentsH && (segmentsW & (segmentsW - 1)) == 0) {
                    this.vertex = this.geometry.getVertexForIndex(0, egret3d.VertexFormat.VF_POSITION, null, this.geometry.vertexCount);
                    this.lodQuadTree = new egret3d.LODQuadTree(this.vertex, segmentsW);
                    this.lodQuadTree.onUpdate(this.modelMatrix);
                }
                else {
                    egret3d.Egret3DLog.outError("地形宽高不相等或者不是2的N次方!");
                }
            }
        }
        /**
        * @language zh_CN
        * @private
        * @param other copy对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Terrain.prototype.copy = function (other) {
            _super.prototype.copy.call(this, other);
        };
        /**
        * @private
        * @language zh_CN
        * 克隆当前地形
        * @returns Terrain 克隆后的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Terrain.prototype.clone = function () {
            var cloneMesh = new Terrain(this.terrainGeometry.heightmap, this.terrainGeometry.width, this.terrainGeometry.height, this.terrainGeometry.depth, this.terrainGeometry.segmentsW, this.terrainGeometry.segmentsH, this.useLod, this.material);
            cloneMesh.copy(this);
            return cloneMesh;
        };
        Object.defineProperty(Terrain.prototype, "terrainGeometry", {
            /**
            * @language zh_CN
            * 返回地形的ElevationGeometry
            * @see egret3d.ElevationGeometry
            * @returns ElevationGeometry 地形网格
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.geometry;
            },
            enumerable: true,
            configurable: true
        });
        Terrain.prototype.onUpdateTransform = function () {
            _super.prototype.onUpdateTransform.call(this);
            if (this.lodQuadTree) {
                this.lodQuadTree.onUpdate(this.modelMatrix);
            }
        };
        /**
        * @language zh_CN
        * 开启或关闭LOD
        * @param useLod 开启或关闭
        * @version Egret 3.0
        * @platform Web,Native
        */
        Terrain.prototype.startLOD = function (useLod) {
            if (useLod && !this.lodQuadTree) {
                var eleGeo = this.geometry;
                if (eleGeo.segmentsW == eleGeo.segmentsH && (eleGeo.segmentsW & (eleGeo.segmentsW - 1)) == 0) {
                    this.vertex = this.geometry.getVertexForIndex(0, egret3d.VertexFormat.VF_POSITION, null, this.geometry.vertexCount);
                    this.lodQuadTree = new egret3d.LODQuadTree(this.vertex, eleGeo.segmentsW);
                    this.lodQuadTree.onUpdate(this.modelMatrix);
                }
                else {
                    egret3d.Egret3DLog.outError("地形宽高不相等或者不是2的N次方!");
                }
            }
            else {
                if (this.lodQuadTree) {
                    this.lodQuadTree.enable = false;
                }
            }
        };
        /**
        * @language zh_CN
        * @private
        */
        Terrain.prototype.update = function (time, delay, camera) {
            _super.prototype.update.call(this, time, delay, camera);
            if (this.lodQuadTree) {
                var index = 0;
                index = this.lodQuadTree.build(index, this.geometry.indexArray, this.cullCamrea ? this.cullCamrea : camera);
                this.geometry.indexCount = index;
                this.geometry.bufferDiry = true;
                this.geometry.subGeometrys[0].count = this.geometry.indexCount;
                if (!this.lodQuadTree.enable) {
                    this.lodQuadTree = null;
                }
            }
        };
        return Terrain;
    }(egret3d.Mesh));
    egret3d.Terrain = Terrain;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
        * @private
        */
        var BitmapFont = (function () {
            function BitmapFont() {
            }
            /**
            * @private
            */
            BitmapFont.load = function (data) {
                this._fontTextures = data;
            };
            /**
            * @private
            */
            BitmapFont.getTexture = function (unicode) {
                var texture = this._fontTextures[unicode];
                return texture;
            };
            return BitmapFont;
        }());
        gui.BitmapFont = BitmapFont;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.gui.DisplayObject
    * @classdesc 2D显示对象基础类,封装有坐标/尺寸/旋转/缩放/颜色/是否可见/遮罩信息；</p>
    * GUI中鼠标事件的捕获最底层对象。</p>
    * GUI树形结构的封装对象。
    * @includeExample gui/DisplayObject.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var DisplayObject = (function (_super) {
        __extends(DisplayObject, _super);
        function DisplayObject() {
            _super.call(this);
            /**
            * @private
            * 鼠标检测用的包围盒，不开放使用
            */
            this.aabb = new egret3d.Rectangle();
            /**
            * @language zh_CN
            * 是否响应鼠标检测
            */
            this.mouseEnable = true;
            /**
            * @language zh_CN
            * 孩子节点是否响应鼠标检测
            */
            this.mouseChildren = true;
            this._renderText = false;
            this._childs = [];
            this._child3Ds = [];
            this._rgbNumber = 0xffffff;
            this._alphaNumber = 1.0;
            this._color = new egret3d.ColorTransform();
            this._pivot = new egret3d.Vector3D();
            this._pos = new egret3d.Point();
            this._rot = new egret3d.Vector3D();
            this._sca = new egret3d.Vector3D(1.0, 1.0, 100.0, 100.0);
            this._globalColor = new egret3d.ColorTransform();
            this._globalPos = new egret3d.Point();
            this._globalRot = new egret3d.Vector3D();
            this._globalSca = new egret3d.Vector3D(1.0, 1.0, 100.0, 100.0);
            this._orientation = new egret3d.Quaternion();
            this._globalOrientation = new egret3d.Quaternion();
            this._localVisible = true;
            this._globalVisible = true;
            this._visibleChange = true;
            this._colorChange = true;
            this._transformChange = true;
            this._maskRectChange = true;
            this._transformInvalid = true;
            this._renderTextInvalid = true;
            this._maskRectInvalid = true;
            this._colorInvalid = true;
            this._textureInvalid = true;
            this._visibleInvalid = true;
            /**
            * @private
            * 是否父节点为stage对象，不对外开放
            */
            this.parentIsStage = false;
        }
        Object.defineProperty(DisplayObject.prototype, "mouseX", {
            /**
            * @language zh_CN
            * 获取鼠标在该显示对象的相对位置X
            * @returns 鼠标x方向位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                var temp = this;
                var x = egret3d.Input.mouseX;
                while (temp) {
                    x -= temp.x;
                    if (temp.parent && !temp.parentIsStage) {
                        temp = temp.parent;
                    }
                    else {
                        temp = null;
                    }
                }
                return x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "mouseY", {
            /**
            * @language zh_CN
            * 获取鼠标在该显示对象的相对位置Y
            * @returns 鼠标Y方向位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                var temp = this;
                var y = egret3d.Input.mouseY;
                while (temp) {
                    y -= temp.y;
                    if (temp.parent && !temp.parentIsStage) {
                        temp = temp.parent;
                    }
                    else {
                        temp = null;
                    }
                }
                return y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "stage", {
            /**
            * @language zh_CN
            * 获得当前舞台引用
            * @returns 所在舞台对象，有可能为null
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._stage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "childs", {
            /**
            * @language zh_CN
            * 获得子节点列表的引用
            * @returns DisplayObject的列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._childs;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "parent", {
            /**
            * @language zh_CN
            * 获得父亲节点，有可能为null
            * @returns DisplayObject 2d显示对象引用
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "renderText", {
            /**
            * @language zh_CN
            * 设定渲染类型，指定当前quad是否为textfield
            * @param value 渲染类型，true表示为文本
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (value != this._renderText) {
                    this._renderTextInvalid = true;
                    this._renderText = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "width", {
            /**
            * @language zh_CN
            * @returns 获取显示对象宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca.z;
            },
            /**
            * @language zh_CN
            * 设定宽度
            * @param value 宽度的数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (value != this._sca.z) {
                    this._sca.z = value;
                    this.updateTransformChange(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "height", {
            /**
            * @language zh_CN
            * 获得像素高度数据
            * @returns 像素高度数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () { return this._sca.w; },
            /**
            * @language zh_CN
            * 设定像素高度数据
            * @param value 高度数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (value != this._sca.w) {
                    this._sca.w = value;
                    this.updateTransformChange(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "pivotX", {
            /**
            * @language zh_CN
            * 获得注册点x位置
            * @returns 注册点x坐标数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () { return this._pivot.x; },
            /**
            * @language zh_CN
            * 设定注册点x位置
            * @param value 注册点x坐标数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (value != this._pivot.x) {
                    this._pivot.x = value;
                    this.updateTransformChange(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "pivotY", {
            /**
            * @language zh_CN
            * 获得注册点y位置
            * @returns 注册点y坐标数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () { return this._pivot.y; },
            /**
            * @language zh_CN
            * 设定注册点y位置
            * @param value 注册点y坐标数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (value != this._pivot.y) {
                    this._pivot.y = value;
                    this.updateTransformChange(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "pivotZ", {
            /**
            * @private
            */
            get: function () { return this._pivot.z; },
            /**
            * @language zh_CN
            * 设定注册点z位置
            * @param value 注册点z坐标数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (value != this._pivot.z) {
                    this._pivot.z = value;
                    this.updateTransformChange(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "mask", {
            /**
           * @language zh_CN
           * 获得遮罩信息
           * @returns Rectangle 遮罩信息
           * @version Egret 3.0
           * @platform Web,Native
           */
            get: function () {
                return this._localMaskRect;
            },
            /**
            * @language zh_CN
            * 设定遮罩范围
            * @param value 遮罩范围，数据将被拷贝进来
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (value == null && this._localMaskRect == null)
                    return;
                this._localMaskRect = this._localMaskRect || new egret3d.Rectangle();
                this._localMaskRect.copyFrom(value);
                this.updateMaskChange(true);
            },
            enumerable: true,
            configurable: true
        });
        DisplayObject.prototype.calculateTransform = function () {
            if (!this._transformChange)
                return;
            if (this._parent != null) {
                var parentOrientation = this._parent.globalOrientation;
                this._globalOrientation.multiply(parentOrientation, this._orientation);
                this._globalOrientation.toEulerAngles(this._globalRot);
                var parentScale = this._parent.globalScale;
                this._globalSca.copyFrom(parentScale.multiply(this._sca));
                DisplayObject.ThisPos.setTo(this._pos.x, this._pos.y, 0, 1);
                parentScale.multiply(DisplayObject.ThisPos);
                parentOrientation.transformVector(DisplayObject.ThisPos, DisplayObject.TargetPos);
                this._pos.x = DisplayObject.ThisPos.x;
                this._pos.y = DisplayObject.ThisPos.y;
                this._globalPos.x = DisplayObject.TargetPos.x;
                this._globalPos.y = DisplayObject.TargetPos.y;
                this._globalPos.incrementBy(this._parent.globalPosition);
            }
            else {
                this._globalOrientation.copyFrom(this._orientation);
                this._globalPos.copyFrom(this._pos);
                this._globalSca.copyFrom(this._sca);
                this._globalRot.copyFrom(this._rot);
            }
            this._transformChange = false;
            this.calculateMask();
            this.onUpdateTransform();
        };
        DisplayObject.prototype.calculateMask = function () {
            this.calculateTransform();
            if (!this._maskRectChange)
                return;
            if (this._parent) {
                if (this._localMaskRect) {
                    this._globalMaskRect = this._globalMaskRect || new egret3d.Rectangle();
                    this._globalMaskRect.x = this._localMaskRect.x * this._globalSca.x + this._globalPos.x;
                    this._globalMaskRect.y = this._localMaskRect.y * this._globalSca.y + this._globalPos.y;
                    this._globalMaskRect.width = this._localMaskRect.width * this._globalSca.x;
                    this._globalMaskRect.height = this._localMaskRect.height * this._globalSca.y;
                    if (this._parent.globalMask)
                        this._globalMaskRect.innerArea(this._parent.globalMask, this._globalMaskRect);
                }
                else {
                    if (this._parent.globalMask) {
                        this._globalMaskRect = this._globalMaskRect || new egret3d.Rectangle();
                        this._globalMaskRect.copyFrom(this._parent.globalMask);
                    }
                    else {
                        this._globalMaskRect = null;
                    }
                }
            }
            else {
                if (this._localMaskRect) {
                    this._globalMaskRect = this._globalMaskRect || new egret3d.Rectangle();
                    this._globalMaskRect.x = this._localMaskRect.x * this._globalSca.x + this._globalPos.x;
                    this._globalMaskRect.y = this._localMaskRect.y * this._globalSca.y + this._globalPos.y;
                    this._globalMaskRect.width = this._localMaskRect.width * this._globalSca.x;
                    this._globalMaskRect.height = this._localMaskRect.height * this._globalSca.y;
                }
                else {
                    this._globalMaskRect = null;
                }
            }
            this._maskRectChange = false;
        };
        DisplayObject.prototype.onUpdateTransform = function () {
        };
        /**
        * @language zh_CN
        * 添加孩子节点
        * @param object 被添加的孩子节点
        * @version Egret 3.0
        * @platform Web,Native
        */
        DisplayObject.prototype.addChild = function (object) {
            if (object instanceof DisplayObject)
                return this.doAddChildAt(object, egret3d.MathUtil.MAX_VALUE);
        };
        DisplayObject.prototype.addObject3D = function (obj) {
            if (obj)
                this._child3Ds.push(obj);
            return obj;
        };
        /**
        * @language zh_CN
        * 添加孩子节点至某个index位置
        * @param object 被添加的孩子节点
        * @param index 指定的层级关系index
        * @returns DisplayObject 如果添加成功，返回当前object对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        DisplayObject.prototype.addChildAt = function (object, index) {
            return this.doAddChildAt(object, index);
        };
        DisplayObject.prototype.doAddChildAt = function (object, index) {
            if (object == null)
                return null;
            if (object.parent) {
                throw Error("This object is already the other child object.");
            }
            if (this._childs.indexOf(object) >= 0) {
                throw Error("The same child object has been added.");
            }
            if (index < 0) {
                throw Error("Child index can not be small than 0 !");
            }
            if (index >= this._childs.length) {
                this._childs.push(object);
            }
            else {
                this._childs.splice(index, 0, object);
            }
            object._parent = this;
            this._stage && this._stage.setRenderListInvalid();
            object.activeStage(this._stage);
            return object;
        };
        /**
        * @language zh_CN
        * 移除某个孩子节点
        * @param object 被移除的孩子节点
        * @returns DisplayObject 如果移除成功，返回当前object对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        DisplayObject.prototype.removeChild = function (object) {
            return this.doRemoveChild(object);
        };
        /**
        * @language zh_CN
        * 移除指定层级的孩子节点
        * @param index 指定的层级
        * @returns DisplayObject 如果移除成功，返回当前object对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        DisplayObject.prototype.removeChildAt = function (index) {
            return this.doRemoveChild(this._childs[index]);
        };
        DisplayObject.prototype.doRemoveChild = function (object) {
            if (object == null)
                return null;
            var index = this._childs.indexOf(object);
            if (index == -1)
                throw Error("The display isn't a child of this container!");
            this._childs.splice(index, 1);
            object._parent = null;
            this._stage && this._stage.setRenderListInvalid();
            object.activeStage(null);
            return object;
        };
        /**
        * @language zh_CN
        * 交换孩子节点至指定的层级（未实现）
        * @param object 外部传入的将要交换的节点
        * @param index 指定的层级
        * @version Egret 3.0
        * @platform Web,Native
        */
        DisplayObject.prototype.swapChildIndex = function (object, index) {
        };
        /**
        * @language zh_CN、
        * @private
        * 变更舞台信息，从舞台移除或者添加到舞台后触发（不予开发者使用）
        * @param stage 最新的舞台数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        DisplayObject.prototype.activeStage = function (stage) {
            if (this._stage != stage) {
                this._stage = stage;
                this.updateMaskChange(true);
                this.updateTransformChange(true);
                this.updateColorChange(true);
                this.updateVisibleChange(true);
                for (var i = 0, count = this._childs.length; i < count; i++) {
                    this._childs[i].activeStage(stage);
                }
                this.onActiveStage();
            }
        };
        DisplayObject.prototype.onActiveStage = function () {
        };
        /**
        * @language zh_CN
        * 获取某个孩子节点的下标
        * @param object 显示对象
        * @returns number 下标数值，-1代表不含有这个显示对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        DisplayObject.prototype.hasChild = function (object) {
            return this.childs.indexOf(object);
        };
        /**
        * @language zh_CN
        * 根据下标获取孩子节点
        * @param index 下标
        * @returns DisplayObject 孩子节点，有可能为null
        * @version Egret 3.0
        * @platform Web,Native
        */
        DisplayObject.prototype.getChildByIndex = function (index) {
            return this.childs[index];
        };
        /**
        * @language zh_CN
        * 根据名字获取孩子节点
        * @param name 孩子节点的名字
        * @returns DisplayObject 孩子节点，有可能为null
        * @version Egret 3.0
        * @platform Web,Native
        */
        DisplayObject.prototype.getChildByName = function (name) {
            if (!name)
                return null;
            var child;
            for (var _i = 0, _a = this._childs; _i < _a.length; _i++) {
                child = _a[_i];
                if (child.name == name)
                    return child;
            }
            return null;
        };
        /**
        * @language zh_CN
        * 在渲染之前逻辑更新，每帧执行一次
        * @param time 当前运行的总时间
        * @param delay 振间隔时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        DisplayObject.prototype.update = function (time, delay) {
            this.globalPosition;
            this.globalRotation;
            this.globalScale;
            this.globalColor;
            this.globalVisible;
            this.globalMask;
            this.updateMouseAABB();
        };
        DisplayObject.prototype.updateMouseAABB = function () {
            if (this.mouseEnable) {
                var pos = this.globalPosition;
                var sca = this.globalScale;
                if (this._maskRectInvalid || this._transformInvalid) {
                    //更新mouse aabb
                    this.aabb.x = pos.x;
                    this.aabb.y = pos.y;
                    //inner mask
                    this.aabb.width = this.width * sca.x;
                    this.aabb.height = this.height * sca.y;
                    if (this.globalMask) {
                        this.aabb.innerArea(this.globalMask, this.aabb);
                    }
                }
                else {
                }
            }
            else {
                this.aabb.setTo(0, 0, 0, 0);
            }
        };
        DisplayObject.prototype.updateMaskChange = function (change) {
            if (this._maskRectChange == change)
                return;
            this._maskRectChange = change;
            this._maskRectInvalid = change;
            for (var i = 0; i < this._childs.length; ++i) {
                this._childs[i].updateMaskChange(change);
            }
        };
        /**
        * @language zh_CN
        * 设置缩放/旋转/位移信息状态
        * @param change 是否有更新
        * @version Egret 3.0
        * @platform Web,Native
        */
        DisplayObject.prototype.updateTransformChange = function (change) {
            if (this._transformChange == change)
                return;
            this._transformChange = change;
            this._transformInvalid = change;
            for (var i = 0; i < this._childs.length; ++i) {
                this._childs[i].updateTransformChange(change);
            }
            this.updateMaskChange(change);
        };
        DisplayObject.prototype.updateVisibleChange = function (change) {
            if (this._visibleChange == change)
                return;
            this._visibleChange = change;
            this._visibleInvalid = change;
            for (var i = 0; i < this._childs.length; ++i) {
                this._childs[i].updateVisibleChange(change);
            }
        };
        Object.defineProperty(DisplayObject.prototype, "globalVisible", {
            /**
            * @private
            */
            get: function () {
                if (this._visibleChange) {
                    if (this._parent) {
                        this._globalVisible = this._localVisible && this._parent.globalVisible;
                    }
                    else {
                        this._globalVisible = this._localVisible;
                    }
                    this._visibleChange = false;
                }
                return this._globalVisible;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "visible", {
            /**
            * @language zh_CN
            * 获取是否可见
            * @returns boolean 是否可见
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._localVisible;
            },
            /**
            * @language zh_CN
            * 设置可见信息
            * @param value 是否可见
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._localVisible != value) {
                    this._localVisible = value;
                    this.updateVisibleChange(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 设置颜色变换信息状态
        * @param change 是否有更新
        * @version Egret 3.0
        * @platform Web,Native
        */
        DisplayObject.prototype.updateColorChange = function (change) {
            if (this._colorChange == change)
                return;
            this._colorChange = change;
            this._colorInvalid = change;
            for (var i = 0; i < this._childs.length; ++i) {
                this._childs[i].updateColorChange(change);
            }
        };
        Object.defineProperty(DisplayObject.prototype, "globalX", {
            /**
            * @private
            */
            get: function () {
                return this.globalPosition.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "globalY", {
            /**
            * @private
            * @language zh_CN
            * 返回 object 世界位置 y
            * @returns object 世界位置 y
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalPosition.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "globalPosition", {
            /**
            * @language zh_CN
            * 返回 object 世界位置
            * 返回世界坐标系的 全局位置坐标
            * @returns object 世界位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.calculateTransform();
                }
                return this._globalPos;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "globalRotationX", {
            /**
            * @private
            * @language zh_CN
            * 设置 object 世界位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public set globalPosition(pos: Point) {
            //    if (this._parent) {
            //        this._parent.globalOrientation.inverse(this._qut);
            //        var vec: Vector3D = DisplayObject.ThisVector;
            //        vec.setTo(this._parent.globalPosition.x - pos.x, this._parent.globalPosition.x - pos.x, 0, 1);
            //        this._qut.transformVector(vec, vec);
            //        vec.divided(this._parent.globalScale, vec);
            //        this.position.setTo(vec.x, vec.y);
            //    }
            //    else {
            //        this.position = pos;
            //    }
            //}
            /**
            * @private
            * @language zh_CN
            * 返回 object 世界旋转x
            * @returns object 世界旋转x
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalRotation.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "globalRotationY", {
            /**
            * @private
            * @language zh_CN
            * 返回 object 世界旋转y
            * @returns object 世界旋转y
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalRotation.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "globalRotationZ", {
            /**
            * @private
            * @language zh_CN
            * 返回 object 世界旋转z
            * @returns object 世界旋转z
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalRotation.z;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "globalRotation", {
            /**
            * @private
            * @language zh_CN
            * 返回 object 世界旋转
            * 返回世界坐标系的 全局旋转信息
            * @returns object 世界旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.calculateTransform();
                }
                return this._globalRot;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "globalScale", {
            /**
            * @private
            * @language zh_CN
            * 设置 object 世界旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public set globalRotation(rot: Vector3D) {
            //    this._qut.fromEulerAngles(rot.x, rot.y, rot.z);
            //    this.globalOrientation = this._qut;
            //}
            /**
            * @private
            * @language zh_CN
            * 返回 object 世界缩放
            * 返回世界坐标系的 全局缩放信息
            * @returns object 世界缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.calculateTransform();
                }
                return this._globalSca;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "globalScaleX", {
            /**
            * @private
            * @language zh_CN
            * 获取 object 世界缩放 x
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalScale.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "globalScaleY", {
            /**
            * @private
            * @language zh_CN
            * 获取 object 世界缩放 y
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalScale.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "globalScaleZ", {
            /**
            * @private
            * @language zh_CN
            * 获取 object 世界缩放 z
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.globalScale.z;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "globalOrientation", {
            /**
            * @private
            * @language zh_CN
            * 返回 object 世界旋转 四元数
            * 返回世界坐标系的 全局旋转信息，数据类型是 四元素
            * @returns object 世界旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.calculateTransform();
                }
                return this._globalOrientation;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "globalMask", {
            /**
            * @private
            */
            get: function () {
                if (this._maskRectChange) {
                    this.calculateMask();
                }
                return this._globalMaskRect;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "position", {
            /**
            * @language zh_CN
            * 返回位移。</p>
            * 获取容器的坐标位置，基于父节点的位置坐标。</p>
            * @returns 位移
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos;
            },
            /**
            * @language zh_CN
            * 设置位移。</p>
            * 设置基于父节点的位置坐标，当父容器发生变化时，子节点也会变化。</p>
            * @param vec 位移
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (vec) {
                this._pos.copyFrom(vec);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "rotation", {
            /**
            * @language zh_CN
            * 返回旋转。</p>
            * 获取容器的旋转信息，基于父节点的旋转信息 欧拉角信息。</p>
            * @returns 旋转 欧拉角信息
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot;
            },
            /**
            * @language zh_CN
            * 设置旋转 。</p>
            * 设置基于父节点的旋转信息 欧拉角信息，当父容器发生变化时，子节点也会变化。</p>
            * @param vec 旋转 欧拉角信息
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._rot.x = value.x;
                this._rot.y = value.y;
                this._rot.z = value.z;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "orientation", {
            /**
            * @language zh_CN
            * 返回旋转。</p>
            * 返回 基于四元素的旋转信息。</p>
            * @returns 旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._orientation;
            },
            /**
            * @language zh_CN
            * 设置旋转。</p>
            * 设置旋转 基于四元素 旋转信息，当父容器发生变化时，子节点也会变化。</p>
            * @param value 旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._orientation.copyFrom(value);
                this._orientation.toEulerAngles(this._rot);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "orientationX", {
            /**
            * @language zh_CN
            * 设置旋转 分量x
            * @param value 分量x
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._orientation.x == value)
                    return;
                this._orientation.x = value;
                this._orientation.toEulerAngles(this._rot);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "orientationY", {
            /**
            * @language zh_CN
            * 设置旋转 分量y
            * @param value 分量y
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._orientation.y == value)
                    return;
                this._orientation.y = value;
                this._orientation.toEulerAngles(this._rot);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "orientationZ", {
            /**
            * @language zh_CN
            * 设置旋转 分量z
            * @param value 分量z
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._orientation.z == value)
                    return;
                this._orientation.z = value;
                this._orientation.toEulerAngles(this._rot);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "orientationW", {
            /**
            * @language zh_CN
            * 设置旋转 分量w
            * @param value 分量w
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._orientation.w == value)
                    return;
                this._orientation.w = value;
                this._orientation.toEulerAngles(this._rot);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "scale", {
            /**
            * @language zh_CN
            * 返回缩放。</p>
            * 返回基于父容器的缩放信息。</p>
            * @returns 缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca;
            },
            /**
            * @language zh_CN
            * 设置缩放。</p>
            * 设置基于父容器的缩放信息，当父容器发生变化时，子节点也会变化。</p>
            * @param vec 缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                this._sca = val;
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "x", {
            /**
            * @language zh_CN
            * 返回x坐标
            * 返回基于父容器的位置坐标信息值
            * @returns x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos.x;
            },
            /**
            * @language zh_CN
            * 设置x坐标。</p>
            * 设置基于父容器的位置信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._pos.x == value)
                    return;
                this._pos.x = value;
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "y", {
            /**
            * @language zh_CN
            * 返回y坐标
            *
            * 返回基于父容器的位置坐标信息值
            * @returns y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos.y;
            },
            /**
            * @language zh_CN
            * 设置y坐标。</p>
            * 设置基于父容器的位置信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._pos.y == value)
                    return;
                this.updateTransformChange(true);
                this._pos.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "rotationX", {
            /**
            * @language zh_CN
            * 返回x旋转
            *
            * 返回基于父容器的位置旋转信息值
            * @returns x旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot.x;
            },
            /**
            * @language zh_CN
            * 设置x轴旋转。</p>
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value x轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._rot.x == value)
                    return;
                this._rot.x = value;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "rotationY", {
            /**
            * @language zh_CN
            * 返回y旋转
            *
            * 返回基于父容器的位置旋转信息值
            * @returns y旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot.y;
            },
            /**
            * @language zh_CN
            * 设置y轴旋转。</p>
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value y轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._rot.y == value)
                    return;
                this._rot.y = value;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "rotationZ", {
            /**
            * @language zh_CN
            * 返回z旋转
            *
            * 返回基于父容器的位置旋转信息值
            * @returns z旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot.z;
            },
            /**
            * @language zh_CN
            * 设置z轴旋转。</p>
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变。</p>
            * @param value z轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._rot.z == value)
                    return;
                this._rot.z = value;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "scaleX", {
            /**
            * @language zh_CN
            * 返回x缩放
            * 返回基于父容器的缩放信息值
            * @returns x缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca.x;
            },
            /**
            * @language zh_CN
            * 设置x轴缩放。</p>
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value x轴缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._sca.x == value)
                    return;
                this._sca.x = value;
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "scaleY", {
            /**
            * @language zh_CN
            * 返回y缩放
            * 返回基于父容器的缩放信息值
            * @returns y缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca.y;
            },
            /**
            * @language zh_CN
            * 设置y轴缩放
            *
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value y轴缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._sca.y == value)
                    return;
                this.updateTransformChange(true);
                this._sca.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "globalColor", {
            /**
            * private
            */
            get: function () {
                if (this._colorChange) {
                    this._color.alpha = this._alphaNumber;
                    this._color.setColorRGB(this._rgbNumber);
                    if (this._parent) {
                        this._globalColor.multiply(this._parent.globalColor);
                    }
                    else {
                        this._globalColor.copyFrom(this._color);
                    }
                    this._colorChange = false;
                }
                return this._color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "color", {
            /**
            * @language zh_CN
            * 返回颜色值 0xffffff格式
            * @returns color
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rgbNumber;
            },
            /**
            * @language zh_CN
            * 设置颜色 0xffffff格式
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._rgbNumber != value) {
                    this._rgbNumber = value;
                    this.updateColorChange(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DisplayObject.prototype, "alpha", {
            /**
            * @language zh_CN
            * 获得alpha值，[0,1]之间的一个数
            * @returns number alpha
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._alphaNumber;
            },
            /**
            * @language zh_CN
            * 设置alpha值[0,1]之间的一个数
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._alphaNumber = value;
                if (this._alphaNumber != value) {
                    this._alphaNumber = value;
                    this.updateColorChange(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        DisplayObject.ThisVector = new egret3d.Vector3D();
        DisplayObject.ThisPos = new egret3d.Vector3D();
        DisplayObject.TargetPos = new egret3d.Vector3D();
        return DisplayObject;
    }(egret3d.EventDispatcher));
    egret3d.DisplayObject = DisplayObject;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var QuadData = (function () {
        function QuadData() {
        }
        QuadData.buildGeometry = function (geometry, start, numberQuad) {
            var geometry = geometry;
            geometry.vertexFormat = egret3d.VertexFormat.VF_QUAD_POS | egret3d.VertexFormat.VF_QUAD_ORIGN | egret3d.VertexFormat.VF_QUAD_UVREC | egret3d.VertexFormat.VF_QUAD_ROTATION | egret3d.VertexFormat.VF_QUAD_MASK | egret3d.VertexFormat.VF_QUAD_COLOR;
            var subGeometry = new egret3d.SubGeometry();
            geometry.vertexCount = numberQuad * 4;
            geometry.indexCount = QuadData.singleQuadIndex.length * numberQuad;
            var zIndex = 0;
            var offset = 0;
            for (var i = 0; i < numberQuad; i++) {
                zIndex = (i + start);
                QuadData.singleQuadData[0 * QuadData.vertexLen + 2] = zIndex;
                QuadData.singleQuadData[1 * QuadData.vertexLen + 2] = zIndex;
                QuadData.singleQuadData[2 * QuadData.vertexLen + 2] = zIndex;
                QuadData.singleQuadData[3 * QuadData.vertexLen + 2] = zIndex;
                offset = i * 4 * geometry.vertexAttLength;
                for (var j1 = 0; j1 < QuadData.singleQuadData.length; j1++) {
                    geometry.vertexArray[offset + j1] = QuadData.singleQuadData[j1];
                }
                for (var j2 = 0; j2 < QuadData.singleQuadIndex.length; j2++) {
                    geometry.indexArray[i * QuadData.singleQuadIndex.length + j2] = QuadData.singleQuadIndex[j2] + 4 * i;
                }
            }
            subGeometry.geometry = geometry;
            subGeometry.start = 0;
            subGeometry.count = geometry.indexCount;
            geometry.subGeometrys.push(subGeometry);
            geometry.vertexAttLength = QuadData.vertexLen;
        };
        QuadData.singleQuadData = [
            /*pos*/ 0.0, 0.0, 100000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            /*pos*/ 0.0, 0.0, 100000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            /*pos*/ 0.0, 0.0, 100000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            /*pos*/ 0.0, 0.0, 100000.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0
        ];
        QuadData.vertexLen = 24;
        QuadData.posOffest = 0;
        QuadData.posSize = 4; //(width, height, zIndex, ?)
        QuadData.originalOffset = 4;
        QuadData.originalSize = 4; //(x, y, texId, boolList)
        QuadData.uvRectangleOffest = 8;
        QuadData.uvRectangleSize = 4; //(U, V, scaleX, scaleY)
        QuadData.rotationOffest = 12;
        QuadData.rotationSize = 4; //(x, y, z, w)
        QuadData.maskOffset = 16;
        QuadData.maskSize = 4; //(maskX, maskY, maskWidth, maskHeight)
        QuadData.colorOffest = 20;
        QuadData.colorSize = 4; //(r, g, b, a)
        QuadData.singleQuadIndex = [0, 2, 1, 0, 3, 2];
        QuadData.vertexBytes = QuadData.vertexLen * 4;
        QuadData.quadVertexLen = QuadData.vertexLen * 4;
        return QuadData;
    }());
    egret3d.QuadData = QuadData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Quad
    * @classdesc
    * gui中基础显示单元</p>
    * 在这个class中，主要完成更新顶点数据，更新贴图。</p>
    * @see egret3d.DisplayObject
    * @includeExample gui/Quad.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Quad = (function (_super) {
        __extends(Quad, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Quad() {
            _super.call(this);
            this._globalIndex = -1; //记录上一次在全局位置的下标
            this._boolArray = new egret3d.BooleanArray();
        }
        Object.defineProperty(Quad.prototype, "texture", {
            /**
            * @language zh_CN
            * Quad对象中的Texture
            * @returns Quad对象中的Texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._texture;
            },
            /**
            * @language zh_CN
            * Quad对象中的Texture
            * @param value Quad对象中的Texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (!value) {
                    this.setTexture(value);
                    return;
                }
                if (value instanceof egret3d.Texture) {
                    this.setTexture(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Quad.prototype.setTexture = function (value) {
            if (value !== this._texture) {
                this._texture = value;
                this._textureInvalid = true;
            }
        };
        /**
        * @language zh_CN
        * 在渲染之前逻辑更新顶点数据，只有发生数据变化才需要更新顶点
        * @param zIndex 在geometry中下标
        * @param geometry 当前quad所在geometry
        * @param globalIndex 全局下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quad.prototype.updateVertices = function (zIndex, geometry, globalIndex) {
            if (!geometry.sharedVertexBuffer || !geometry.sharedVertexBuffer.arrayBuffer)
                return;
            var pos = this.globalPosition;
            var rot = this.globalRotation;
            var sca = this.globalScale;
            if (this._globalIndex != globalIndex) {
                this._globalIndex = globalIndex;
                this._colorInvalid = this._transformInvalid = this._renderTextInvalid = this._textureInvalid = this._visibleInvalid = this._maskRectInvalid = true;
                this._boolArray.clear();
            }
            if (this._visibleInvalid) {
                this._visibleInvalid = false;
                this._boolArray.setBoolean(Quad.FLAG_IS_VISIBLE, this.globalVisible);
            }
            //一个真实的quad，而不是geometry中没有用到的部分
            this._boolArray.setBoolean(Quad.FLAG_VALLID_QUAD, true);
            //
            var index = 0;
            var positionFrom;
            var positionOffset = geometry.vertexAttLength;
            var verticesData = geometry.sharedVertexBuffer.arrayBuffer;
            if (this._transformInvalid) {
                this._transformInvalid = false;
                //________________(x,y)
                positionFrom = zIndex * egret3d.QuadData.quadVertexLen + egret3d.QuadData.originalOffset;
                for (var i = 0; i < 4; i++) {
                    index = positionFrom + i * positionOffset;
                    if (this._renderText) {
                        verticesData[index] = pos.x >> 0;
                        verticesData[index + 1] = -pos.y >> 0;
                    }
                    else {
                        verticesData[index] = pos.x;
                        verticesData[index + 1] = -pos.y;
                    }
                }
                //____________________(width,height)
                positionFrom = zIndex * egret3d.QuadData.quadVertexLen + egret3d.QuadData.posOffest;
                //0
                index = positionFrom + 0 * positionOffset;
                verticesData[index] = 0;
                verticesData[index + 1] = 0;
                //1
                index = positionFrom + 1 * positionOffset;
                verticesData[index] = this.width;
                verticesData[index + 1] = 0;
                //2
                index = positionFrom + 2 * positionOffset;
                verticesData[index] = this.width;
                verticesData[index + 1] = -this.height;
                //3
                index = positionFrom + 3 * positionOffset;
                verticesData[index] = 0;
                verticesData[index + 1] = -this.height;
                //____________________(scale x y)
                positionFrom = zIndex * egret3d.QuadData.quadVertexLen + egret3d.QuadData.uvRectangleOffest;
                for (var i = 0; i < 4; i++) {
                    index = positionFrom + i * positionOffset;
                    verticesData[index + 2] = sca.x;
                    verticesData[index + 3] = sca.y;
                }
                //____________________(rotation xyzw )
                //rotation upload GPU , on GPU caculate;
                var quaternion = egret3d.Quaternion.HELP_0;
                quaternion.fromEulerAngles(this._globalRot.x, this._globalRot.y, this._globalRot.z);
                positionFrom = zIndex * egret3d.QuadData.quadVertexLen + egret3d.QuadData.rotationOffest;
                for (var i = 0; i < 4; i++) {
                    index = positionFrom + i * positionOffset;
                    verticesData[index] = quaternion.x;
                    verticesData[index + 1] = quaternion.y;
                    verticesData[index + 2] = quaternion.z;
                    verticesData[index + 3] = quaternion.w;
                }
            }
            if (this._renderTextInvalid) {
                this._renderTextInvalid = false;
                this._boolArray.setBoolean(Quad.FLAG_IS_TEXTFIELD, this._renderText);
            }
            if (this._textureInvalid) {
                this._textureInvalid = false;
                this._boolArray.setBoolean(Quad.FLAG_HAS_TEXTURE, this._texture != null);
                //____________________gui index
                var texId = 0;
                var uvRec;
                if (this._texture) {
                    uvRec = this._texture.uvRectangle;
                    //use gui index
                    texId = this._texture.guiIndex;
                    positionFrom = zIndex * egret3d.QuadData.quadVertexLen + egret3d.QuadData.uvRectangleOffest;
                    index = positionFrom + 0 * positionOffset;
                    verticesData[index] = uvRec.x;
                    verticesData[index + 1] = uvRec.y;
                    index = positionFrom + 1 * positionOffset;
                    verticesData[index] = uvRec.x + uvRec.width;
                    verticesData[index + 1] = uvRec.y;
                    index = positionFrom + 2 * positionOffset;
                    verticesData[index] = uvRec.x + uvRec.width;
                    verticesData[index + 1] = uvRec.y + uvRec.height;
                    index = positionFrom + 3 * positionOffset;
                    verticesData[index] = uvRec.x;
                    verticesData[index + 1] = uvRec.y + uvRec.height;
                    //____________________texId;
                    positionFrom = zIndex * egret3d.QuadData.quadVertexLen + egret3d.QuadData.originalOffset;
                    for (var i = 0; i < 4; i++) {
                        index = positionFrom + i * positionOffset;
                        verticesData[index + 2] = texId;
                    }
                }
            }
            if (this._maskRectInvalid) {
                this._maskRectInvalid = false;
                //____________________mask x y width height
                var maskRect = this.globalMask;
                this._boolArray.setBoolean(Quad.FLAG_HAS_MASK, maskRect != null);
                var maskX, maskY, maskW, maskH;
                if (maskRect) {
                    maskX = maskRect.x;
                    maskY = maskRect.y;
                    maskW = maskRect.width;
                    maskH = maskRect.height;
                    positionFrom = zIndex * egret3d.QuadData.quadVertexLen + egret3d.QuadData.maskOffset;
                    for (var i = 0; i < 4; i++) {
                        index = positionFrom + i * positionOffset;
                        verticesData[index + 0] = maskX;
                        verticesData[index + 1] = maskY;
                        verticesData[index + 2] = maskW;
                        verticesData[index + 3] = maskH;
                    }
                }
            }
            if (this._colorInvalid) {
                //____________________rgba
                //calc global color
                var clrAlpha = this.globalColor.alpha;
                var tempVector = Quad.TempVector;
                this.globalColor.m44.transformVector(Quad.IdentityVector, tempVector);
                positionFrom = zIndex * egret3d.QuadData.quadVertexLen + egret3d.QuadData.colorOffest;
                for (var i = 0; i < 4; i++) {
                    index = positionFrom + i * positionOffset;
                    verticesData[index] = tempVector.x;
                    verticesData[index + 1] = tempVector.y;
                    verticesData[index + 2] = tempVector.z;
                    verticesData[index + 3] = clrAlpha;
                }
                this._colorInvalid = false;
            }
            //merge boolList
            if (this._boolArray.dirty) {
                var makeRes = this._boolArray.makeResult;
                positionFrom = zIndex * egret3d.QuadData.quadVertexLen + egret3d.QuadData.originalOffset;
                for (var i = 0; i < 4; i++) {
                    index = positionFrom + i * positionOffset;
                    verticesData[index + 3] = makeRes;
                }
            }
        };
        Quad.prototype.onActiveStage = function () {
            _super.prototype.onActiveStage.call(this);
            this._globalIndex = -1;
        };
        /**
        * @private
        * @language zh_CN
        * 在渲染之前清理某个下标位置的顶点数据，标记为null状态
        * @param zIndex 在geometry中下标
        * @param geometry 当前quad所在geometry
        * @version Egret 3.0
        * @platform Web,Native
        */
        Quad.clear = function (zIndex, geometry) {
            if (geometry.sharedVertexBuffer && geometry.sharedVertexBuffer.arrayBuffer) {
                var verticesData = geometry.sharedVertexBuffer.arrayBuffer;
                //null 
                var index;
                var positionFrom = zIndex * egret3d.QuadData.quadVertexLen + egret3d.QuadData.originalOffset;
                for (var i = 0; i < 4; i++) {
                    index = positionFrom + i * geometry.vertexAttLength;
                    verticesData[index + 3] = 0;
                }
            }
        };
        Quad.FLAG_VALLID_QUAD = 0;
        Quad.FLAG_IS_VISIBLE = 1;
        Quad.FLAG_HAS_MASK = 2;
        Quad.FLAG_HAS_TEXTURE = 3;
        Quad.FLAG_IS_TEXTFIELD = 4;
        Quad.IdentityVector = new egret3d.Vector3D(1, 1, 1, 1);
        Quad.TempVector = new egret3d.Vector3D();
        Quad.DefaultUVRect = new egret3d.Rectangle(0, 0, 1, 1);
        return Quad;
    }(egret3d.DisplayObject));
    egret3d.Quad = Quad;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var GUIEventFire = (function () {
        function GUIEventFire(quadStage) {
            this._mouseList = [];
            this._lastMouseList = [];
            this._quadStage = quadStage;
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_DOWN, this.mouseDown, this, null, Number.MAX_VALUE);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.mouseUp, this, null, Number.MAX_VALUE);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_OVER, this.mouseOver, this, null, Number.MAX_VALUE);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_CLICK, this.mouseClick, this, null, Number.MAX_VALUE);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_MOVE, this.mouseMove, this, null, Number.MAX_VALUE);
            egret3d.Input.addEventListener(egret3d.MouseEvent3D.MOUSE_OUT, this.mouseOut, this, null, Number.MAX_VALUE);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_START, this.mouseDown, this, null, Number.MAX_VALUE);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_END, this.mouseUp, this, null, Number.MAX_VALUE);
            egret3d.Input.addEventListener(egret3d.TouchEvent3D.TOUCH_MOVE, this.mouseMove, this, null, Number.MAX_VALUE);
        }
        GUIEventFire.prototype.dispatchMouseEvent = function (e) {
            //todo 事件冒泡加入捕获阶段
            //todo 事件阻断机制
            var eventType = e.eventType;
            if (eventType === egret3d.TouchEvent3D.TOUCH_START) {
                eventType = egret3d.MouseEvent3D.MOUSE_DOWN;
            }
            else if (eventType === egret3d.TouchEvent3D.TOUCH_END) {
                eventType = egret3d.MouseEvent3D.MOUSE_UP;
            }
            else if (eventType === egret3d.TouchEvent3D.TOUCH_MOVE) {
                eventType = egret3d.MouseEvent3D.MOUSE_MOVE;
            }
            if (eventType === egret3d.MouseEvent3D.MOUSE_MOVE) {
                this._lastMouseList = this._mouseList;
            }
            var list = this.getMousePickList();
            var target;
            var currentTraget;
            if (list.length === 0) {
                //当没有任何对象被点击时. 抛出舞台事件
                var evt = new egret3d.MouseEvent3D(eventType);
                this._quadStage.dispatchEvent(evt);
                return;
            }
            e.stopImmediatePropagation();
            target = list[0]; //最上层显示对象
            currentTraget = target;
            while (currentTraget) {
                var event = new egret3d.MouseEvent3D(eventType);
                currentTraget.dispatchEvent(event);
                if (!currentTraget.parentIsStage) {
                    currentTraget = currentTraget.parent;
                }
                else {
                    currentTraget = null;
                }
            }
            var stageEvent = new egret3d.MouseEvent3D(eventType);
            this._quadStage.dispatchEvent(stageEvent);
        };
        GUIEventFire.prototype.onTouchStart = function (e) {
        };
        GUIEventFire.prototype.onTouchEnd = function (e) {
        };
        GUIEventFire.prototype.onTouchMove = function (e) {
        };
        GUIEventFire.prototype.mouseOut = function (e) {
            this.dispatchMouseEvent(e);
        };
        GUIEventFire.prototype.mouseDown = function (e) {
            this.dispatchMouseEvent(e);
        };
        GUIEventFire.prototype.mouseUp = function (e) {
            this.dispatchMouseEvent(e);
        };
        GUIEventFire.prototype.mouseOver = function (e) {
            this.dispatchMouseEvent(e);
        };
        GUIEventFire.prototype.mouseMove = function (e) {
            this.dispatchMouseEvent(e);
        };
        GUIEventFire.prototype.mouseClick = function (e) {
            this.dispatchMouseEvent(e);
        };
        GUIEventFire.prototype.fire = function () {
            this._finalist = this._quadStage.quadList;
        };
        GUIEventFire.prototype.getGlobalRect = function (dis) {
            var rect = new egret3d.Rectangle();
            rect.copyFrom(dis.aabb);
            dis = dis.parent;
            while (dis) {
                rect.x += dis.x;
                rect.y += dis.y;
                dis = dis.parent;
            }
            return rect;
        };
        GUIEventFire.prototype.getMousePickList = function () {
            var i;
            this._mouseList.length = 0;
            var quad;
            if (this._finalist) {
                for (i = 0; i < this._finalist.length; i++) {
                    quad = this._finalist[i];
                    //                    console.log("quad.aabb: ", quad.aabb);
                    //                    console.log("mouseX: ", Input.mouseX, "mouseY: ", Input.mouseY);
                    if (quad.globalVisible && quad.mouseEnable && quad.aabb.inner(egret3d.Input.mouseX, egret3d.Input.mouseY)) {
                        this._mouseList.push(quad);
                    }
                }
            }
            this._mouseList.reverse();
            return this._mouseList;
        };
        return GUIEventFire;
    }());
    egret3d.GUIEventFire = GUIEventFire;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var QuadMesh = (function (_super) {
        __extends(QuadMesh, _super);
        function QuadMesh(start) {
            _super.call(this, new egret3d.Geometry(), new egret3d.TextureMaterial());
            this.startQuad = 0;
            this.numberQuad = 0;
            this.quadList = [];
            this.startQuad = start;
            this.numberQuad = egret3d.QuadStage.moreQuad;
            this.geometry.drawType = egret3d.Context3DProxy.gl.DYNAMIC_DRAW;
            egret3d.QuadData.buildGeometry(this.geometry, start, egret3d.QuadStage.moreQuad);
            this.guiMethod = new egret3d.GUIMethod();
            this.enableCulling = false;
            this.uiMaterial = this.material;
            this.uiMaterial.blendMode = egret3d.BlendMode.ALPHA;
            this.uiMaterial.repeat = true;
            this.uiMaterial.diffusePass.addMethod(this.guiMethod);
            this.enablePick = false;
            this.tag.name = "gui";
        }
        /*
        *@private
        */
        QuadMesh.prototype.setTexture = function (index, texture) {
            this.guiMethod.setTextures(index, texture);
        };
        return QuadMesh;
    }(egret3d.Mesh));
    egret3d.QuadMesh = QuadMesh;
    /*
    *@private
    * GUI的根容器
    */
    var GUIRootContainer = (function (_super) {
        __extends(GUIRootContainer, _super);
        function GUIRootContainer() {
            _super.call(this);
        }
        GUIRootContainer.prototype.dispose = function () {
            //啥也不干
        };
        return GUIRootContainer;
    }(egret3d.Object3D));
    egret3d.GUIRootContainer = GUIRootContainer;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var GUITextureGroup = (function () {
        function GUITextureGroup() {
            this._nextIndex = 0;
            this._textures = [];
            for (var i = 0; i < GUITextureGroup.MAX_COUNT; i++) {
                this._textures[i] = egret3d.CheckerboardTexture.texture;
            }
        }
        /**
        * @language zh_CN
        * @private
        * 注册一张UI贴图，最多支持7张
        * @param texture 将要注册的贴图
        * @returns boolean 是否注册成功
        * @version Egret 3.0
        * @platform Web,Native
        */
        GUITextureGroup.prototype.register = function (texture) {
            if (this._nextIndex >= GUITextureGroup.MAX_COUNT)
                return false;
            if (this._textures.indexOf(texture) >= 0)
                return false;
            this._textures[this._nextIndex] = texture;
            texture.guiIndex = this._nextIndex;
            this._nextIndex++;
            return true;
        };
        /**
        * @language zh_CN
        * @private
        * 替换一张UI贴图至指定下标位置
        * @param texture 将要注册的贴图
        * @param index 指定下标位置
        * @returns boolean 是否注册成功
        * @version Egret 3.0
        * @platform Web,Native
        */
        GUITextureGroup.prototype.replace = function (texture, index) {
            if (index < 0 || index >= GUITextureGroup.MAX_COUNT)
                throw new Error("index error");
            var last = this._textures[index];
            this._textures[index] = texture;
            return last;
        };
        /**
        * @language zh_CN
        * @private
        * 渲染之前，将贴图信息绑定至mesh中
        * @param mesh 绑定至目标mesh对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        GUITextureGroup.prototype.activeTexture = function (mesh) {
            for (var i = 0; i < GUITextureGroup.MAX_COUNT; i++) {
                mesh.setTexture(i, this._textures[i]);
            }
        };
        GUITextureGroup.MAX_COUNT = 7;
        return GUITextureGroup;
    }());
    egret3d.GUITextureGroup = GUITextureGroup;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.QuadStage
    * @classdesc
    * GUI的舞台对象，引擎会自动创建该对象
    * @see egret3d.QuadStage
    * @version Egret 3.0
    * @platform Web,Native
    */
    var QuadStage = (function (_super) {
        __extends(QuadStage, _super);
        /**
        * @private
        * @constructor
        * @classdesc
        * gui中基础的2d显示单元</p>
        * 在这个class中，主要完成更新顶点数据。</p>
        * @version Egret 3.0
        * @platform Web,Native
        */
        function QuadStage(view3D) {
            _super.call(this);
            this._childList = [];
            this._quadMeshs = [];
            this._quadCurHistory = [];
            this._quadLastHistory = [];
            this._renderListInvalid = false;
            this.x = 0;
            this.y = 0;
            this.width = 0;
            this.height = 0;
            /*
            * @private
            */
            this.quadList = [];
            this._view3D = view3D;
            this._guiEventFire = new egret3d.GUIEventFire(this);
            this._textureGroup = new egret3d.GUITextureGroup();
            this._guiContainer = new egret3d.GUIRootContainer();
            this.changeCamera();
        }
        /**
        * @private
        * @language zh_CN
        * 注册ui用到的贴图素材源，最多7张。
        * @param texture gui所用到的贴图
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadStage.prototype.registerTexture = function (texture) {
            return this._textureGroup.register(texture);
        };
        /*
        *@private
        */
        QuadStage.prototype.changeCamera = function () {
            if (this._guiContainer.parent)
                this._guiContainer.parent.removeChild(this._guiContainer);
            this._view3D.camera3D.addChild(this._guiContainer);
        };
        QuadStage.prototype.creatQuadMesh = function () {
            var quadMesh = new egret3d.QuadMesh(this._quadMeshs.length * QuadStage.moreQuad);
            this._quadMeshs.push(quadMesh);
            this._guiContainer.addChild(quadMesh);
        };
        QuadStage.prototype.getChildQuads = function (displayObject, quadChilds) {
            var i = 0;
            var tempDisplayObject;
            /*判断当前 displayObject 类型,优先放入*/
            var quad;
            if (displayObject instanceof egret3d.Quad) {
                // add to quad list
                quad = displayObject;
                quadChilds.push(quad);
            }
            /*获取最深的显示对象*/
            while (i < displayObject.childs.length) {
                tempDisplayObject = displayObject.childs[i++];
                this.getChildQuads(tempDisplayObject, quadChilds);
            }
        };
        /**
        * @private
        * @language zh_CN
        * 添加孩子到舞台上
        * @param object 添加的2d显示对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadStage.prototype.addChild = function (object) {
            if (!object) {
                throw Error("This object is null");
            }
            if (object.parent) {
                throw Error("parent isn't null");
            }
            this._childList.push(object);
            object.activeStage(this);
            object.parentIsStage = true;
            this.setRenderListInvalid();
        };
        /**
        * @private
        * @language zh_CN
        * 标记当前渲染队列需要重新计算
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadStage.prototype.setRenderListInvalid = function () {
            this._renderListInvalid = true;
        };
        QuadStage.prototype.updateRenderList = function () {
            this.quadList.length = 0;
            for (var i = 0; i < this._childList.length; i++) {
                this.getChildQuads(this._childList[i], this.quadList);
            }
            // if quadMesh not enough then creat new 
            if (this.quadList.length > this._quadMeshs.length * QuadStage.moreQuad) {
                var less = Math.ceil((this.quadList.length / QuadStage.moreQuad)) - this._quadMeshs.length;
                for (var i = 0; i < less; i++) {
                    this.creatQuadMesh();
                }
            }
        };
        /**
        * @private
        * @language zh_CN
        * 从舞台上移除某个孩子节点
        * @param object 添加的2d显示对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadStage.prototype.removeChild = function (object) {
            var index = this._childList.indexOf(object);
            if (index != -1) {
                this._childList.splice(index, 1);
            }
            //if (quad instanceof Quad) {
            //    if (this.quadList.length < this.quadMeshs.length * QuadStage.moreQuad) {
            //        var tempQuadMesh: QuadMesh = (this.quadMeshs.splice(this.quadMeshs.length - 1, 1))[0];
            //        this._view3D.camera3D.removeChild(tempQuadMesh);
            //        tempQuadMesh.dispose();
            //    }
            //}
            object.activeStage(null);
            object.parentIsStage = false;
            this.setRenderListInvalid();
        };
        /**
        * @private
        * @language zh_CN
        * 在渲染之前逻辑更新，每帧执行一次
        * @param time 当前运行的总时间
        * @param delay 振间隔时间
        * @param context3DProxy 上下文引用
        * @param view3D 视图引用
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadStage.prototype.update = function (time, delay, context3DProxy, view3D) {
            var self = this;
            self.x = view3D.x;
            self.y = view3D.y;
            self.width = view3D.width;
            self.height = view3D.height;
            //collect render list
            if (this._renderListInvalid) {
                this._renderListInvalid = false;
                this.updateRenderList();
            }
            egret3d.Context3DProxy.gl.disable(egret3d.Context3DProxy.gl.DEPTH_TEST);
            egret3d.Egret3DCanvas.context3DProxy.disAttribPointer();
            //update data
            var i;
            var len = self.quadList.length;
            for (i = 0; i < len; i++) {
                this.quadList[i].update(time, delay);
            }
            //fire mouse event
            this._guiEventFire.fire();
            //update by zoon
            var geometryIndex;
            for (i = 0; i < len; i++) {
                geometryIndex = Math.floor(i / QuadStage.moreQuad);
                this.quadList[i].updateVertices(i % QuadStage.moreQuad, self._quadMeshs[geometryIndex].geometry, i);
            }
            //clear data
            this.clearInvalidVertices(len);
            //upload vertex data
            var quad;
            for (i = 0; i < self._quadMeshs.length; i++) {
                quad = self._quadMeshs[i];
                quad.geometry.upload(context3DProxy, egret3d.Context3DProxy.gl.DYNAMIC_DRAW);
                self._textureGroup.activeTexture(quad);
            }
            egret3d.Context3DProxy.gl.enable(egret3d.Context3DProxy.gl.DEPTH_TEST);
        };
        QuadStage.prototype.clearInvalidVertices = function (count) {
            var self = this;
            this._quadCurHistory.length = 0;
            var index = 0;
            while (count >= QuadStage.moreQuad) {
                this._quadCurHistory[index] = QuadStage.moreQuad;
                count -= QuadStage.moreQuad;
                index++;
            }
            if (count > 0) {
                self._quadCurHistory[index] = count;
            }
            count = self._quadMeshs.length;
            var lastCount = 0;
            var currentCount = 0;
            for (index = 0; index < count; index++) {
                lastCount = self._quadLastHistory[index] || 0;
                currentCount = self._quadCurHistory[index] || 0;
                if (currentCount < lastCount) {
                    //clear at index
                    for (var i = currentCount; i < lastCount; i++) {
                        egret3d.Quad.clear(i, self._quadMeshs[index].geometry);
                    }
                }
            }
            //交换保存的数据
            var temp = self._quadCurHistory;
            self._quadCurHistory = self._quadLastHistory;
            self._quadLastHistory = temp;
        };
        /*
        * @private
        */
        QuadStage.moreQuad = 400;
        return QuadStage;
    }(egret3d.EventDispatcher));
    egret3d.QuadStage = QuadStage;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
        * @private
        * @class egret3d.GUISkinManager
        * @classdesc
        * gui的默认皮肤管理器
        * @see egret3d.TextureResourceManager
        * @version Egret 3.0
        * @platform Web,Native
        */
        var GUISkinManager = (function () {
            function GUISkinManager() {
                this._defaultSkinTexture = {};
            }
            /**
            * @private
            * 获取默认贴图
            * @param skinName 根据皮肤名称获取默认的Texture
            * @returns Texture 获取到的默认贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            GUISkinManager.prototype.getDefaultSkin = function (skinName) {
                return this._defaultSkinTexture[skinName];
            };
            /**
            * @private
            * 初始化该管理器
            * @version Egret 3.0
            * @platform Web,Native
            */
            GUISkinManager.prototype.initDefaultSkin = function () {
                var upState = egret3d.textureResMgr.getTexture("normal.png");
                var downState = egret3d.textureResMgr.getTexture("pressed.png");
                var overState = egret3d.textureResMgr.getTexture("hover.png");
                var checkUpState = egret3d.textureResMgr.getTexture("default.png");
                var checkDownState = egret3d.textureResMgr.getTexture("checked.png");
                var whiteBg = egret3d.textureResMgr.getTexture("whitebackground.png");
                var progressBg = egret3d.textureResMgr.getTexture("backgroundpic.png");
                var progressBarSkin = egret3d.textureResMgr.getTexture("blue.png");
                var radioUpState = egret3d.textureResMgr.getTexture("unselected.png");
                var radioSelected = egret3d.textureResMgr.getTexture("selected.png");
                var radioHover = egret3d.textureResMgr.getTexture("hover1.png");
                var sliderBar = egret3d.textureResMgr.getTexture("bluebackground.png");
                var sliderBackground = egret3d.textureResMgr.getTexture("whitebackground.png");
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_BUTTON_UP, upState);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_BUTTON_DOWN, downState);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_BUTTON_OVER, overState);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_LABEL_BUTTON_UP, upState);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_LABE_BUTTON_DOWN, downState);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_CHECK_BOX_UP, checkUpState);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_CHECK_BOX_DOWN, checkUpState);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_CHECK_BOX_SELECTED_UP, checkDownState);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_CHECK_BOX_SELECTED_DOWN, checkDownState);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_RADIO_BUTTON_UP, radioUpState);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_RADIO_BUTTON_DOWN, radioHover);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_RADIO_BUTTON_SELECTED_DOWN, radioHover);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_RADIO_BUTTON_SELECTED_UP, radioSelected);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_SLIDER_BAR, sliderBar);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_SLIDER_BACKGROUND, sliderBackground);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_PROGRESS_BAR, progressBarSkin);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_PROGRESS_BAR_BACKGROUND, progressBg);
                GUISkinManager.instance.setDefaultSkin(gui.DefaultSkinName.DEFAULT_PANEL_BACKGROUND, whiteBg);
            };
            /**
            * @private
            * 设置默认皮肤对应的贴图
            * @param skinName 默认的皮肤名
            * @param texture 默认皮肤对应的贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            GUISkinManager.prototype.setDefaultSkin = function (skinName, texture) {
                if (typeof texture === "string") {
                    texture = egret3d.textureResMgr.getTexture(texture);
                }
                this._defaultSkinTexture[skinName] = texture;
            };
            Object.defineProperty(GUISkinManager, "instance", {
                /**
                * @private
                * 获取单例
                * @param skinName 默认的皮肤名
                * @returns SkinManager 管理器的蛋例
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    if (!GUISkinManager._instance) {
                        GUISkinManager._instance = new GUISkinManager();
                    }
                    return GUISkinManager._instance;
                },
                enumerable: true,
                configurable: true
            });
            return GUISkinManager;
        }());
        gui.GUISkinManager = GUISkinManager;
        /**
        * @private
        */
        var DefaultSkinName = (function () {
            function DefaultSkinName() {
            }
            DefaultSkinName.DEFAULT_BUTTON_UP = 'defaultButtonUp';
            DefaultSkinName.DEFAULT_BUTTON_DOWN = 'defaultButtonDown';
            DefaultSkinName.DEFAULT_BUTTON_OVER = 'defaultButtonOver';
            DefaultSkinName.DEFAULT_BUTTON_DISABLE = "defaultButtonDisable";
            DefaultSkinName.DEFAULT_LABEL_BUTTON_UP = 'defaultLabelButtonUp';
            DefaultSkinName.DEFAULT_LABE_BUTTON_DOWN = 'defaultLabelButtonDown';
            DefaultSkinName.DEFAULT_LABE_BUTTON_DISABLE = "defaultLabelButtonDisable";
            DefaultSkinName.DEFAULT_CHECK_BOX_UP = "defaultCheckBoxUp";
            DefaultSkinName.DEFAULT_CHECK_BOX_DOWN = "defaultCheckBoxDown";
            DefaultSkinName.DEFAULT_CHECK_BOX_SELECTED_UP = "defaultCheckBoxSelectedUp";
            DefaultSkinName.DEFAULT_CHECK_BOX_SELECTED_DOWN = "defaultCheckBoxSelectedDown";
            DefaultSkinName.DEFAULT_CHECK_BOX_DISABLE = "defaultCheckBoxDisable";
            DefaultSkinName.DEFAULT_PROGRESS_BAR = "defaultProgressBar";
            DefaultSkinName.DEFAULT_PROGRESS_BAR_BACKGROUND = "defaultProgressBarBackground";
            DefaultSkinName.DEFAULT_RADIO_BUTTON_UP = "defaultRadioButtonUp";
            DefaultSkinName.DEFAULT_RADIO_BUTTON_DOWN = "defaultRadioButtonDown";
            DefaultSkinName.DEFAULT_RADIO_BUTTON_SELECTED_UP = "defaultRadioButtonSelectedUp";
            DefaultSkinName.DEFAULT_RADIO_BUTTON_SELECTED_DOWN = "defaultRadioButtonSelectedDown";
            DefaultSkinName.DEFAULT_RADIO_BUTTON_DISABLE = "defaultRadioButtonDisable";
            DefaultSkinName.DEFAULT_SLIDER_BAR = "defaultSliderBar";
            DefaultSkinName.DEFAULT_SLIDER_BACKGROUND = "defaultSliderBarBACKGROUND";
            DefaultSkinName.DEFAULT_PANEL_BACKGROUND = "defaultPanelBackground";
            return DefaultSkinName;
        }());
        gui.DefaultSkinName = DefaultSkinName;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
   * @private
   * @class egret3d.gui.UILayout
   * @classdesc
   * @version Egret 3.0
   * @platform Web,Native
   */
        var UILayout = (function (_super) {
            __extends(UILayout, _super);
            function UILayout() {
                _super.apply(this, arguments);
            }
            UILayout.prototype.onRender = function () {
            };
            UILayout.prototype.onUpdate = function () {
            };
            UILayout.prototype.onEvent = function () {
            };
            return UILayout;
        }(egret3d.DisplayObject));
        gui.UILayout = UILayout;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
        * @class egret3d.gui.UIElement
        * @classdesc
        * 所有可视组件的基类</p>.
        * @version Egret 3.0
        * @platform Web,Native
        */
        var UIElement = (function (_super) {
            __extends(UIElement, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @version Egret 3.0
            * @platform Web,Native
            */
            function UIElement() {
                _super.call(this);
            }
            /**
            * @private
            */
            UIElement.prototype.onRender = function () {
            };
            /**
            * @private
            */
            UIElement.prototype.onUpdate = function () {
            };
            /**
            * @private
            */
            UIElement.prototype.onEvent = function () {
            };
            /**
            * @language zh_CN
            * 对此组件实例设置样式属性。
            * @param style 样式属性的名称。
            * @param value  样式的值。可由Texture或string, string的值由texturepacker出的配置文件内的文件名得来.
            * @version Egret 3.0
            * @platform Web,Native
            */
            UIElement.prototype.setStyle = function (style, value) {
                if (!this.instanceStyles) {
                    this.instanceStyles = {};
                }
                if (typeof value === "string") {
                    var tex = egret3d.textureResMgr.getTexture(value);
                    if (!tex) {
                        console.log("未找到名为: " + value + " 的资源贴图");
                        return;
                    }
                    else {
                        value = tex;
                    }
                }
                if (this.instanceStyles[style] === value) {
                    return;
                }
                this.instanceStyles[style] = value;
            };
            /**
          * @language zh_CN
          * 检索组件的样式查找链中设置的样式属性。
          * @param style 样式属性的名称。
          * @version Egret 3.0
          * @platform Web,Native
          */
            UIElement.prototype.getStyle = function (style) {
                return this.instanceStyles ? this.instanceStyles[style] : this.getDefaultStyle(style);
            };
            /**
            * @private
            */
            UIElement.prototype.getDefaultStyle = function (style) {
                return gui.GUISkinManager.instance.getDefaultSkin(this.getDefaultStyleNameByStyleName(style));
            };
            /**
             * @private
             * 用于子类重写
            * @version Egret 3.0
            * @platform Web,Native
            */
            UIElement.prototype.getDefaultStyleNameByStyleName = function (styleName) {
                return "";
            };
            /**
            * @private
           * @version Egret 3.0
           * @platform Web,Native
           */
            UIElement.mergeStyles = function () {
                var list = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    list[_i - 0] = arguments[_i];
                }
                var styles = {};
                var l = list.length;
                for (var i = 0; i < l; i++) {
                    var styleList = list[i];
                    for (var n in styleList) {
                        if (styles[n] != null) {
                            continue;
                        }
                        styles[n] = list[i][n];
                    }
                }
                return styles;
            };
            UIElement.defaultStyles = {};
            return UIElement;
        }(egret3d.DisplayObject));
        gui.UIElement = UIElement;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
        * @class egret3d.gui.UIButton
        * @classdesc
        * 常用的矩形按钮组件.</p>
        * 仅包含图片皮肤.如果要使用文本.请使用UILabelButton组件.</p>
        * 可响应鼠标事件;
        * @see egret3d.MouseEvent3D
        * @see egret3d.gui.UILabelButton
        * 示例:
        * @includeExample gui/component/UIButton.ts
        * @version Egret 3.0
        * @platform Web,Native
        */
        var UIButton = (function (_super) {
            __extends(UIButton, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @version Egret 3.0
            * @platform Web,Native
            */
            function UIButton() {
                _super.call(this);
                this._skin = new egret3d.Quad();
                this.addChild(this._skin);
                this._state = UIButton.STATE_UP;
                this._enable = true;
                this._isDowning = false;
                this.addEventListener(egret3d.MouseEvent3D.MOUSE_DOWN, this.mouseEventHandler, this);
                this.addEventListener(egret3d.MouseEvent3D.MOUSE_OUT, this.mouseEventHandler, this);
                this.addEventListener(egret3d.MouseEvent3D.MOUSE_OVER, this.mouseEventHandler, this);
                this.drawBackground();
            }
            /**
           * @private
           */
            UIButton.prototype.getDefaultStyleNameByStyleName = function (styleName) {
                var obj = {
                    "down": gui.DefaultSkinName.DEFAULT_BUTTON_DOWN,
                    "up": gui.DefaultSkinName.DEFAULT_BUTTON_UP,
                    "over": gui.DefaultSkinName.DEFAULT_BUTTON_OVER,
                    "disable": gui.DefaultSkinName.DEFAULT_BUTTON_DISABLE
                };
                var result = obj[styleName];
                if (!result) {
                    console.log(" ERROR!!! UIButton can't find default style : ", styleName);
                }
                return result;
            };
            Object.defineProperty(UIButton.prototype, "width", {
                /**
                * @language zh_CN
                * 获取或设置组件的宽度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._skin.width;
                },
                /**
                * @language zh_CN
                * 获取或设置组件的宽度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    this._skin.width = value;
                    this.onRender();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UIButton.prototype, "height", {
                /**
                * @language zh_CN
                * 获取或设置组件的高度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._skin.height;
                },
                /**
                * @language zh_CN
                * 获取或设置组件的高度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    this._skin.height = value;
                    this.onRender();
                },
                enumerable: true,
                configurable: true
            });
            /**
           * @language zh_CN
           * 设置皮肤
           * @param style 皮肤名称, 可选值:down, up, over, disable.
           * @param value 皮肤贴图
           * @version Egret 3.0
           * @platform Web,Native
           */
            UIButton.prototype.setStyle = function (style, value) {
                _super.prototype.setStyle.call(this, style, value);
                this.onRender();
            };
            /**
           * @private
           */
            UIButton.prototype.mouseEventHandler = function (event) {
                if (!this._enable)
                    return;
                if (event.eventType === egret3d.MouseEvent3D.MOUSE_DOWN) {
                    this.startPress();
                }
                else if (event.eventType === egret3d.MouseEvent3D.MOUSE_UP) {
                    this.endPress();
                }
                else if (event.eventType === egret3d.MouseEvent3D.MOUSE_OUT) {
                    this.mouseOut();
                }
                else if (event.eventType === egret3d.MouseEvent3D.MOUSE_OVER) {
                }
            };
            /**
           * @private
           */
            UIButton.prototype.mouseOut = function () {
                this.setMouseState(UIButton.STATE_UP);
            };
            /**
           * @private
           */
            UIButton.prototype.mouseOver = function () {
                if (this._isDowning) {
                    this.setMouseState(UIButton.STATE_DOWN);
                }
                else {
                    this.setMouseState(UIButton.STATE_OVER);
                }
            };
            /**
           * @private
           */
            UIButton.prototype.startPress = function () {
                this.addEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.mouseEventHandler, this);
                if (this.stage) {
                    this.stage.addEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.onStageEnd, this);
                }
                this._isDowning = true;
                this.setMouseState(UIButton.STATE_DOWN);
            };
            /**
           * @private
           */
            UIButton.prototype.onStageEnd = function (event) {
                if (this.stage) {
                    this.stage.removeEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.onStageEnd, this);
                }
                this.removeEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.mouseEventHandler, this);
                this.setMouseState(UIButton.STATE_UP);
                this._isDowning = false;
            };
            /**
           * @private
           */
            UIButton.prototype.endPress = function () {
                this.setMouseState(UIButton.STATE_UP);
                this._isDowning = false;
                if (this.stage) {
                    this.stage.removeEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.onStageEnd, this);
                }
                this.removeEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.mouseEventHandler, this);
            };
            Object.defineProperty(UIButton.prototype, "enable", {
                /**
               * @language zh_CN
               * 是否可用.默认为true. 当设置为false时.将不响应鼠标输入事件
               * @version Egret 3.0
               * @platform Web,Native
               */
                get: function () {
                    return this._enable;
                },
                set: function (value) {
                    this._enable = value;
                    this.mouseEnable = value;
                },
                enumerable: true,
                configurable: true
            });
            /**
           * @private
           */
            UIButton.prototype.setMouseState = function (state) {
                if (this._state === state) {
                    return;
                }
                this._state = state;
                this.onRender();
            };
            /**
           * @private
           */
            UIButton.prototype.onRender = function () {
                this.drawBackground();
            };
            /**
           * @private
           */
            UIButton.prototype.drawBackground = function () {
                var skin = this.enable ? this.getStyle(this._state) : this.getStyle(UIButton.STATE_DISABLE);
                this._skin.texture = skin;
            };
            UIButton.STATE_DOWN = "down";
            UIButton.STATE_UP = "up";
            UIButton.STATE_OVER = "over";
            UIButton.STATE_DISABLE = "disable";
            return UIButton;
        }(gui.UIElement));
        gui.UIButton = UIButton;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
        * @class egret3d.gui.UITextFieldAutoSize
        * @classdesc
        * 设置 UITextField 类的 autoSize 属性时使用的常量值的枚举
        * @see egret3d.gui.UITextField
        * @version Egret 3.0
        * @platform Web,Native
        */
        (function (UITextFieldAutoSize) {
            /**
            * @language zh_CN
            * 指定不调整大小。
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextFieldAutoSize[UITextFieldAutoSize["NONE"] = 0] = "NONE";
            /**
            * @language zh_CN
            * 指定将文本视为左对齐文本，即文本字段的左侧固定不变，只在右侧调整单行的大小。
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextFieldAutoSize[UITextFieldAutoSize["LEFT"] = 1] = "LEFT";
            /**
            * @language zh_CN
            * 指定将文本视为右对齐文本，即文本字段的右侧固定不变，只在左侧调整单行的大小
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextFieldAutoSize[UITextFieldAutoSize["RIGHT"] = 2] = "RIGHT";
            /**
            * @language zh_CN
            * 指定将文本视为居中对齐文本。
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextFieldAutoSize[UITextFieldAutoSize["CENTER"] = 3] = "CENTER";
        })(gui.UITextFieldAutoSize || (gui.UITextFieldAutoSize = {}));
        var UITextFieldAutoSize = gui.UITextFieldAutoSize;
        /**
       * @class egret3d.gui.UITextFieldType
       * @classdesc
       * 设置 UITextField 类的 type 属性时使用的常量值的枚举
       * @see egret3d.gui.UITextField
       * @version Egret 3.0
       * @platform Web,Native
       */
        (function (UITextFieldType) {
            /**
            * @language zh_CN
            * 用户无法编辑的动态文本字段
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextFieldType[UITextFieldType["DYNAMIC"] = 0] = "DYNAMIC";
            /**
            * @language zh_CN
            * 用户可以编辑的输入文本字段。
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextFieldType[UITextFieldType["INPUT"] = 1] = "INPUT";
        })(gui.UITextFieldType || (gui.UITextFieldType = {}));
        var UITextFieldType = gui.UITextFieldType;
        /**
        * @private
        */
        var TextLineInfo = (function () {
            function TextLineInfo() {
            }
            return TextLineInfo;
        }());
        /**
        * @private
        * @class egret3d.gui.UITextFormatAlign
        * @classdesc
        * UITextFormatAlign 类为 UITextFormat 类中的文本对齐方式提供值。
        * @see egret3d.gui.UITextFormat
        * @version Egret 3.0
        * @platform Web,Native
        */
        (function (UITextFormatAlign) {
            /**
            * @language zh_CN
            * 在文本字段内将文本居中对齐。
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextFormatAlign[UITextFormatAlign["CENTER"] = 0] = "CENTER";
            /**
            * @language zh_CN
            * 在文本字段内将文本两端对齐。
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextFormatAlign[UITextFormatAlign["JUSTIFY"] = 1] = "JUSTIFY";
            /**
            * @language zh_CN
            * 在文本字段内将文本左对齐。
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextFormatAlign[UITextFormatAlign["LEFT"] = 2] = "LEFT";
            /**
            * @language zh_CN
            * 在文本字段内将文本右对齐。
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextFormatAlign[UITextFormatAlign["RIGHT"] = 3] = "RIGHT";
        })(gui.UITextFormatAlign || (gui.UITextFormatAlign = {}));
        var UITextFormatAlign = gui.UITextFormatAlign;
        /**
    * @private
    * @class egret3d.gui.UITextFormat
    * @classdesc
    * @version Egret 3.0
    * @platform Web,Native
    */
        var UITextFormat = (function () {
            function UITextFormat() {
            }
            return UITextFormat;
        }());
        gui.UITextFormat = UITextFormat;
        /**
    * @private
    * @class egret3d.gui.UITextField
    * @classdesc
    * @version Egret 3.0
    * @platform Web,Native
    */
        var UITextField = (function (_super) {
            __extends(UITextField, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @param textFieldType 文本类型，参照egret3d.UITextFieldType
            * @version Egret 3.0
            * @platform Web,Native
            */
            function UITextField(textFieldType) {
                if (textFieldType === void 0) { textFieldType = UITextFieldType.DYNAMIC; }
                _super.call(this);
                this._textLineInfo = [];
                this._text = "";
                this._maxChars = 0;
                this._restrict = "";
                this._textWidth = 0;
                this._textLine = [];
                this._quadPool = [];
                this._textHeight = 0;
                this._fontQuadLine = [];
                this._multiline = false;
                this._selectable = false;
                this._type = textFieldType;
                this._textColor = 0x00cc00;
                this._selectionEndIndex = -1;
                this._selectionBeginIndex = -1;
                this._displayAsPassword = false;
                this._autoSize = UITextFieldAutoSize.LEFT;
                this._fontQuadPanel = new egret3d.DisplayObject();
                this._blankQuad = this.createFontQuad("b".charCodeAt(0), false);
                if (!UITextField.sharedHTMLInputElement) {
                    UITextField.sharedHTMLInputElement = document.createElement("input");
                    UITextField.sharedHTMLInputElement.style.width = this.width + "px";
                    UITextField.sharedHTMLInputElement.style.height = this.height + "px";
                    UITextField.sharedHTMLInputElement.hidden = true;
                    UITextField.sharedHTMLInputElement.style.color = "#00ff00";
                    UITextField.sharedHTMLInputElement.style.border = "0px";
                    UITextField.sharedHTMLInputElement.style.backgroundColor = "transparent";
                    document.getElementById("egret3D").parentElement.appendChild(UITextField.sharedHTMLInputElement);
                }
                if (!UITextField.sharedHTMLTextAreaElement) {
                    UITextField.sharedHTMLTextAreaElement = document.createElement("textarea");
                    UITextField.sharedHTMLTextAreaElement.style.width = this.width + "px";
                    UITextField.sharedHTMLTextAreaElement.style.height = this.height + "px";
                    UITextField.sharedHTMLTextAreaElement.hidden = true;
                    UITextField.sharedHTMLTextAreaElement.style.color = "#00ff00";
                    UITextField.sharedHTMLTextAreaElement.style.paddingLeft = "0px";
                    UITextField.sharedHTMLTextAreaElement.style.paddingTop = "0px";
                    UITextField.sharedHTMLTextAreaElement.style.margin = "0px";
                    UITextField.sharedHTMLTextAreaElement.style.backgroundColor = "transparent";
                    document.getElementById("egret3D").parentElement.appendChild(UITextField.sharedHTMLTextAreaElement);
                }
                this._bgQuad = new egret3d.Quad();
                if (UITextFieldType.INPUT == this._type) {
                    this._bgQuad.mouseEnable = true;
                    this._bgQuad.width = this.width;
                    this._bgQuad.height = this.height;
                    this.addChild(this._bgQuad);
                    this._bgQuad.addEventListener(egret3d.TouchEvent3D.TOUCH_START, this.onShowInputAgent, this);
                    this._bgQuad.addEventListener(egret3d.MouseEvent3D.MOUSE_CLICK, this.onShowInputAgent, this);
                }
                this.width = 100;
                this.height = 20;
                this.addChild(this._fontQuadPanel);
            }
            /**
            * @private
            */
            UITextField.prototype.onShowInputAgent = function (e) {
                var _this = this;
                if (this._multiline) {
                    UITextField.sharedHTMLTextAreaElement.hidden = false;
                    UITextField.sharedHTMLTextAreaElement.style.position = "absolute";
                    UITextField.sharedHTMLTextAreaElement.style.left = this.x + "px";
                    UITextField.sharedHTMLTextAreaElement.style.top = this.y + "px";
                    UITextField.sharedHTMLTextAreaElement.style.width = this.width + "px";
                    UITextField.sharedHTMLTextAreaElement.style.height = this.height + "px";
                    UITextField.sharedHTMLTextAreaElement.value = this._text;
                    UITextField.sharedHTMLTextAreaElement.focus();
                    UITextField.sharedHTMLTextAreaElement.onblur = function (e) { return _this.onSharedHTMLTextLoseFocus(e); };
                }
                else {
                    UITextField.sharedHTMLInputElement.hidden = false;
                    UITextField.sharedHTMLInputElement.style.position = "absolute";
                    UITextField.sharedHTMLInputElement.style.left = this.x + "px";
                    UITextField.sharedHTMLInputElement.style.top = this.y + "px";
                    UITextField.sharedHTMLInputElement.style.width = this.width + "px";
                    UITextField.sharedHTMLInputElement.style.height = this.height + "px";
                    UITextField.sharedHTMLInputElement.value = this._text;
                    UITextField.sharedHTMLInputElement.focus();
                    UITextField.sharedHTMLInputElement.onblur = function (e) { return _this.onSharedHTMLTextLoseFocus(e); };
                }
                this._fontQuadPanel.visible = false;
            };
            /**
            * @private
            */
            UITextField.prototype.onSharedHTMLTextLoseFocus = function (ev) {
                this.text = this._multiline ? UITextField.sharedHTMLTextAreaElement.value : UITextField.sharedHTMLInputElement.value;
                UITextField.sharedHTMLInputElement.onblur = UITextField.sharedHTMLTextAreaElement.onblur = null;
                UITextField.sharedHTMLInputElement.hidden = UITextField.sharedHTMLTextAreaElement.hidden = true;
                //this.showAllFontQuad(true);
                this._fontQuadPanel.visible = true;
            };
            Object.defineProperty(UITextField.prototype, "width", {
                /**
                * @language zh_CN
                * 获取或设置组件的宽度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._sca.z;
                },
                /**
                * @language zh_CN
                * 获取或设置组件的宽度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    if (value != this._sca.z) {
                        this._fontQuadPanel.width = value;
                        this._sca.z = value;
                        this._transformChange = true;
                        this._bgQuad.width = value;
                        this.refreshAlign();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UITextField.prototype, "height", {
                /**
                * @language zh_CN
                * 获取或设置组件的高度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._sca.w;
                },
                /**
                * @language zh_CN
                * 获取或设置组件的高度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    if (value != this._sca.w) {
                        this._fontQuadPanel.height = value;
                        this._sca.w = value;
                        this._transformChange = true;
                        this._bgQuad.height = value;
                        this.refreshAlign();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UITextField.prototype, "displayAsPassword", {
                /**
               * @language zh_CN
               * 指定文本字段是否是密码文本字段。
               * @param displayAsPassword  是否为密码文本字段
               * @version Egret 3.0
               * @platform Web,Native
               */
                get: function () {
                    return this._displayAsPassword;
                },
                /**
                * @language zh_CN
                * 指定文本字段是否是密码文本字段。
                * @param displayAsPassword  是否为密码文本字段
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (displayAsPassword) {
                    this._displayAsPassword = displayAsPassword;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UITextField.prototype, "length", {
                /**
                * @language zh_CN
                * (只读)文本字段中的字符数。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._text.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UITextField.prototype, "maxChars", {
                /**
                * @language zh_CN
                * 文本字段中最多可包含的字符数（即用户输入的字符数）。
                * @param maxChars  最大字符数
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._maxChars;
                },
                /**
                * @language zh_CN
                * 文本字段中最多可包含的字符数（即用户输入的字符数）。
                * @param maxChars  最大字符数
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (maxChars) {
                    this._maxChars = maxChars;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UITextField.prototype, "multiline", {
                /**
                * @language zh_CN
                * 指示字段是否为多行文本字段。
                * @param multiline  是否多行
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._multiline;
                },
                /**
                * @language zh_CN
                * 指示字段是否为多行文本字段。
                * @param multiline  是否多行
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (multiline) {
                    this._multiline = multiline;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UITextField.prototype, "restrict", {
                /**
                * @language zh_CN
                * 指示用户可输入到文本字段中的字符集。
                * @param restrict  字符集
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._restrict;
                },
                /**
                * @language zh_CN
                * 指示用户可输入到文本字段中的字符集。
                * @param restrict  字符集
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (restrict) {
                    this._restrict = restrict;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UITextField.prototype, "selectable", {
                /**
                * @language zh_CN
                * 一个布尔值，指示文本字段是否可选。
                * @param selectable  是否可选
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._selectable;
                },
                /**
                * @language zh_CN
                * 一个布尔值，指示文本字段是否可选。
                * @param selectable  是否可选
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (selectable) {
                    this._selectable = selectable;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UITextField.prototype, "selectionBeginIndex", {
                /**
                * @language zh_CN
                * (只读)当前所选内容中第一个字符从零开始的字符索引值。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._selectionBeginIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UITextField.prototype, "selectionEndIndex", {
                /**
                * @language zh_CN
                * (只读)当前所选内容中最后一个字符从零开始的字符索引值。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._selectionEndIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UITextField.prototype, "type", {
                /**
                * @language zh_CN
                * 该文本字段的类型。
                * @param type  文本字段的类型
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._type;
                },
                /**
                * @language zh_CN
                * 该文本字段的类型。
                * @param type  文本字段的类型
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (type) {
                    this._type = type;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UITextField.prototype, "textColor", {
                /**
                * @language zh_CN
                * 文本字段中文本的颜色（采用十六进制格式）。
                * @param textColor  文本颜色
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._textColor;
                },
                /**
                * @language zh_CN
                * 文本字段中文本的颜色（采用十六进制格式）。
                * @param textColor  文本颜色
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (textColor) {
                    this._textColor = textColor;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UITextField.prototype, "textWidth", {
                /**
                * @language zh_CN
                * （只读）文本的宽度，以像素为单位。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._textWidth;
                },
                set: function (value) {
                    this._textWidth = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UITextField.prototype, "textHeight", {
                /**
                * @language zh_CN
                * （只读）文本的高度，以像素为单位。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._textHeight;
                },
                /**
                 * @private
                 */
                set: function (value) {
                    this._textHeight = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UITextField.prototype, "text", {
                /**
                * @language zh_CN
                * 当前文本字段中当前文本的字符串。
                * @param text  文本字符串
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._text;
                },
                /**
                * @language zh_CN
                * 当前文本字段中当前文本的字符串。
                * @param text  文本字符串
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (text) {
                    this.clearText();
                    this._text = text;
                    this._textLine = text.split("\n");
                    if (!this._multiline) {
                        this._textLine[0] = this._textLine.join("");
                        this._textLine.length = 1;
                    }
                    var textLineInfo = null;
                    for (var i = 0; i < this._textLine.length; ++i) {
                        var lineStr = this._textLine[i];
                        textLineInfo = this.buildTextLineInfo(lineStr);
                        this._textLineInfo.push(textLineInfo);
                    }
                    this.refreshAlign();
                },
                enumerable: true,
                configurable: true
            });
            /**
            * @private
            */
            UITextField.prototype.clearText = function () {
                var textLineInfo = null;
                for (var i = 0; i < this._textLineInfo.length; ++i) {
                    textLineInfo = this._textLineInfo[i];
                    for (var j = 0; j < textLineInfo.lineQuads.length; ++j) {
                        this.deleteFontQuad(textLineInfo.lineQuads[j]);
                    }
                    textLineInfo.lineQuads = null;
                }
                this._textLineInfo = [];
            };
            Object.defineProperty(UITextField.prototype, "autoSize", {
                /**
                * @language zh_CN
                * @param text  文本字符串
                * 控制文本字段的自动大小调整和对齐。
                * 如果 autoSize 设置为 UITextFieldAutoSize.NONE（默认值），则不会进行调整。</p>
                * 如果 autoSize 设置为 UITextFieldAutoSize.LEFT，会将文本视为左对齐文本，这意味着该文本字段的左边距保持固定，在右边可调整单个文本字段行。 如果文本中包括换行符（例如 "\n" 或 "\r"），则会另外调整底边来适合文本的下一行。
                * 如果 autoSize 设置为 UITextFieldAutoSize.RIGHT，会将文本视为右对齐文本，这意味着该文本字段的右边距保持固定，可在左边调整单个文本字段行。 如果文本中包括换行符（例如 "\n" or "\r")），则会另外调整底边来适合文本的下一行。
                * 如果 autoSize 设置为 UITextFieldAutoSize.CENTER，会将文本视为居中对齐文本，这意味着对单个文本字段行的调整将使其在左右边距间均衡分布。 如果文本中包括换行符（例如 "\n" 或 "\r"），则会另外调整底边来适合文本的下一行。
                * @see egret3d.gui.UITextFieldAutoSize
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._autoSize;
                },
                /**
                * @language zh_CN
                * @param text  文本字符串
                * 控制文本字段的自动大小调整和对齐。
                * 如果 autoSize 设置为 UITextFieldAutoSize.NONE（默认值），则不会进行调整。</p>
                * 如果 autoSize 设置为 UITextFieldAutoSize.LEFT，会将文本视为左对齐文本，这意味着该文本字段的左边距保持固定，在右边可调整单个文本字段行。 如果文本中包括换行符（例如 "\n" 或 "\r"），则会另外调整底边来适合文本的下一行。
                * 如果 autoSize 设置为 UITextFieldAutoSize.RIGHT，会将文本视为右对齐文本，这意味着该文本字段的右边距保持固定，可在左边调整单个文本字段行。 如果文本中包括换行符（例如 "\n" or "\r")），则会另外调整底边来适合文本的下一行。
                * 如果 autoSize 设置为 UITextFieldAutoSize.CENTER，会将文本视为居中对齐文本，这意味着对单个文本字段行的调整将使其在左右边距间均衡分布。 如果文本中包括换行符（例如 "\n" 或 "\r"），则会另外调整底边来适合文本的下一行。
                * @see egret3d.gui.UITextFieldAutoSize
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (autoSize) {
                    this._autoSize = autoSize;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * @private
            */
            UITextField.prototype.refreshAlign = function () {
                var fontQuad = null;
                var textLineInfo = null;
                var offsetX, offsetY;
                if (this._autoSize == UITextFieldAutoSize.LEFT) {
                    offsetY = 0;
                    if (!this.multiline && this._textLineInfo.length >= 1) {
                        offsetY = this.height / 2 - this._textLineInfo[0].lineHeight / 2;
                    }
                    for (var i = 0; i < this._textLineInfo.length; ++i) {
                        textLineInfo = this._textLineInfo[i];
                        offsetX = 0;
                        for (var j = 0; j < textLineInfo.lineQuads.length; ++j) {
                            fontQuad = textLineInfo.lineQuads[j];
                            fontQuad.x = offsetX;
                            fontQuad.y = offsetY;
                            offsetX += fontQuad.width;
                            fontQuad.visible = (fontQuad.x + fontQuad.width) <= this.width;
                        }
                        offsetY += textLineInfo.lineHeight;
                    }
                }
                else if (this._autoSize == UITextFieldAutoSize.RIGHT) {
                    offsetY = 0;
                    if (!this.multiline && this._textLineInfo.length >= 1) {
                        offsetY = this.height / 2 - this._textLineInfo[0].lineHeight / 2;
                    }
                    for (var i = 0; i < this._textLineInfo.length; ++i) {
                        textLineInfo = this._textLineInfo[i];
                        offsetX = this.width;
                        for (var j = textLineInfo.lineQuads.length - 1; j >= 0; --j) {
                            fontQuad = textLineInfo.lineQuads[j];
                            fontQuad.x = offsetX -= fontQuad.width;
                            fontQuad.y = offsetY;
                            fontQuad.visible = (fontQuad.x + fontQuad.width) > 0;
                        }
                        offsetY += textLineInfo.lineHeight;
                    }
                }
                else if (this._autoSize == UITextFieldAutoSize.CENTER) {
                    offsetY = 0;
                    if (!this.multiline && this._textLineInfo.length >= 1) {
                        offsetY = this.height / 2 - this._textLineInfo[0].lineHeight / 2;
                    }
                    for (var i = 0; i < this._textLineInfo.length; ++i) {
                        textLineInfo = this._textLineInfo[i];
                        offsetX = this.width * 0.5 - textLineInfo.lineWidth * 0.5;
                        for (var j = 0; j < textLineInfo.lineQuads.length; ++j) {
                            fontQuad = textLineInfo.lineQuads[j];
                            fontQuad.x = offsetX;
                            fontQuad.y = offsetY;
                            offsetX += fontQuad.width;
                            fontQuad.visible = (fontQuad.x + fontQuad.width) <= this.width && (fontQuad.x + fontQuad.width) > 0;
                        }
                        offsetY += textLineInfo.lineHeight;
                    }
                }
            };
            /**
            * @private
            */
            UITextField.prototype.buildTextLineInfo = function (text) {
                var textLineInfo = new TextLineInfo();
                textLineInfo.lineText = text;
                textLineInfo.lineWidth = 0;
                textLineInfo.lineHeight = 0;
                textLineInfo.lineQuads = [];
                for (var i = 0; i < text.length; ++i) {
                    var fontQuad = null;
                    var charCode = text.charCodeAt(i);
                    fontQuad = (charCode != 32) ? this.createFontQuad(charCode) : this._blankQuad;
                    textLineInfo.lineQuads.push(fontQuad);
                    textLineInfo.lineWidth += fontQuad.width;
                    if (textLineInfo.lineHeight < fontQuad.height) {
                        textLineInfo.lineHeight = fontQuad.height;
                    }
                }
                return textLineInfo;
            };
            /**
            * @language zh_CN
            * 将 newText 参数指定的字符串追加到文本字段的文本的末尾。
            * @param newText 新字符串
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextField.prototype.appendText = function (newText) {
            };
            /**
            * @language zh_CN
            * 返回一个矩形，该矩形是字符的边框。
            * @param charIndex 字符索引值
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextField.prototype.getCharBoundaries = function (charIndex) {
                return null;
            };
            /**
            * @language zh_CN
            * 在 x 和 y 参数指定的位置返回从零开始的字符索引值。
            * @param x x坐标位置
            * @param y y坐标位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextField.prototype.getCharIndexAtPoint = function (x, y) {
                return 0;
            };
            /**
            * @language zh_CN
            * 使用 value 参数的内容替换当前所选内容。
            * @param value 新字符串
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextField.prototype.replaceSelectedText = function (value) {
            };
            /**
            * @language zh_CN
            * 使用 newText 参数的内容替换 beginIndex 和 endIndex 参数指定的字符范围。
            * @param beginIndex 起始位置索引
            * @param endIndex 结束位置索引
            * @param newText 新字符串
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextField.prototype.replaceText = function (beginIndex, endIndex, newText) {
            };
            /**
            * @language zh_CN
            * 将第一个字符和最后一个字符的索引值（使用 beginIndex 和 endIndex 参数指定）指定的文本设置为所选内容。
            * @param beginIndex 起始位置索引
            * @param endIndex 结束位置索引
            * @version Egret 3.0
            * @platform Web,Native
            */
            UITextField.prototype.setSelection = function (beginIndex, endIndex) {
            };
            /**
            * @private
            */
            UITextField.prototype.createFontQuad = function (unicode, isAddChild) {
                if (isAddChild === void 0) { isAddChild = true; }
                var fontQuad;
                if (this._quadPool.length > 0) {
                    fontQuad = this._quadPool[this._quadPool.length - 1];
                    this._quadPool.splice(this._quadPool.length - 1, 1);
                }
                else {
                    fontQuad = new egret3d.Quad();
                    fontQuad.renderText = true;
                }
                var fontTexture = gui.BitmapFont.getTexture(unicode);
                if (!fontTexture) {
                    fontTexture = gui.BitmapFont.getTexture(("?").charCodeAt(0));
                }
                fontQuad.width = fontTexture.width;
                fontQuad.height = fontTexture.height;
                fontQuad.texture = fontTexture;
                fontQuad.color = this._textColor;
                if (isAddChild) {
                    this._fontQuadPanel.addChild(fontQuad);
                }
                return fontQuad;
            };
            /**
            * @private
            */
            UITextField.prototype.deleteFontQuad = function (fontQuad) {
                if (this._blankQuad == fontQuad)
                    return;
                this._fontQuadPanel.removeChild(fontQuad);
                this._quadPool.push(fontQuad);
            };
            return UITextField;
        }(egret3d.DisplayObject));
        gui.UITextField = UITextField;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
   * @class egret3d.gui.UILabelButton
   * @classdesc
   * 含文本组件的按钮, 用于在按钮上显示文字
   * @see egret3d.MouseEvent3D
   * @see egret3d.gui.UIButton
   * @version Egret 3.0
   * @platform Web,Native
   */
        var UILabelButton = (function (_super) {
            __extends(UILabelButton, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @version Egret 3.0
            * @platform Web,Native
            */
            function UILabelButton() {
                _super.call(this);
                this._label = "";
                this._textField = new gui.UITextField();
                this._textField.autoSize = gui.UITextFieldAutoSize.CENTER;
                this._textField.textColor = 0xff000000;
                this.addChild(this._textField);
                this.onRender();
                this._textHeight = -1;
                this._textWidth = -1;
            }
            /**
           * @private
           */
            UILabelButton.prototype.getDefaultStyleNameByStyleName = function (styleName) {
                var obj = {
                    "down": gui.DefaultSkinName.DEFAULT_LABE_BUTTON_DOWN,
                    "up": gui.DefaultSkinName.DEFAULT_LABEL_BUTTON_UP,
                    "disable": gui.DefaultSkinName.DEFAULT_LABE_BUTTON_DISABLE
                };
                var result = obj[styleName];
                if (!result) {
                    console.log(" ERROR!!! UILabelButton can't find default style : ", styleName);
                }
                return result;
            };
            Object.defineProperty(UILabelButton.prototype, "textHeight", {
                /**
               * @private
               */
                get: function () {
                    return this._textHeight;
                },
                /**
               * @private
               */
                set: function (value) {
                    this._textHeight = value;
                    this.onRender();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UILabelButton.prototype, "textWidth", {
                /**
               * @private
               */
                get: function () {
                    return this._textWidth;
                },
                /**
               * @private
               */
                set: function (value) {
                    this._textWidth = value;
                    this.onRender();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UILabelButton.prototype, "textField", {
                /**
               * @language zh_CN
               * 获取按钮内的文本组件。
               * @version Egret 3.0
               * @platform Web,Native
               */
                get: function () {
                    return this._textField;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UILabelButton.prototype, "label", {
                /**
               * @language zh_CN
               * 获取或设置组件的文本标签。
               * @version Egret 3.0
               * @platform Web,Native
               */
                get: function () {
                    return this._label;
                },
                /**
                * @language zh_CN
                * 获取或设置组件的文本标签。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    this._label = value;
                    this._textField.text = this._label;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * @private
            */
            UILabelButton.prototype.onRender = function () {
                _super.prototype.onRender.call(this);
                if (this._textHeight > 0) {
                    this.textField.textHeight = this._textHeight;
                }
                else {
                    this._textField.height = this._skin.height;
                }
                if (this._textWidth > 0) {
                    this.textField.textWidth = this._textWidth;
                }
                else {
                    this._textField.width = this._skin.width;
                }
            };
            return UILabelButton;
        }(gui.UIButton));
        gui.UILabelButton = UILabelButton;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
        * @class egret3d.gui.UIToggleButtonBase
        * @classdesc
        * UIToggleButtonBase 组件是支持 selected 属性的按钮组件的基类.</p>
        * UICheckBox 和 UIRadioButton 是 UIToggleButtonBase 的子类.</p>
        * @see egret3d.gui.UIRadioButton.
        * @see egret3d.gui.UICheckBox.
        * @version Egret 3.0
        * @platform Web,Native
        */
        var UIToggleButtonBase = (function (_super) {
            __extends(UIToggleButtonBase, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @version Egret 3.0
            * @platform Web,Native
            */
            function UIToggleButtonBase() {
                _super.call(this);
                this._selected = false;
                this._textPadding = 5;
                this.textField.autoSize = gui.UITextFieldAutoSize.LEFT;
                this.textWidth = 45;
                this.onRender();
            }
            Object.defineProperty(UIToggleButtonBase.prototype, "buttonAndLabelWidth", {
                /**
               * @language zh_CN
               * (只读)获取按钮和文本宽度之和
               * @version Egret 3.0
               * @platform Web,Native
               */
                get: function () {
                    return this._skin.width + this.textPadding + this.textWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UIToggleButtonBase.prototype, "textPadding", {
                /**
               * @language zh_CN
               * 获取或设置按钮和文本的间隔（以像素为单位）。
               * @version Egret 3.0
               * @platform Web,Native
               */
                get: function () {
                    return this._textPadding;
                },
                /**
                * @language zh_CN
                * 获取或设置按钮和文本的间隔（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    this._textPadding = value;
                    this.onRender();
                },
                enumerable: true,
                configurable: true
            });
            /**
            * @private
            */
            UIToggleButtonBase.prototype.onRender = function () {
                _super.prototype.onRender.call(this);
                this.textField.x = this._skin.width + this._textPadding;
            };
            Object.defineProperty(UIToggleButtonBase.prototype, "selected", {
                /**
                * @language zh_CN
                * 获取或设置一个布尔值，指示切换按钮是否已切换至打开或关闭位置。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._selected;
                },
                /**
                * @language zh_CN
                * 获取或设置一个布尔值，指示切换按钮是否已切换至打开或关闭位置。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    if (this._selected === value)
                        return;
                    this._selected = value;
                    this._selected ? this.setMouseState(UIToggleButtonBase.STATE_UP_AND_SELECTED) : this.setMouseState(gui.UIButton.STATE_UP);
                    var evt = new egret3d.Event3D(egret3d.Event3D.CHANGE);
                    evt.target = this;
                    this.dispatchEvent(evt);
                },
                enumerable: true,
                configurable: true
            });
            /**
            * @private
            */
            UIToggleButtonBase.prototype.setMouseState = function (state) {
                if (state === gui.UIButton.STATE_DOWN) {
                    this._selected ? _super.prototype.setMouseState.call(this, UIToggleButtonBase.STATE_DOWN_AND_SELECTED) : _super.prototype.setMouseState.call(this, gui.UIButton.STATE_DOWN);
                }
                else if (state === gui.UIButton.STATE_UP) {
                    this._selected ? _super.prototype.setMouseState.call(this, UIToggleButtonBase.STATE_UP_AND_SELECTED) : _super.prototype.setMouseState.call(this, gui.UIButton.STATE_UP);
                }
                else {
                    _super.prototype.setMouseState.call(this, state);
                }
            };
            /**
            * @private
            */
            UIToggleButtonBase.prototype.startPress = function () {
                _super.prototype.startPress.call(this);
                this._selected ? this.setMouseState(UIToggleButtonBase.STATE_DOWN_AND_SELECTED) : this.setMouseState(gui.UIButton.STATE_DOWN);
            };
            /**
            * @private
            */
            UIToggleButtonBase.prototype.endPress = function () {
                _super.prototype.endPress.call(this);
                this.selected = !this.selected;
                this._selected ? this.setMouseState(UIToggleButtonBase.STATE_UP_AND_SELECTED) : this.setMouseState(gui.UIButton.STATE_UP);
            };
            UIToggleButtonBase.STATE_DOWN_AND_SELECTED = "downAndSelected";
            UIToggleButtonBase.STATE_UP_AND_SELECTED = "upAndSelected";
            return UIToggleButtonBase;
        }(gui.UILabelButton));
        gui.UIToggleButtonBase = UIToggleButtonBase;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
   * @class egret3d.gui.UIPanel
   * @classdesc
   * 基础的面板组件. 内含背景图片,以及矩形显示区域限制
   * @version Egret 3.0
   * @platform Web,Native
   */
        var UIPanel = (function (_super) {
            __extends(UIPanel, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @version Egret 3.0
            * @platform Web,Native
            */
            function UIPanel() {
                _super.call(this);
                this._background = new egret3d.Quad();
                this._container = new gui.UIElement();
                _super.prototype.addChild.call(this, this._background);
                _super.prototype.addChild.call(this, this._container);
                this._w = 100;
                this._h = 100;
                this.drawBackground();
                this.updateMask();
            }
            /**
            * @private
            */
            UIPanel.prototype.updateMask = function () {
                this.mask = new egret3d.Rectangle(0, 0, this._w, this._h);
            };
            Object.defineProperty(UIPanel.prototype, "background", {
                /**
                * @private
                */
                get: function () {
                    return this._background;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UIPanel.prototype, "width", {
                /**
                * @language zh_CN
                * 获取或设置组件的高度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._w;
                },
                /**
                * @language zh_CN
                * 获取或设置组件的高度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    this._w = value;
                    this._background.width = value;
                    this.updateMask();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UIPanel.prototype, "height", {
                /**
                * @language zh_CN
                * 获取或设置组件的高度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._h;
                },
                /**
                * @language zh_CN
                * 获取或设置组件的高度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    this._h = value;
                    this._background.height = value;
                    this.updateMask();
                },
                enumerable: true,
                configurable: true
            });
            /**
            * @private
            */
            UIPanel.prototype.onRender = function () {
                _super.prototype.onRender.call(this);
                this.drawBackground();
                this.updateMask();
            };
            /**
            * @private
            */
            UIPanel.prototype.getDefaultStyleNameByStyleName = function (styleName) {
                var obj = {
                    "background": gui.DefaultSkinName.DEFAULT_PANEL_BACKGROUND
                };
                var result = obj[styleName];
                if (!result) {
                    console.log(" ERROR!!! UIPanel can't find default style : ", styleName);
                }
                return result;
            };
            /**
            * @private
            */
            UIPanel.prototype.drawBackground = function () {
                var texture = this.getStyle("background");
                this._background.texture = texture;
            };
            /**
           * @language zh_CN
           * 检索组件的样式查找链中设置的样式属性。
           * @param style 样式属性的名称。 可选值:background.
           * @version Egret 3.0
           * @platform Web,Native
           */
            UIPanel.prototype.setStyle = function (style, value) {
                _super.prototype.setStyle.call(this, style, value);
                this.onRender();
            };
            /**
            * @private
            */
            UIPanel.prototype.addChild = function (display) {
                return this._container.addChild(display);
            };
            /**
            * @private
            */
            UIPanel.prototype.addChildAt = function (display, index) {
                return this._container.addChildAt(display, index);
            };
            /**
            * @private
            */
            UIPanel.prototype.removeChild = function (display) {
                return this._container.removeChild(display);
            };
            /**
            * @private
            */
            UIPanel.prototype.removeChildAt = function (index) {
                return this._container.removeChildAt(index);
            };
            /**
            * @private
            */
            UIPanel.prototype.swapChildIndex = function (display, index) {
                this._container.swapChildIndex(display, index);
            };
            /**
            * @private
            */
            UIPanel.prototype.hasChild = function (display) {
                return this._container.hasChild(display);
            };
            /**
            * @private
            */
            UIPanel.prototype.getChildByIndex = function (index) {
                return this._container.getChildByIndex(index);
            };
            /**
            * @private
            */
            UIPanel.prototype.getChildByName = function (name) {
                return this._container.getChildByName(name);
            };
            return UIPanel;
        }(gui.UIElement));
        gui.UIPanel = UIPanel;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
       * @class egret3d.gui.UIList
       * @classdesc
       * 基础的列表组件. 实现了滚动交互</p>
       * 鼠标按下拖动时, 将能够拖动内部的显示区域
       * @version Egret 3.0
       * @platform Web,Native
       */
        var UIList = (function (_super) {
            __extends(UIList, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @version Egret 3.0
            * @platform Web,Native
            */
            function UIList() {
                _super.call(this);
                this._items = [];
                this._gap = 5;
                this._selectedIndex = -1;
                this._selectedItem = null;
                this.addEventListener(egret3d.MouseEvent3D.MOUSE_DOWN, this.onMouseDown, this);
                this._startDrag = false;
                this._container.height = 0;
            }
            /**
            * @private
            */
            UIList.prototype.onMouseDown = function (event) {
                this._startDrag = true;
                this.addEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.onMouseUp, this);
                this.addEventListener(egret3d.MouseEvent3D.MOUSE_MOVE, this.onMouseMove, this);
                if (this.stage) {
                    this.stage.addEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.onMouseUp, this);
                }
            };
            /**
            * @private
            */
            UIList.prototype.onMouseUp = function (event) {
                this._startDrag = false;
                this.removeEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.onMouseUp, this);
                this.removeEventListener(egret3d.MouseEvent3D.MOUSE_MOVE, this.onMouseMove, this);
                if (this.stage) {
                    this.stage.removeEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.onMouseUp, this);
                }
            };
            /**
            * @private
            */
            UIList.prototype.onMouseMove = function (event) {
                if (this._startDrag) {
                    //                this._container.x += Input.mouseOffsetX;
                    this._container.y += egret3d.Input.mouseOffsetY;
                    if (this._container.y > 0) {
                        this._container.y = 0;
                    }
                    else if (this._containerHeight < this.height) {
                        this._container.y = 0;
                    }
                    else if (this._container.y < this.height - this._containerHeight) {
                        this._container.y = this.height - this._containerHeight;
                    }
                }
            };
            /**
            * @private
            */
            UIList.prototype.updateView = function () {
                var sum = 0;
                for (var i = 0; i < this._items.length; i++) {
                    var child = this._items[i];
                    child.y = sum;
                    sum = child.y + child.height + this._gap;
                }
                this._containerHeight = sum;
            };
            Object.defineProperty(UIList.prototype, "gap", {
                /**
               * @language zh_CN
               * 组件内对象的间隔距离
               * @version Egret 3.0
               * @platform Web,Native
               */
                get: function () {
                    return this._gap;
                },
                /**
             * @language zh_CN
             * 组件内对象的间隔距离
             * @version Egret 3.0
             * @platform Web,Native
             */
                set: function (value) {
                    this._gap = value;
                    this.updateView();
                },
                enumerable: true,
                configurable: true
            });
            /**
           * @language zh_CN
           * 向组件里添加一项, 添加在组件尾部
           * @param item 需要添加的项
           * @version Egret 3.0
           * @platform Web,Native
           */
            UIList.prototype.addItem = function (item) {
                this._items.push(item);
                this.addChildAt(item, this._container.childs.length);
                this.updateView();
            };
            /**
           * @language zh_CN
           * 移除组件内部的一项
           * @param item 需要移除的项
           * @version Egret 3.0
           * @platform Web,Native
           */
            UIList.prototype.removeItem = function (item) {
                this.removeChild(item);
                this._items.splice(this._items.indexOf(item), 1);
                this.updateView();
            };
            return UIList;
        }(egret3d.gui.UIPanel));
        gui.UIList = UIList;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
   * @class egret3d.gui.UICheckBox
   * @classdesc
   * 组件显示一个小方框，该方框内可以有选中标记。 </p>
   * UICheckBox 组件还可以显示可选的文本标签。
   * @see egret3d.gui.UIToggleButtonBase
   * @see egret3d.MouseEvent3D
   * @version Egret 3.0
   * @platform Web,Native
   */
        var UICheckBox = (function (_super) {
            __extends(UICheckBox, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @version Egret 3.0
            * @platform Web,Native
            */
            function UICheckBox() {
                _super.call(this);
            }
            /**
            * @private
            */
            UICheckBox.prototype.getDefaultStyleNameByStyleName = function (styleName) {
                var obj = {
                    "down": gui.DefaultSkinName.DEFAULT_CHECK_BOX_DOWN,
                    "up": gui.DefaultSkinName.DEFAULT_CHECK_BOX_UP,
                    "downAndSelected": gui.DefaultSkinName.DEFAULT_CHECK_BOX_SELECTED_DOWN,
                    "upAndSelected": gui.DefaultSkinName.DEFAULT_CHECK_BOX_SELECTED_UP,
                    "disable": gui.DefaultSkinName.DEFAULT_CHECK_BOX_DISABLE
                };
                var result = obj[styleName];
                if (!result) {
                    console.log(" ERROR!!! UICheckBox can't find default style : ", styleName);
                }
                return result;
            };
            return UICheckBox;
        }(gui.UIToggleButtonBase));
        gui.UICheckBox = UICheckBox;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
   * @class egret3d.gui.UIRadioButton
   * @classdesc
   * 圆形的单选框按钮组件.</p>
   * 配合UIRadioButtonGroup可实现在任何给定的时刻，都只有一个组成员被选中.</p>
   * 当状态发生变化时调度Event3D.CHANGE.</p>
   * @see egret3d.gui.UIToggleButtonBase
   * @see egret3d.Event3D
   * @version Egret 3.0
   * @platform Web,Native
   */
        var UIRadioButton = (function (_super) {
            __extends(UIRadioButton, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @version Egret 3.0
            * @platform Web,Native
            */
            function UIRadioButton() {
                _super.call(this);
            }
            Object.defineProperty(UIRadioButton.prototype, "group", {
                /**
                * @language zh_CN
                * @param group 此 UIRadioButton 所属的 UIRadioButtonGroup 对象。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (group) {
                    this._group = group;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * @private
            */
            UIRadioButton.prototype.getDefaultStyleNameByStyleName = function (styleName) {
                var obj = {
                    "down": gui.DefaultSkinName.DEFAULT_RADIO_BUTTON_DOWN,
                    "up": gui.DefaultSkinName.DEFAULT_RADIO_BUTTON_UP,
                    "downAndSelected": gui.DefaultSkinName.DEFAULT_RADIO_BUTTON_SELECTED_DOWN,
                    "upAndSelected": gui.DefaultSkinName.DEFAULT_RADIO_BUTTON_SELECTED_UP,
                    "disable": gui.DefaultSkinName.DEFAULT_RADIO_BUTTON_DISABLE
                };
                var result = obj[styleName];
                if (!result) {
                    console.log(" ERROR!!! UIRadioButton can't find default style : ", styleName);
                }
                return result;
            };
            return UIRadioButton;
        }(gui.UIToggleButtonBase));
        gui.UIRadioButton = UIRadioButton;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
        * @class egret3d.gui.UIRadioButtonGroup
        * @classdesc
        * RadioButtonGroup 类将一组 RadioButton 组件定义为单个组件。 选中一个单选按钮后，不能再选中同一组中的其它单选按钮
        * 当组内的选定 RadioButton 实例发生变化时调度Event3D.CHANGE.</p>
        * @see egret3d.Event3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        var UIRadioButtonGroup = (function (_super) {
            __extends(UIRadioButtonGroup, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @version Egret 3.0
            * @platform Web,Native
            */
            function UIRadioButtonGroup() {
                _super.call(this);
                this._items = [];
                this._enable = true;
            }
            Object.defineProperty(UIRadioButtonGroup.prototype, "enable", {
                /**
                * @language zh_CN
                * 组件是否可用
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._enable;
                },
                /**
                * @language zh_CN
                * 组件是否可用
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    if (this._enable === value)
                        return;
                    this._enable = value;
                    for (var i = 0; i < this._items.length; i++) {
                        var item = this._items[i];
                        item.enable = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UIRadioButtonGroup.prototype, "selection", {
                /**
                * @language zh_CN
                * (只读)获取当前选中的项
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._selection;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UIRadioButtonGroup.prototype, "selectedIndex", {
                /**
                * @language zh_CN
                * 获取或设置当前选中项的索引
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._items.indexOf(this._selection);
                },
                /**
                * @language zh_CN
                * 获取或设置当前选中项的索引
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (index) {
                    var item = this._items[index];
                    if (item) {
                        item.selected = true;
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
           * @language zh_CN
           * 添加一个UIRadioButton到组件中
           * @param item 要添加的UIRadioButton组件
           * @version Egret 3.0
           * @platform Web,Native
           */
            UIRadioButtonGroup.prototype.addItem = function (item) {
                this._items.push(item);
                item.enable = this._enable;
                item.addEventListener(egret3d.Event3D.CHANGE, this.onItemChange, this);
            };
            /**
            * @language zh_CN
            * 移除一个UIRadioButton组件
            * @param item 要移除的UIRadioButton组件
            * @version Egret 3.0
            * @platform Web,Native
            */
            UIRadioButtonGroup.prototype.removeItem = function (item) {
                var index = this._items.indexOf(item);
                if (index !== -1) {
                    item.removeEventListener(egret3d.Event3D.CHANGE, this.onItemChange, this);
                    this._items.splice(index, 1);
                }
            };
            /**
            * @private
            */
            UIRadioButtonGroup.prototype.getRadioButtonAt = function (index) {
                return this._items[index];
            };
            /**
            * @private
            */
            UIRadioButtonGroup.prototype.onItemChange = function (event) {
                var target = event.target;
                this.changeSelectedItem(target);
                //            if (target.selected === false) return;
                //            if (this._selection === target) {
                //                return;
                //            }
                //            if(this._selection) this._selection.selected = false;
                //            this._selection = target;
                //            var evt: Event3D = new Event3D(Event3D.CHANGE);
                //            evt.target = this;
                //            this.dispatchEvent(evt);
            };
            /**
           * @private
           */
            UIRadioButtonGroup.prototype.changeSelectedItem = function (item) {
                if (item.selected === false)
                    return;
                if (this._selection === item) {
                    return;
                }
                if (this._selection)
                    this._selection.selected = false;
                this._selection = item;
                var evt = new egret3d.Event3D(egret3d.Event3D.CHANGE);
                evt.target = this;
                this.dispatchEvent(evt);
            };
            return UIRadioButtonGroup;
        }(egret3d.EventDispatcher));
        gui.UIRadioButtonGroup = UIRadioButtonGroup;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
   * @class egret3d.gui.UIProgressBar
   * @classdesc
   * 基础的进度条组件.</p>
   * 由底部背景条以及顶部的进度条组成.</p>
   * 组件样式名为background以及 bar 分别用来设置底部背景条以及顶部进度条的样式
   * @version Egret 3.0
   * @platform Web,Native
   */
        var UIProgressBar = (function (_super) {
            __extends(UIProgressBar, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @version Egret 3.0
            * @platform Web,Native
            */
            function UIProgressBar() {
                _super.call(this);
                this._mask = new egret3d.Rectangle();
                this._background = new egret3d.Quad();
                this.addChild(this._background);
                this._bar = new egret3d.Quad();
                this.addChild(this._bar);
                this._ratio = 0.5;
                this.updateStyle();
            }
            Object.defineProperty(UIProgressBar.prototype, "ratio", {
                /**
               * @language zh_CN
               * 进度条的比例.</p>
               * 取值范围为0-1,即进度条由空到填满</p>
               * 小于0 取0, 大于1 取1
               * @version Egret 3.0
               * @platform Web,Native
               */
                get: function () {
                    return this._ratio;
                },
                /**
               * @language zh_CN
               * 进度条的比例.</p>
               * 取值范围为0-1,即进度条由空到填满</p>
               * 小于0 取0, 大于1 取1
               * @version Egret 3.0
               * @platform Web,Native
               */
                set: function (value) {
                    if (value > 1) {
                        value = 1;
                    }
                    else if (value < 0) {
                        value = 0;
                    }
                    this._ratio = value;
                    this.updateBar();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UIProgressBar.prototype, "width", {
                /**
                * @language zh_CN
                * 获取或设置组件的宽度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._background.width;
                },
                /**
                * @language zh_CN
                * 获取或设置组件的宽度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    this._background.width = this._bar.width = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UIProgressBar.prototype, "height", {
                /**
                * @language zh_CN
                * 获取或设置组件的高度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._background.height;
                },
                /**
                * @language zh_CN
                * 获取或设置组件的高度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    this._background.height = this._bar.height = value;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * @private
            */
            UIProgressBar.prototype.setBarRect = function (x, y, w, h) {
                this._bar.x = x;
                this._bar.y = y;
                this._bar.width = w;
                this._bar.height = h;
            };
            Object.defineProperty(UIProgressBar.prototype, "bar", {
                /**
                * @language zh_CN
                * 获取进度条的显示对象.
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._bar;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UIProgressBar.prototype, "background", {
                /**
                * @language zh_CN
                * 获取背景的显示对象.
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._background;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * @private
            */
            UIProgressBar.prototype.updateBar = function () {
                this._mask.width = this._ratio * this._bar.width;
                this._mask.height = this._bar.height;
                this._bar.mask = this._mask;
            };
            /**
           * @language zh_CN
           * 检索组件的样式查找链中设置的样式属性。
           * @param style 样式属性的名称。 可选值:bar, background.
           * @version Egret 3.0
           * @platform Web,Native
           */
            UIProgressBar.prototype.setStyle = function (style, value) {
                _super.prototype.setStyle.call(this, style, value);
                this.updateStyle();
                this.updateBar();
            };
            /**
            * @private
            */
            UIProgressBar.prototype.getDefaultStyleNameByStyleName = function (styleName) {
                var obj = {
                    "bar": gui.DefaultSkinName.DEFAULT_PROGRESS_BAR,
                    "background": gui.DefaultSkinName.DEFAULT_PROGRESS_BAR_BACKGROUND
                };
                var result = obj[styleName];
                if (!result) {
                    console.log(" ERROR!!! UISlider can't find default style : ", styleName);
                }
                return result;
            };
            /**
            * @private
            */
            UIProgressBar.prototype.updateStyle = function () {
                this._background.texture = this.getStyle("background");
                this._bar.texture = this.getStyle("bar");
            };
            return UIProgressBar;
        }(gui.UIElement));
        gui.UIProgressBar = UIProgressBar;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var gui;
    (function (gui) {
        /**
        * @class egret3d.gui.UISlider
        * @classdesc
        * 通过使用 Slider 组件，用户可以在滑块轨道的端点之间移动滑块来选择值。 </p>
        * Slider 组件的当前值由滑块端点之间滑块的相对位置确定，端点对应于 Slider 组件的 minimum 和 maximum 值。
        * 组件样式名为background以及 bar 分别用来设置底部背景条以及顶部的样式
        * @version Egret 3.0
        * @platform Web,Native
        */
        var UISlider = (function (_super) {
            __extends(UISlider, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @version Egret 3.0
            * @platform Web,Native
            */
            function UISlider() {
                _super.call(this);
                this._background = new egret3d.Quad();
                this._bar = new egret3d.Quad();
                this._text = new gui.UITextField(gui.UITextFieldType.DYNAMIC);
                this._text.autoSize = gui.UITextFieldAutoSize.CENTER;
                this._text.textColor = 0xff000000;
                this.addChild(this._background);
                this.addChild(this._bar);
                this.addChild(this._text);
                //            this._background.color = 0xff00ffff;
                //            this._bar.color = 0xffff00ff;
                this._minimum = 0;
                this._maximum = 100;
                this._snapInterval = 10;
                this.value = 50;
                this.addEventListener(egret3d.MouseEvent3D.MOUSE_DOWN, this.onMouseDown, this);
                this.drawTexture();
            }
            /**
            * @language zh_CN
            * 设置皮肤
            * @param style 皮肤名称, 可选值: background, bar.
            * @param value 皮肤贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            UISlider.prototype.setStyle = function (style, value) {
                _super.prototype.setStyle.call(this, style, value);
                this.drawTexture();
                //            if (style === "bar") {
                //                this._bar.texture = value;
                //            } else if (style === "background") {
                //                this._background.texture = value;
                //            }
                this.onRender();
            };
            /**
            * @private
            */
            UISlider.prototype.drawTexture = function () {
                this._bar.texture = this.getStyle("bar");
                this._background.texture = this.getStyle("background");
            };
            /**
            * @private
            */
            UISlider.prototype.getDefaultStyleNameByStyleName = function (styleName) {
                var obj = {
                    "bar": gui.DefaultSkinName.DEFAULT_SLIDER_BAR,
                    "background": gui.DefaultSkinName.DEFAULT_SLIDER_BACKGROUND
                };
                var result = obj[styleName];
                if (!result) {
                    console.log(" ERROR!!! UISlider can't find default style : ", styleName);
                }
                return result;
            };
            /**
            * @private
            */
            UISlider.prototype.onMouseUp = function (event) {
                this.removeEventListener(egret3d.MouseEvent3D.MOUSE_MOVE, this.onMouseMove, this);
                this.removeEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.onMouseUp, this);
            };
            /**
            * @private
            */
            UISlider.prototype.onMouseDown = function (event) {
                this.addEventListener(egret3d.MouseEvent3D.MOUSE_MOVE, this.onMouseMove, this);
                //            this.addEventListener(MouseEvent3D.MOUSE_UP, this.onMouseUp, this);
                if (this.stage) {
                    this.stage.addEventListener(egret3d.MouseEvent3D.MOUSE_UP, this.onMouseUp, this);
                }
                var cx = this.mouseX;
                this.value = cx / this._background.width * (this._maximum - this._minimum) + this._minimum;
            };
            /**
            * @private
            */
            UISlider.prototype.updateBar = function () {
                var ratio = Math.abs((this._value - this._minimum) / (this._maximum - this._minimum));
                this._bar.width = this._background.width * ratio;
                this._text.text = this.value.toString();
            };
            Object.defineProperty(UISlider.prototype, "snapInterval", {
                /**
                * @language zh_CN
                * 获取或设置用户移动滑块时值增加或减小的量。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._snapInterval;
                },
                /**
              * @language zh_CN
              * 获取或设置用户移动滑块时值增加或减小的量。
              * @version Egret 3.0
              * @platform Web,Native
              */
                set: function (value) {
                    this._snapInterval = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UISlider.prototype, "value", {
                /**
                * @language zh_CN
                * 获取或设置 Slider 组件的当前值。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._value;
                },
                /**
                * @language zh_CN
                * 获取或设置 Slider 组件的当前值。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    if (value % this._snapInterval !== 0) {
                        value = Math.round(value / this._snapInterval) * this._snapInterval;
                    }
                    if (this._value === value)
                        return;
                    this._value = value;
                    var event = new egret3d.Event3D(egret3d.Event3D.CHANGE);
                    this.dispatchEvent(event);
                    this.updateBar();
                },
                enumerable: true,
                configurable: true
            });
            /**
            * @private
            */
            UISlider.prototype.onMouseMove = function (event) {
                var cx = this.mouseX;
                this.value = cx / this._background.width * (this._maximum - this._minimum) + this._minimum;
            };
            Object.defineProperty(UISlider.prototype, "maximum", {
                /**
               * @language zh_CN
               * Slider 组件实例所允许的最大值。
               * @version Egret 3.0
               * @platform Web,Native
               */
                get: function () {
                    return this._maximum;
                },
                /**
                * @language zh_CN
                * Slider 组件实例所允许的最大值。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    this._maximum = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UISlider.prototype, "minimum", {
                /**
                * @language zh_CN
                * Slider 组件实例所允许的最小值。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._minimum;
                },
                /**
                * @language zh_CN
                * Slider 组件实例所允许的最小值。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    this._minimum = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UISlider.prototype, "width", {
                /**
                * @language zh_CN
                * 获取或设置组件的宽度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._background.width;
                },
                /**
                * @language zh_CN
                * 获取或设置组件的宽度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    this._background.width = this._text.width = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UISlider.prototype, "height", {
                /**
                * @language zh_CN
                * 获取或设置组件的高度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                get: function () {
                    return this._background.height;
                },
                /**
                * @language zh_CN
                * 获取或设置组件的高度（以像素为单位）。
                * @version Egret 3.0
                * @platform Web,Native
                */
                set: function (value) {
                    this._background.height = this._text.height = this._bar.height = value;
                },
                enumerable: true,
                configurable: true
            });
            return UISlider;
        }(gui.UIElement));
        gui.UISlider = UISlider;
    })(gui = egret3d.gui || (egret3d.gui = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    *@language zh_CN
    * @class egret3d.LightType
    * 灯光类型
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (LightType) {
        /**
        *@language zh_CN
        * 点光源
        * @version Egret 3.0
        * @platform Web,Native
        */
        LightType[LightType["pointlight"] = 0] = "pointlight";
        /**
        *@language zh_CN
        * 平行光
        * @version Egret 3.0
        * @platform Web,Native
        */
        LightType[LightType["directlight"] = 1] = "directlight";
        /**
        *@language zh_CN
        * 聚光灯
        * @version Egret 3.0
        * @platform Web,Native
        */
        LightType[LightType["spotLightlight"] = 2] = "spotLightlight";
    })(egret3d.LightType || (egret3d.LightType = {}));
    var LightType = egret3d.LightType;
    /**
    * @class egret3d.DirectLight
    * @classdesc
    * 灯光的基础类型。</p>
    * 所有的灯光基本要素 灯光的颜色，强度，位置，方向。</p>
    * 颜色的色值均是16进制 red:0xffff0000 argb的定义模式。</p>
    * 每个材质球所能最大使用的灯光建议别太多，能省则省，尤其是移动端，能用灯光缓存图 lightmap 最好。</p>
    * @see egret3d.Object3D
    * @see egret3d.LightGroup
    * @see egret3d.LightBase
    * @see egret3d.PointLight
    * @see egret3d.SpotLight
    * @version Egret 3.0
    * @platform Web,Native
    */
    var LightBase = (function (_super) {
        __extends(LightBase, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function LightBase() {
            _super.call(this);
            /**
            *@language zh_CN
            * 灯光在配置表中的id，用于和贴图建立绑定关系
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lightId = -1;
            /**
            *@language zh_CN
            * 灯光类型
            * @see egret3d.LightType
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lightType = -1;
            /**
            * @language zh_CN
            * @private
            * 环境颜色
            */
            this._ambient = new egret3d.Vector3D(0.0, 0.0, 0.0);
            /**
            * @language zh_CN
            * @private
            * 漫反射
            */
            this._diffuse = new egret3d.Vector3D(1.0, 1.0, 1.0);
            // /**
            // * @language zh_CN  
            // *@private
            // * 背光颜色
            // */
            //protected _halfColor: Vector3D = new Vector3D(1.0, 1.0, 1.0);
            /**
             * @language zh_CN
             *@private
             * 镜面反射
             */
            this._specular = new egret3d.Vector3D(1.0, 1.0, 1.0);
            /**
             * @language zh_CN
             *@private
             */
            this._halfVector = new egret3d.Vector3D(1.0, 1.0, 1.0);
            /**
             * @language zh_CN
             *@private
             * @param value 强度
             */
            this._intensity = 1;
            this._radius = 100;
            this._cutoff = 0.01;
            /**
            *@language zh_CN
            *@private
            * @param value 背光强度
            */
            this._halfIntensity = 0.0;
            /**
             * @language zh_CN
             *@private
             */
            this._spotExponent = 1.1;
            /**
             * @language zh_CN
             *@private
             */
            this._spotCutoff = 0.7;
            /**
             * @language zh_CN
             *@private
             */
            this._spotCosCutoff = 0.1;
            /**
             * @language zh_CN
             *@private
             */
            this._constantAttenuation = 0.1;
            /**
             * @language zh_CN
             *@private
             */
            this._linearAttenuation = 0.1;
            /**
             * @language zh_CN
             *@private
             */
            this._quadraticAttenuation = 0.1;
            /**
             * @language zh_CN
             *@private
             */
            this._lightIndex = -1;
            /**
             * @language zh_CN
             *@private
             */
            this.len = 25;
            /**
             * @language zh_CN
             *@private
             */
            this._change = true;
            /**
             * @language zh_CN
             *@private
             */
            this.lightViewPos = new egret3d.Vector3D();
        }
        Object.defineProperty(LightBase.prototype, "intensity", {
            /**
            * @language zh_CN
            * 得到灯光强度。</p>
            * 影响灯光的强弱显示，值的范围0~没有上限，但是值过大会导致画面过度曝光。</p>
            * @returns number 灯光强度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._intensity;
            },
            /**
            * @language zh_CN
            * 设置灯光强度。</p>
            * 影响灯光的强弱显示，值的范围0~没有上限，但是值过大会导致画面过度曝光。</p>
            * @param value 强度数值
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._intensity != value) {
                    this._intensity = value;
                    this._change = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "halfIntensity", {
            /**
            * @language zh_CN
            * 得到背光灯光强度。</p>
            * 影响背光灯光的强弱显示，值的范围0~没有上限，但是值过大会导致画面过度曝光。</p>
            * @returns number 背光灯光的强弱
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._halfIntensity;
            },
            /**
            * @language zh_CN
            * 设置背光灯光强度。</p>
            * 影响背光灯光的强弱显示，值的范围0~没有上限，但是值过大会导致画面过度曝光。</p>
            * @param value 背光灯光强度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._halfIntensity != value) {
                    this._halfIntensity = value;
                    this._change = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "ambient", {
            /**
            * @language zh_CN
            * 获取 灯光环境颜色。</p>
            * 物体在未受到光的直接照射的地方 模拟间接环境光颜色，会影响背光面的颜色。</p>
            * @returns number ambient  灯光环境颜色
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return 0;
            },
            /**
            * @language zh_CN
            * 设置灯光环境颜色。</p>
            * 物体在未受到光的直接照射的地方 模拟间接环境光颜色，会影响背光面的颜色。</p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this._ambient.w = (color >> 24 & 0xff) / 255;
                this._ambient.x = (color >> 16 & 0xff) / 255;
                this._ambient.y = (color >> 8 & 0xff) / 255;
                this._ambient.z = (color & 0xff) / 255;
                this._change = false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "diffuse", {
            /**
            * @language zh_CN
            * 设置灯光漫反射颜色。</p>
            * 直接影响最终灯光的颜色色值 16进制的颜色 例如 red：0xffff0000。</p>
            * 也可以通过 diffusePower 来改变这个值的总体强弱。</p>
            * @returns number diffuse
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return 0;
            },
            /**
            * @language zh_CN
            * 设置灯光漫反射颜色。</p>
            * 直接影响最终灯光的颜色色值 16进制的颜色, 例如 red：0xffff0000。</p>
            * 也可以通过 diffusePower 来改变这个值的总体强弱
            * @param color 颜色值，0xffffffff格式
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this._diffuse.w = (color >> 24 & 0xff) / 255;
                this._diffuse.x = (color >> 16 & 0xff) / 255;
                this._diffuse.y = (color >> 8 & 0xff) / 255;
                this._diffuse.z = (color & 0xff) / 255;
                this._change = false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "specular", {
            /**
            * @language zh_CN
            * 在灯光方向与物体和相机成一个反光角度的时候，就会产生反光，高光，而不同的物体会有不同的颜色色值，尤其是金属。</p>
            * 16进制的颜色 例如 red：0xffff0000。</p>
            * 也可以通过 specularPower 来改变这个值的总体强弱。</p>
            * @returns number  灯光镜面高光反射颜色
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return 0;
            },
            /**
            * @language zh_CN
            * 设置灯光镜面高光反射颜色。</p>
            * 在灯光方向与物体和相机成一个反光角度的时候，就会产生反光，高光，而不同的物体会有不同的颜色色值，尤其是金属。</p>
            * 16进制的颜色 例如 red：0xffff0000。</p>
            * 也可以通过 specularPower 来改变这个值的总体强弱。</p>
            * @param color 颜色值，0xffffffff格式
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this._specular.w = (color >> 24 & 0xff) / 255;
                this._specular.x = (color >> 16 & 0xff) / 255;
                this._specular.y = (color >> 8 & 0xff) / 255;
                this._specular.z = (color & 0xff) / 255;
                this._change = false;
            },
            enumerable: true,
            configurable: true
        });
        LightBase.prototype.init = function () {
        };
        /**
        * @language zh_CN
        * @private
        * 更新灯光数据
        * @param index 灯光ID
        * @param lightData 灯光数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        LightBase.prototype.updateLightData = function (camera, index, lightData) {
        };
        return LightBase;
    }(egret3d.Object3D));
    egret3d.LightBase = LightBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.DirectLight
    * @classdesc
    *
    * 点光源
    * 所有的灯光基本要素 灯光的颜色，强度，位置，方向
    * 颜色的色值均是16进制 red:0xffff0000 argb的定义模式
    * 每个材质球所能最大使用的灯光建议别太多，能省则省，尤其是移动端，能用灯光缓存图 lightmap 最好
    * 点光源是游戏中常常用到的动态光源，实时渲染中，灯光的数量会直接影响渲染性能
    * @see egret3d.Object3D
    * @see egret3d.LightGroup
    * @see egret3d.LightBase
    * @includeExample lights/PointLight.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        /**
        * @language zh_CN
        * 创建一个点光源
        * @param color 灯光颜色值
        * @default 0xffffff
        * @version Egret 3.0
        * @platform Web,Native
        */
        function PointLight(color) {
            if (color === void 0) { color = 0xffffff; }
            _super.call(this);
            this.scenePosMat = new egret3d.Matrix4_4();
            this.lightType = egret3d.LightType.pointlight;
            this.diffuse = color;
        }
        Object.defineProperty(PointLight.prototype, "radius", {
            /**
            * @language zh_CN
            * 获取灯光半径
            * @returns number 灯光半径
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._radius;
            },
            /**
            * @language zh_CN
            * 设置灯光半径
            * @param value 灯光半径
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._radius = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointLight.prototype, "cutoff", {
            /**
            * @language zh_CN
            * 获取灯光衰减度
            * @returns number 灯光衰减度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._cutoff;
            },
            /**
            * @language zh_CN
            * 设置灯光衰减度
            * @param value 灯光衰减度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._cutoff = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointLight.prototype, "ambient", {
            /**
              * @language zh_CN
              *
              * 背光颜色
              * 模拟间接光照而开发的背光，而不用去同时打两盏不同方向的组合灯光，可以优化显示效果
              * @param color 背光颜色色值
              * @version Egret 3.0
              * @platform Web,Native
              */
            set: function (color) {
                this._ambient.w = (color >> 24 & 0xff) / 255;
                this._ambient.x = (color >> 16 & 0xff) / 255;
                this._ambient.y = (color >> 8 & 0xff) / 255;
                this._ambient.z = (color & 0xff) / 255;
                this._change = false;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * @private
        * 更新灯光数据
        * @param index 灯光ID
        * @param lightData 灯光数据
        */
        PointLight.prototype.updateLightData = function (camera, index, lightData) {
            lightData[index * PointLight.stride] = this.globalPosition.x;
            lightData[index * PointLight.stride + 1] = this.globalPosition.y;
            lightData[index * PointLight.stride + 2] = this.globalPosition.z;
            lightData[index * PointLight.stride + 3] = this._diffuse.x * this._intensity;
            lightData[index * PointLight.stride + 4] = this._diffuse.y * this._intensity;
            lightData[index * PointLight.stride + 5] = this._diffuse.z * this._intensity;
            lightData[index * PointLight.stride + 6] = this._ambient.x;
            lightData[index * PointLight.stride + 7] = this._ambient.y;
            lightData[index * PointLight.stride + 8] = this._ambient.z;
            lightData[index * PointLight.stride + 9] = this._intensity;
            lightData[index * PointLight.stride + 10] = this._radius;
            lightData[index * PointLight.stride + 11] = this._cutoff;
        };
        PointLight.scenePos = new egret3d.Vector3D();
        /**
         * @language zh_CN
         * @private
         * 点光源的数据长度
         */
        PointLight.stride = 12;
        return PointLight;
    }(egret3d.LightBase));
    egret3d.PointLight = PointLight;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.SpotLight
    * @classdesc
    * spot 的灯光 也就是筒灯
    * 所有的灯光基本要素 灯光的颜色，强度，位置，方向
    * 颜色的色值均是16进制 red:0xffff0000 argb的定义模式
    * 每个材质球所能最大使用的灯光建议别太多，能省则省，尤其是移动端，能用灯光缓存图 lightmap 最好
    * spot light 可以直接想象为点光源照了个罩子，有方向且有范围的灯光
    * @see egret3d.Object3D
    * @see egret3d.LightGroup
    * @see egret3d.LightBase
    * @see egret3d.PointLight
    * @see egret3d.SpotLight
    * @version Egret 3.0
    * @platform Web,Native
    */
    var SpotLight = (function (_super) {
        __extends(SpotLight, _super);
        /**
        * @language zh_CN
        * 创建一个聚光源
        * @param color 灯光颜色值
        * @version Egret 3.0
        * @platform Web,Native
        */
        function SpotLight(color) {
            _super.call(this);
            this.diffuse = color;
            this.lightType = egret3d.LightType.spotLightlight;
        }
        Object.defineProperty(SpotLight.prototype, "spotCosCutoff", {
            /**
            * @language zh_CN
            *
            * spot 的 裁切范围
            * spot light 照射范围的大小指数
            * @returns number Cutoff -spot 的 裁切范围
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._spotCosCutoff;
            },
            /**
            * @language zh_CN
            *
            * spot 的 裁切范围
            * spot light 照射范围的大小指数
            * @param value Cutoff
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._spotCosCutoff = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "spotExponent", {
            /**
            * @language zh_CN
            *
            * spot 的 灯光强弱
            * spot light 灯光圆形范围内随半径大小改变发生的灯光强弱指数
            * @returns number 灯光强弱指数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._spotExponent;
            },
            /**
            * @language zh_CN
            * spot 的 灯光强弱
            * spot light 灯光圆形范围内随半径大小改变发生的灯光强弱指数
            *
            * @param value 灯光强弱指数
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._spotExponent = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "constantAttenuation", {
            /**
            * @language zh_CN
            * spot 的 灯光衰减
            * spot light 灯光圆形范围内随半径大小改变发生的灯光衰减常数指数
            * @returns number 持续衰减
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._constantAttenuation;
            },
            /**
            * @language zh_CN
            *
            * spot 的 灯光衰减
            * spot light 灯光圆形范围内随半径大小改变发生的灯光衰减常数指数
            * @param value 持续衰减
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._constantAttenuation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "linearAttenuation", {
            /**
            * @language zh_CN
            *
            * spot 的 灯光线性衰减
            * spot light 灯光圆形范围内随半径大小改变发生的灯光线性衰减
            * @returns number 线性衰减
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._linearAttenuation;
            },
            /**
            * @language zh_CN
            *
            * spot 的 灯光线性衰减
            * spot light 灯光圆形范围内随半径大小改变发生的灯光线性衰减
            * @param value 线性衰减
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._linearAttenuation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "quadraticAttenuation", {
            /**
            * @language zh_CN
            *
            * spot 的 灯光线性2次衰减
            * spot light 灯光圆形范围内随半径大小改变发生的灯光线性2次衰减
            * @returns number 返回2次衰减
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._quadraticAttenuation;
            },
            /**
            * @language zh_CN
            *
            * spot 的 灯光线性2次衰减
            * spot light 灯光圆形范围内随半径大小改变发生的灯光线性2次衰减
            * @param value 2次衰减
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._quadraticAttenuation = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         * @private
         * 更新灯光数据
         * @param index 灯光ID
         * @param lightData 灯光数据
         */
        SpotLight.prototype.updateLightData = function (camera, index, lightData) {
            lightData[index * SpotLight.stride] = this.globalPosition.x;
            lightData[index * SpotLight.stride + 1] = this.globalPosition.y;
            lightData[index * SpotLight.stride + 2] = this.globalPosition.z;
            lightData[index * SpotLight.stride + 3] = this.globalRotation.x * egret3d.MathUtil.DEGREES_TO_RADIANS;
            lightData[index * SpotLight.stride + 4] = this.globalRotation.y * egret3d.MathUtil.DEGREES_TO_RADIANS;
            lightData[index * SpotLight.stride + 5] = this.globalRotation.z * egret3d.MathUtil.DEGREES_TO_RADIANS;
            lightData[index * SpotLight.stride + 6] = this._diffuse.x;
            lightData[index * SpotLight.stride + 7] = this._diffuse.y;
            lightData[index * SpotLight.stride + 8] = this._diffuse.z;
            lightData[index * SpotLight.stride + 9] = this._spotExponent;
            lightData[index * SpotLight.stride + 10] = this._spotCosCutoff;
            lightData[index * SpotLight.stride + 11] = this._constantAttenuation;
            lightData[index * SpotLight.stride + 12] = this._linearAttenuation;
            lightData[index * SpotLight.stride + 13] = this._quadraticAttenuation;
        };
        /**
         * @language zh_CN
         * @priavete
         */
        SpotLight.stride = 14;
        return SpotLight;
    }(egret3d.LightBase));
    egret3d.SpotLight = SpotLight;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.DirectLight
    * @classdesc
    * 平行灯光</p>
    * 平行光是一种只有方向，强弱度，没有大小范围的灯光，一般情况下，directlight 可以产生阴影;</p>
    * 如果要产生阴影 需要设置 egret3d.ShadowRender.castShadowLight = directLight; 及其他相关模型的设置.</p>
    *
    * @see egret3d.LightGroup
    * @see egret3d.LightBase
    * @see egret3d.ShadowRender
    * @includeExample lights/DirectLight.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var DirectLight = (function (_super) {
        __extends(DirectLight, _super);
        /**
        * @language zh_CN
        * 创建一个平行光对象
        * @param dir 光线的方向
        * @default Vector3D(0, 0, 1)
        * @version Egret 3.0
        * @platform Web,Native
        */
        function DirectLight(dir) {
            if (dir === void 0) { dir = new egret3d.Vector3D(0, 0, 1); }
            _super.call(this);
            this._dir = new egret3d.Vector3D(0, 0, 1);
            this._dir.copyFrom(dir);
            this._dir.normalize();
            egret3d.Quaternion.fromToRotation(egret3d.Vector3D.Z_AXIS, this._dir, DirectLight.q0);
            this.globalOrientation = DirectLight.q0;
            this.lightType = egret3d.LightType.directlight;
        }
        Object.defineProperty(DirectLight.prototype, "ambient", {
            /**
            * @language zh_CN
            *
            * 背光颜色
            * 模拟间接光照而开发的背光，而不用去同时打两盏不同方向的组合灯光，可以优化显示效果
            * @param color 背光颜色色值，格式0xffffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this._ambient.w = (color >> 24 & 0xff) / 255;
                this._ambient.x = (color >> 16 & 0xff) / 255;
                this._ambient.y = (color >> 8 & 0xff) / 255;
                this._ambient.z = (color & 0xff) / 255;
                this._change = false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DirectLight.prototype, "dir", {
            /**
            * @language zh_CN
            * 光线的方向
            * @returns dir 光线的方向
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._dir;
            },
            /**
            * @language zh_CN
            * 光线的方向
            * @param dir 光线的方向
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (dir) {
                this._dir.copyFrom(dir);
                this._dir.normalize();
                egret3d.Quaternion.fromToRotation(egret3d.Vector3D.Z_AXIS, this._dir, DirectLight.q0);
                this.globalOrientation = DirectLight.q0;
            },
            enumerable: true,
            configurable: true
        });
        DirectLight.prototype.onUpdateTransform = function () {
            _super.prototype.onUpdateTransform.call(this);
            this.globalOrientation.transformVector(egret3d.Vector3D.Z_AXIS, this._dir);
            this._dir.normalize();
        };
        /**
         * @language zh_CN
         *
         * 是否产生阴影
         * 模拟间接光照而开发的背光，而不用去同时打两盏不同方向的组合灯光，可以优化显示效果
         * @param color 背光颜色色值
         */
        //public set castShadow(value: boolean) {
        //if (value )
        //    RttManager.getInstance().shadowMapRender.castShadowLight = this; 
        //}
        /**
        * @language zh_CN
        * @private
        * 更新灯光数据
        * @param camera 灯光ID
        * @param index 灯光数据
        * @param lightData 灯光数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        DirectLight.prototype.updateLightData = function (camera, index, lightData) {
            //camera.viewMatrix.mat3TransformVector(this._rot, this.lightViewPos);
            var dir = this.dir;
            lightData[index * DirectLight.stride + 0] = dir.x;
            lightData[index * DirectLight.stride + 1] = dir.y;
            lightData[index * DirectLight.stride + 2] = dir.z;
            lightData[index * DirectLight.stride + 3] = this._diffuse.x;
            lightData[index * DirectLight.stride + 4] = this._diffuse.y;
            lightData[index * DirectLight.stride + 5] = this._diffuse.z;
            lightData[index * DirectLight.stride + 6] = this._ambient.x;
            lightData[index * DirectLight.stride + 7] = this._ambient.y;
            lightData[index * DirectLight.stride + 8] = this._ambient.z;
            lightData[index * DirectLight.stride + 9] = this._intensity;
            //lightData[index * DirectLight.stride + 10] = this._halfIntensity;
        };
        DirectLight.q0 = new egret3d.Quaternion();
        /**
        * @language zh_CN
        * @private
        * 光源数据结构长度
        */
        DirectLight.stride = 10;
        return DirectLight;
    }(egret3d.LightBase));
    egret3d.DirectLight = DirectLight;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @class egret3d.DirectLight
   * @classdesc
   *
   * 灯光组。</p>
   * 把需要使用的灯光，放入一个组里面，然后给材质进行渲染。
   * @see egret3d.Object3D
   * @see egret3d.LightBase
   * @see egret3d.PointLight
   * @see egret3d.SpotLight
   * @see egret3d.EventDispatcher
   * @version Egret 3.0
   * @platform Web,Native
   */
    var LightGroup = (function (_super) {
        __extends(LightGroup, _super);
        /**
        * @language zh_CN
        * 创建一个灯光组
        * @version Egret 3.0
        * @platform Web,Native
        */
        function LightGroup() {
            _super.call(this);
            /**
            * @language zh_CN
            * 灯光个数
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lightNum = 0;
            this.event = new egret3d.Event3D();
            this.directLightList = new Array();
            this.spotLightList = new Array();
            this.pointLightList = new Array();
        }
        /**
        * @language zh_CN
        * 为灯光组,添加一个灯光
        * @param light 灯光实例对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        LightGroup.prototype.addLight = function (light) {
            switch (light.lightType) {
                case egret3d.LightType.directlight:
                    this.directLightList.push(light);
                    this.lightNum++;
                    this.event.eventType = LightGroup.EVENT_LIGHT_RESET;
                    this.dispatchEvent(this.event);
                    break;
                case egret3d.LightType.pointlight:
                    this.pointLightList.push(light);
                    this.lightNum++;
                    this.event.eventType = LightGroup.EVENT_LIGHT_RESET;
                    this.dispatchEvent(this.event);
                    break;
                case egret3d.LightType.spotLightlight:
                    this.spotLightList.push(light);
                    this.lightNum++;
                    this.event.eventType = LightGroup.EVENT_LIGHT_RESET;
                    this.dispatchEvent(this.event);
                    break;
            }
        };
        /**
        * @language zh_CN
        * 移除某个灯光
        * @param light 灯光实例对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        LightGroup.prototype.removeLight = function (light) {
            switch (light.lightType) {
                case egret3d.LightType.directlight:
                    var index = this.directLightList.indexOf(light);
                    if (index >= 0 && index < this.directLightList.length) {
                        this.directLightList.splice(index, 1);
                        this.lightNum--;
                        this.event.eventType = LightGroup.EVENT_LIGHT_RESET;
                        this.dispatchEvent(this.event);
                    }
                    break;
                case egret3d.LightType.pointlight:
                    var index = this.pointLightList.indexOf(light);
                    if (index >= 0 && index < this.pointLightList.length) {
                        this.pointLightList.splice(index, 1);
                        this.lightNum--;
                        this.event.eventType = LightGroup.EVENT_LIGHT_RESET;
                        this.dispatchEvent(this.event);
                    }
                    break;
                case egret3d.LightType.spotLightlight:
                    var index = this.spotLightList.indexOf(light);
                    if (index >= 0 && index < this.spotLightList.length) {
                        this.spotLightList.splice(index, 1);
                        this.lightNum--;
                        this.event.eventType = LightGroup.EVENT_LIGHT_RESET;
                        this.dispatchEvent(this.event);
                    }
                    break;
            }
        };
        /**
        * @private
        */
        LightGroup.EVENT_LIGHT_RESET = "Event_Light_Reset";
        return LightGroup;
    }(egret3d.EventDispatcher));
    egret3d.LightGroup = LightGroup;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    function sortByOrder(a, b) {
        return b.drawOrder - a.drawOrder;
    }
    function alphaZSort(a, b) {
        return b.zIndex - a.zIndex;
    }
    /**
    * @private
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (SpecialCast) {
        SpecialCast[SpecialCast["Shadow"] = 0] = "Shadow";
        SpecialCast[SpecialCast["Pick"] = 1] = "Pick";
    })(egret3d.SpecialCast || (egret3d.SpecialCast = {}));
    var SpecialCast = egret3d.SpecialCast;
    /**
    * @private
    * @class egret3d.EntityCollect
    * @classdesc
    * Object3D 渲染对象收集器,把渲染对象进行可视筛选，
    * 并且划分渲染层级，依次排序到加入列表.
    *
    * @see egret3d.Scene3D
    * @see egret3d.View3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EntityCollect = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param root 渲染根节点
        * @version Egret 3.0
        * @platform Web,Native
        */
        function EntityCollect() {
            this.numberVertex = 0;
            this.numberFace = 0;
            this.numberDraw = 0;
            this.numberSkin = 0;
            this.numberAnimation = 0;
            this.numberParticle = 0;
            this.numberCastShadow = 0;
            this.numberAcceptShadow = 0;
            this.numberPick = 0;
            this.softLayerRenderItems = {};
            this.specialCastItem = {};
            for (var i = 0; i < egret3d.Layer.layerType.length; i++) {
                this.softLayerRenderItems[egret3d.Layer.layerType[i]] = [];
            }
            this.specialCastItem[SpecialCast.Shadow] = [];
            this.specialCastItem[SpecialCast.Pick] = [];
            this.renderList = new Array();
        }
        Object.defineProperty(EntityCollect.prototype, "root", {
            get: function () {
                return this.rootScene;
            },
            set: function (rootScene) {
                this.rootScene = rootScene;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 尝试添加节点
        * @version Egret 3.0
        * @param child   尝试添加的节点
        * @param camera     相机
        * @platform Web,Native
        */
        EntityCollect.prototype.applyRender = function (child, camera) {
            //检查鼠标能pick
            if (child.enablePick) {
                this.specialCastItem[SpecialCast.Pick].push(child);
                this.numberPick++;
            }
            if (!child.visible) {
                return;
            }
            this.addRenderItem(child, camera);
            for (var i = 0; i < child.childs.length; i++) {
                this.applyRender(child.childs[i], camera);
            }
        };
        /**
        * @language zh_CN
        * 尝试添加四叉树列表
        * @version Egret 3.0
        * @param quadList   需要被判定是否在视锥体里的节点列表
        * @param camera     相机
        * @platform Web,Native
        */
        EntityCollect.prototype.appendQuadList = function (quadList, camera) {
            var mesh;
            var node;
            for (var _i = 0, quadList_1 = quadList; _i < quadList_1.length; _i++) {
                node = quadList_1[_i];
                if (!(node instanceof egret3d.Mesh))
                    continue;
                mesh = node;
                if (mesh && mesh.visible && mesh["material"])
                    this.addRenderItem(mesh, camera, false);
            }
        };
        /**
        * @language zh_CN
        * 尝试将一个渲染对象，进行视锥体裁剪，放入到渲染队列中
        * @param root 渲染根节点
        * @param cameraCulling 是否使用相机裁剪
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.addRenderItem = function (renderItem, camera, cameraCulling) {
            if (cameraCulling === void 0) { cameraCulling = true; }
            if (cameraCulling) {
                if (!camera.isVisibleToCamera(renderItem)) {
                    return;
                }
            }
            if (!renderItem.material) {
                return;
            }
            //检查阴影产生者
            if (renderItem.material.castShadow) {
                this.specialCastItem[SpecialCast.Shadow].push(renderItem);
                this.numberCastShadow++;
            }
            //检查阴影接受者
            if (renderItem.material.acceptShadow) {
                this.numberAcceptShadow++;
            }
            //按 layer 进行渲染排序分类
            if (renderItem.material.materialData.alphaBlending && renderItem.tag.name == egret3d.Layer.TAG_NAME_NORMAL_OBJECT) {
                var scenePos = camera.object3DToScreenRay(renderItem.position, egret3d.Vector3D.HELP_0);
                renderItem.zIndex = egret3d.Vector3D.HELP_0.z;
                this.softLayerRenderItems[egret3d.Layer.TAG_NAME_ALPHA_OBJECT].push(renderItem);
            }
            else {
                for (var i = 0; i < egret3d.Layer.layerType.length; i++) {
                    if (renderItem.tag.name == egret3d.Layer.layerType[i]) {
                        this.softLayerRenderItems[egret3d.Layer.layerType[i]].push(renderItem);
                    }
                }
            }
            if (egret3d.Egret3DEngine.instance.debug) {
                this.numberFace += renderItem.geometry.faceCount;
                this.numberVertex += renderItem.geometry.vertexCount;
                this.numberDraw += 1;
                if (renderItem.animation)
                    this.numberSkin += 1;
                if (renderItem.proAnimation)
                    this.numberAnimation += 1;
                if (renderItem.type == egret3d.IRender.TYPE_PARTICLE_EMIT)
                    this.numberParticle += 1;
            }
        };
        /**
        * @language zh_CN
        * 数据更新 处理需要渲染的对象
        * @param camera 当前摄像机
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.update = function (camera) {
            camera.modelMatrix;
            this.clear();
            if (egret3d.Egret3DEngine.instance.debug) {
                egret3d.Egret3DEngine.instance.performance.startCounter("entityCollect applyRender", 60);
            }
            if (this.rootScene.quad) {
                var box = camera.frustum.box;
                var quadList = this.rootScene.quad.getNodesByAABB(box.min.x, box.min.y, box.max.x, box.max.y);
                this.appendQuadList(quadList, camera);
            }
            else {
                this.applyRender(this.rootScene, camera);
            }
            if (egret3d.Egret3DEngine.instance.debug) {
                egret3d.Egret3DEngine.instance.performance.endCounter("entityCollect applyRender");
            }
            // 排序
            var renders, layerName, listLen;
            // 进行alpha排序
            layerName = egret3d.Layer.TAG_NAME_ALPHA_OBJECT;
            renders = this.softLayerRenderItems[layerName];
            if (renders && renders.length) {
                listLen = renders.length;
                renders.sort(alphaZSort);
            }
            // 进行重要度排序
            for (var j = 0; j < egret3d.Layer.layerType.length; j++) {
                layerName = egret3d.Layer.layerType[j];
                renders = this.softLayerRenderItems[layerName];
                if (renders) {
                    listLen = renders.length;
                    renders.sort(sortByOrder);
                    for (var i = 0; i < listLen; i++) {
                        this.renderList.push(renders[i]);
                    }
                }
            }
        };
        EntityCollect.prototype.clear = function () {
            this.numberFace = 0;
            this.numberVertex = 0;
            this.numberDraw = 0;
            this.numberSkin = 0;
            this.numberAnimation = 0;
            this.numberParticle = 0;
            this.numberCastShadow = 0;
            this.numberPick = 0;
            this.numberAcceptShadow = 0;
            for (var i = 0; i < egret3d.Layer.layerType.length; i++) {
                this.softLayerRenderItems[egret3d.Layer.layerType[i]].length = 0;
            }
            for (var j in this.specialCastItem) {
                this.specialCastItem[j].length = 0;
            }
            this.renderList.length = 0;
        };
        /**
        * @language zh_CN
        * 查找一个对象在渲染列表的下标
        * @param obj 要查找的对象
        * @returns 返回对象在渲染列表的下标
        */
        EntityCollect.prototype.findRenderObject = function (obj) {
            for (var i = 0; i < this.renderList.length; ++i) {
                if (this.renderList[i] === obj) {
                    return i;
                }
            }
            return -1;
        };
        return EntityCollect;
    }());
    egret3d.EntityCollect = EntityCollect;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.Frustum
    * @classdesc
    * 摄像机视椎体,计算出摄像机的可视范围.
    *
    * @see egret3d.Camera3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Frustum = (function () {
        /**
        * @language zh_CN
        * 构造
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Frustum(camera) {
            if (camera === void 0) { camera = null; }
            this._vtxNum = 8;
            this._planeNum = 6;
            this.nearCenter = new egret3d.Vector3D();
            this.farCenter = new egret3d.Vector3D();
            /**
            * @private
            **/
            this._tempVector = new egret3d.Vector3D();
            this.camera = camera;
            this._vertex = new Array();
            for (var i = 0; i < this._vtxNum; ++i) {
                this._vertex.push(new egret3d.Vector3D());
            }
            this._tempVertices = new Array();
            for (var i = 0; i < this._vtxNum; ++i) {
                this._tempVertices.push(new egret3d.Vector3D());
            }
            this._pos = new egret3d.Vector3D();
            this._plane = new Array();
            for (var i = 0; i < 6; ++i) {
                this._plane.push(new egret3d.Plane3D());
            }
            this.box = new egret3d.BoundBox(null, new egret3d.Vector3D(), new egret3d.Vector3D());
            this.center = new egret3d.Vector3D();
        }
        Object.defineProperty(Frustum.prototype, "vertices", {
            /**
            * @language zh_CN
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._vertex;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Frustum.prototype, "wireframe", {
            /**
            * @language zh_CN
            * 摄像机渲染线框
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._frustum;
            },
            enumerable: true,
            configurable: true
        });
        Frustum.prototype.initFrustum = function () {
            if (this._frustum == null) {
                this._frustum = new egret3d.Wireframe();
                this._frustum.material.diffuseColor = 0xffffff;
                this._frustum.name = "CameraFrustum";
                this._frustum.geometry.vertexCount = 8;
                this._frustum.geometry.indexCount = 24;
                this._frustum.geometry.setVertexIndices(0, [0, 1, 1, 2, 2, 3, 0, 3, 4, 5, 5, 6, 6, 7, 4, 7, 0, 4, 1, 5, 3, 7, 2, 6]);
            }
        };
        Object.defineProperty(Frustum.prototype, "visible", {
            /**
            * @language zh_CN
            * 是否可见
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._frustum == null) {
                    return false;
                }
                return this._frustum.parent ? true : false;
            },
            /**
            * @language zh_CN
            * 是否可见
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.initFrustum();
                if (value) {
                    if (!this._frustum.parent) {
                        this.camera.addChild(this._frustum);
                    }
                    else {
                        if (this._frustum.parent != this.camera) {
                            this._frustum.parent.removeChild(this._frustum);
                            this.camera.addChild(this._frustum);
                        }
                    }
                }
                else {
                    if (this._frustum.parent) {
                        this._frustum.parent.removeChild(this._frustum);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * @private
        * 生成一个视椎体
        * @param fovY 观察时y 轴方向的角度，就是观察范围夹角。
        * @param aspectRatio 纵横比，在视空间宽度除以高度.
        * @param nearPlane 近裁剪面位置Z值.
        * @param farPlane 远裁剪面位置Z值.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.makeFrustum = function (fovY, aspectRatio, nearPlane, farPlane) {
            ///var tangent: number = Math.tan(fovY / 2.0 * (Math.PI / 180.0));
            var tangent = Math.tan(fovY / 2.0 * (Math.PI / 180.0));
            var nearHeight = nearPlane * tangent;
            var nearWidth = nearHeight * aspectRatio;
            var farHeight = farPlane * tangent;
            var farWidth = farHeight * aspectRatio;
            /// near top right
            this._vertex[0].x = nearWidth;
            this._vertex[0].y = nearHeight;
            this._vertex[0].z = nearPlane;
            /// near top left
            this._vertex[1].x = -nearWidth;
            this._vertex[1].y = nearHeight;
            this._vertex[1].z = nearPlane;
            /// near bottom left
            this._vertex[2].x = -nearWidth;
            this._vertex[2].y = -nearHeight;
            this._vertex[2].z = nearPlane;
            /// near bottom right
            this._vertex[3].x = nearWidth;
            this._vertex[3].y = -nearHeight;
            this._vertex[3].z = nearPlane;
            /// far top right
            this._vertex[4].x = farWidth;
            this._vertex[4].y = farHeight;
            this._vertex[4].z = farPlane;
            /// far top left
            this._vertex[5].x = -farWidth;
            this._vertex[5].y = farHeight;
            this._vertex[5].z = farPlane;
            /// far bottom left
            this._vertex[6].x = -farWidth;
            this._vertex[6].y = -farHeight;
            this._vertex[6].z = farPlane;
            /// far bottom right
            this._vertex[7].x = farWidth;
            this._vertex[7].y = -farHeight;
            this._vertex[7].z = farPlane;
        };
        Frustum.prototype.makeOrthoFrustum = function (w, h, zn, zf) {
            /// near top right
            this._vertex[0].x = w / 2;
            this._vertex[0].y = h / 2;
            this._vertex[0].z = zn;
            /// near top left
            this._vertex[1].x = -w / 2;
            this._vertex[1].y = h / 2;
            this._vertex[1].z = zn;
            /// near bottom left
            this._vertex[2].x = -w / 2;
            this._vertex[2].y = -h / 2;
            this._vertex[2].z = zn;
            /// near bottom right
            this._vertex[3].x = w / 2;
            this._vertex[3].y = -h / 2;
            this._vertex[3].z = zn;
            /// far top right
            this._vertex[4].x = w / 2;
            this._vertex[4].y = h / 2;
            this._vertex[4].z = zf;
            /// far top left
            this._vertex[5].x = -w / 2;
            this._vertex[5].y = h / 2;
            this._vertex[5].z = zf;
            /// far bottom left
            this._vertex[6].x = -w / 2;
            this._vertex[6].y = -h / 2;
            this._vertex[6].z = zf;
            /// far bottom right
            this._vertex[7].x = w / 2;
            this._vertex[7].y = -h / 2;
            this._vertex[7].z = zf;
        };
        Frustum.prototype.makeOrthoToCenterFrustum = function (l, r, b, t, zn, zf) {
            /// near top right
            this._vertex[0].x = r;
            this._vertex[0].y = t;
            this._vertex[0].z = zn;
            /// near top left
            this._vertex[1].x = l;
            this._vertex[1].y = t;
            this._vertex[1].z = zn;
            /// near bottom left
            this._vertex[2].x = l;
            this._vertex[2].y = b;
            this._vertex[2].z = zn;
            /// near bottom right
            this._vertex[3].x = r;
            this._vertex[3].y = b;
            this._vertex[3].z = zn;
            /// far top right
            this._vertex[4].x = r;
            this._vertex[4].y = t;
            this._vertex[4].z = zf;
            /// far top left
            this._vertex[5].x = l;
            this._vertex[5].y = t;
            this._vertex[5].z = zf;
            /// far bottom left
            this._vertex[6].x = l;
            this._vertex[6].y = b;
            this._vertex[6].z = zf;
            /// far bottom right
            this._vertex[7].x = r;
            this._vertex[7].y = b;
            this._vertex[7].z = zf;
        };
        /**
        * @language zh_CN
        * 数据更新.
        * @param camera 视椎的摄像机.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.updateFrustum = function () {
            switch (this.camera.cameraType) {
                case egret3d.CameraType.perspective:
                    this.makeFrustum(this.camera.fieldOfView, this.camera.aspectRatio, this.camera.near, this.camera.far);
                    break;
                case egret3d.CameraType.orthogonal:
                    this.makeOrthoFrustum(this.camera.viewPort.width, this.camera.viewPort.height, this.camera.near, this.camera.far);
                    break;
                case egret3d.CameraType.orthogonalToCenter:
                    this.makeOrthoToCenterFrustum(this.camera.viewPort.x, this.camera.viewPort.y, this.camera.viewPort.width, this.camera.viewPort.height, this.camera.near, this.camera.far);
                    break;
            }
            if (this._frustum != null) {
                for (var i = 0; i < this.vertices.length; ++i) {
                    this._frustum.geometry.setVerticesForIndex(i, egret3d.VertexFormat.VF_POSITION, [this.vertices[i].x, this.vertices[i].y, this.vertices[i].z], 1);
                }
            }
        };
        /**
        * @language zh_CN
        * 数据更新.
        * @param camera 视椎的摄像机.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.update = function () {
            /// 摄像机变化之后的顶点也变化;
            var mat = egret3d.Matrix4_4.helpMatrix;
            mat.copyFrom(this.camera.modelMatrix);
            //this._frustum.modelMatrix = mat;
            for (var i = 0; i < this._vtxNum; ++i) {
                mat.transformVector(this._vertex[i], this._tempVertices[i]);
            }
            this.box.max.x = this.box.max.y = this.box.max.z = -egret3d.MathUtil.MAX_VALUE;
            this.box.min.x = this.box.min.y = this.box.min.z = egret3d.MathUtil.MAX_VALUE;
            for (var i = 0; i < this._tempVertices.length; ++i) {
                if (this.box.max.x < this._tempVertices[i].x) {
                    this.box.max.x = this._tempVertices[i].x;
                }
                if (this.box.max.y < this._tempVertices[i].y) {
                    this.box.max.y = this._tempVertices[i].y;
                }
                if (this.box.max.z < this._tempVertices[i].z) {
                    this.box.max.z = this._tempVertices[i].z;
                }
                if (this.box.min.x > this._tempVertices[i].x) {
                    this.box.min.x = this._tempVertices[i].x;
                }
                if (this.box.min.y > this._tempVertices[i].y) {
                    this.box.min.y = this._tempVertices[i].y;
                }
                if (this.box.min.z > this._tempVertices[i].z) {
                    this.box.min.z = this._tempVertices[i].z;
                }
            }
            this.box.calculateBox();
            this._plane[0].fromPoints(this._tempVertices[4], this._tempVertices[5], this._tempVertices[6]); /// 远平面(far);
            this._plane[1].fromPoints(this._tempVertices[1], this._tempVertices[6], this._tempVertices[5]); /// 左平面(left);
            this._plane[2].fromPoints(this._tempVertices[0], this._tempVertices[4], this._tempVertices[7]); /// 右平面(right);
            this._plane[3].fromPoints(this._tempVertices[1], this._tempVertices[0], this._tempVertices[3]); /// 近平面(near);
            this._plane[4].fromPoints(this._tempVertices[1], this._tempVertices[5], this._tempVertices[4]); /// 上平面(top);
            this._plane[5].fromPoints(this._tempVertices[3], this._tempVertices[7], this._tempVertices[6]); /// 下平面(bottom);
            for (var i = 0; i < this._planeNum; i++) {
                this._plane[i].normalize();
            }
            this.nearCenter.copyFrom(this._tempVertices[0].subtract(this._tempVertices[2], egret3d.MathUtil.CALCULATION_VECTOR3D_0));
            this.nearCenter.scaleBy(0.5);
            this.nearCenter.copyFrom(this._tempVertices[2].add(this.nearCenter, egret3d.MathUtil.CALCULATION_VECTOR3D_1));
            this.farCenter.copyFrom(this._tempVertices[4].subtract(this._tempVertices[6], egret3d.MathUtil.CALCULATION_VECTOR3D_2));
            this.farCenter.scaleBy(0.5);
            this.farCenter.copyFrom(this._tempVertices[6].add(this.farCenter, egret3d.MathUtil.CALCULATION_VECTOR3D_0));
            this.center.copyFrom(this.farCenter.subtract(this.nearCenter, egret3d.MathUtil.CALCULATION_VECTOR3D_1));
            this.center.scaleBy(0.5);
            this.center.copyFrom(this.nearCenter.add(this.center, egret3d.MathUtil.CALCULATION_VECTOR3D_2));
        };
        /**
        * @language zh_CN
        * 检测一个坐标点是否在视椎体内
        * @param pos 检测的坐标
        * @returns 在视椎内返回ture
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.inPoint = function (pos) {
            var dis = 0;
            for (var i = 0; i < this._plane.length; ++i) {
                dis = this._plane[i].distance(pos);
                if (dis > 0.0) {
                    return false;
                }
            }
            return true;
        };
        /**
        * @language zh_CN
        * 检测一个球是否在视椎体内
        * @param center 球的坐标
        * @param radius 球的半径
        * @returns 在视椎内返回ture
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.inSphere = function (center, radius) {
            var dis = 0;
            for (var i = 0; i < this._plane.length; ++i) {
                dis = this._plane[i].distance(center);
                if (dis > radius) {
                    return false;
                }
            }
            return true;
        };
        /**
        * @language zh_CN
        * 检测一个盒子是否在视椎体内
        * @param box 盒子
        * @returns 在视椎内返回ture
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.inBox = function (box) {
            var dis = 0;
            var planeCount = this._plane.length;
            for (var i = 0; i < planeCount; ++i) {
                var incount = box.vexData.length / 3;
                var vexDataLength = box.vexData.length;
                for (var j = 0; j < vexDataLength; j += 3) {
                    this._tempVector.setTo(box.vexData[j], box.vexData[j + 1], box.vexData[j + 2]);
                    box.transform.transformVector(this._tempVector, this._tempVector);
                    dis = this._plane[i].distance(this._tempVector);
                    if (dis > 0) {
                        incount--;
                    }
                }
                if (incount <= 0) {
                    return false;
                }
            }
            return true;
        };
        /**
        * @language zh_CN
        * 释放所有数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.dispose = function () {
            if (this._frustum != null) {
                this._frustum.dispose();
            }
            this._frustum = null;
        };
        return Frustum;
    }());
    egret3d.Frustum = Frustum;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Layer
    * @classdesc
    * Object3D 渲染Layer
    * 每个Layer分两个渲染列表，一个是有alpha的对象列表，另一个是没有alpha的对象列表
    * 不同的Layer层级可以使用不同的渲染方式，来达到各组不同的渲染效果.
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Layer = (function () {
        function Layer() {
        }
        /**
        * @language zh_CN
        * 普通对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Layer.TAG_NAME_NORMAL_OBJECT = "normalObject";
        /**
        * @language zh_CN
        * 带alpha的普通对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Layer.TAG_NAME_NORMAL_ALPHA_OBJECT = "normalAlphaObject";
        /**
        * @language zh_CN
        * 带alpha对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Layer.TAG_NAME_ALPHA_OBJECT = "alphaObject";
        /**
        * @language zh_CN
        * 贴花对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Layer.TAG_NAME_DECAL = "decal";
        /**
        * @language zh_CN
        * 特效对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Layer.TAG_NAME_EFFECT = "effect";
        /**
        * @language zh_CN
        * GUI对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Layer.TAG_NAME_GUI = "gui";
        /**
        * @language zh_CN
        * 渲染类型
        * 渲染顺序按照此列表的顺序
        * @version Egret 3.0
        * @platform Web,Native
        */
        Layer.layerType = ["normalObject", "normalAlphaObject", "alphaObject", "decal", "effect", "gui"];
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        Layer.layerTypeThan = [3, 2, 1, 0];
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        Layer.layerNumber = 5;
        return Layer;
    }());
    egret3d.Layer = Layer;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Tag
    * @classdesc
    * Object3D 渲染tag
    * 图形属性标签页的属性，由layer列表组成，共用深度信息
    * 渲染每个tag他们的深度信息是不清理的
    * 渲染顺序会根据 Tag.name来进行渲染
    * 渲染顺序按照
    * @see egret3d.Layer
    *
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Tag = (function () {
        function Tag() {
            /**
            * @language zh_CN
            * 根据类型进行渲染排序
            * @see egret3d.Layer
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.name = "normalObject";
            /*
            * @private
            */
            this.clearDepth = false;
        }
        return Tag;
    }());
    egret3d.Tag = Tag;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Picker
    * @classdesc
    * 射线对场景中的实体对像进行检测。</p>
    * 以摄像机向场景中产生的一条射线对所有场景中的对象进行拾取。</p>
    * 根据性能的需要分为几种拣选类型。</p>
    * 1.包围盒拣选。</p>
    * 2.模型拣选返回模型拣选到的位置。</p>
    * 3.模型拣选返回模型拣选到的UV坐标。</p>
    * PickType通过 Object3D.pickType 进行修改
    * @see egret3d.Ray
    * @see egret3d.PickType
    *
    * @includeExample core/traverse/Picker.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Picker = (function () {
        function Picker() {
        }
        /**
        * @language zh_CN
        * 根据View创建在当前view中光标射线
        * @param view 当前检测view
        * @returns Rya 光标射线
        * @version Egret 3.0
        * @platform Web,Native
        */
        Picker.createRayToView = function (view, ray) {
            if (ray === void 0) { ray = null; }
            if (!ray) {
                ray = Picker.ray;
            }
            if (egret3d.Input.mouseX < view.x || egret3d.Input.mouseX > x + view.width || egret3d.Input.mouseY < view.y || egret3d.Input.mouseY > y + view.height) {
                return null;
            }
            var x = egret3d.Input.mouseX - view.x;
            var y = egret3d.Input.mouseY - view.y;
            ray.CalculateAndTransformRay(view.width, view.height, view.camera3D.modelMatrix, view.camera3D.projectMatrix, x, y);
            return ray;
        };
        /**
        * @language zh_CN
        * 返回鼠标拾取对象得到的所有对象,调用之前到设置被拣选对象的pickType.
        * 会检测对象的所有子节点,然后把检测的对象进行返回
        * @param view 当前检测view
        * @param object 检测的对象
        * @param target 将结果放入到该列表
        * @returns 拾取的object列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        Picker.pickObject3D = function (view, object, target) {
            if (target === void 0) { target = null; }
            target = target || [];
            target.length = 0;
            var ray = Picker.createRayToView(view);
            Picker.pickObject(ray, object, target);
            return target;
        };
        /**
        * @language zh_CN
        * 返回射线检测对象得到的所有对象,调用之前到设置被拣选对象的pickType.
        * 会检测对象的所有子节点,然后把检测的对象进行返回
        * @param ray 当前检测射线
        * @param object 检测的对象
        * @param target 将结果放入到该列表
        * @returns 拾取的object列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        Picker.pickObject = function (ray, object, target) {
            if (target === void 0) { target = null; }
            if (Picker.doPickerObject(ray, object)) {
                target.push(object);
            }
            for (var i = 0; i < object.childs.length; ++i) {
                Picker.pickObject(ray, object.childs[i], target);
            }
            return target;
        };
        /**
        * @language zh_CN
        * 返回射线检测对象是否成功,调用之前到设置被拣选对象的pickType.
        * @param ray 当前检测射线
        * @param object 检测的对象
        * @returns boolean 成功返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        Picker.doPickerObject = function (ray, object) {
            var renderItem;
            switch (object.pickType) {
                case egret3d.PickType.BoundPick:
                    if (object.bound != null) {
                        var bound = object.currentBound;
                        if (bound) {
                            if (ray.IntersectBound(bound, object.pickResult)) {
                                return true;
                            }
                        }
                    }
                    return false;
                case egret3d.PickType.PositionPick:
                    if (object instanceof egret3d.IRender) {
                        renderItem = object;
                        var uvoffset = 0;
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_POSITION) {
                            uvoffset += egret3d.Geometry.positionSize;
                        }
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_NORMAL) {
                            uvoffset += egret3d.Geometry.normalSize;
                        }
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_TANGENT) {
                            uvoffset += egret3d.Geometry.tangentSize;
                        }
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_COLOR) {
                            uvoffset += egret3d.Geometry.colorSize;
                        }
                        var boundBox = renderItem.bound;
                        var ret = [];
                        if (ray.IntersectSphere(boundBox.center, boundBox.radius, ret, renderItem.modelMatrix)) {
                            if (ray.IntersectMeshEx(renderItem, uvoffset, renderItem.pickResult)) {
                                return true;
                            }
                        }
                    }
                    return false;
                case egret3d.PickType.UVPick:
                    if (object instanceof egret3d.IRender) {
                        renderItem = object;
                        var uvoffset = 0;
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_POSITION) {
                            uvoffset += egret3d.Geometry.positionSize;
                        }
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_NORMAL) {
                            uvoffset += egret3d.Geometry.normalSize;
                        }
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_TANGENT) {
                            uvoffset += egret3d.Geometry.tangentSize;
                        }
                        if (renderItem.geometry.vertexFormat & egret3d.VertexFormat.VF_COLOR) {
                            uvoffset += egret3d.Geometry.colorSize;
                        }
                        var boundBox = renderItem.bound;
                        if (ray.IntersectSphere(boundBox.center, boundBox.radius, ret, boundBox.transform)) {
                            if (ray.IntersectMeshEx(renderItem, uvoffset, renderItem.pickResult)) {
                                return true;
                            }
                        }
                    }
                    return false;
            }
            return false;
        };
        /**
        * @language zh_CN
        * 返回鼠标拾取对象得到的所有对象,调用之前到设置被拣选对象的pickType.
        * @param view 当前检测view
        * @param objects 检测的对象列表
        * @param target 将结果放入到该列表
        * @returns 拾取的object列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        Picker.pickObject3DList = function (view, objects, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Array();
            }
            target.length = 0;
            var ray = Picker.createRayToView(view);
            for (var i = 0; i < objects.length; ++i) {
                if (Picker.doPickerObject(ray, objects[i])) {
                    target.push(objects[i]);
                }
            }
            return target;
        };
        Picker.ray = new egret3d.Ray();
        return Picker;
    }());
    egret3d.Picker = Picker;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.VertexFormat
    * @classdesc
    * 顶点数据格式类型 是由2进制组成 一个顶点可以由多个类型组成
    * 创建顶点数据的顺序必需按照下面枚举定义的顺序进行赋值
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (VertexFormat) {
        /**
        * @language zh_CN
        * 顶点坐标
        * @version Egret 3.0
        * @platform Web,Native
        */
        VertexFormat[VertexFormat["VF_POSITION"] = 1] = "VF_POSITION";
        /**
        * @language zh_CN
        * 顶点法线
        * @version Egret 3.0
        * @platform Web,Native
        */
        VertexFormat[VertexFormat["VF_NORMAL"] = 2] = "VF_NORMAL";
        /**
        * @language zh_CN
        * 顶点切线
        * @version Egret 3.0
        * @platform Web,Native
        */
        VertexFormat[VertexFormat["VF_TANGENT"] = 4] = "VF_TANGENT";
        /**
        * @language zh_CN
        * 顶点颜色
        * @version Egret 3.0
        * @platform Web,Native
        */
        VertexFormat[VertexFormat["VF_COLOR"] = 8] = "VF_COLOR";
        /**
        * @language zh_CN
        * 顶点uv
        * @version Egret 3.0
        * @platform Web,Native
        */
        VertexFormat[VertexFormat["VF_UV0"] = 16] = "VF_UV0";
        /**
        * @language zh_CN
        * 顶点第二uv
        * @version Egret 3.0
        * @platform Web,Native
        */
        VertexFormat[VertexFormat["VF_UV1"] = 32] = "VF_UV1";
        /**
        * @language zh_CN
        * 顶点蒙皮信息
        * @version Egret 3.0
        * @platform Web,Native
        */
        VertexFormat[VertexFormat["VF_SKIN"] = 64] = "VF_SKIN";
        /**
          * @private
          * @language zh_CN
          * quad uv rectangle
          * @version Egret 3.0
          * @platform Web,Native
          */
        VertexFormat[VertexFormat["VF_QUAD_UVREC"] = 128] = "VF_QUAD_UVREC";
        /**
     * @private
     * @language zh_CN
     * quad uv rectangle
     * @version Egret 3.0
     * @platform Web,Native
     */
        VertexFormat[VertexFormat["VF_QUAD_ROTATION"] = 256] = "VF_QUAD_ROTATION";
        /**
     * @private
     * @language zh_CN
     * quad uv rectangle
     * @version Egret 3.0
     * @platform Web,Native
     */
        VertexFormat[VertexFormat["VF_QUAD_MASK"] = 1024] = "VF_QUAD_MASK";
        /**
        * @private
        * @language zh_CN
        * quad uv rectangle
        * @version Egret 3.0
        * @platform Web,Native
        */
        VertexFormat[VertexFormat["VF_QUAD_POS"] = 2048] = "VF_QUAD_POS";
        /**
        * @private
        * @language zh_CN
        * quad uv rectangle
        * @version Egret 3.0
        * @platform Web,Native
        */
        VertexFormat[VertexFormat["VF_QUAD_ORIGN"] = 4096] = "VF_QUAD_ORIGN";
        /**
         * @private
         * @language zh_CN
         * quad uv rectangle
         * @version Egret 3.0
         * @platform Web,Native
         */
        VertexFormat[VertexFormat["VF_QUAD_COLOR"] = 8192] = "VF_QUAD_COLOR";
    })(egret3d.VertexFormat || (egret3d.VertexFormat = {}));
    var VertexFormat = egret3d.VertexFormat;
    /**
    * @language zh_CN
    * @class egret3d.Geometry
    * @classdesc
    * 注意:当使用vertexArray 或 indexArray 必须先设置 vertexCount 或 indexCount
    * 表示几何形状 子集
    * @see egret3d.VertexBuffer3D
    * @see egret3d.IndexBuffer3D
    * @see egret3d.SubGeometry
    *
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Geometry = (function (_super) {
        __extends(Geometry, _super);
        function Geometry() {
            _super.apply(this, arguments);
            /**
            * @private
            * @language zh_CN
            * 顶点格式
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.drawType = egret3d.Context3DProxy.gl.STATIC_DRAW;
            /**
            * @language zh_CN
            * 顶点格式
            * @default 0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._vertexFormat = 0;
            /**
            * @language zh_CN
            * 顶点属性长度
            * @default 0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.vertexAttLength = 0;
            /**
            * @language zh_CN
            * 面翻转，仅对系统 geometry 有效
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.faceOrBack = false;
            /**
            * @language zh_CN
            * geometry子集
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.subGeometrys = [];
            /**
            * @language zh_CN
            * @private
            * buffer 需要重新提交的时候
            */
            this._bufferDiry = true;
            /**
            * @language zh_CN
            * 顶点的数量
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._vertexCount = 0;
            /**
            * @language zh_CN
            * 索引数量
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._indexCount = 0;
            this._totalIndexCount = 0;
            this._faceCount = 0;
        }
        Object.defineProperty(Geometry.prototype, "bufferDiry", {
            /**
            * @language zh_CN
            * 是否重新提交数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._bufferDiry;
            },
            /**
            * @language zh_CN
            * 是否重新提交数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._bufferDiry = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "skeleton", {
            /**
            * @language zh_CN
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._skeleton;
            },
            /**
            * @language zh_CN
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (skeleton) {
                if (!skeleton) {
                    return;
                }
                this._skeleton = skeleton;
                this.skeletonGPUData = new Float32Array(skeleton.jointNum * 8);
                for (var i = 0; i < skeleton.jointNum; ++i) {
                    this.skeletonGPUData[i * 8 + 3] = 1;
                    this.skeletonGPUData[i * 8 + 7] = 1;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "vertexCount", {
            /**
            * @language zh_CN
            * 顶点的数量
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._vertexCount;
            },
            /**
            * @language zh_CN
            * 设置顶点的数量，同时 this.vertexArray = new Float32Array(this.vertexAttLength * this.vertexCount);
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._vertexCount == value) {
                    return;
                }
                var dataCount = value * this.vertexAttLength;
                var data = null;
                if (this.vertexArray) {
                    if (this.vertexCount < value) {
                        data = new Float32Array(dataCount);
                        data.set(this.vertexArray);
                        delete this.vertexArray;
                    }
                    else {
                        data = this.vertexArray;
                    }
                }
                else {
                    data = new Float32Array(dataCount);
                }
                this.vertexArray = data;
                this._vertexCount = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "indexCount", {
            /**
            * @language zh_CN
            * 索引的数量
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._indexCount;
            },
            /**
            * @language zh_CN
            * 设置索引的数量，同时 this.indexArray = new Uint16Array(this._indexCount);
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._indexCount = value;
                this._faceCount = value / 3;
                if (this._totalIndexCount >= value) {
                    return;
                }
                var data = new Uint16Array(value);
                if (this.indexArray) {
                    data.set(this.indexArray);
                    delete this.indexArray;
                }
                this.indexArray = data;
                this._totalIndexCount = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "faceCount", {
            /**
            * @language zh_CN
            * 模型面数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._faceCount;
            },
            /**
            * @language zh_CN
            * 模型面数
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._faceCount == value) {
                    return;
                }
                this.indexCount = value * 3;
                this._faceCount = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * @private
        */
        Geometry.prototype.buildDefaultSubGeometry = function () {
            var subGeometry = new egret3d.SubGeometry();
            subGeometry.matID = 0;
            subGeometry.geometry = this;
            subGeometry.start = 0;
            subGeometry.count = this.indexCount;
            this.subGeometrys.push(subGeometry);
        };
        Object.defineProperty(Geometry.prototype, "vertexFormat", {
            /**
            * @language zh_CN
            * 获取顶点格式
            * @returns number 顶点格式
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._vertexFormat;
            },
            /**
            * @language zh_CN
            * 使用和定义顶点的数据结构
            *<p>例如 vertexFormat( VertexFormat.VF_POSITION )
            *设置这样的定义后,就会增加这样的数据顶点数据结构，
            *如果源文件中没有这样的数据结构，
            *就会通过计算的方式计算补全，
            *不能计算的就默认为0
            *@param vertexFormat 需要定义的顶点格式类型 VertexFormat.VF_COLOR | VertexFormat.VF_UV1
            * this.useVertexFormat( VertexFormat.VF_POSITION | VertexFormat.VF_NORMAL | VertexFormat.VF_COLOR |  VertexFormat.VF_UV0 | VertexFormat.VF_UV1 );//定义了一个完整的数据结构
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (vertexFormat) {
                this._vertexFormat = vertexFormat;
                if (this.vertexFormat & VertexFormat.VF_POSITION) {
                    this.vertexAttLength += Geometry.positionSize;
                }
                if (this.vertexFormat & VertexFormat.VF_NORMAL) {
                    this.vertexAttLength += Geometry.normalSize;
                }
                if (this.vertexFormat & VertexFormat.VF_TANGENT) {
                    this.vertexAttLength += Geometry.tangentSize;
                }
                if (this.vertexFormat & VertexFormat.VF_COLOR) {
                    this.vertexAttLength += Geometry.colorSize;
                }
                if (this.vertexFormat & VertexFormat.VF_UV0) {
                    this.vertexAttLength += Geometry.uvSize;
                }
                if (this.vertexFormat & VertexFormat.VF_UV1) {
                    this.vertexAttLength += Geometry.uv2Size;
                }
                if (this.vertexFormat & VertexFormat.VF_SKIN) {
                    this.vertexAttLength += Geometry.skinSize;
                }
                if (this.vertexFormat & VertexFormat.VF_QUAD_UVREC) {
                    this.vertexAttLength += egret3d.QuadData.uvRectangleSize;
                }
                if (this.vertexFormat & VertexFormat.VF_QUAD_ROTATION) {
                    this.vertexAttLength += egret3d.QuadData.rotationSize;
                }
                if (this.vertexFormat & VertexFormat.VF_QUAD_MASK) {
                    this.vertexAttLength += egret3d.QuadData.maskSize;
                }
                if (this.vertexFormat & VertexFormat.VF_QUAD_POS) {
                    this.vertexAttLength += egret3d.QuadData.posSize;
                }
                if (this.vertexFormat & VertexFormat.VF_QUAD_ORIGN) {
                    this.vertexAttLength += egret3d.QuadData.originalSize;
                }
                if (this.vertexFormat & VertexFormat.VF_QUAD_COLOR) {
                    this.vertexAttLength += egret3d.QuadData.colorSize;
                }
                this.vertexSizeInBytes = this.vertexAttLength * 4;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.prototype.activeState = function (time, delay, context3DProxy, camera3D) {
            if (this._bufferDiry) {
                this._bufferDiry = false;
                this.upload(context3DProxy, this.drawType);
            }
            context3DProxy.bindVertexBuffer(this.sharedVertexBuffer);
            context3DProxy.bindIndexBuffer(this.sharedIndexBuffer);
        };
        /**
        * @language zh_CN
        * @private
        * 提交顶点数据 如果顶点数据有变化的话,需要调用此函数重新提交
        * @param context3DProxy 上下文设备
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.prototype.upload = function (context3DProxy, drawType) {
            if (drawType === void 0) { drawType = egret3d.Context3DProxy.gl.STATIC_DRAW; }
            if (!this.sharedIndexBuffer && !this.sharedVertexBuffer) {
                this.sharedIndexBuffer = context3DProxy.creatIndexBuffer(this.indexArray);
                this.sharedVertexBuffer = context3DProxy.creatVertexBuffer(this.vertexArray, drawType);
            }
            else {
                context3DProxy.uploadVertexBuffer(this.sharedVertexBuffer);
                context3DProxy.uploadIndexBuffer(this.sharedIndexBuffer);
            }
        };
        /**
        * @language zh_CN
        * 由顶点索引根据格式拿到顶点数据
        * @param index 顶点索引
        * @param vf 得到顶点的需要的数据格式
        * @param target 得到数据返回目标可以为null
        * @param count 得到顶点个数 默认一个
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.prototype.getVertexForIndex = function (index, vf, target, count) {
            if (target === void 0) { target = null; }
            if (count === void 0) { count = 1; }
            if (!target) {
                target = new Array();
            }
            if (index < 0 || index >= this.vertexCount) {
                return target;
            }
            for (var i = 0; i < count; ++i) {
                var offset = 0;
                if (vf & VertexFormat.VF_POSITION) {
                    if (this.vertexFormat & VertexFormat.VF_POSITION) {
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 0]);
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 1]);
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 2]);
                    }
                    else {
                        target.push(0, 0, 0);
                    }
                }
                if (this.vertexFormat & VertexFormat.VF_POSITION) {
                    offset += Geometry.positionSize;
                }
                if (vf & VertexFormat.VF_NORMAL) {
                    if (this.vertexFormat & VertexFormat.VF_NORMAL) {
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 0]);
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 1]);
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 2]);
                    }
                    else {
                        target.push(0, 0, 0);
                    }
                }
                if (this.vertexFormat & VertexFormat.VF_NORMAL) {
                    offset += Geometry.normalSize;
                }
                if (vf & VertexFormat.VF_TANGENT) {
                    if (this.vertexFormat & VertexFormat.VF_TANGENT) {
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 0]);
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 1]);
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 2]);
                    }
                    else {
                        target.push(0, 0, 0);
                    }
                }
                if (this.vertexFormat & VertexFormat.VF_TANGENT) {
                    offset += Geometry.tangentSize;
                }
                if (vf & VertexFormat.VF_COLOR) {
                    if (this.vertexFormat & VertexFormat.VF_COLOR) {
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 0]);
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 1]);
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 2]);
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 3]);
                    }
                    else {
                        target.push(0, 0, 0, 0);
                    }
                }
                if (this.vertexFormat & VertexFormat.VF_COLOR) {
                    offset += Geometry.colorSize;
                }
                if (vf & VertexFormat.VF_UV0) {
                    if (this.vertexFormat & VertexFormat.VF_UV0) {
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 0]);
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 1]);
                    }
                    else {
                        target.push(0, 0);
                    }
                }
                if (this.vertexFormat & VertexFormat.VF_UV0) {
                    offset += Geometry.uvSize;
                }
                if (vf & VertexFormat.VF_UV1) {
                    if (this.vertexFormat & VertexFormat.VF_UV1) {
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 0]);
                        target.push(this.vertexArray[index * this.vertexAttLength + offset + 1]);
                    }
                    else {
                        target.push(0, 0);
                    }
                }
                if (this.vertexFormat & VertexFormat.VF_UV1) {
                    offset += Geometry.uv2Size;
                }
                if (vf & VertexFormat.VF_SKIN) {
                    if (this.vertexFormat & VertexFormat.VF_SKIN) {
                        for (var j = 0; j < Geometry.skinSize; ++j) {
                            target.push(this.vertexArray[index * this.vertexAttLength + offset + j]);
                        }
                    }
                    else {
                        target.push(0, 0, 0, 0, 0, 0, 0, 0);
                    }
                }
                if (this.vertexFormat & VertexFormat.VF_SKIN) {
                    offset += Geometry.skinSize;
                }
                index++;
            }
            return target;
        };
        /**
        * @language zh_CN
        * 由顶点索引根据格式设置顶点数据
        * @param index 顶点索引
        * @param vf 设置顶点的需要的数据格式
        * @param src 设置的数据
        * @param vertexCount 设置的顶点数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.prototype.setVerticesForIndex = function (index, vf, src, vertexCount) {
            if (vertexCount === void 0) { vertexCount = 1; }
            if (index + vertexCount > this.vertexCount) {
                this.vertexCount = index + vertexCount;
            }
            this._bufferDiry = true;
            var offset = 0;
            var srcOffset = 0;
            for (var i = 0; i < vertexCount; ++i) {
                offset = 0;
                if (this.vertexFormat & VertexFormat.VF_POSITION) {
                    if (vf & VertexFormat.VF_POSITION) {
                        this.vertexArray[index * this.vertexAttLength + offset + 0] = src[srcOffset + 0];
                        this.vertexArray[index * this.vertexAttLength + offset + 1] = src[srcOffset + 1];
                        this.vertexArray[index * this.vertexAttLength + offset + 2] = src[srcOffset + 2];
                    }
                    offset += Geometry.positionSize;
                }
                if (vf & VertexFormat.VF_POSITION) {
                    srcOffset += Geometry.positionSize;
                }
                if (this.vertexFormat & VertexFormat.VF_NORMAL) {
                    if (vf & VertexFormat.VF_NORMAL) {
                        this.vertexArray[index * this.vertexAttLength + offset + 0] = src[srcOffset + 0];
                        this.vertexArray[index * this.vertexAttLength + offset + 1] = src[srcOffset + 1];
                        this.vertexArray[index * this.vertexAttLength + offset + 2] = src[srcOffset + 2];
                    }
                    offset += Geometry.normalSize;
                }
                if (vf & VertexFormat.VF_NORMAL) {
                    srcOffset += Geometry.normalSize;
                }
                if (this.vertexFormat & VertexFormat.VF_TANGENT) {
                    if (vf & VertexFormat.VF_TANGENT) {
                        this.vertexArray[index * this.vertexAttLength + offset + 0] = src[srcOffset + 0];
                        this.vertexArray[index * this.vertexAttLength + offset + 1] = src[srcOffset + 1];
                        this.vertexArray[index * this.vertexAttLength + offset + 2] = src[srcOffset + 2];
                    }
                    offset += Geometry.tangentSize;
                }
                if (vf & VertexFormat.VF_TANGENT) {
                    srcOffset += Geometry.tangentSize;
                }
                if (this.vertexFormat & VertexFormat.VF_COLOR) {
                    if (vf & VertexFormat.VF_COLOR) {
                        this.vertexArray[index * this.vertexAttLength + offset + 0] = src[srcOffset + 0];
                        this.vertexArray[index * this.vertexAttLength + offset + 1] = src[srcOffset + 1];
                        this.vertexArray[index * this.vertexAttLength + offset + 2] = src[srcOffset + 2];
                        this.vertexArray[index * this.vertexAttLength + offset + 3] = src[srcOffset + 3];
                    }
                    else {
                        if (this.vertexArray[index * this.vertexAttLength + offset + 0] == 0 &&
                            this.vertexArray[index * this.vertexAttLength + offset + 1] == 0 &&
                            this.vertexArray[index * this.vertexAttLength + offset + 2] == 0 &&
                            this.vertexArray[index * this.vertexAttLength + offset + 3] == 0) {
                            this.vertexArray[index * this.vertexAttLength + offset + 0] = 1;
                            this.vertexArray[index * this.vertexAttLength + offset + 1] = 1;
                            this.vertexArray[index * this.vertexAttLength + offset + 2] = 1;
                            this.vertexArray[index * this.vertexAttLength + offset + 3] = 1;
                        }
                    }
                    offset += Geometry.colorSize;
                }
                if (vf & VertexFormat.VF_COLOR) {
                    srcOffset += Geometry.colorSize;
                }
                if (this.vertexFormat & VertexFormat.VF_UV0) {
                    if (vf & VertexFormat.VF_UV0) {
                        this.vertexArray[index * this.vertexAttLength + offset + 0] = src[srcOffset + 0];
                        this.vertexArray[index * this.vertexAttLength + offset + 1] = src[srcOffset + 1];
                    }
                    offset += Geometry.uvSize;
                }
                if (vf & VertexFormat.VF_UV0) {
                    srcOffset += Geometry.uvSize;
                }
                if (this.vertexFormat & VertexFormat.VF_UV1) {
                    if (vf & VertexFormat.VF_UV1) {
                        this.vertexArray[index * this.vertexAttLength + offset + 0] = src[srcOffset + 0];
                        this.vertexArray[index * this.vertexAttLength + offset + 1] = src[srcOffset + 1];
                    }
                    offset += Geometry.uv2Size;
                }
                if (vf & VertexFormat.VF_UV1) {
                    srcOffset += Geometry.uv2Size;
                }
                if (this.vertexFormat & VertexFormat.VF_SKIN) {
                    if (vf & VertexFormat.VF_SKIN) {
                        for (var j = 0; j < Geometry.skinSize; ++j) {
                            this.vertexArray[index * this.vertexAttLength + offset + j] = src[srcOffset + j];
                        }
                    }
                    offset += Geometry.skinSize;
                }
                if (vf & VertexFormat.VF_SKIN) {
                    srcOffset += Geometry.skinSize;
                }
                index++;
            }
        };
        /**
        * @language zh_CN
        * 获取顶点索引数据
        * @param start 数据开始位置
        * @param count 需要的索引数据，默认参数为-1，如果为-1那么取从start后面的所有索引数据
        * @param target 取到之后的数据，默认参数为null，如果为null那么就会new Array<number>进行返回
        * @returns Array<number> 索引数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.prototype.getVertexIndices = function (start, count, target) {
            if (count === void 0) { count = -1; }
            if (target === void 0) { target = null; }
            if (!target) {
                target = new Array();
            }
            if (start >= this.indexCount) {
                return target;
            }
            count == -1 ? count = this.indexCount : count;
            if (start + count > this.indexCount) {
                count = this.indexCount - start;
            }
            for (var i = 0; i < count; ++i) {
                target[i] = this.indexArray[i + start];
            }
            return target;
        };
        /**
        * @language zh_CN
        * 设置顶点索引数据
        * @param start 数据开始位置
        * @param indices 数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.prototype.setVertexIndices = function (start, indices) {
            if (start + indices.length > this.indexCount) {
                this.indexCount = start + indices.length;
            }
            for (var i = 0; i < indices.length; ++i) {
                this.indexArray[start + i] = indices[i];
            }
        };
        /*
        * @private
        */
        Geometry.prototype.cloneMirror = function (x, y, z) {
            var geometry = new Geometry();
            geometry.vertexFormat = this.vertexFormat;
            geometry.vertexCount = this.vertexCount;
            geometry.indexCount = this.indexCount;
            var i = 0;
            var tempPos = new egret3d.Vector3D();
            var pos = new egret3d.Vector3D();
            var scal = new egret3d.Vector3D(x ? -1 : 1, y ? -1 : 1, z ? -1 : 1);
            var rot = new egret3d.Quaternion();
            geometry.vertexArray = new Float32Array(this.vertexArray.length); // this.vertexArray.subarray(0, this.vertexArray.length);
            geometry.indexArray = new Float32Array(this.indexArray.length); //this.indexArray.subarray(0, this.indexArray.length);
            for (i = 0; i < geometry.vertexArray.length; i++) {
                geometry.vertexArray[i] = this.vertexArray[i];
            }
            for (i = 0; i < geometry.indexArray.length; i++) {
                geometry.indexArray[i] = this.indexArray[i];
            }
            egret3d.Matrix4_4.helpMatrix.makeTransform(pos, scal, rot);
            for (i = 0; i < this.vertexCount; i++) {
                tempPos.x = geometry.vertexArray[i * this.vertexAttLength];
                tempPos.y = geometry.vertexArray[i * this.vertexAttLength + 1];
                tempPos.z = geometry.vertexArray[i * this.vertexAttLength + 2];
                egret3d.Matrix4_4.helpMatrix.transformVector(tempPos, egret3d.Vector3D.HELP_0);
                geometry.vertexArray[i * this.vertexAttLength] = egret3d.Vector3D.HELP_0.x;
                geometry.vertexArray[i * this.vertexAttLength + 1] = egret3d.Vector3D.HELP_0.y;
                geometry.vertexArray[i * this.vertexAttLength + 2] = egret3d.Vector3D.HELP_0.z;
            }
            for (i = 0; i < this.indexCount / 3; i++) {
                tempPos.x = geometry.indexArray[i * 3 + 0];
                tempPos.y = geometry.indexArray[i * 3 + 1];
                tempPos.z = geometry.indexArray[i * 3 + 2];
                geometry.indexArray[i * 3 + 0] = tempPos.x;
                geometry.indexArray[i * 3 + 1] = tempPos.z;
                geometry.indexArray[i * 3 + 2] = tempPos.y;
            }
            for (i = 0; i < this.subGeometrys.length; ++i) {
                var subGeometry = new egret3d.SubGeometry();
                subGeometry.matID = i;
                subGeometry.geometry = geometry;
                //subGeometry.start = source.material[i].start * 3 * Uint16Array.BYTES_PER_ELEMENT;
                subGeometry.start = this.subGeometrys[i].start * 3;
                subGeometry.count = this.subGeometrys[i].count * 3;
                subGeometry.textureDiffuse = this.subGeometrys[i].textureDiffuse;
                subGeometry.textureNormal = this.subGeometrys[i].textureNormal;
                subGeometry.textureSpecular = this.subGeometrys[i].textureSpecular;
                geometry.subGeometrys.push(subGeometry);
            }
            return geometry;
        };
        /*
        * @private
        */
        Geometry.prototype.copy = function (other) {
            this.vertexFormat = other.vertexFormat;
            this.vertexCount = other.vertexCount;
            this.indexCount = other.indexCount;
            for (var i = 0; i < other.vertexArray.length; ++i) {
                this.vertexArray[i] = other.vertexArray[i];
            }
            for (var i = 0; i < other.indexArray.length; ++i) {
                this.indexArray[i] = other.indexArray[i];
            }
            this.subGeometrys.length = 0;
            for (var i = 0; i < other.subGeometrys.length; ++i) {
                var sub = new egret3d.SubGeometry();
                this.subGeometrys.push(sub);
                var o_sub = other.subGeometrys[i];
                sub.geometry = this;
                sub.start = o_sub.start;
                sub.count = o_sub.count;
                sub.matID = o_sub.matID;
                sub.textureDiffuse = o_sub.textureDiffuse;
                sub.textureNormal = o_sub.textureNormal;
                sub.textureSpecular = o_sub.textureSpecular;
            }
        };
        /**
        * @language zh_CN
        * 释放接口
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.prototype.dispose = function () {
            this.decRef();
            if (this.isDispose) {
                if (this.sharedIndexBuffer) {
                    this.sharedIndexBuffer.dispose();
                    this.sharedIndexBuffer = null;
                }
                if (this.sharedVertexBuffer) {
                    this.sharedVertexBuffer.dispose();
                    this.sharedVertexBuffer = null;
                }
                this.vertexArray = null;
                this.indexArray = null;
                this.skeletonGPUData = null;
                this.skeleton = null;
                this.subGeometrys = [];
            }
        };
        /**
        * @language zh_CN
        * 顶点坐标大小
        * @default 3
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.positionSize = 3;
        /**
        * @language zh_CN
        * 顶点法线大小
        * @default 3
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.normalSize = 3;
        /**
        * @language zh_CN
        * 顶点切线大小
        * @default 3
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.tangentSize = 3;
        /**
        * @language zh_CN
        * 顶点色大小
        * @default 4
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.colorSize = 4;
        /**
        * @language zh_CN
        * 顶点uv大小
        * @default 2
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.uvSize = 2;
        /**
        * @language zh_CN
        * 顶点uv2大小
        * @default 2
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.uv2Size = 2;
        /**
        * @language zh_CN
        * 顶点uv2大小
        * @default 8
        * @version Egret 3.0
        * @platform Web,Native
        */
        Geometry.skinSize = 8;
        return Geometry;
    }(egret3d.Reference));
    egret3d.Geometry = Geometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.GeometryData
     * @classdesc
     * GeometryData类 表示几何形状数据
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/GeometryData.ts
     */
    var GeometryData = (function () {
        function GeometryData() {
            /**
            * @language zh_CN
            * 顶点属性长度
            */
            this.vertexAttLength = 17;
            /**
            * @language zh_CN
            * 顶点长度
            */
            this.vertLen = 0;
            /**
            * @language zh_CN
            * 面数
            */
            this.faces = 0;
            /**
            * @language zh_CN
            * 索引数据
            */
            this.source_indexData = new Array();
            /**
            * @language zh_CN
            * 顶点数据
            */
            this.source_vertexData = new Array();
            /**
            * @language zh_CN
            * 顶点色数据
            */
            this.source_vertexColorData = new Array();
            /**
            * @language zh_CN
            * 顶点法线
            */
            this.source_normalData = new Array();
            /**
            * @language zh_CN
            * 顶点切线数据
            */
            this.source_tangtData = new Array();
            /**
            * @language zh_CN
            * 顶点uv数据
            */
            this.source_uvData = new Array();
            /**
            * @language zh_CN
            * 顶点uv2数据
            */
            this.source_uv2Data = new Array();
            /**
            * @language zh_CN
            * 蒙皮数据
            */
            this.source_skinData = new Array();
            /**
            * @language zh_CN
            * 顶点索引
            */
            this.vertexIndex = 0;
            /**
            * @language zh_CN
            * 索引数据数组
            */
            this.indices = new Array();
            /**
            * @language zh_CN
            * 顶点数据数组(x、y、z)三个number为一个顶点数据
            */
            this.vertices = new Array();
            /**
            * @language zh_CN
            * 法线数据数组(x、y、z)三个number为一个法线数据
            */
            this.normals = new Array();
            /**
            * @language zh_CN
            * 切线数据数组(x、y、z)三个number为一个切线数据
            */
            this.tangts = new Array();
            /**
            * @language zh_CN
            * 顶点颜色数据数组
            */
            this.verticesColor = new Array();
            /**
            * @language zh_CN
            * 第一套UV数据数组
            */
            this.uvs = new Array();
            /**
            * @language zh_CN
            * 第二套UV数据数组
            */
            this.uv2s = new Array();
            /**
            * @language zh_CN
            * 蒙皮数据数组
            */
            this.skinMesh = new Array();
            /**
            * @language zh_CN
            * 面法线数据数组
            */
            this.faceNormals = new Array();
            /**
            * @language zh_CN
            * 面权重数据数组
            */
            this.faceWeights = new Array();
            /**
              * @language zh_CN
              * 顶点索引数据
              */
            this.vertexIndices = new Array();
            /**
            * @language zh_CN
            * uv索引数据
            */
            this.uvIndices = new Array();
            /**
            * @language zh_CN
            * uv2索引数据
            */
            this.uv2Indices = new Array();
            /**
            * @language zh_CN
            * 法线索引数据
            */
            this.normalIndices = new Array();
            /**
            * @language zh_CN
            * 顶点色索引数据
            */
            this.colorIndices = new Array();
            /**
            * @language zh_CN
            * 索引数据数组
            */
            this.indexIds = new Array(); // used for real index lookups
            this.matCount = 0;
            this.material = {};
        }
        /**
        * @language zh_CN
        *
        * 构建顶点数据数组
        * @param source 未组合顶点数据的GeometryData对象
        * @param vertexFormat 生成顶点格式
        * @returns 经过组合并生成顶点数据数组的新GeometryData对象
        */
        GeometryData.buildGeomtry = function (source, vertexFormat) {
            var target = new egret3d.Geometry();
            target.vertexFormat = vertexFormat;
            target.vertexCount = source.faces * 3;
            target.indexCount = source.faces * 3;
            target.faceCount = source.faces;
            target.skeleton = source.skeleton;
            var vertex = new egret3d.Vector3D();
            var normal = new egret3d.Vector3D(1.0, 1.0, 1.0);
            var color = new egret3d.Vector3D(1.0, 1.0, 1.0, 1.0);
            var uv_0 = { u: 1, v: 0 };
            var uv_1 = { u: 1, v: 0 };
            var index = 0;
            var vertexIndex = 0;
            var offset = 0;
            for (var faceIndex = 0; faceIndex < source.faces; faceIndex++) {
                target.indexArray[faceIndex * 3 + 0] = faceIndex * 3 + 0;
                target.indexArray[faceIndex * 3 + 1] = faceIndex * 3 + 2;
                target.indexArray[faceIndex * 3 + 2] = faceIndex * 3 + 1;
                for (var i = 0; i < 3; i++) {
                    vertexIndex = faceIndex * 3 + i;
                    vertexIndex *= target.vertexAttLength;
                    offset = 0;
                    index = source.vertexIndices[faceIndex * 3 + i] * egret3d.Geometry.positionSize;
                    if (vertexFormat & egret3d.VertexFormat.VF_POSITION) {
                        vertex.x = source.source_vertexData[index + 0];
                        vertex.y = source.source_vertexData[index + 1];
                        vertex.z = source.source_vertexData[index + 2];
                        target.vertexArray[vertexIndex + offset + 0] = vertex.x;
                        target.vertexArray[vertexIndex + offset + 1] = vertex.y;
                        target.vertexArray[vertexIndex + offset + 2] = vertex.z;
                        offset += egret3d.Geometry.positionSize;
                    }
                    if (vertexFormat & egret3d.VertexFormat.VF_NORMAL) {
                        if (source.normalIndices && source.source_normalData && source.source_normalData.length > 0) {
                            index = source.normalIndices[faceIndex * 3 + i] * egret3d.Geometry.normalSize;
                            normal.x = source.source_normalData[index + 0];
                            normal.y = source.source_normalData[index + 1];
                            normal.z = source.source_normalData[index + 2];
                        }
                        target.vertexArray[vertexIndex + offset + 0] = normal.x;
                        target.vertexArray[vertexIndex + offset + 1] = normal.y;
                        target.vertexArray[vertexIndex + offset + 2] = normal.z;
                        offset += egret3d.Geometry.normalSize;
                    }
                    if (vertexFormat & egret3d.VertexFormat.VF_TANGENT) {
                        target.vertexArray[vertexIndex + offset + 0] = 0;
                        target.vertexArray[vertexIndex + offset + 1] = 0;
                        target.vertexArray[vertexIndex + offset + 2] = 0;
                        offset += egret3d.Geometry.tangentSize;
                    }
                    if (vertexFormat & egret3d.VertexFormat.VF_COLOR) {
                        if (source.colorIndices && source.source_vertexColorData && source.source_vertexColorData.length > 0) {
                            index = source.colorIndices[faceIndex * 3 + i] * egret3d.Geometry.colorSize;
                            color.x = source.source_vertexColorData[index + 0];
                            color.y = source.source_vertexColorData[index + 1];
                            color.z = source.source_vertexColorData[index + 2];
                            color.w = source.source_vertexColorData[index + 3];
                        }
                        target.vertexArray[vertexIndex + offset + 0] = color.x;
                        target.vertexArray[vertexIndex + offset + 1] = color.y;
                        target.vertexArray[vertexIndex + offset + 2] = color.z;
                        target.vertexArray[vertexIndex + offset + 3] = color.w;
                        offset += egret3d.Geometry.colorSize;
                    }
                    if (vertexFormat & egret3d.VertexFormat.VF_UV0) {
                        if (source.uvIndices && source.source_uvData && source.source_uvData.length > 0) {
                            index = source.uvIndices[faceIndex * 3 + i] * egret3d.Geometry.uvSize;
                            uv_0.u = source.source_uvData[index + 0];
                            uv_0.v = source.source_uvData[index + 1];
                        }
                        target.vertexArray[vertexIndex + offset + 0] = uv_0.u;
                        target.vertexArray[vertexIndex + offset + 1] = uv_0.v;
                        offset += egret3d.Geometry.uvSize;
                    }
                    if (vertexFormat & egret3d.VertexFormat.VF_UV1) {
                        if (source.uv2Indices && source.source_uv2Data && source.source_uv2Data.length > 0) {
                            index = source.uv2Indices[faceIndex * 3 + i] * egret3d.Geometry.uv2Size;
                            uv_1.u = source.source_uv2Data[index + 0];
                            uv_1.v = source.source_uv2Data[index + 1];
                        }
                        target.vertexArray[vertexIndex + offset + 0] = uv_1.u;
                        target.vertexArray[vertexIndex + offset + 1] = uv_1.v;
                        offset += egret3d.Geometry.uv2Size;
                    }
                    if (vertexFormat & egret3d.VertexFormat.VF_SKIN) {
                        if (source.source_skinData != null && source.source_skinData.length > 0) {
                            index = source.vertexIndices[faceIndex * 3 + i] * egret3d.Geometry.skinSize;
                            target.vertexArray[vertexIndex + offset + 0] = source.source_skinData[index + 0];
                            target.vertexArray[vertexIndex + offset + 1] = source.source_skinData[index + 2];
                            target.vertexArray[vertexIndex + offset + 2] = source.source_skinData[index + 4];
                            target.vertexArray[vertexIndex + offset + 3] = source.source_skinData[index + 6];
                            target.vertexArray[vertexIndex + offset + 4] = source.source_skinData[index + 1];
                            target.vertexArray[vertexIndex + offset + 5] = source.source_skinData[index + 3];
                            target.vertexArray[vertexIndex + offset + 6] = source.source_skinData[index + 5];
                            target.vertexArray[vertexIndex + offset + 7] = source.source_skinData[index + 7];
                        }
                        else {
                            target.vertexArray[vertexIndex + offset + 0] = 0;
                            target.vertexArray[vertexIndex + offset + 1] = 0;
                            target.vertexArray[vertexIndex + offset + 2] = 0;
                            target.vertexArray[vertexIndex + offset + 3] = 0;
                            target.vertexArray[vertexIndex + offset + 4] = 0;
                            target.vertexArray[vertexIndex + offset + 5] = 0;
                            target.vertexArray[vertexIndex + offset + 6] = 0;
                            target.vertexArray[vertexIndex + offset + 7] = 0;
                        }
                    }
                }
            }
            // GeometryData.updateFaceTangents(target);
            for (var i = 0; i < source.matCount; ++i) {
                var subGeometry = new egret3d.SubGeometry();
                subGeometry.matID = i;
                subGeometry.geometry = target;
                //subGeometry.start = source.material[i].start * 3 * Uint16Array.BYTES_PER_ELEMENT;
                subGeometry.start = source.material[i].start * 3;
                subGeometry.count = source.material[i].count * 3;
                subGeometry.textureDiffuse = source.material[i].textureDiffuse;
                subGeometry.textureNormal = source.material[i].textureNormal;
                subGeometry.textureSpecular = source.material[i].textureSpecular;
                target.subGeometrys.push(subGeometry);
            }
            return target;
        };
        //private static translateMaterialGroup(geomtryData: GeometryData): GeometryData {
        //    var faces: Array<FaceData> = geomtryData.source_faceData;
        //    var face: FaceData;
        //    var numFaces: number = faces.length;
        //    var numVerts: number;
        //    var targetGeomtryData: GeometryData = new GeometryData();
        //    targetGeomtryData.vertexAttLength = geomtryData.vertexAttLength;
        //    var j: number;
        //    for (var i: number = 0; i < numFaces; ++i) {
        //        face = faces[i];
        //        numVerts = face.indexIds.length - 1;
        //        for (j = 1; j < numVerts; ++j) {
        //            this.translateVertexData(face, j, geomtryData, targetGeomtryData);
        //            this.translateVertexData(face, 0, geomtryData, targetGeomtryData);
        //            this.translateVertexData(face, j + 1, geomtryData, targetGeomtryData);
        //        }
        //    }
        //    if (targetGeomtryData.vertices.length > 0) {
        //        targetGeomtryData.vertLen = (targetGeomtryData.vertices.length / 3) * geomtryData.vertexAttLength;
        //       targetGeomtryData.vertexDatas = new Array<number>(targetGeomtryData.vertLen)
        //        //this.updateFaceTangents(targetGeomtryData);
        //        //this.updateFaceNormals(targetGeomtryData);
        //        this.combinGeomtryData(targetGeomtryData);
        //    }
        //    return targetGeomtryData;
        //}
        //private static translateVertexData(face: FaceData, vertexIndex: number, sourceGeomtryData: GeometryData, targetGeomtryData: GeometryData) {
        //    var index: number;
        //    var vertex: Vector3D;
        //    var color: Vector3D;
        //    var vertexNormal: Vector3D;
        //    var uv: UV;
        //    if (!targetGeomtryData.indices[face.indexIds[vertexIndex]]) {
        //        index = targetGeomtryData.vertexIndex;
        //        targetGeomtryData.indices[face.indexIds[vertexIndex]] = ++targetGeomtryData.vertexIndex;
        //        vertex = sourceGeomtryData.source_vertexData[face.vertexIndices[vertexIndex] - 1];
        //        targetGeomtryData.vertices.push(vertex.x, vertex.y, vertex.z);
        //        if (sourceGeomtryData.source_vertexColorData != null && sourceGeomtryData.source_vertexColorData.length > 0) {
        //            color = sourceGeomtryData.source_vertexColorData[face.vertexIndices[vertexIndex] - 1]
        //            targetGeomtryData.verticesColor.push(color.r, color.g, color.b, color.a);
        //        }
        //        if (sourceGeomtryData.source_skinData != null && sourceGeomtryData.source_skinData.length > 0) {
        //            targetGeomtryData.skinMesh.push(
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 0],
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 2],
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 4],
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 6],
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 1],
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 3],
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 5],
        //                sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 7]
        //                );
        //        }
        //        if (face.normalIndices.length > 0) {
        //            vertexNormal = sourceGeomtryData.source_normalData[face.normalIndices[vertexIndex] - 1];
        //            targetGeomtryData.normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);
        //        }
        //        if (face.uvIndices.length > 0) {
        //            try {
        //                uv = sourceGeomtryData.source_uvData[face.uvIndices[vertexIndex] - 1];
        //                targetGeomtryData.uvs.push(uv.u, uv.v);
        //                if (sourceGeomtryData.source_uv2Data.length > 0) {
        //                    uv = sourceGeomtryData.source_uv2Data[face.uv2Indices[vertexIndex] - 1];
        //                    targetGeomtryData.uv2s.push(uv.u, uv.v);
        //                }
        //            } catch (e) {
        //                switch (vertexIndex) {
        //                    case 0:
        //                        targetGeomtryData.uvs.push(0, 1);
        //                        break;
        //                    case 1:
        //                        targetGeomtryData.uvs.push(.5, 0);
        //                        break;
        //                    case 2:
        //                        targetGeomtryData.uvs.push(1, 1);
        //                }
        //            }
        //        }
        //    } else
        //        index = targetGeomtryData.indices[face.indexIds[vertexIndex]] - 1;
        //    targetGeomtryData.indices.push(index);
        //}
        /**
        * 4 pos
        * 3 normal
        * 4 color
        * 2 uv
        * 2 uv2s
        * length 15
        */
        GeometryData.combinGeomtryData = function (geomtrtData, needTangent) {
            if (needTangent === void 0) { needTangent = true; }
            var index = 0;
            var v = 0;
            var n = 0;
            var t = 0;
            var u1 = 0;
            var u2 = 0;
            var c = 0;
            var skin = 0;
            var data = geomtrtData.vertexDatas;
            while (index < geomtrtData.vertLen) {
                data[index++] = geomtrtData.vertices[v++];
                data[index++] = geomtrtData.vertices[v++];
                data[index++] = geomtrtData.vertices[v++];
                if (geomtrtData.normals && geomtrtData.normals.length) {
                    data[index++] = geomtrtData.normals[n++];
                    data[index++] = geomtrtData.normals[n++];
                    data[index++] = geomtrtData.normals[n++];
                }
                else {
                    data[index++] = 0;
                    data[index++] = 0;
                    data[index++] = 0;
                }
                if (geomtrtData.tangts) {
                    index++;
                    index++;
                    index++;
                }
                else {
                    data[index++] = 0;
                    data[index++] = 0;
                    data[index++] = 0;
                }
                if (geomtrtData.source_vertexColorData && geomtrtData.source_vertexColorData.length) {
                    data[index++] = geomtrtData.verticesColor[c++];
                    data[index++] = geomtrtData.verticesColor[c++];
                    data[index++] = geomtrtData.verticesColor[c++];
                    data[index++] = geomtrtData.verticesColor[c++];
                }
                else {
                    data[index++] = 1;
                    data[index++] = 1;
                    data[index++] = 1;
                    data[index++] = 1;
                }
                if (geomtrtData.uvs && geomtrtData.uvs.length) {
                    data[index++] = geomtrtData.uvs[u1++];
                    data[index++] = geomtrtData.uvs[u1++];
                    if (geomtrtData.uv2s && geomtrtData.uv2s.length) {
                        data[index++] = geomtrtData.uv2s[u2++];
                        data[index++] = geomtrtData.uv2s[u2++];
                    }
                    else {
                        data[index++] = geomtrtData.uvs[u2++];
                        data[index++] = geomtrtData.uvs[u2++];
                    }
                }
                else {
                    data[index++] = 0;
                    data[index++] = 0;
                    data[index++] = 0;
                    data[index++] = 0;
                }
                if (geomtrtData.skinMesh && geomtrtData.skinMesh.length) {
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                }
            }
            //if (needTangent)
            //    this.updateFaceTangents(geomtrtData
        };
        /**
         * @private
         * Updates the normals for each face.
         */
        GeometryData.updateFaceNormals = function (geomtrtData) {
            var i = 0, j = 0, k = 0;
            var index;
            var len = geomtrtData.indices.length;
            var x1, x2, x3;
            var y1, y2, y3;
            var z1, z2, z3;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var d;
            var vertices = geomtrtData.vertexDatas;
            var posStride = 17;
            var posOffset = 3;
            //if (_useFaceWeights)
            //    _faceWeights ||= new Vector.<number>(len / 3, true);
            while (i < len) {
                index = posOffset + geomtrtData.indices[i++] * posStride;
                x1 = vertices[index];
                y1 = vertices[index + 1];
                z1 = vertices[index + 2];
                index = posOffset + geomtrtData.indices[i++] * posStride;
                x2 = vertices[index];
                y2 = vertices[index + 1];
                z2 = vertices[index + 2];
                index = posOffset + geomtrtData.indices[i++] * posStride;
                x3 = vertices[index];
                y3 = vertices[index + 1];
                z3 = vertices[index + 2];
                dx1 = x3 - x1;
                dy1 = y3 - y1;
                dz1 = z3 - z1;
                dx2 = x2 - x1;
                dy2 = y2 - y1;
                dz2 = z2 - z1;
                cx = dz1 * dy2 - dy1 * dz2;
                cy = dx1 * dz2 - dz1 * dx2;
                cz = dy1 * dx2 - dx1 * dy2;
                d = Math.sqrt(cx * cx + cy * cy + cz * cz);
                // length of cross product = 2*triangle area
                if (true) {
                    var w = d * 10000;
                    if (w < 1)
                        w = 1;
                    geomtrtData.faceWeights[k++] = w;
                }
                d = 1 / d;
                geomtrtData.faceNormals[j++] = cx * d;
                geomtrtData.faceNormals[j++] = cy * d;
                geomtrtData.faceNormals[j++] = cz * d;
            }
            //_faceNormalsDirty = false;
        };
        /**
         * Updates the vertex normals based on the geometry.
         */
        GeometryData.updateVertexNormals = function (geomtrtData) {
            this.updateFaceNormals(geomtrtData);
            var v1;
            var f1 = 0, f2 = 1, f3 = 2;
            var lenV = geomtrtData.vertexDatas.length;
            var normalStride = 17;
            var normalOffset = 3;
            //target ||= new Vector.<Number>(lenV, true);
            //v1 = normalOffset;
            //while(v1 < lenV) {
            //    target[v1] = 0.0;
            //    target[v1 + 1] = 0.0;
            //    target[v1 + 2] = 0.0;
            //    v1 += normalStride;
            //}
            var i = 0, k = 0;
            var lenI = geomtrtData.indices.length;
            var index;
            var weight;
            while (i < lenI) {
                weight = geomtrtData.faceWeights[k++];
                index = normalOffset + geomtrtData.indices[i++] * normalStride;
                geomtrtData.vertexDatas[index] += geomtrtData.faceNormals[f1] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f2] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f3] * weight;
                index = normalOffset + geomtrtData.indices[i++] * normalStride;
                geomtrtData.vertexDatas[index] += geomtrtData.faceNormals[f1] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f2] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f3] * weight;
                index = normalOffset + geomtrtData.indices[i++] * normalStride;
                geomtrtData.vertexDatas[index] += geomtrtData.faceNormals[f1] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f2] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f3] * weight;
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            //v1 = normalOffset;
            //    while(v1 < lenV) {
            //        var vx: Number = target[v1];
            //        var vy: Number = target[v1 + 1];
            //        var vz: Number = target[v1 + 2];
            //        var d: Number = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
            //        target[v1] = vx * d;
            //        target[v1 + 1] = vy * d;
            //        target[v1 + 2] = vz * d;
            //        v1 += normalStride;
            //    }
            //_vertexNormalsDirty = false;
        };
        return GeometryData;
    }());
    egret3d.GeometryData = GeometryData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.SubGeometry
     * @classdesc
     * 表示几何形状 子集 不同的子集渲染时使用的材质会不同。
     * 这样就可以用不同的材质来共用相同的geometry buffer
     *
     * @see egret3d.Geometry
     * @version Egret 3.0
     * @platform Web,Native
     */
    var SubGeometry = (function () {
        function SubGeometry() {
            this.useVertexAttributeList = [];
            /**
             * @language zh_CN
             * 顶点索引
             * @version Egret 3.0
             * @platform Web,Native
             */
            this._start = 0;
            /**
            * @language zh_CN
            * 顶点索引数量
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.count = 0;
            /**
            * @language zh_CN
            * 材质ID 对应 IRender.getMaterial(this.matID)
            * @see egret3d.IRender
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.matID = 0;
            /**
            * @language zh_CN
            * @private
            */
            this.preAttList = new Array();
            /**
           * @private
           * @language zh_CN
           * @version Egret 3.0
           * @platform Web,Native
           */
            this.localActive = false;
        }
        Object.defineProperty(SubGeometry.prototype, "start", {
            /**
            * @language zh_CN
            * 顶点索引中的索引
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._start;
            },
            /**
            * @language zh_CN
            * 顶点索引中的索引
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                this._start = val;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        */
        SubGeometry.prototype.upload = function (passUsage, contextPorxy) {
            passUsage.attributeDiry = false;
            var offsetBytes = 0;
            passUsage["attributeList"] = [];
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_POSITION) {
                if (passUsage.attribute_position) {
                    if (!passUsage.attribute_position.uniformIndex) {
                        passUsage.attribute_position.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_position.varName);
                    }
                    passUsage.attribute_position.size = egret3d.Geometry.positionSize;
                    passUsage.attribute_position.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_position.normalized = false;
                    passUsage.attribute_position.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_position.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_position);
                    this.useVertexAttributeList[passUsage.attribute_position.uniformIndex] = passUsage.attribute_position.uniformIndex;
                }
                offsetBytes += egret3d.Geometry.positionSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_NORMAL) {
                if (passUsage.attribute_normal) {
                    if (!passUsage.attribute_normal.uniformIndex) {
                        passUsage.attribute_normal.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_normal.varName);
                    }
                    passUsage.attribute_normal.size = egret3d.Geometry.normalSize;
                    passUsage.attribute_normal.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_normal.normalized = false;
                    passUsage.attribute_normal.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_normal.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_normal);
                    this.useVertexAttributeList[passUsage.attribute_normal.uniformIndex] = passUsage.attribute_normal.uniformIndex;
                }
                offsetBytes += egret3d.Geometry.normalSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_TANGENT) {
                if (passUsage.attribute_tangent) {
                    if (!passUsage.attribute_tangent.uniformIndex) {
                        passUsage.attribute_tangent.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_tangent.varName);
                    }
                    passUsage.attribute_tangent.size = egret3d.Geometry.tangentSize;
                    passUsage.attribute_tangent.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_tangent.normalized = false;
                    passUsage.attribute_tangent.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_tangent.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_tangent);
                    this.useVertexAttributeList[passUsage.attribute_tangent.uniformIndex] = passUsage.attribute_tangent.uniformIndex;
                }
                offsetBytes += egret3d.Geometry.tangentSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_COLOR) {
                if (passUsage.attribute_color) {
                    if (!passUsage.attribute_color.uniformIndex) {
                        passUsage.attribute_color.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_color.varName);
                    }
                    passUsage.attribute_color.size = egret3d.Geometry.colorSize;
                    passUsage.attribute_color.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_color.normalized = false;
                    passUsage.attribute_color.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_color.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_color);
                    this.useVertexAttributeList[passUsage.attribute_color.uniformIndex] = passUsage.attribute_color.uniformIndex;
                }
                offsetBytes += egret3d.Geometry.colorSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_UV0) {
                if (passUsage.attribute_uv0) {
                    if (!passUsage.attribute_uv0.uniformIndex) {
                        passUsage.attribute_uv0.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_uv0.varName);
                    }
                    passUsage.attribute_uv0.size = egret3d.Geometry.uvSize;
                    passUsage.attribute_uv0.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_uv0.normalized = false;
                    passUsage.attribute_uv0.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_uv0.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_uv0);
                    this.useVertexAttributeList[passUsage.attribute_uv0.uniformIndex] = passUsage.attribute_uv0.uniformIndex;
                }
                offsetBytes += egret3d.Geometry.uvSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_UV1) {
                if (passUsage.attribute_uv1) {
                    if (!passUsage.attribute_uv1.uniformIndex) {
                        passUsage.attribute_uv1.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_uv1.varName);
                    }
                    passUsage.attribute_uv1.size = egret3d.Geometry.uv2Size;
                    passUsage.attribute_uv1.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_uv1.normalized = false;
                    passUsage.attribute_uv1.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_uv1.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_uv1);
                    this.useVertexAttributeList[passUsage.attribute_uv1.uniformIndex] = passUsage.attribute_uv1.uniformIndex;
                }
                offsetBytes += egret3d.Geometry.uv2Size * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_SKIN) {
                if (passUsage.attribute_boneIndex) {
                    if (!passUsage.attribute_boneIndex.uniformIndex) {
                        passUsage.attribute_boneIndex.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_boneIndex.varName);
                    }
                    passUsage.attribute_boneIndex.size = egret3d.Geometry.skinSize / 2;
                    passUsage.attribute_boneIndex.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_boneIndex.normalized = false;
                    passUsage.attribute_boneIndex.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_boneIndex.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_boneIndex);
                    this.useVertexAttributeList[passUsage.attribute_boneIndex.uniformIndex] = passUsage.attribute_boneIndex.uniformIndex;
                }
                offsetBytes += egret3d.Geometry.skinSize / 2 * Float32Array.BYTES_PER_ELEMENT;
                if (passUsage.attribute_boneWeight) {
                    if (!passUsage.attribute_boneWeight.uniformIndex) {
                        passUsage.attribute_boneWeight.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_boneWeight.varName);
                    }
                    passUsage.attribute_boneWeight.size = egret3d.Geometry.skinSize / 2;
                    passUsage.attribute_boneWeight.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_boneWeight.normalized = false;
                    passUsage.attribute_boneWeight.stride = this.geometry.vertexSizeInBytes;
                    passUsage.attribute_boneWeight.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_boneWeight);
                    this.useVertexAttributeList[passUsage.attribute_boneWeight.uniformIndex] = passUsage.attribute_boneWeight.uniformIndex;
                }
                offsetBytes += egret3d.Geometry.skinSize / 2 * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_QUAD_POS) {
                if (passUsage.attribute_position) {
                    if (!passUsage.attribute_position.uniformIndex) {
                        passUsage.attribute_position.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_position.varName);
                    }
                    passUsage.attribute_position.size = egret3d.QuadData.posSize;
                    passUsage.attribute_position.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_position.normalized = false;
                    passUsage.attribute_position.stride = egret3d.QuadData.vertexBytes;
                    passUsage.attribute_position.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_position);
                    this.useVertexAttributeList[passUsage.attribute_position.uniformIndex] = passUsage.attribute_position.uniformIndex;
                }
                offsetBytes += egret3d.QuadData.posSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_QUAD_ORIGN) {
                if (passUsage.attribute_shapePosition) {
                    if (!passUsage.attribute_shapePosition.uniformIndex) {
                        passUsage.attribute_shapePosition.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_shapePosition.varName);
                    }
                    passUsage.attribute_shapePosition.size = egret3d.QuadData.originalSize;
                    passUsage.attribute_shapePosition.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_shapePosition.normalized = false;
                    passUsage.attribute_shapePosition.stride = egret3d.QuadData.vertexBytes;
                    passUsage.attribute_shapePosition.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_shapePosition);
                    this.useVertexAttributeList[passUsage.attribute_shapePosition.uniformIndex] = passUsage.attribute_shapePosition.uniformIndex;
                }
                offsetBytes += egret3d.QuadData.originalSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_QUAD_UVREC) {
                if (passUsage.attribute_uvRec) {
                    if (!passUsage.attribute_uvRec.uniformIndex) {
                        passUsage.attribute_uvRec.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_uvRec.varName);
                    }
                    passUsage.attribute_uvRec.size = egret3d.QuadData.uvRectangleSize;
                    passUsage.attribute_uvRec.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_uvRec.normalized = false;
                    passUsage.attribute_uvRec.stride = egret3d.QuadData.vertexBytes;
                    passUsage.attribute_uvRec.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_uvRec);
                    this.useVertexAttributeList[passUsage.attribute_uvRec.uniformIndex] = passUsage.attribute_uvRec.uniformIndex;
                }
                offsetBytes += egret3d.QuadData.uvRectangleSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_QUAD_ROTATION) {
                if (passUsage.attribute_rotate) {
                    if (!passUsage.attribute_rotate.uniformIndex) {
                        passUsage.attribute_rotate.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_rotate.varName);
                    }
                    passUsage.attribute_rotate.size = egret3d.QuadData.rotationSize;
                    passUsage.attribute_rotate.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_rotate.normalized = false;
                    passUsage.attribute_rotate.stride = egret3d.QuadData.vertexBytes;
                    passUsage.attribute_rotate.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_rotate);
                    this.useVertexAttributeList[passUsage.attribute_rotate.uniformIndex] = passUsage.attribute_rotate.uniformIndex;
                }
                offsetBytes += egret3d.QuadData.rotationSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_QUAD_MASK) {
                if (passUsage.attribute_maskRectangle) {
                    if (!passUsage.attribute_maskRectangle.uniformIndex) {
                        passUsage.attribute_maskRectangle.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_maskRectangle.varName);
                    }
                    passUsage.attribute_maskRectangle.size = egret3d.QuadData.maskSize;
                    passUsage.attribute_maskRectangle.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_maskRectangle.normalized = false;
                    passUsage.attribute_maskRectangle.stride = egret3d.QuadData.vertexBytes;
                    passUsage.attribute_maskRectangle.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_maskRectangle);
                    this.useVertexAttributeList[passUsage.attribute_maskRectangle.uniformIndex] = passUsage.attribute_maskRectangle.uniformIndex;
                }
                offsetBytes += egret3d.QuadData.maskSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (this.geometry.vertexFormat & egret3d.VertexFormat.VF_QUAD_COLOR) {
                if (passUsage.attribute_quad_color) {
                    if (!passUsage.attribute_quad_color.uniformIndex) {
                        passUsage.attribute_quad_color.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, passUsage.attribute_quad_color.varName);
                    }
                    passUsage.attribute_quad_color.size = egret3d.QuadData.colorSize;
                    passUsage.attribute_quad_color.dataType = egret3d.ContextConfig.FLOAT;
                    passUsage.attribute_quad_color.normalized = false;
                    passUsage.attribute_quad_color.stride = egret3d.QuadData.vertexBytes;
                    passUsage.attribute_quad_color.offsetBytes = offsetBytes;
                    passUsage["attributeList"].push(passUsage.attribute_quad_color);
                    this.useVertexAttributeList[passUsage.attribute_quad_color.uniformIndex] = passUsage.attribute_quad_color.uniformIndex;
                }
                offsetBytes += egret3d.QuadData.colorSize * Float32Array.BYTES_PER_ELEMENT;
            }
            for (var i = 0; i < this.preAttList.length; ++i) {
                var var0 = this.preAttList[i];
                var attribute = passUsage[var0.name];
                if (attribute) {
                    if (!attribute.uniformIndex) {
                        attribute.uniformIndex = contextPorxy.getShaderAttribLocation(passUsage.program3D, attribute.varName);
                        attribute.size = var0.size;
                        attribute.dataType = egret3d.ContextConfig.FLOAT;
                        attribute.normalized = false;
                        attribute.stride = this.geometry.vertexSizeInBytes;
                        attribute.offsetBytes = offsetBytes;
                        passUsage["attributeList"].push(attribute);
                        this.useVertexAttributeList[attribute.uniformIndex] = attribute.uniformIndex;
                    }
                }
                offsetBytes += var0.size * Float32Array.BYTES_PER_ELEMENT;
            }
        };
        /**
       * @private
       * @language zh_CN
       * @version Egret 3.0
       * @platform Web,Native
       */
        SubGeometry.prototype.activeState = function (time, delay, passUsage, contextProxy) {
            if (passUsage.attributeDiry)
                this.upload(passUsage, contextProxy);
            var active = contextProxy.activeAttribPointer(this.geometry.vertexFormat, passUsage["attributeList"].length);
            // if (active) {
            for (var i = 0; i < passUsage["attributeList"].length; i++) {
                var attribute = passUsage["attributeList"][i];
                if (attribute.uniformIndex >= 0)
                    contextProxy.vertexAttribPointer(attribute.uniformIndex, attribute.size, attribute.dataType, attribute.normalized, attribute.stride, attribute.offsetBytes);
            }
            //}
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        SubGeometry.use = false;
        return SubGeometry;
    }());
    egret3d.SubGeometry = SubGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.CubeGeometry
     * @classdesc
     * CubeGeometry类 表示立方体</p>
     *
     * 示例：</p>
     * 用 CubeGeometry 对象创建一个mesh，并给予默认纹理材质TextureMaterial（默认为棋盘格纹理）; </p>
     <pre>
      var box: egret3d.Mesh = new egret3d.Mesh( new egret3d.CubeGeometry(), new egret3d.TextureMaterial() );
     </pre>
     *
     * @see egret3d.Geometry
     * @see egret3d.Mesh
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/CubeGeometry.ts
     */
    var CubeGeometry = (function (_super) {
        __extends(CubeGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param width {number} 宽度 默认为80
        * @param height {number} 高度 默认为80
        * @param depth {number} 深度 默认为80
        * @version Egret 3.0
        * @platform Web,Native
        */
        function CubeGeometry(width, height, depth) {
            if (width === void 0) { width = 80; }
            if (height === void 0) { height = 80; }
            if (depth === void 0) { depth = 80; }
            _super.call(this);
            this._width = 80;
            this._height = 80;
            this._depth = 80;
            this._width = width;
            this._height = height;
            this._depth = depth;
            this.buildGeomtry(true);
        }
        Object.defineProperty(CubeGeometry.prototype, "width", {
            /**
            * @language zh_CN
            * Cube宽度
            * @returns {number} 宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "height", {
            /**
            * @language zh_CN
            * Cube高度
            * @returns {number} 高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CubeGeometry.prototype, "depth", {
            /**
            * @language zh_CN
            * Cube深度
            * @returns {number} 高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._depth;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * 生成网格
        * @version Egret 3.0
        * @platform Web,Native
        */
        CubeGeometry.prototype.buildGeomtry = function (front) {
            this.vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_UV1;
            this.vertexCount = 36;
            this.indexCount = 36;
            this.vertexArray.set([
                -this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0,
                -this._width * 0.5, this._height * 0.5, -this._depth * 0.5, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0,
                this._width * 0.5, this._height * 0.5, -this._depth * 0.5, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0,
                this._width * 0.5, this._height * 0.5, -this._depth * 0.5, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0,
                this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0,
                -this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0,
                -this._width * 0.5, -this._height * 0.5, this._depth * 0.5, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0,
                this._width * 0.5, -this._height * 0.5, this._depth * 0.5, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0,
                this._width * 0.5, this._height * 0.5, this._depth * 0.5, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0,
                this._width * 0.5, this._height * 0.5, this._depth * 0.5, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0,
                -this._width * 0.5, this._height * 0.5, this._depth * 0.5, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0,
                -this._width * 0.5, -this._height * 0.5, this._depth * 0.5, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0,
                -this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0,
                this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0,
                this._width * 0.5, -this._height * 0.5, this._depth * 0.5, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0,
                this._width * 0.5, -this._height * 0.5, this._depth * 0.5, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0,
                -this._width * 0.5, -this._height * 0.5, this._depth * 0.5, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0,
                -this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0,
                this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0,
                this._width * 0.5, this._height * 0.5, -this._depth * 0.5, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0,
                this._width * 0.5, this._height * 0.5, this._depth * 0.5, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0,
                this._width * 0.5, this._height * 0.5, this._depth * 0.5, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0,
                this._width * 0.5, -this._height * 0.5, this._depth * 0.5, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0,
                this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0,
                this._width * 0.5, this._height * 0.5, -this._depth * 0.5, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0,
                -this._width * 0.5, this._height * 0.5, -this._depth * 0.5, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0,
                -this._width * 0.5, this._height * 0.5, this._depth * 0.5, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0,
                -this._width * 0.5, this._height * 0.5, this._depth * 0.5, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0,
                this._width * 0.5, this._height * 0.5, this._depth * 0.5, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0,
                this._width * 0.5, this._height * 0.5, -this._depth * 0.5, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0,
                -this._width * 0.5, this._height * 0.5, -this._depth * 0.5, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0,
                -this._width * 0.5, -this._height * 0.5, -this._depth * 0.5, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0,
                -this._width * 0.5, -this._height * 0.5, this._depth * 0.5, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0,
                -this._width * 0.5, -this._height * 0.5, this._depth * 0.5, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0,
                -this._width * 0.5, this._height * 0.5, this._depth * 0.5, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0,
                -this._width * 0.5, this._height * 0.5, -this._depth * 0.5, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0
            ]);
            if (front) {
                this.indexArray.set([
                    0, 2, 1, 3, 5, 4,
                    6, 8, 7, 9, 11, 10,
                    12, 14, 13, 15, 17, 16,
                    18, 20, 19, 21, 23, 22,
                    24, 26, 25, 27, 29, 28,
                    30, 32, 31, 33, 35, 34]);
            }
            else {
                this.indexArray.set([
                    0, 1, 2, 3, 4, 5,
                    6, 7, 8, 9, 10, 11,
                    12, 13, 14, 15, 16, 17,
                    18, 19, 20, 21, 22, 23,
                    24, 25, 26, 27, 28, 29,
                    30, 31, 32, 33, 34, 35]);
            }
            this.buildDefaultSubGeometry();
        };
        return CubeGeometry;
    }(egret3d.Geometry));
    egret3d.CubeGeometry = CubeGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.CylinderGeometry
     * @classdesc
     * CylinderGeometry类 表示圆柱体</p>
     *
     * 示例：</p>
     * 用 CylinderGeometry 对象创建一个mesh，并给予默认纹理材质TextureMaterial（默认为棋盘格纹理)</p>
     <pre>
     var box: egret3d.Mesh = new egret3d.Mesh( new egret3d.CylinderGeometry(), new egret3d.TextureMaterial() );
     </pre>
     * @includeExample geometry/CubeGeometry.ts
     * @see egret3d.Geometry
     * @version Egret 3.0
     * @platform Web,Native
     */
    var CylinderGeometry = (function (_super) {
        __extends(CylinderGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param height {number} 宽度 默认为100
        * @param radius {number} 半径 默认为200
        * @version Egret 3.0
        * @platform Web,Native
        */
        function CylinderGeometry(height, radius) {
            if (height === void 0) { height = 100; }
            if (radius === void 0) { radius = 200; }
            _super.call(this);
            this._height = height;
            this._radius = radius;
            this.buildGeomtry();
        }
        Object.defineProperty(CylinderGeometry.prototype, "height", {
            /**
            * @language zh_CN
            * 圆柱体高度
            * @returns {number} 高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CylinderGeometry.prototype, "radius", {
            /**
            * @language zh_CN
            * 圆柱体半径
            * @returns {number} 半径
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._radius;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * 生成网格
        */
        CylinderGeometry.prototype.buildGeomtry = function () {
            this.vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_UV1;
            var vertexBuffer = [];
            var indexBuffer = [];
            //this.vertexCount = m_nSegments * 2 + 2;
            //this.indexCount = 
            var m_nSegments = 20;
            var nCurrentSegment = 20;
            var rDeltaSegAngle = (2.0 * Math.PI / m_nSegments);
            var rSegmentLength = 1.0 / m_nSegments;
            for (nCurrentSegment = 0; nCurrentSegment < m_nSegments; nCurrentSegment++) {
                var x0 = this._radius * Math.sin(nCurrentSegment * rDeltaSegAngle);
                var z0 = this._radius * Math.cos(nCurrentSegment * rDeltaSegAngle);
                vertexBuffer.push(x0, 0.0 + (this._height / 2.0), z0, x0, 0.0, z0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, x0, 0.0 - (this._height / 2.0), z0, x0, 0.0, z0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0);
            }
            var len_base = vertexBuffer.length / this.vertexAttLength;
            var topCenter = len_base;
            vertexBuffer.push(0.0, 0.0 - (this._height / 2.0), 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0);
            var buttomCenter = len_base + 1;
            vertexBuffer.push(0.0, 0.0 + (this._height / 2.0), 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0);
            for (var i = 0; i < len_base; i++) {
                if ((i & 1) != 0) {
                    indexBuffer.push(i, i + 1 >= len_base ? i + 1 - len_base : i + 1, i + 2 >= len_base ? i + 2 - len_base : i + 2, topCenter, i, i + 2 >= len_base ? i + 2 - len_base : i + 2);
                }
                else {
                    indexBuffer.push(i + 1 >= len_base ? i + 1 - len_base : i + 1, i, i + 2 >= len_base ? i + 2 - len_base : i + 2, i, buttomCenter, i + 2 >= len_base ? i + 2 - len_base : i + 2);
                }
            }
            this.setVerticesForIndex(0, this.vertexFormat, vertexBuffer, vertexBuffer.length / this.vertexAttLength);
            this.setVertexIndices(0, indexBuffer);
            var subGeometry = new egret3d.SubGeometry();
            subGeometry.geometry = this;
            subGeometry.start = 0;
            subGeometry.count = this.indexCount;
            this.subGeometrys.push(subGeometry);
        };
        return CylinderGeometry;
    }(egret3d.Geometry));
    egret3d.CylinderGeometry = CylinderGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.PlaneGeometry
     * @classdesc
     * PlaneGeometry类 表示面板几何体
     *
     * 示例：
     * //用 PlaneGeometry 对象创建一个mesh，并给予默认纹理材质TextureMaterial（默认为棋盘格纹理）;
     * var box: egret3d.Mesh = new egret3d.Mesh( new egret3d.PlaneGeometry(), new egret3d.TextureMaterial() );
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/CubeGeometry.ts
     */
    var PlaneGeometry = (function (_super) {
        __extends(PlaneGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param width {number} 宽度
        * @param height {number} 高度
        * @param segmentsW {number} 宽度分段数
        * @param segmentsH {number} 高度分段数
        * @param uScale {number} U缩放
        * @param vScale {number} V缩放
        * @param aixs {Vector3D} 平面的朝向 默认参数为Vector3D.Y_AXIS
        * @param wCenter {boolean} 是否width以中心位置为(0,0)点
        * @param hCenter {boolean} 是否height以中心位置为(0,0)点
        */
        function PlaneGeometry(width, height, segmentsW, segmentsH, uScale, vScale, aixs, wCenter, hCenter) {
            if (width === void 0) { width = 500; }
            if (height === void 0) { height = 500; }
            if (segmentsW === void 0) { segmentsW = 1; }
            if (segmentsH === void 0) { segmentsH = 1; }
            if (uScale === void 0) { uScale = 1; }
            if (vScale === void 0) { vScale = 1; }
            if (aixs === void 0) { aixs = egret3d.Vector3D.Y_AXIS; }
            if (wCenter === void 0) { wCenter = true; }
            if (hCenter === void 0) { hCenter = true; }
            _super.call(this);
            this._segmentsW = 1;
            this._segmentsH = 1;
            this._width = 500.0;
            this._height = 500.0;
            this._scaleU = 1;
            this._scaleV = 1;
            this._width = width;
            this._height = height;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._scaleU = uScale;
            this._scaleV = vScale;
            this._wCenter = wCenter;
            this._hCenter = hCenter;
            this.buildGeometry(aixs);
        }
        Object.defineProperty(PlaneGeometry.prototype, "segmentsW", {
            /**
            * @language zh_CN
            * 宽度分段数
            * @returns {number} 宽度分段数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._segmentsW;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "segmentsH", {
            /**
            * @language zh_CN
            * 高度分段数
            * @returns {number} 高度分段数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._segmentsH;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "width", {
            /**
            * @language zh_CN
            * 宽度
            * @returns {number} 宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "height", {
            /**
            * @language zh_CN
            * 高度
            * @returns {number} 高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "scaleU", {
            /**
            * @language zh_CN
            * U缩放
            * @returns {number} 缩放值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._scaleU;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlaneGeometry.prototype, "scaleV", {
            /**
            * @language zh_CN
            * U缩放
            * @returns {number} 缩放值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._scaleV;
            },
            enumerable: true,
            configurable: true
        });
        PlaneGeometry.prototype.buildGeometry = function (aixs) {
            this.vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0;
            var x, y;
            var numIndices;
            var base;
            var tw = this._segmentsW + 1;
            var numVertices = (this._segmentsH + 1) * tw;
            var stride = this.vertexAttLength;
            var skip = stride - 15;
            numIndices = this._segmentsH * this._segmentsW * 6;
            this.vertexCount = numVertices;
            this.indexCount = numIndices;
            numIndices = 0;
            var point = new egret3d.Vector3D();
            var index = 0;
            for (var yi = 0; yi <= this._segmentsH; ++yi) {
                for (var xi = 0; xi <= this._segmentsW; ++xi) {
                    x = (xi / this._segmentsW - .5) * this._width;
                    y = (yi / this._segmentsH - .5) * this._height;
                    if (this._wCenter == false) {
                        x += this._width / 2;
                    }
                    if (this._hCenter == false) {
                        y += this._height / 2;
                    }
                    switch (aixs) {
                        case egret3d.Vector3D.Y_AXIS:
                            this.vertexArray[index++] = x;
                            this.vertexArray[index++] = 0;
                            this.vertexArray[index++] = y;
                            this.vertexArray[index++] = 0;
                            this.vertexArray[index++] = 1;
                            this.vertexArray[index++] = 0;
                            break;
                        case egret3d.Vector3D.Z_AXIS:
                            this.vertexArray[index++] = x;
                            this.vertexArray[index++] = y;
                            this.vertexArray[index++] = 0;
                            this.vertexArray[index++] = 0;
                            this.vertexArray[index++] = 0;
                            this.vertexArray[index++] = -1;
                            break;
                        case egret3d.Vector3D.X_AXIS:
                            this.vertexArray[index++] = 0;
                            this.vertexArray[index++] = x;
                            this.vertexArray[index++] = y;
                            this.vertexArray[index++] = 1;
                            this.vertexArray[index++] = 0;
                            this.vertexArray[index++] = 0;
                            break;
                        default:
                            this.vertexArray[index++] = x;
                            this.vertexArray[index++] = 0;
                            this.vertexArray[index++] = y;
                            this.vertexArray[index++] = 0;
                            this.vertexArray[index++] = 1;
                            this.vertexArray[index++] = 0;
                            break;
                    }
                    this.vertexArray[index++] = 1;
                    this.vertexArray[index++] = 0;
                    this.vertexArray[index++] = 0;
                    this.vertexArray[index++] = 1;
                    this.vertexArray[index++] = 1;
                    this.vertexArray[index++] = 1;
                    this.vertexArray[index++] = 1;
                    this.vertexArray[index++] = (xi / this._segmentsW) * this._scaleU;
                    this.vertexArray[index++] = (1 - yi / this._segmentsH) * this._scaleV;
                    index += skip;
                    if (xi != this._segmentsW && yi != this._segmentsH) {
                        base = xi + yi * tw;
                        var mult = 1;
                        this.indexArray[numIndices++] = base * mult;
                        this.indexArray[numIndices++] = (base + tw + 1) * mult;
                        this.indexArray[numIndices++] = (base + tw) * mult;
                        this.indexArray[numIndices++] = base * mult;
                        this.indexArray[numIndices++] = (base + 1) * mult;
                        this.indexArray[numIndices++] = (base + tw + 1) * mult;
                    }
                }
            }
            var subGeometry = new egret3d.SubGeometry();
            subGeometry.geometry = this;
            subGeometry.start = 0;
            subGeometry.count = this.indexCount;
            this.subGeometrys.push(subGeometry);
        };
        return PlaneGeometry;
    }(egret3d.Geometry));
    egret3d.PlaneGeometry = PlaneGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.SphereGeometry
     * @classdesc
     * SphereGeometry类 表示球体
     *
     * 示例：
     * //用 SphereGeometry 对象创建一个mesh，并给予默认纹理材质TextureMaterial（默认为棋盘格纹理）;
     * var box: egret3d.Mesh = new egret3d.Mesh( new egret3d.SphereGeometry(), new egret3d.TextureMaterial() );
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/CubeGeometry.ts
     */
    var SphereGeometry = (function (_super) {
        __extends(SphereGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param r {number} 半径 默认值 100
        * @param segmentsW {number} 宽度分段数 默认值 15
        * @param segmentsH {number} 高度分段数 默认值 15
        * @version Egret 3.0
        * @platform Web,Native
        */
        function SphereGeometry(r, segmentsW, segmentsH) {
            if (r === void 0) { r = 100.0; }
            if (segmentsW === void 0) { segmentsW = 15; }
            if (segmentsH === void 0) { segmentsH = 15; }
            _super.call(this);
            this._segmentsW = 50;
            this._segmentsH = 50;
            this._radius = 100;
            this._radius = r;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this.buildSphere(true);
        }
        Object.defineProperty(SphereGeometry.prototype, "segmentsW", {
            /**
            * @language zh_CN
            * 宽度分段数
            * @returns {number} 宽度分段数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._segmentsW;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SphereGeometry.prototype, "segmentsH", {
            /**
            * @language zh_CN
            * 高度分段数
            * @returns {number} 高度分段数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._segmentsH;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SphereGeometry.prototype, "radius", {
            /**
            * @language zh_CN
            * 半径
            * @returns {number} 半径
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._radius;
            },
            enumerable: true,
            configurable: true
        });
        SphereGeometry.prototype.buildSphere = function (front) {
            if (front === void 0) { front = true; }
            this.vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_UV1;
            var i = 0, j = 0, triIndex = 0;
            var numVerts = (this._segmentsH + 1) * (this._segmentsW + 1);
            var stride = this.vertexAttLength;
            var skip = stride - 9;
            this.vertexCount = numVerts;
            this.indexCount = (this._segmentsH - 1) * this._segmentsW * 6;
            var startIndex = 0;
            var index = 0;
            var comp1 = 0, comp2 = 0, t1 = 0, t2 = 0;
            for (j = 0; j <= this._segmentsH; ++j) {
                startIndex = index;
                var horangle = Math.PI * j / this._segmentsH;
                var z = -this._radius * Math.cos(horangle);
                var ringradius = this._radius * Math.sin(horangle);
                for (i = 0; i <= this._segmentsW; ++i) {
                    var verangle = 2 * Math.PI * i / this._segmentsW;
                    var x = ringradius * Math.cos(verangle);
                    var y = ringradius * Math.sin(verangle);
                    var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
                    var tanLen = Math.sqrt(y * y + x * x);
                    t1 = 0;
                    t2 = tanLen > .007 ? x / tanLen : 0;
                    comp1 = -z;
                    comp2 = y;
                    if (i == this._segmentsW) {
                        this.vertexArray[index++] = this.vertexArray[startIndex];
                        this.vertexArray[index++] = this.vertexArray[startIndex + 1];
                        this.vertexArray[index++] = this.vertexArray[startIndex + 2];
                        this.vertexArray[index++] = x * normLen;
                        ;
                        this.vertexArray[index++] = comp1 * normLen;
                        ;
                        this.vertexArray[index++] = comp2 * normLen;
                        ;
                        this.vertexArray[index++] = tanLen > .007 ? -y / tanLen : 1;
                        this.vertexArray[index++] = t1;
                        this.vertexArray[index++] = t2;
                        this.vertexArray[index + 0] = 1.0;
                        this.vertexArray[index + 1] = 1.0;
                        this.vertexArray[index + 2] = 1.0;
                        this.vertexArray[index + 3] = 1.0;
                    }
                    else {
                        this.vertexArray[index++] = x;
                        this.vertexArray[index++] = comp1;
                        this.vertexArray[index++] = comp2;
                        this.vertexArray[index++] = x * normLen;
                        this.vertexArray[index++] = comp1 * normLen;
                        this.vertexArray[index++] = comp2 * normLen;
                        this.vertexArray[index++] = tanLen > .007 ? -y / tanLen : 1;
                        this.vertexArray[index++] = t1;
                        this.vertexArray[index++] = t2;
                        this.vertexArray[index] = 1.0;
                        this.vertexArray[index + 1] = 1.0;
                        this.vertexArray[index + 2] = 1.0;
                        this.vertexArray[index + 3] = 1.0;
                    }
                    if (i > 0 && j > 0) {
                        var a = (this._segmentsW + 1) * j + i;
                        var b = (this._segmentsW + 1) * j + i - 1;
                        var c = (this._segmentsW + 1) * (j - 1) + i - 1;
                        var d = (this._segmentsW + 1) * (j - 1) + i;
                        if (j == this._segmentsH) {
                            this.vertexArray[index - 9] = this.vertexArray[startIndex];
                            this.vertexArray[index - 8] = this.vertexArray[startIndex + 1];
                            this.vertexArray[index - 7] = this.vertexArray[startIndex + 2];
                            if (front) {
                                this.indexArray[triIndex++] = a;
                                this.indexArray[triIndex++] = d;
                                this.indexArray[triIndex++] = c;
                            }
                            else {
                                this.indexArray[triIndex++] = a;
                                this.indexArray[triIndex++] = c;
                                this.indexArray[triIndex++] = d;
                            }
                        }
                        else if (j == 1) {
                            if (front) {
                                this.indexArray[triIndex++] = a;
                                this.indexArray[triIndex++] = c;
                                this.indexArray[triIndex++] = b;
                            }
                            else {
                                this.indexArray[triIndex++] = a;
                                this.indexArray[triIndex++] = b;
                                this.indexArray[triIndex++] = c;
                            }
                        }
                        else {
                            if (front) {
                                this.indexArray[triIndex++] = a;
                                this.indexArray[triIndex++] = d;
                                this.indexArray[triIndex++] = c;
                                this.indexArray[triIndex++] = a;
                                this.indexArray[triIndex++] = c;
                                this.indexArray[triIndex++] = b;
                            }
                            else {
                                this.indexArray[triIndex++] = a;
                                this.indexArray[triIndex++] = c;
                                this.indexArray[triIndex++] = d;
                                this.indexArray[triIndex++] = a;
                                this.indexArray[triIndex++] = b;
                                this.indexArray[triIndex++] = c;
                            }
                        }
                    }
                    index += skip;
                }
            }
            //var i: number, j: number;
            var stride = 17;
            var numUvs = (this._segmentsH + 1) * (this._segmentsW + 1) * stride;
            var data;
            var skip = stride - 2;
            var index = 13;
            for (j = 0; j <= this._segmentsH; ++j) {
                for (i = 0; i <= this._segmentsW; ++i) {
                    this.vertexArray[index++] = (i / this._segmentsW);
                    this.vertexArray[index++] = (j / this._segmentsH);
                    index += skip;
                }
            }
            var subGeometry = new egret3d.SubGeometry();
            subGeometry.geometry = this;
            subGeometry.start = 0;
            subGeometry.count = this.indexCount;
            this.subGeometrys.push(subGeometry);
        };
        return SphereGeometry;
    }(egret3d.Geometry));
    egret3d.SphereGeometry = SphereGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @class egret3d.OctahedronSphereGeometry
     * @classdesc
     * 六面体球形Geometry
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/CubeGeometry.ts
     */
    var OctahedronSphereGeometry = (function (_super) {
        __extends(OctahedronSphereGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @returns {number} 宽度
        * @version Egret 3.0
        * @platform Web,Native
        */
        function OctahedronSphereGeometry(subdivisions, radius, isHemisphere) {
            if (isHemisphere === void 0) { isHemisphere = false; }
            _super.call(this);
            this.vector3_Down = new egret3d.Vector3D(0, -1, 0);
            this.vector3_Forward = new egret3d.Vector3D(0, 0, 1);
            this.vector3_Up = new egret3d.Vector3D(0, 1, 0);
            this.directions = [
                //Vector3.left,
                new egret3d.Vector3D(-1, 0, 0),
                //Vector3.back,
                new egret3d.Vector3D(0, 0, -1),
                //Vector3.right
                new egret3d.Vector3D(1, 0, 0),
                //Vector3.forward
                new egret3d.Vector3D(0, 0, 1)
            ];
            if (subdivisions < 0) {
                subdivisions = 0;
                console.error("Sky Sphere subdivisions increased to minimum, which is 0.");
            }
            else if (subdivisions > 6) {
                subdivisions = 6;
                console.error("Sky Sphere subdivisions decreased to maximum, which is 6.");
            }
            this._subdivisions = subdivisions;
            this._radius = radius;
            this.buildGeomtry(false, isHemisphere);
        }
        OctahedronSphereGeometry.prototype.buildGeomtry = function (front, isHemisphere) {
            var vertexBuffer = [];
            var indexBuffer = [];
            var resolution = 1 << this._subdivisions;
            var vertices = [];
            var triangles = [];
            this.CreateOctahedron(vertices, triangles, resolution, isHemisphere);
            for (var i = 0; i < vertices.length; i++) {
                console.log(vertices[i]);
            }
            var normals = [];
            this.Normalize(vertices, normals, front);
            var uv = [];
            this.CreateUV(vertices, uv);
            //var tangents: Quaternion[] = [];
            //this.CreateTangents(vertices, tangents);
            if (this._radius != 1) {
                for (var i = 0; i < vertices.length; i++) {
                    vertices[i].x *= this._radius;
                    vertices[i].y *= this._radius;
                    vertices[i].z *= this._radius;
                    console.log(vertices[i].x + " " + vertices[i].y + " " + vertices[i].z);
                }
            }
            this.vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0;
            for (var i = 0; i < vertices.length; i++) {
                var pos = vertices[i];
                vertexBuffer.push(pos.x);
                vertexBuffer.push(pos.y);
                vertexBuffer.push(pos.z);
                var normal = normals[i];
                vertexBuffer.push(normal.x);
                vertexBuffer.push(normal.y);
                vertexBuffer.push(normal.z);
                ///color
                vertexBuffer.push(1, 1, 1, 1);
                var uv_0 = uv[i];
                vertexBuffer.push(uv_0.u);
                vertexBuffer.push(1 - uv_0.v);
            }
            indexBuffer = triangles;
            this.setVerticesForIndex(0, this.vertexFormat, vertexBuffer, vertexBuffer.length / this.vertexAttLength);
            this.setVertexIndices(0, indexBuffer);
            this.buildDefaultSubGeometry();
        };
        OctahedronSphereGeometry.prototype.CreateOctahedron = function (vertices, triangles, resolution, isHemisphere) {
            var v = 0, vBottom = 0, t = 0;
            if (isHemisphere == false) {
                for (var i = 0; i < 4; i++) {
                    vertices[v++] = this.vector3_Down.clone();
                }
                for (var i = 1; i <= resolution; i++) {
                    var progress = i / resolution;
                    var _from = new egret3d.Vector3D();
                    var _to = new egret3d.Vector3D();
                    _to.lerp(this.vector3_Down, this.vector3_Forward, progress);
                    vertices[v++] = _to;
                    for (var d = 0; d < 4; d++) {
                        _from = _to.clone();
                        _to.lerp(this.vector3_Down, this.directions[d], progress);
                        t = this.CreateLowerStrip(i, v, vBottom, t, triangles);
                        v = this.CreateVertexLine(_from, _to, i, v, vertices);
                        vBottom += i > 1 ? (i - 1) : 1;
                    }
                    vBottom = v - 1 - i * 4;
                }
            }
            for (var i = resolution - 1; i >= 1; i--) {
                var progress = i / resolution;
                var _from;
                var _to = new egret3d.Vector3D();
                _to.lerp(this.vector3_Up, this.vector3_Forward, progress);
                vertices[v++] = _to;
                for (var d = 0; d < 4; d++) {
                    _from = _to.clone();
                    _to.lerp(this.vector3_Up, this.directions[d], progress);
                    t = this.CreateUpperStrip(i, v, vBottom, t, triangles);
                    v = this.CreateVertexLine(_from, _to, i, v, vertices);
                    vBottom += i + 1;
                }
                vBottom = v - 1 - i * 4;
            }
            for (var i = 0; i < 4; i++) {
                triangles[t++] = vBottom;
                triangles[t++] = v;
                triangles[t++] = ++vBottom;
                vertices[v++] = this.vector3_Up.clone();
            }
            //triangles = triangles.reverse();
        };
        OctahedronSphereGeometry.prototype.CreateLowerStrip = function (steps, vTop, vBottom, t, triangles) {
            for (var i = 1; i < steps; i++) {
                triangles[t++] = vBottom;
                triangles[t++] = vTop - 1;
                triangles[t++] = vTop;
                triangles[t++] = vBottom++;
                triangles[t++] = vTop++;
                triangles[t++] = vBottom;
            }
            triangles[t++] = vBottom;
            triangles[t++] = vTop - 1;
            triangles[t++] = vTop;
            return t;
        };
        OctahedronSphereGeometry.prototype.CreateVertexLine = function (_from, _to, steps, v, vertices) {
            for (var i = 1; i <= steps; i++) {
                var vec = new egret3d.Vector3D();
                vec.lerp(_from, _to, i / steps);
                vertices[v++] = vec;
            }
            return v;
        };
        OctahedronSphereGeometry.prototype.CreateUpperStrip = function (steps, vTop, vBottom, t, triangles) {
            triangles[t++] = vBottom;
            triangles[t++] = vTop - 1;
            triangles[t++] = ++vBottom;
            for (var i = 1; i <= steps; i++) {
                triangles[t++] = vTop - 1;
                triangles[t++] = vTop;
                triangles[t++] = vBottom;
                triangles[t++] = vBottom;
                triangles[t++] = vTop++;
                triangles[t++] = ++vBottom;
            }
            return t;
        };
        OctahedronSphereGeometry.prototype.Normalize = function (vertices, normals, front) {
            for (var i = 0; i < vertices.length; i++) {
                var vec = vertices[i];
                vec.normalize();
                normals[i] = vec;
                vertices[i] = vec;
            }
        };
        OctahedronSphereGeometry.prototype.CreateUV = function (vertices, uv) {
            var previousX = 1.0;
            for (var i = 0; i < vertices.length; i++) {
                var v = vertices[i];
                if (v.x == previousX) {
                    uv[i - 1].u = 1.0;
                }
                previousX = v.x;
                var textureCoordinates = {
                    u: Math.atan2(v.x, v.z) / (-2.0 * Math.PI),
                    v: Math.asin(v.y) / Math.PI + 0.5
                };
                if (textureCoordinates.u < 0) {
                    textureCoordinates.u += 1.0;
                }
                textureCoordinates.v = Math.asin(v.y) / Math.PI + 0.5;
                uv[i] = textureCoordinates;
            }
            uv[vertices.length - 4].u = uv[0].u = 0.125;
            uv[vertices.length - 3].u = uv[1].u = 0.375;
            uv[vertices.length - 2].u = uv[2].u = 0.625;
            uv[vertices.length - 1].u = uv[3].u = 0.875;
        };
        OctahedronSphereGeometry.prototype.CreateTangents = function (vertices, tangents) {
            for (var i = 0; i < vertices.length; i++) {
                var v = vertices[i];
                v.y = 0;
                v.normalize();
                var tangent = new egret3d.Quaternion();
                tangent.x = -v.z;
                tangent.y = 0.0;
                tangent.z = v.x;
                tangent.w = -1.0;
                tangents[i] = tangent;
            }
            tangents[0] = new egret3d.Quaternion(-1, 0, -1);
            tangents[1] = new egret3d.Quaternion(1, 0, -1);
            tangents[2] = new egret3d.Quaternion(1, 0, 1);
            tangents[3] = new egret3d.Quaternion(-1, 0, 1);
            tangents[0].normalize();
            tangents[1].normalize();
            tangents[2].normalize();
            tangents[3].normalize();
            tangents[vertices.length - 4] = tangents[0];
            tangents[vertices.length - 3] = tangents[1];
            tangents[vertices.length - 2] = tangents[2];
            tangents[vertices.length - 1] = tangents[3];
            for (var i = 0; i < 4; i++) {
                tangents[vertices.length - 1 - i].w = tangents[i].w = -1;
            }
        };
        return OctahedronSphereGeometry;
    }(egret3d.Geometry));
    egret3d.OctahedronSphereGeometry = OctahedronSphereGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.GeometryUtil
    * @classdesc
    * 创建Geometry的功能类,
    * 可以创建引擎内部默认顶点数据类型的 Geometry
    * @see egret3d.Geometry
    * @version Egret 3.0
    * @platform Web,Native
    */
    var GeometryUtil = (function () {
        function GeometryUtil() {
        }
        /**
        * @language zh_CN
        * 创建一个Geometry对象，指定了顶点的数据结构，但是顶点数据需要额外填充
        * @param vertexFromat {VertexFormat} 顶点数据格式，默认参数为 VertexFormat.VF_POSITION | VertexFormat.VF_NORMAL | VertexFormat.VF_TANGENT | VertexFormat.VF_COLOR | VertexFormat.VF_UV0 | VertexFormat.VF_UV1
        * @default VertexFormat.VF_POSITION | VertexFormat.VF_NORMAL | VertexFormat.VF_TANGENT | VertexFormat.VF_COLOR | VertexFormat.VF_UV0 | VertexFormat.VF_UV1
        * @returns {Geometry} Geometry对象
        * @see egret3d.VertexFormat
        * @version Egret 3.0
        * @platform Web,Native
        */
        GeometryUtil.createGeometry = function (vertexFromat) {
            if (vertexFromat === void 0) { vertexFromat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_UV1; }
            var geo = new egret3d.Geometry();
            geo.vertexFormat = vertexFromat;
            return geo;
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        GeometryUtil.createGemetryForType = function (type, gemetry) {
            switch (type) {
                case "CubeGeometry":
                    return new egret3d.CubeGeometry(gemetry.width, gemetry.height, gemetry.depth);
                case "CylinderGeometry":
                    return new egret3d.CylinderGeometry(gemetry.height, gemetry.radius);
                case "ElevationGeometry":
                    return new egret3d.ElevationGeometry(gemetry.heightmap, gemetry.width, gemetry.height, gemetry.depth, gemetry.segmentsW, gemetry.segmentsH);
                case "PlaneGeometry":
                    return new egret3d.PlaneGeometry(gemetry.width, gemetry.height, gemetry.segmentsW, gemetry.segmentsH, gemetry.uScale, gemetry.vScale);
                case "SphereGeometry":
                    return new egret3d.SphereGeometry(gemetry.r, gemetry.segmentsW, gemetry.segmentsH);
            }
            return null;
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        GeometryUtil.fromVertexFormatToLength = function (vf) {
            var length = 0;
            if (vf & egret3d.VertexFormat.VF_POSITION) {
                length += egret3d.Geometry.positionSize;
            }
            if (vf & egret3d.VertexFormat.VF_NORMAL) {
                length += egret3d.Geometry.normalSize;
            }
            if (vf & egret3d.VertexFormat.VF_TANGENT) {
                length += egret3d.Geometry.tangentSize;
            }
            if (vf & egret3d.VertexFormat.VF_COLOR) {
                length += egret3d.Geometry.colorSize;
            }
            if (vf & egret3d.VertexFormat.VF_UV0) {
                length += egret3d.Geometry.uvSize;
            }
            if (vf & egret3d.VertexFormat.VF_UV1) {
                length += egret3d.Geometry.uv2Size;
            }
            if (vf & egret3d.VertexFormat.VF_SKIN) {
                length += egret3d.Geometry.skinSize;
            }
            if (vf & egret3d.VertexFormat.VF_QUAD_ORIGN) {
                length += egret3d.QuadData.originalSize;
            }
            if (vf & egret3d.VertexFormat.VF_QUAD_POS) {
                length += egret3d.QuadData.posOffest;
            }
            if (vf & egret3d.VertexFormat.VF_QUAD_UVREC) {
                length += egret3d.QuadData.uvRectangleSize;
            }
            if (vf & egret3d.VertexFormat.VF_QUAD_ROTATION) {
                length += egret3d.QuadData.rotationSize;
            }
            if (vf & egret3d.VertexFormat.VF_QUAD_MASK) {
                length += egret3d.QuadData.maskSize;
            }
            if (vf & egret3d.VertexFormat.VF_QUAD_COLOR) {
                length += egret3d.QuadData.colorSize;
            }
            return length;
        };
        return GeometryUtil;
    }());
    egret3d.GeometryUtil = GeometryUtil;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.ElevationGeometry
    * @classdesc
    * 使用高度图创建Geometry
    * 高度图的一个任意一个通道 算出0.0 - 1.0 值  然后乘以 height 就是当前顶点高度值
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample geometry/CubeGeometry.ts
    */
    var ElevationGeometry = (function (_super) {
        __extends(ElevationGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
       
        * @param heightmap {ImageTexture} 高度图
        * @param width {number} 地形宽度 默认1000
        * @param height {number} 地形主度 默认100
        * @param depth {number} 地形长度 默认1000
        * @param segmentsW {number} 格子列 默认30
        * @param segmentsH {number} 格子行 默认30
        * @param maxElevation {number} 高度最大值 默认255
        * @param minElevation {number} 高度最小值 默认0
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ElevationGeometry(heightmap, width, height, depth, segmentsW, segmentsH, maxElevation, minElevation) {
            if (width === void 0) { width = 1000; }
            if (height === void 0) { height = 100; }
            if (depth === void 0) { depth = 1000; }
            if (segmentsW === void 0) { segmentsW = 30; }
            if (segmentsH === void 0) { segmentsH = 30; }
            if (maxElevation === void 0) { maxElevation = 255; }
            if (minElevation === void 0) { minElevation = 0; }
            _super.call(this);
            this._width = 100;
            this._height = 100;
            this._segmentsW = 100;
            this._segmentsH = 100;
            this._depth = 100;
            this._minElevation = 100;
            this._maxElevation = 100;
            this._scaleU = 1;
            this._scaleV = 1;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._width = width;
            this._height = height;
            this._depth = depth;
            this._minElevation = minElevation;
            this._maxElevation = maxElevation;
            this._heightmap = heightmap;
            this._imageData = heightmap.readPixels(0, 0, heightmap.width, heightmap.height);
            this._positionXYZ = [];
            this.buildGeomtry(true);
        }
        Object.defineProperty(ElevationGeometry.prototype, "width", {
            /**
            * @language zh_CN
            * 得到宽度
            * @returns {ImageTexture} 宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ElevationGeometry.prototype, "height", {
            /**
            * @language zh_CN
            * 得到高度
            * @returns {ImageTexture} 高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ElevationGeometry.prototype, "depth", {
            /**
            * @language zh_CN
            * 得到深度
            * @returns {ImageTexture} 深度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._depth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ElevationGeometry.prototype, "heightmap", {
            /**
            * @language zh_CN
            * 得到高度图
            * @returns {ImageTexture} 高度图
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._heightmap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ElevationGeometry.prototype, "segmentsW", {
            /**
            * @language zh_CN
            * 得到格子列数
            * @returns {number} 格子列数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._segmentsW;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ElevationGeometry.prototype, "segmentsH", {
            /**
            * @language zh_CN
            * 得到格子行数
            * @returns {number} 格子行数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._segmentsH;
            },
            enumerable: true,
            configurable: true
        });
        /**
       * @private
       * @language zh_CN
       * 生成网格
       * @version Egret 3.0
       * @platform Web,Native
       */
        ElevationGeometry.prototype.buildGeomtry = function (front) {
            this.vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_UV1;
            var x, z;
            var numInds;
            var base;
            var tw = this._segmentsW + 1;
            var numVerts = (this._segmentsH + 1) * tw;
            var uDiv = (this._heightmap.width - 1) / this._segmentsW;
            var vDiv = (this._heightmap.height - 1) / this._segmentsH;
            var u, v;
            var y;
            this.vertexCount = numVerts;
            this.indexCount = this._segmentsH * this._segmentsW * 6;
            numVerts = 0;
            numInds = 0;
            var col;
            for (var zi = 0; zi <= this._segmentsH; ++zi) {
                for (var xi = 0; xi <= this._segmentsW; ++xi) {
                    x = (xi / this._segmentsW - 0.5) * this._width;
                    z = (zi / this._segmentsH - 0.5) * this._depth;
                    u = xi * uDiv;
                    v = (this._segmentsH - zi) * vDiv;
                    y = this.getHeightByPixel(u, v);
                    //pos
                    this.vertexArray[numVerts++] = x;
                    this.vertexArray[numVerts++] = y;
                    this.vertexArray[numVerts++] = z;
                    //normal
                    this.vertexArray[numVerts++] = 1.0;
                    this.vertexArray[numVerts++] = 1.0;
                    this.vertexArray[numVerts++] = 1.0;
                    //tan
                    this.vertexArray[numVerts++] = -1.0;
                    this.vertexArray[numVerts++] = 0.0;
                    this.vertexArray[numVerts++] = 0.0;
                    //color
                    this.vertexArray[numVerts++] = 1.0;
                    this.vertexArray[numVerts++] = 1.0;
                    this.vertexArray[numVerts++] = 1.0;
                    this.vertexArray[numVerts++] = 1.0;
                    //uv
                    this.vertexArray[numVerts++] = xi / this._segmentsW * this._scaleU;
                    this.vertexArray[numVerts++] = 1.0 - zi / this._segmentsH * this._scaleV;
                    this.vertexArray[numVerts++] = xi / this._segmentsW;
                    this.vertexArray[numVerts++] = 1.0 - zi / this._segmentsH;
                    if (xi != this._segmentsW && zi != this._segmentsH) {
                        base = xi + zi * tw;
                        this.indexArray[numInds++] = base;
                        this.indexArray[numInds++] = base + tw + 1;
                        this.indexArray[numInds++] = base + tw;
                        this.indexArray[numInds++] = base;
                        this.indexArray[numInds++] = base + 1;
                        this.indexArray[numInds++] = base + tw + 1;
                    }
                }
            }
            this.updateFaceNormals();
            this.buildDefaultSubGeometry();
        };
        /**
       * @language zh_CN
       * @private
       * 根据像素点获取高度
     
       * @param intX {number} 像素整形位置X
       * @param intZ {number} 像素整形位置Z
       * @returns {number} 指定位置的高度
       * @version Egret 3.0
       * @platform Web,Native
       */
        ElevationGeometry.prototype.getHeightByPixel = function (intX, intZ) {
            intX = Math.floor(intX);
            intZ = Math.floor(intZ);
            if (intX < 0) {
                intX = 0;
            }
            else if (intX >= this._imageData.width) {
                intX = this._imageData.width - 1;
            }
            if (intZ < 0) {
                intZ = 0;
            }
            else if (intZ > this._imageData.height) {
                intZ = this._imageData.height - 1;
            }
            var color = this.getPixelColor(intX, intZ) & 0xff;
            return (color > this._maxElevation) ? (this._maxElevation / 0xff) * this._height : ((color < this._minElevation) ? (this._minElevation / 0xff) * this._height : (color / 0xff) * this._height);
        };
        /**
        * @language zh_CN
        * @private
        * 获取像素点颜色
        * @param intX {number} 像素浮点位置X
        * @param intZ {number} 像素浮点位置Z
        * @returns {number} 颜色值
        * @version Egret 3.0
        * @platform Web,Native
        */
        ElevationGeometry.prototype.getPixelColor = function (intX, intZ) {
            var index = (intZ * this._heightmap.imageData.width + intX) * 4;
            var color = this._imageData.data[index + 3] << 24 | this._imageData.data[index + 0] << 16 | this._imageData.data[index + 1] << 8 | this._imageData.data[index + 2];
            return color;
        };
        /**
        * @language zh_CN
        * 根据像素浮点位置获取3D场景的位置(需要插值计算)
        * @param floatX {number} 像素浮点位置X
        * @param floatZ {number} 像素浮点位置Z
        * @param imageWidth {number} 所在图片的宽度
        * @param imageHeight {number} 所在图片的高度
        * @returns {Vector3D} 场景中的3D坐标
        * @version Egret 3.0
        * @platform Web,Native
        */
        ElevationGeometry.prototype.get3DCoordAtPixel = function (floatX, floatZ, imageWidth, imageHeight, target) {
            if (target === void 0) { target = null; }
            floatZ = imageHeight - floatZ;
            target = target || new egret3d.Vector3D();
            //换算成3d空间的xy位置
            floatX *= this._width / imageWidth;
            floatX -= this._width * 0.5;
            floatZ *= this._depth / imageHeight;
            floatZ -= this._depth * 0.5;
            target.setTo(floatX, 0, floatZ);
            target.y = this.getHeightBySceneCoord(floatX, floatZ);
            return target;
        };
        /**
        * @language zh_CN
        * 根据3D场景中的浮点位置X和Z获取高度Y
        * @param floatX {number} 像素浮点位置X
        * @param floatZ {number} 像素浮点位置Z
        * @return {number} 指定位置的高度
        * @version Egret 3.0
        * @platform Web,Native
        */
        ElevationGeometry.prototype.getHeightBySceneCoord = function (floatX, floatZ) {
            //得到所在网格的index
            floatX += this._width * 0.5;
            floatZ += this._depth * 0.5;
            if (floatX < 0 || floatZ < 0) {
                return 0;
            }
            if (floatX >= this._width || floatZ >= this._depth) {
                return 0;
            }
            //颠倒一下
            floatZ = this._depth - floatZ;
            floatX *= this._imageData.width / this._width;
            floatZ *= this._imageData.height / this._depth;
            var pixelX = Math.floor(floatX);
            var pixelY = Math.floor(floatZ);
            var y0 = this.getHeightByPixel(pixelX, pixelY);
            var y1 = this.getHeightByPixel(pixelX + 1, pixelY);
            var y2 = this.getHeightByPixel(pixelX, pixelY + 1);
            var y3 = this.getHeightByPixel(pixelX + 1, pixelY + 1);
            var tx = floatX - pixelX;
            var ty = floatZ - pixelY;
            y0 = egret3d.MathUtil.mix(y0, y1, tx);
            y1 = egret3d.MathUtil.mix(y2, y3, tx);
            y0 = egret3d.MathUtil.mix(y0, y1, ty);
            return y0;
        };
        ElevationGeometry.prototype.updateFaceNormals = function () {
            var i = 0, j = 0, k = 0;
            var index;
            var len = this.indexCount;
            var x1, x2, x3;
            var y1, y2, y3;
            var z1, z2, z3;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var d;
            var posStride = 17;
            var posOffset = 0;
            var faceNormals = [];
            while (i < len) {
                index = posOffset + this.indexArray[i + 0] * posStride;
                x1 = this.vertexArray[index];
                y1 = this.vertexArray[index + 1];
                z1 = this.vertexArray[index + 2];
                index = posOffset + this.indexArray[i + 1] * posStride;
                x2 = this.vertexArray[index];
                y2 = this.vertexArray[index + 1];
                z2 = this.vertexArray[index + 2];
                index = posOffset + this.indexArray[i + 2] * posStride;
                x3 = this.vertexArray[index];
                y3 = this.vertexArray[index + 1];
                z3 = this.vertexArray[index + 2];
                dx1 = x2 - x1;
                dy1 = y2 - y1;
                dz1 = z2 - z1;
                dx2 = x3 - x1;
                dy2 = y3 - y1;
                dz2 = z3 - z1;
                cx = dz1 * dy2 - dy1 * dz2;
                cy = dx1 * dz2 - dz1 * dx2;
                cz = dy1 * dx2 - dx1 * dy2;
                d = Math.sqrt(cx * cx + cy * cy + cz * cz);
                faceNormals[j++] = cz * d;
                faceNormals[j++] = cy * d;
                faceNormals[j++] = cx * d;
                i += 3;
            }
            i = 0;
            var f1 = 0, f2 = 1, f3 = 2;
            var normalStride = this.vertexAttLength;
            var normalOffset = 3;
            while (i < len) {
                index = normalOffset + this.indexArray[i++] * normalStride;
                this.vertexArray[index++] = faceNormals[f1];
                this.vertexArray[index++] = faceNormals[f2];
                this.vertexArray[index++] = faceNormals[f3];
                index = normalOffset + this.indexArray[i++] * normalStride;
                this.vertexArray[index++] = faceNormals[f1];
                this.vertexArray[index++] = faceNormals[f2];
                this.vertexArray[index++] = faceNormals[f3];
                index = normalOffset + this.indexArray[i++] * normalStride;
                this.vertexArray[index++] = faceNormals[f1];
                this.vertexArray[index++] = faceNormals[f2];
                this.vertexArray[index++] = faceNormals[f3];
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
        };
        return ElevationGeometry;
    }(egret3d.Geometry));
    egret3d.ElevationGeometry = ElevationGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Face = (function () {
        function Face() {
        }
        return Face;
    }());
    egret3d.Face = Face;
    var TerrainCollision = (function () {
        function TerrainCollision(mesh) {
            this.height = 0;
            this.selectFaces = [];
            this.mesh = mesh;
            this._offsetPos = new egret3d.Vector3D();
            this._offsetPos.copyFrom(mesh.globalPosition);
            this._geometry = mesh.geometry;
            this.buildFace();
        }
        TerrainCollision.prototype.buildFace = function () {
            var index1 = 0;
            var index2 = 0;
            var index3 = 0;
            var nodes = [];
            for (var i = 0; i < this._geometry.indexCount / 3; i++) {
                var face = new Face();
                face.v_0 = new egret3d.Vector3D();
                face.v_1 = new egret3d.Vector3D();
                face.v_2 = new egret3d.Vector3D();
                face.min = new egret3d.Vector3D();
                face.max = new egret3d.Vector3D();
                face.centre = new egret3d.Vector3D();
                index1 = this._geometry.indexArray[i * 3 + 0];
                index2 = this._geometry.indexArray[i * 3 + 1];
                index3 = this._geometry.indexArray[i * 3 + 2];
                face.v_0.x = this._offsetPos.x + this._geometry.vertexArray[index1 * this._geometry.vertexAttLength + 0];
                face.v_0.y = this._offsetPos.y + this._geometry.vertexArray[index1 * this._geometry.vertexAttLength + 1];
                face.v_0.z = this._offsetPos.z + this._geometry.vertexArray[index1 * this._geometry.vertexAttLength + 2];
                face.v_1.x = this._offsetPos.x + this._geometry.vertexArray[index2 * this._geometry.vertexAttLength + 0];
                face.v_1.y = this._offsetPos.y + this._geometry.vertexArray[index2 * this._geometry.vertexAttLength + 1];
                face.v_1.z = this._offsetPos.z + this._geometry.vertexArray[index2 * this._geometry.vertexAttLength + 2];
                face.v_2.x = this._offsetPos.x + this._geometry.vertexArray[index3 * this._geometry.vertexAttLength + 0];
                face.v_2.y = this._offsetPos.y + this._geometry.vertexArray[index3 * this._geometry.vertexAttLength + 1];
                face.v_2.z = this._offsetPos.z + this._geometry.vertexArray[index3 * this._geometry.vertexAttLength + 2];
                face.min.x = Math.min(face.v_0.x, face.v_1.x, face.v_2.x);
                face.min.y = Math.min(face.v_0.y, face.v_1.y, face.v_2.y);
                face.min.z = Math.min(face.v_0.z, face.v_1.z, face.v_2.z);
                face.max.x = Math.max(face.v_0.x, face.v_1.x, face.v_2.x);
                face.max.y = Math.max(face.v_0.y, face.v_1.y, face.v_2.y);
                face.max.z = Math.max(face.v_0.z, face.v_1.z, face.v_2.z);
                face.centre.x = face.min.x + (face.max.x - face.min.x) * 0.5;
                face.centre.y = face.min.y + (face.max.y - face.min.y) * 0.5;
                face.centre.z = face.min.z + (face.max.z - face.min.z) * 0.5;
                nodes.push(new egret3d.KDData([face.centre.x, face.centre.z, face.centre.y], face));
            }
            this._kdTree = new egret3d.KDTree();
            this._kdTree.buildTree(nodes);
        };
        TerrainCollision.prototype.getTerrainCollisionHeight = function (sceneX, sceneZ) {
            var list = this._kdTree.root.find([sceneX, sceneZ], 3);
            var face;
            this.selectFaces.length = 0;
            for (var i = 0; i < list.length; i++) {
                face = list[i]["datum"].data;
                this.selectFaces.push(face);
                if (this.checkPointInTriangle(sceneX, sceneZ, face)) {
                    return this.height = this.getHeightInTriangle(sceneX, sceneZ, face);
                }
            }
            return this.height;
        };
        TerrainCollision.prototype.checkPointInTriangle = function (x, y, face) {
            var p1 = face.v_0;
            var p2 = face.v_1;
            var p3 = face.v_2;
            // p1-p2
            var A1 = p1.z - p2.z;
            var B1 = p2.x - p1.x;
            var C1 = p1.x * p2.z - p2.x * p1.z;
            // p2-p3
            var A2 = p2.z - p3.z;
            var B2 = p3.x - p2.x;
            var C2 = p2.x * p3.z - p3.x * p2.z;
            // p3-p1
            var A3 = p3.z - p1.z;
            var B3 = p1.x - p3.x;
            var C3 = p3.x * p1.z - p1.x * p3.z;
            var isInTri = false;
            var D1 = A1 * x + B1 * y + C1;
            var D2 = A2 * x + B2 * y + C2;
            var D3 = A3 * x + B3 * y + C3;
            var Tiny = 0.01;
            if ((D1 >= -Tiny && D2 >= -Tiny && D3 >= -Tiny) || (D1 <= Tiny && D2 <= Tiny && D3 <= Tiny))
                isInTri = true;
            return isInTri;
        };
        TerrainCollision.prototype.getHeightInTriangle = function (x, y, face) {
            var p1 = face.v_0;
            var p2 = face.v_1;
            var p3 = face.v_2;
            // 计算(x,y)在三角面(p1,p2,p3)上的位置
            var tmp = egret3d.Vector3D.HELP_2;
            // p1.x >= p2.x >= x >= p3.x || p1.x <= p2.x <= x <= p3.x
            if (p1.x >= x) {
                if (p3.x >= x) {
                    tmp = p3;
                    p3 = p2;
                    p2 = tmp;
                }
                else {
                    if (p2.x >= x) {
                    }
                    else {
                        tmp = p3;
                        p3 = p1;
                        p1 = tmp;
                    }
                }
            }
            else if (p1.x < x) {
                if (p3.x < x) {
                    tmp = p3;
                    p3 = p2;
                    p2 = tmp;
                }
                else {
                    if (p2.x < x) {
                    }
                    else {
                        tmp = p3;
                        p3 = p1;
                        p1 = tmp;
                    }
                }
            }
            else
                return p1.y;
            var p4 = egret3d.Vector3D.HELP_0; // p4 in p1 p3
            var p5 = egret3d.Vector3D.HELP_1; // p4 in p2 p3
            p4.x = x;
            if ((p1.x - p3.x) == 0) {
                p4.y = p3.y;
                p4.z = p3.z;
            }
            else {
                p4.y = (p1.y - p3.y) * (x - p3.x) / (p1.x - p3.x) + p3.y;
                p4.z = (p1.z - p3.z) * (x - p3.x) / (p1.x - p3.x) + p3.z;
            }
            p5.x = x;
            if ((p2.x - p3.x) == 0) {
                p5.y = p3.y;
                p5.z = p3.z;
            }
            else {
                p5.y = (p2.y - p3.y) * (x - p3.x) / (p2.x - p3.x) + p3.y;
                p5.z = (p2.z - p3.z) * (x - p3.x) / (p2.x - p3.x) + p3.z;
            }
            var result;
            if (p4.z == p5.z)
                result = p5.y;
            else
                result = (p4.y - p5.y) * (y - p5.z) / (p4.z - p5.z) + p5.y;
            return result;
        };
        return TerrainCollision;
    }());
    egret3d.TerrainCollision = TerrainCollision;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Input
    * @classdesc
    * 触摸事件信息参数。
    * 作为触摸事件基本参数保存于TouchEvent3D，
    * @see egret3d.TouchEvent3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TouchData = (function () {
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        function TouchData(touch) {
            this.canvasX = Input.getX(touch.clientX); // - Input.canvas.x + Input.canvas.offsetX;
            this.canvasY = Input.getY(touch.clientY); // - Input.canvas.y + Input.canvas.offsetY;
            this.identifier = touch.identifier;
            this.clientX = touch.clientX;
            this.clientY = touch.clientY;
            this.pageX = touch.pageX;
            this.pageY = touch.pageY;
            this.screenX = touch.screenX;
            this.screenY = touch.screenY;
        }
        return TouchData;
    }());
    egret3d.TouchData = TouchData;
    /**
     * @language zh_CN
     * @class egret3d.Input
     * @classdesc
     * 处理输入设备,鼠标.键盘.触摸。
     * 当点事件产生时如果没有点击到任何的View3D内，
     * 当前事件将不用派发.
     * @includeExample input/Input.ts
     * @see egret3d.EventDispatcher
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Input = (function (_super) {
        __extends(Input, _super);
        /**
        * @language zh_CN
        * 创建一个新的 Input 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Input() {
            var _this = this;
            _super.call(this);
            this._time = 0;
            this._keyStatus = {};
            this._mouseStatus = {};
            this._isTouchStart = false;
            this._mouseEvent3d = new egret3d.MouseEvent3D();
            this._keyEvent3d = new egret3d.KeyEvent3D();
            this._touchEvent3d = new egret3d.TouchEvent3D();
            this._windowsEvent3d = new egret3d.Event3D();
            this._orientationEvent3d = new egret3d.OrientationEvent3D();
            /**
            * @language zh_CN
            * 游戏手柄Stick1事件侦听函数。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.onGamepadStick1 = null;
            /**
            * @language zh_CN
            * 游戏手柄Stick2事件侦听函数。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.onGamepadStick2 = null;
            this.disableWindowTouch = false;
            this._gp = false;
            this._oldPosition1 = null;
            this._oldPosition2 = null;
            window.addEventListener("click", function (e) { !_this.disableWindowTouch && _this.mouseClick(e); }, true);
            window.addEventListener("mousedown", function (e) { !_this.disableWindowTouch && _this.mouseStart(e); }, true);
            window.addEventListener("mouseup", function (e) { !_this.disableWindowTouch && _this.mouseEnd(e); }, true);
            window.addEventListener("mousewheel", function (e) { !_this.disableWindowTouch && _this.mouseWheel(e); }, true);
            window.addEventListener("mousemove", function (e) { !_this.disableWindowTouch && _this.mouseMove(e); }, true);
            window.addEventListener("mouseover", function (e) { !_this.disableWindowTouch && _this.mouseOver(e); }, true);
            window.addEventListener("keydown", function (e) { return _this.keyDown(e); }, true);
            window.addEventListener("keyup", function (e) { return _this.keyUp(e); }, true);
            if (this.canGame()) {
                window.addEventListener("gamepadconnected", function (e) { return _this.ongamepadconnected(e); }, true);
                window.addEventListener("gamepaddisconnected", function (e) { return _this.ongamepaddisconnected(e); }, true);
            }
            window.addEventListener("touchstart", function (e) { !_this.disableWindowTouch && _this.touchStart(e); }, true);
            window.addEventListener("touchend", function (e) { !_this.disableWindowTouch && _this.touchEnd(e); }, true);
            window.addEventListener("touchmove", function (e) { !_this.disableWindowTouch && _this.touchMove(e); }, true);
            window.addEventListener("touchcancel", function (e) { !_this.disableWindowTouch && _this.touchEnd(e); }, true);
            //window.addEventListener("deviceorientation", (e: DeviceOrientationEvent) => this.ondeviceorientation(e), true);
            //window.addEventListener("deviceorientation", (e: DeviceOrientationEvent) => this.ondeviceorientation(e), true);
            //window.addEventListener("devicemotion", (e: DeviceMotionEvent) => this.detectShake(e), true);
            //window.addEventListener("devicemotion", (e: DeviceMotionEvent) => this.detectShake(e), true);
            //window.addEventListener("resize", (e: UIEvent) => this.onWindowsResize(e));
            window.addEventListener("resize", function (e) { return _this.onWindowsResize(e); }, true);
            //window.addEventListener("orientationchange", (e: Event) => this.onOrientationChange(e), true);
            //window.addEventListener("devicemotion", (e: DeviceMotionEvent) => this.onDeviceMotion(e), true);
            //window.addEventListener("deviceorientation", (e: DeviceOrientationEvent) => this.onDeviceOrientation(e), true);
        }
        Input.getX = function (value) {
            return (value - Input.canvas.x + Input.canvas.offsetX) / Input.scaleX;
        };
        Input.getY = function (value) {
            return (value - Input.canvas.y + Input.canvas.offsetY) / Input.scaleY;
        };
        Object.defineProperty(Input, "instance", {
            /**
            * @language zh_CN
            * 获取Input类对象的单例。
            * @returns Input
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._instance == null) {
                    this._instance = new Input();
                }
                return this._instance;
            },
            enumerable: true,
            configurable: true
        });
        Input.prototype.init = function (canvas) {
            var _this = this;
            this.disableWindowTouch = true;
            // window.removeEventListener("click", (e: MouseEvent) => this.mouseClick(e), true);
            // window.removeEventListener("mousedown", (e: MouseEvent) => this.mouseStart(e), true);
            // window.removeEventListener("mouseup", (e: MouseEvent) => this.mouseEnd(e), true);
            // window.removeEventListener("mousewheel", (e: MouseWheelEvent) => this.mouseWheel(e), true);
            // window.removeEventListener("mousemove", (e: MouseEvent) => this.mouseMove(e), true);
            // window.removeEventListener("mouseover", (e: MouseEvent) => this.mouseOver(e), true);
            // window.removeEventListener("keydown", (e: KeyboardEvent) => this.keyDown(e), true);
            // window.removeEventListener("keyup", (e: KeyboardEvent) => this.keyUp(e), true);
            // window.removeEventListener("touchstart", (e: TouchEvent) => this.touchStart(e), true);
            // window.removeEventListener("touchend", (e: TouchEvent) => this.touchEnd(e), true);
            // window.removeEventListener("touchmove", (e: TouchEvent) => this.touchMove(e), true);
            // window.removeEventListener("touchcancel", (e: TouchEvent) => this.touchEnd(e), true);
            canvas.addEventListener("click", function (e) { return _this.mouseClick(e); }, false);
            canvas.addEventListener("mousedown", function (e) { return _this.mouseStart(e); }, false);
            canvas.addEventListener("mouseup", function (e) { return _this.mouseEnd(e); }, false);
            canvas.addEventListener("mousewheel", function (e) { return _this.mouseWheel(e); }, false);
            canvas.addEventListener("mousemove", function (e) { return _this.mouseMove(e); }, false);
            canvas.addEventListener("mouseover", function (e) { return _this.mouseOver(e); }, false);
            // canvas.addEventListener("keydown", (e: KeyboardEvent) => this.keyDown(e), false);
            // canvas.addEventListener("keyup", (e: KeyboardEvent) => this.keyUp(e), false);
            canvas.addEventListener("touchstart", function (e) { return _this.touchStart(e); }, false);
            canvas.addEventListener("touchend", function (e) { return _this.touchEnd(e); }, false);
            canvas.addEventListener("touchmove", function (e) { return _this.touchMove(e); }, false);
            canvas.addEventListener("touchcancel", function (e) { return _this.touchEnd(e); }, false);
        };
        /**
        * @language zh_CN
        * 对象注册事件侦听器对象，以使侦听器能够接收事件通知。可以为特定类型的事件和优先级注册事件侦听器。
        * 成功注册一个事件侦听器后，不使用后 需要removeEventListenerAt().
        * @param type {string} 事件的类型。
        * @param callback {Function} 处理事件的侦听器函数。此函数必须接受 Event3D 对象作为其唯一的参数，并且不能返回任何结果，
        * 如下面的示例所示： function(evt:Event3D):void 函数可以有任何名称。
        * @param param 事件携带参数
        * @param  priority {number} 事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在
        * 优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
        * @returns 事件ID 返回值 removeEventListenerAt 时会用到
         * @version Egret 3.0
         * @platform Web,Native
        */
        Input.addEventListener = function (type, callback, thisObject, param, priolity) {
            if (param === void 0) { param = null; }
            if (priolity === void 0) { priolity = 0; }
            return Input.instance.addEventListener(type, callback, thisObject, param, priolity);
        };
        Input.prototype.addEventListener = function (type, callback, thisObject, param, priority) {
            var _this = this;
            if (param === void 0) { param = null; }
            if (priority === void 0) { priority = 0; }
            if (type == egret3d.OrientationEvent3D.ORIENTATION_CHANGE && !this.containEventListener(egret3d.OrientationEvent3D.ORIENTATION_CHANGE)) {
                window.addEventListener("orientationchange", function (e) { return _this.onOrientationChange(e); }, true);
            }
            else if (type == egret3d.OrientationEvent3D.DEVICE_MOTION && !this.containEventListener(egret3d.OrientationEvent3D.DEVICE_MOTION)) {
                window.addEventListener("devicemotion", function (e) { return _this.onDeviceMotion(e); }, true);
            }
            else if (type == egret3d.OrientationEvent3D.DEVICE_ORIENTATION && !this.containEventListener(egret3d.OrientationEvent3D.DEVICE_ORIENTATION)) {
                window.addEventListener("deviceorientation", function (e) { return _this.onDeviceOrientation(e); }, true);
            }
            var id = _super.prototype.addEventListener.call(this, type, callback, thisObject, param, priority);
            return id;
        };
        /**
         * @language zh_CN
         * 根据addEventListener传入的事件数据信息,移除事件侦听器。
         * @param type {string} 事件名。
         * @param callback {Function} 侦听函数。
         * @version Egret 3.0
         * @platform Web,Native
         */
        Input.removeEventListener = function (type, callback, thisObject) {
            Input.instance.removeEventListener(type, callback, thisObject);
        };
        /**
         * @language zh_CN
         * 根据addEventListener 的返回值,移除事件侦听器。
         * @param id  事件id, addEventListener 的返回值.
         * @version Egret 3.0
         * @platform Web,Native
         */
        Input.removeEventListenerAt = function (id) {
            Input.instance.removeEventListenerAt(id);
        };
        /**
        * @private
        * @language zh_CN
        * 获取按键是否压下
        * @param code
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.getKeyPress = function (code) {
            return Input.instance._keyStatus[code];
        };
        /**
        * @private
        * @language zh_CN
        * 获取鼠标是否压下
        * @param code
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.getMousePress = function (code) {
            return Input.instance._mouseStatus[code];
        };
        Input.prototype.ongamepaddisconnected = function (e) {
            //Debug.instance.trace("Gamepad disconnected!");
            this._gp = false;
        };
        Input.prototype.ongamepadconnected = function (e) {
            //Debug.instance.trace("Gamepad connected!");
            this._gp = true;
        };
        /**
        * @language zh_CN
        * 游戏手柄按钮是否按下。
        * @version Egret 3.0
        * @platform Web,Native
        * @param index {number}
        * @returns {boolean}
        */
        Input.prototype.getGamepadButtonState = function (index) {
            return navigator.getGamepads()[0].buttons[index].pressed;
        };
        /**
        * @language zh_CN
        * 游戏手柄摇杆方向 Stick1 。
        * @version Egret 3.0
        * @platform Web,Native
        * @returns {Vector3D}
        */
        Input.prototype.getGamepadStick1 = function () {
            return new egret3d.Vector3D(navigator.getGamepads()[0].axes[0], navigator.getGamepads()[0].axes[1], 0);
        };
        /**
        * @language zh_CN
        * 游戏手柄摇杆方向 Stick2 。
        * @version Egret 3.0
        * @platform Web,Native
        * @returns {Vector3D}
        */
        Input.prototype.getGamepadStick2 = function () {
            return new egret3d.Vector3D(navigator.getGamepads()[0].axes[2], navigator.getGamepads()[0].axes[3], 0);
        };
        Input.prototype.canGame = function () {
            return "getGamepads" in navigator;
        };
        /**
        * @private
        * @language zh_CN
        * 更新游戏手柄信息。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.reportOnGamepad = function () {
            if (Input.instance.canGame() && Input.instance._gp) {
                if (Input.instance.onGamepadStick1 != null) {
                    Input.instance.onGamepadStick1(Input.instance.getGamepadStick1());
                }
                if (Input.instance.onGamepadStick2 != null) {
                    Input.instance.onGamepadStick2(Input.instance.getGamepadStick2());
                }
            }
        };
        Input.prototype.printout = function () {
            var html = "";
            html += "id: " + navigator.getGamepads()[0].id + "<br/>";
            var len = navigator.getGamepads()[0].buttons.length;
            for (var i = 0; i < len; i++) {
                html += "Button " + (i + 1) + ": ";
                if (this.getGamepadButtonState(i))
                    html += " pressed";
                html += "<br/>";
            }
            var v = this.getGamepadStick1();
            html += "Stick 1" + ": " + v.x + "," + v.y + "<br/>";
            v = this.getGamepadStick2();
            html += "Stick 2" + ": " + v.x + "," + v.y + "<br/>";
            //Debug.instance.trace(html);
        };
        //private detectShake(evt: DeviceMotionEvent) {
        //    var accl = evt.acceleration; //acceleration 排除重力影响的加速度  accelerationIncludingGravity(含重力的加速度)
        //    //x、y 和 z 轴方向加速
        //    if (accl.x > 1.5 || accl.y > 1.5 || accl.z > 1.5) {
        //    } else {
        //    }
        //    //if (this._ondevicemotion && this._ondevicemotion.length > 0) {
        //    //    var x: number = Math.ceil(accl.x * 1000) / 1000;
        //    //    var y: number = Math.ceil(accl.y * 1000) / 1000;
        //    //    var z: number = Math.ceil(accl.z * 1000) / 1000;
        //    //    this._ondevicemotion[0](x, y, z);
        //    //}
        //}
        //private _caheX: number;
        //private _caheY: number;
        //private _caheZ: number;
        //private _delayX: number;
        //private _delayY: number;
        //private _delayZ: number;
        //private _first: boolean = true;
        //private _initAngle: Vector3D = new Vector3D();
        //private ondeviceorientation(e: DeviceOrientationEvent) {
        //    //alpha rotation around the z-axis  between 0 and 360 degrees 
        //    //在围绕 z 轴旋转时（即左右旋转时），y 轴的度数差 0 到 360度 。
        //    //beta Rotation around the x-axis cause the beta angle to change. The range of beta is between -180 and 180 degrees 
        //    //在围绕 x 轴旋转时（即前后旋转时），z 轴的度数差 -180到180度。  
        //    //gamma The gamma angle is associated with the y-axis between -90 and 90 degrees 
        //    //在围绕 y 轴旋转时（即扭转设备时），z 轴的度数差 -90到90度。  
        //    //if (this._ondeviceorientation && this._ondeviceorientation.length > 0) {
        //    //    var alpha: number = Math.round(e.alpha * 100) * 0.01;
        //    //    var beta: number = Math.round(e.beta * 100) * 0.01;
        //    //    var gamma: number = Math.round(e.gamma * 100) * 0.01;
        //    //    if (this._first) {
        //    //        this._initAngle["x"] = alpha;
        //    //        this._initAngle["y"] = beta;
        //    //        this._initAngle["z"] = gamma;
        //    //    }
        //    //    this._delayX = alpha - this._caheX;
        //    //    this._delayY = beta - this._caheY;
        //    //    this._delayZ = gamma - this._caheZ;
        //    //    this._caheX = alpha;
        //    //    this._caheY = beta;
        //    //    this._caheZ = gamma;
        //    //    this._initAngle.x += this._delayX;
        //    //    this._initAngle.y += this._delayY;
        //    //    this._initAngle.z += this._delayZ;
        //    //    for (var i: number = 0; i < this._ondeviceorientation.length; i++) {
        //    //        this._ondeviceorientation[i].callback.call(this._ondeviceorientation[i].thisObject, this._initAngle);
        //    //    }
        //    //}
        //}
        Input.prototype.onPinch = function (x, y, x1, y1) {
            this._oldPosition1 = new egret3d.Point(x, y);
            this._oldPosition2 = new egret3d.Point(x1, y1);
        };
        Input.prototype.onSwipe = function (x, y) {
            Input.mouseX = x;
            Input.mouseY = y;
            this._oldPosition1 = null;
            this._oldPosition2 = null;
            this._time = new Date().getTime();
        };
        Input.prototype.touchStart = function (e) {
            if (!this.deliverMessage()) {
                return;
            }
            //e.preventDefault();
            var x1 = Input.getX(e.targetTouches[0].clientX); // - Input.canvas.x + Input.canvas.offsetX;
            var y1 = Input.getY(e.targetTouches[0].clientY); // - Input.canvas.y + Input.canvas.offsetY;
            if (e.targetTouches.length == 2) {
                var x2 = Input.getX(e.targetTouches[1].clientX); // - Input.canvas.x + Input.canvas.offsetX;
                var y2 = Input.getY(e.targetTouches[1].clientY); // - Input.canvas.y + Input.canvas.offsetY;
                this.onPinch(x1, y1, x2, y2);
            }
            else if (e.targetTouches.length == 1) {
                this.onSwipe(x1, y1);
                this._mouseStatus[egret3d.MouseCode.Mouse_Left] = true;
            }
            this._touchEvent3d.reset();
            this._touchEvent3d.targetTouches = this.GetTargetTouches(e.targetTouches);
            this._touchEvent3d.target = this;
            if (!this._isTouchStart) {
                this._isTouchStart = true;
                this._touchEvent3d.eventType = egret3d.TouchEvent3D.TOUCH_START;
                this.dispatchEvent(this._touchEvent3d);
            }
        };
        Input.prototype.touchEnd = function (e) {
            if (e.targetTouches.length > 1) {
                var x = Input.getX(e.targetTouches[0].clientX); // - Input.canvas.x + Input.canvas.offsetX;
                var y = Input.getY(e.targetTouches[0].clientY); // - Input.canvas.y + Input.canvas.offsetY;
                var x1 = Input.getX(e.targetTouches[1].clientX); // - Input.canvas.x + Input.canvas.offsetX;
                var y1 = Input.getY(e.targetTouches[1].clientY); // - Input.canvas.y + Input.canvas.offsetY;
                this.onPinch(x, y, x1, y1);
            }
            else if (e.targetTouches.length == 1) {
                this.onSwipe(Input.getX(e.targetTouches[0].clientX), Input.getY(e.targetTouches[0].clientY));
                this._mouseStatus[egret3d.MouseCode.Mouse_Left] = false;
            }
            else {
                this._oldPosition1 = null;
                this._oldPosition2 = null;
                this._time = 0;
            }
            this._touchEvent3d.reset();
            this._isTouchStart = false;
            this._touchEvent3d.targetTouches = this.GetTargetTouches(e.targetTouches);
            this._touchEvent3d.target = this;
            this._touchEvent3d.eventType = egret3d.TouchEvent3D.TOUCH_END;
            this.dispatchEvent(this._touchEvent3d);
        };
        Input.prototype.touchMove = function (e) {
            Input.mouseLastX = Input.mouseX;
            Input.mouseLastY = Input.mouseY;
            Input.mouseX = Input.getX(e.targetTouches[0].clientX); // - Input.canvas.x + Input.canvas.offsetX;
            Input.mouseY = Input.getY(e.targetTouches[0].clientY); // - Input.canvas.y + Input.canvas.offsetY;
            Input.mouseOffsetX = Input.mouseX - Input.mouseLastX;
            Input.mouseOffsetY = Input.mouseY - Input.mouseLastY;
            e.preventDefault();
            if (e.targetTouches.length > 1) {
                var newPosition1 = new egret3d.Point(Input.mouseX, Input.mouseY);
                var newPosition2 = new egret3d.Point(Input.getX(e.targetTouches[1].clientX), Input.getY(e.targetTouches[1].clientY));
                if (this._oldPosition1 == null)
                    this._oldPosition1 = newPosition1;
                if (this._oldPosition2 == null)
                    this._oldPosition2 = newPosition2;
                if (this.isEnlarge(this._oldPosition1, this._oldPosition2, newPosition1, newPosition2))
                    Input.wheelDelta = 120;
                else
                    Input.wheelDelta = -120;
                this._oldPosition1 = newPosition1;
                this._oldPosition2 = newPosition2;
            }
            else {
            }
            this._touchEvent3d.reset();
            this._touchEvent3d.targetTouches = this.GetTargetTouches(e.targetTouches);
            this._touchEvent3d.target = this;
            this._touchEvent3d.eventType = egret3d.TouchEvent3D.TOUCH_MOVE;
            this.dispatchEvent(this._touchEvent3d);
        };
        Input.prototype.GetTargetTouches = function (targetTouches) {
            var array = new Array();
            for (var i = 0; i < targetTouches.length; i++) {
                var touchData = new TouchData(targetTouches[i]);
                array.push(touchData);
            }
            return array;
        };
        Input.prototype.mouseClick = function (e) {
            if (!this.deliverMessage()) {
                return;
            }
            this._mouseEvent3d.reset();
            this._mouseEvent3d.mouseCode = e.button;
            this._mouseEvent3d.target = this;
            this._mouseEvent3d.eventType = egret3d.MouseEvent3D.MOUSE_CLICK;
            this.dispatchEvent(this._mouseEvent3d);
        };
        Input.prototype.mouseEnd = function (e) {
            this._mouseEvent3d.reset();
            this._mouseEvent3d.mouseCode = e.button;
            this._mouseEvent3d.target = this;
            this._mouseStatus[this._mouseEvent3d.mouseCode] = false;
            this._mouseEvent3d.eventType = egret3d.MouseEvent3D.MOUSE_UP;
            this.dispatchEvent(this._mouseEvent3d);
        };
        Input.prototype.deliverMessage = function () {
            var view3ds = Input.canvas.view3Ds;
            for (var i = 0; i < view3ds.length; ++i) {
                if (view3ds[i].inView3D(Input.mouseX, Input.mouseY)) {
                    return true;
                }
            }
            return false;
        };
        Input.prototype.mouseStart = function (e) {
            if (!this.deliverMessage()) {
                return;
            }
            this._mouseEvent3d.reset();
            this._mouseEvent3d.mouseCode = e.button;
            this._mouseEvent3d.target = this;
            if (!this._mouseStatus[this._mouseEvent3d.mouseCode]) {
                this._mouseStatus[this._mouseEvent3d.mouseCode] = true;
                this._mouseEvent3d.eventType = egret3d.MouseEvent3D.MOUSE_DOWN;
                this.dispatchEvent(this._mouseEvent3d);
            }
        };
        Input.prototype.mouseMove = function (e) {
            Input.mouseLastX = Input.mouseX;
            Input.mouseLastY = Input.mouseY;
            Input.mouseX = Input.getX(e.clientX); // - Input.canvas.x + Input.canvas.offsetX;
            Input.mouseY = Input.getY(e.clientY); // - Input.canvas.y + Input.canvas.offsetY;
            Input.mouseOffsetX = Input.mouseX - Input.mouseLastX;
            Input.mouseOffsetY = Input.mouseY - Input.mouseLastY;
            this._mouseEvent3d.reset();
            this._mouseEvent3d.target = this;
            this._mouseEvent3d.eventType = egret3d.MouseEvent3D.MOUSE_MOVE;
            this.dispatchEvent(this._mouseEvent3d);
        };
        Input.prototype.mouseOver = function (e) {
            this._mouseEvent3d.reset();
            this._mouseEvent3d.target = this;
            this._mouseEvent3d.eventType = egret3d.MouseEvent3D.MOUSE_OVER;
            this.dispatchEvent(this._mouseEvent3d);
        };
        Input.prototype.mouseWheel = function (e) {
            Input.wheelDelta = e.wheelDelta;
            this._mouseEvent3d.reset();
            this._mouseEvent3d.target = this;
            this._mouseEvent3d.eventType = egret3d.MouseEvent3D.MOUSE_WHEEL;
            this.dispatchEvent(this._mouseEvent3d);
        };
        Input.prototype.keyDown = function (e) {
            this._keyEvent3d.reset();
            this._keyEvent3d.keyCode = e.keyCode;
            this._keyEvent3d.target = this;
            if (!this._keyStatus[e.keyCode]) {
                this._keyStatus[e.keyCode] = true;
                //this._keyEvent3d.eventType = KeyEvent3D.KEY_CLICK;
                //this.dispatchEvent(this._keyEvent3d);
                this._keyEvent3d.eventType = egret3d.KeyEvent3D.KEY_DOWN;
                this.dispatchEvent(this._keyEvent3d);
            }
        };
        Input.prototype.keyUp = function (e) {
            this._keyEvent3d.reset();
            this._keyEvent3d.keyCode = e.keyCode;
            this._keyEvent3d.target = this;
            //if (this._keyStatus[e.keyCode]) {
            //    this._keyEvent3d.eventType = KeyEvent3D.KEY_CLICK;
            //    this.dispatchEvent(this._keyEvent3d);
            //}
            this._keyStatus[e.keyCode] = false;
            this._keyEvent3d.eventType = egret3d.KeyEvent3D.KEY_UP;
            this.dispatchEvent(this._keyEvent3d);
        };
        Input.prototype.onWindowsResize = function (e) {
            this._windowsEvent3d.target = this;
            this._windowsEvent3d.eventType = egret3d.Event3D.RESIZE;
            this.dispatchEvent(this._windowsEvent3d);
        };
        Input.prototype.onOrientationChange = function (e) {
            this._orientationEvent3d.target = this;
            this._orientationEvent3d.eventType = egret3d.OrientationEvent3D.ORIENTATION_CHANGE;
            this.dispatchEvent(this._orientationEvent3d);
        };
        Input.prototype.onDeviceMotion = function (e) {
            this._orientationEvent3d.target = this;
            this._orientationEvent3d.eventType = egret3d.OrientationEvent3D.DEVICE_MOTION;
            this._orientationEvent3d.acceleration = e.acceleration;
            this._orientationEvent3d.accelerationIncludingGravity = e.accelerationIncludingGravity;
            this._orientationEvent3d.rotationRate = e.rotationRate;
            this.dispatchEvent(this._orientationEvent3d);
        };
        Input.prototype.onDeviceOrientation = function (e) {
            this._orientationEvent3d.target = this;
            this._orientationEvent3d.eventType = egret3d.OrientationEvent3D.DEVICE_ORIENTATION;
            this._orientationEvent3d.absolute = e.absolute;
            this._orientationEvent3d.alpha = e.alpha;
            this._orientationEvent3d.beta = e.beta;
            this._orientationEvent3d.gamma = e.gamma;
            this.dispatchEvent(this._orientationEvent3d);
        };
        //返回角度
        Input.prototype.GetSlideAngle = function (dx, dy) {
            return Math.atan2(dy, dx) * 180 / Math.PI;
        };
        /**
        * @language zh_CN
        * 根据起点和终点返回方向
        * @param  startX {Number} 起点X坐标
        * @param  startY {Number} 起点Y坐标
        * @param  endX   {Number} 终点X坐标
        * @param  endY   {Number} 终点Y坐标
        * @returns result {number} 1：向上，2：向下，3：向左，4：向右,0：未滑动
        */
        Input.prototype.GetSlideDirection = function (startX, startY, endX, endY) {
            var dy = startY - endY;
            var dx = endX - startX;
            var result = 0;
            //如果滑动距离太短
            if (Math.abs(dx) < 2 && Math.abs(dy) < 2) {
                return result;
            }
            var angle = this.GetSlideAngle(dx, dy);
            if (angle >= -45 && angle < 45) {
                result = 4;
            }
            else if (angle >= 45 && angle < 135) {
                result = 1;
            }
            else if (angle >= -135 && angle < -45) {
                result = 2;
            }
            else if ((angle >= 135 && angle <= 180) || (angle >= -180 && angle < -135)) {
                result = 3;
            }
            return result;
        };
        Input.prototype.isEnlarge = function (op1, op2, np1, np2) {
            //函数传入上一次触摸两点的位置与本次触摸两点的位置计算出用户的手势
            var leng1 = Math.sqrt((op1.x - op2.x) * (op1.x - op2.x) + (op1.y - op2.y) * (op1.y - op2.y));
            var leng2 = Math.sqrt((np1.x - np2.x) * (np1.x - np2.x) + (np1.y - np2.y) * (np1.y - np2.y));
            if (leng1 < leng2) {
                //放大手势
                return true;
            }
            else {
                //缩小手势
                return false;
            }
        };
        Input.scaleX = 1;
        Input.scaleY = 1;
        /**
        * @language zh_CN
        * 当前鼠标X坐标。
        * 基于 Egret3DCanvas 的x坐标
        * @see egret3d.Egret3DCanvas
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.mouseX = 0;
        /**
        * @language zh_CN
        * 当前鼠标Y坐标。
        * 基于 Egret3DCanvas 的y坐标
        * @see egret3d.Egret3DCanvas
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.mouseY = 0;
        /**
        * @language zh_CN
        * 鼠标滚轮增量值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.wheelDelta = 0;
        /**
        * @language zh_CN
        * 鼠标X坐标的偏移值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.mouseOffsetX = 0;
        /**
        * @language zh_CN
        * 鼠标Y坐标的偏移值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.mouseOffsetY = 0;
        /**
        * @language zh_CN
        * 上一次鼠标X坐标。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.mouseLastX = 0;
        /**
        * @language zh_CN
        * 上一次鼠标Y坐标。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.mouseLastY = 0;
        Input._instance = null;
        return Input;
    }(egret3d.EventDispatcher));
    egret3d.Input = Input;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3D.OrientationControler
    * @classdesc
    * 陀螺仪控制器
    * 当前控制器使用后直接控制 view3D.camera3D 的本地旋转
    * @see egret3d.View3D
    * @see egret3d.Camera3D
    * @includeExample input/OrientationControler.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var OrientationController = (function () {
        /**
        * @language zh_CN
        * 构造函数，构建一个陀螺仪控制器
        * @version Egret 3.0
        * @platform Web,Native
        */
        function OrientationController() {
            this.orientation = new egret3d.Vector3D();
            this.screenOrientation = 0;
            this.openDebug = false;
            /**
            * @language zh_CN
            * 偏移旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.offsetRotation = new egret3d.Vector3D();
            /**
            * @private
            * @language zh_CN
            * 陀螺仪当前旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.fixOritation = new egret3d.Vector3D();
            this.state = -1;
            this.degtorad = Math.PI / 180; // Degree-to-Radian conversion
            this.q = new egret3d.Quaternion();
            this.q1 = new egret3d.Quaternion();
            this.outQ = new egret3d.Quaternion();
            this.fix = new egret3d.Vector3D();
            this.fixinterpolate = new egret3d.Vector3D();
            this.fixAxis = new egret3d.Vector3D();
            this.caheFixAxis = new egret3d.Vector3D();
            this.steps = 3.001;
            this.interpolate = true;
            if (this.openDebug) {
                this.accDiv = document.createElement("div");
                this.accGravityDiv = document.createElement("div");
                this.rotationRateDiv = document.createElement("div");
                this.orientationRateDiv = document.createElement("div");
                this.stateDiv = document.createElement("div");
                this.accDiv.style.color = "red";
                this.accGravityDiv.style.color = "red";
                this.rotationRateDiv.style.color = "red";
                this.orientationRateDiv.style.color = "red";
                this.stateDiv.style.color = "red";
                this.stateDiv.style.fontSize = "52";
                document.body.appendChild(this.accDiv);
                document.body.appendChild(this.accGravityDiv);
                document.body.appendChild(this.rotationRateDiv);
                document.body.appendChild(this.orientationRateDiv);
                document.body.appendChild(this.stateDiv);
            }
        }
        /**
        * @language zh_CN
        * 开始陀螺仪控制
        * @version Egret 3.0
        * @platform Web,Native
        */
        OrientationController.prototype.start = function () {
            var _this = this;
            this.orientationchangeHandler();
            window.addEventListener("orientationchange", function () { return _this.orientationchangeHandler(); });
            window.addEventListener("devicemotion", function (e) { return _this.motionHandler(e); });
            window.addEventListener("deviceorientation", function (e) { return _this.orientationHandler(e); });
        };
        /**
        * @language zh_CN
        * 释放陀螺仪控制
        * @version Egret 3.0
        * @platform Web,Native
        */
        OrientationController.prototype.stop = function () {
            var _this = this;
            window.removeEventListener("orientationchange", function () { return _this.orientationchangeHandler(); });
            window.removeEventListener("devicemotion", function (e) { return _this.motionHandler(e); });
            window.removeEventListener("deviceorientation", function (e) { return _this.orientationHandler(e); });
        };
        /**
        * @language zh_CN
        */
        OrientationController.prototype.orientationchangeHandler = function () {
            if (window.orientation != undefined)
                this.screenOrientation = window.orientation;
            //.this.state = window.orientation;
        };
        /**
        * @language zh_CN
        *
        * @param event
        */
        OrientationController.prototype.motionHandler = function (event) {
            this.acc = event.acceleration;
            this.accGravity = event.accelerationIncludingGravity;
            this.rotationRate = event.rotationRate;
        };
        /**
        * @language zh_CN
        *
        * @param event
        * @returns
        */
        OrientationController.prototype.orientationHandler = function (event) {
            this.orientation.x = event.alpha;
            this.orientation.y = event.beta;
            this.orientation.z = event.gamma;
            if (this.openDebug)
                this.debug();
        };
        OrientationController.prototype.debug = function () {
            //this.accDiv.innerHTML = "<br><br><br> acc-x:" + this.acc.x + "<br>acc-y:" + this.acc.y + "<br>acc-z:" + this.acc.z ;
            this.accGravityDiv.innerHTML = "<br><br> Gravity-x:" + this.orientation.x * egret3d.MathUtil.RADIANS_TO_DEGREES + "<br>Gravity-y:" + this.orientation.y + "<br>Gravity-z:" + this.orientation.z;
            //this.rotationRateDiv.innerHTML = "<br> Rate-x:" + this.rotationRate.alpha + "<br>Rate-y:" + this.rotationRate.gamma + "<br>Rate-z:" + this.rotationRate.beta;
            this.orientationRateDiv.innerHTML = "<br> orientation-x:" + this.fixOritation.x + "<br>orientation-y:" + this.fixOritation.y + "<br>orientation-z:" + this.fixOritation.z;
            //this.orientationRateDiv.innerHTML = "<br> orientation-x:" + this.fixOritation.x * MathUtil.RADIANS_TO_DEGREES + "<br>orientation-y:" + this.fixOritation.y * MathUtil.RADIANS_TO_DEGREES + "<br>orientation-z:" + this.fixOritation.z * MathUtil.RADIANS_TO_DEGREES;
            this.stateDiv.innerHTML = "<br> state: " + this.state;
        };
        /**
        * @private
        * @language zh_CN
        *
        * @returns number
        * @version Egret 3.0
        * @platform Web,Native
        */
        OrientationController.prototype.getOrientation = function () {
            switch (window.screen.msOrientation) {
                case 'landscape-primary':
                    return -90;
                case 'landscape-secondary':
                    return 90;
                case 'portrait-secondary':
                    return 180;
                case 'portrait-primary':
                    return 0;
            }
            // this returns 90 if width is greater then height 
            // and window orientation is undefined OR 0
            // if (!window.orientation && window.innerWidth > window.innerHeight)
            //   return 90;
            return 270;
        };
        /**
        * @private
        * @language zh_CN
        * 由陀螺仪的角度值计算出旋转四元数
        * @param alpha
        * @param beta
        * @param gamma
        * @returns 旋转四元数
        * @version Egret 3.0
        * @platform Web,Native
        */
        OrientationController.prototype.getQuaternion = function (alpha, beta, gamma) {
            var _x = beta ? beta * this.degtorad : 0; // beta value
            var _y = gamma ? gamma * this.degtorad : 0; // gamma value
            var _z = alpha ? alpha * this.degtorad : 0; // alpha value
            _x = Math.floor(_x * 100) / 100;
            _y = Math.floor(_y * 100) / 100;
            var orient = -this.getOrientation() * this.degtorad; // this.getOrientation()) * this.degtorad ; // O
            this.state = this.getOrientation();
            var cX = Math.cos(_x / 2);
            var cY = Math.cos(_y / 2);
            var cZ = Math.cos(_z / 2);
            var sX = Math.sin(_x / 2);
            var sY = Math.sin(_y / 2);
            var sZ = Math.sin(_z / 2);
            //this.q1.fromAxisAngle(Vector3D.Y_AXIS, alpha * this.degtorad);
            //
            // ZXY quaternion construction.
            //
            this.q.w = cX * cY * cZ - sX * sY * sZ;
            this.q.x = sX * cY * cZ - cX * sY * sZ;
            this.q.y = cX * sY * cZ + sX * cY * sZ;
            this.q.z = cX * cY * sZ + sX * sY * cZ;
            var zee = new egret3d.Vector3D(0, 0, 1);
            var q0 = new egret3d.Quaternion();
            q0.fromAxisAngle(zee, orient);
            this.q.multiply(this.q, q0); // camera looks out the back of the device, not the top
            zee.setTo(-1, 0, 0);
            q0.fromAxisAngle(zee, 90 * this.degtorad);
            this.q.multiply(this.q, q0);
            return this.q;
        };
        /**
        * @language zh_CN
        * 数据更新
        * 陀螺仪会直接控制view3D.camera3D的旋转
        * @param view3D 当前控制view3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        OrientationController.prototype.update = function (view3D) {
            this.getBaseQuaternion(this.orientation.x, this.orientation.y, this.orientation.z);
            this.q.toEulerAngles(this.fixOritation);
            if (this.interpolate) {
                this.fixinterpolate.x = (this.fixOritation.x - this.fix.x);
                this.fixinterpolate.y = (this.fixOritation.y - this.fix.y);
                this.fixinterpolate.z = (this.fixOritation.z - this.fix.z);
                this.caheFixAxis.x = this.fixOritation.x / Math.abs(this.fixOritation.x);
                this.caheFixAxis.y = this.fixOritation.y / Math.abs(this.fixOritation.y);
                this.caheFixAxis.z = this.fixOritation.z / Math.abs(this.fixOritation.z);
                if (Math.abs(this.fixinterpolate.x) > 150 || Math.abs(this.fixinterpolate.y) > 150 || Math.abs(this.fixinterpolate.z) > 150) {
                    this.fix.x = this.fixOritation.x;
                    this.fix.y = this.fixOritation.y;
                    this.fix.z = this.fixOritation.z;
                }
                else {
                    this.fix.x += this.fixinterpolate.x / (this.steps);
                    this.fix.y += this.fixinterpolate.y / (this.steps);
                    this.fix.z += this.fixinterpolate.z / (this.steps);
                }
                view3D.camera3D.rotationX = -this.fix.x;
                view3D.camera3D.rotationY = -this.fix.y;
                view3D.camera3D.rotationZ = this.fix.z;
            }
            else {
                view3D.camera3D.rotationX = -this.fixOritation.x;
                view3D.camera3D.rotationY = -this.fixOritation.y;
                view3D.camera3D.rotationZ = this.fixOritation.z;
            }
            //view3D.scene.rotationX = -90;
        };
        OrientationController.prototype.getBaseQuaternion = function (alpha, beta, gamma) {
            var _x = beta ? beta * this.degtorad : 0; // beta value
            var _y = gamma ? gamma * this.degtorad : 0; // gamma value
            var _z = alpha ? alpha * this.degtorad : 0; // alpha value
            var cX = Math.cos(_x / 2);
            var cY = Math.cos(_y / 2);
            var cZ = Math.cos(_z / 2);
            var sX = Math.sin(_x / 2);
            var sY = Math.sin(_y / 2);
            var sZ = Math.sin(_z / 2);
            //
            // ZXY quaternion construction.
            //
            var w = cX * cY * cZ - sX * sY * sZ;
            var x = sX * cY * cZ - cX * sY * sZ;
            var y = cX * sY * cZ + sX * cY * sZ;
            var z = cX * cY * sZ + sX * sY * cZ;
            this.q.w = w;
            this.q.x = x;
            this.q.y = y;
            this.q.z = z;
            //var orient = -this.getOrientation() * this.degtorad;// this.getOrientation()) * this.degtorad ; // O
            //this.state = this.getOrientation();
            //var zee: Vector3D = new Vector3D(0, 0, 1);
            //var q0: Quaternion = new Quaternion();
            //q0.fromAxisAngle(Vector3D.X_AXIS, 270 * this.degtorad);
            //this.q.multiply(this.q, q0);                                      // camera looks out the back of the device, not the top
            //zee.setTo(-1, 0, 0);
            //q0.fromAxisAngle(zee, 90 * this.degtorad);
            //this.q.multiply(this.q, q0);
            return this.q;
        };
        return OrientationController;
    }());
    egret3d.OrientationController = OrientationController;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ILoader
    * @classdesc
    * 加载器基类,
    * 加载完成后会返回相应的数据对象
    * @see egret3d.EventDispatcher
    *
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ILoader = (function (_super) {
        __extends(ILoader, _super);
        /**
        * @language zh_CN
        * 构造
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ILoader() {
            _super.call(this);
            /**
            * @language zh_CN
            * 加载的地址
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.url = "";
            /**
            * @language zh_CN
            * 控制以哪种方式接收加载的数据.
            * 如果未赋值则通过加载文件的后缀名来判断加载的类型以解析.
            * 如果未赋值且加载的类型并非为内置支持的文件类型.将以文本格式进行加载
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._dataformat = null;
            /**
            * @language zh_CN
            * 加载完成后的数据。</p>
            * 加载完成之后对应的数据类型。</p>
            * *.text|*.txt|*.xml|*.json 文本类型          ----- <string>转换 </p>
            * *MapConfig.json 加载的 由unity3d插件导出文件 ----- <Object3D>  根据导出类型 Scene3D Role EffectGroup </p>
            * *.png|*.jpg                                 ----- <ImageTexture>转换 </p>
            * *.dds|*.hdr|*.tga                           ----- <Texture>转换 </p>
            * *.esm                                       ----- <Geometry>转换 </p>
            * *.eam                                       ----- <SkeletonAnimationClip>转换 </p>
            * *.epa                                       ----- <PropertyAnim>转换 </p>
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.data = null;
            /**
            * @language zh_CN
            * 任务总数
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.taskTotal = 0;
            /**
            * @language zh_CN
            * 当前完成的任务个数
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.taskCurrent = 0;
            /**
            * @language zh_CN
            * 当前进度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.currentProgress = 0;
            /**
            * @language zh_CN
            * 当前加载资源的名字
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.resourceName = "";
        }
        Object.defineProperty(ILoader.prototype, "dataformat", {
            /**
             * @language zh_CN
             * 控制以哪种方式接收加载的数据.
             * 如果未赋值则通过加载文件的后缀名来判断加载的类型以解析.
             * 如果未赋值且加载的类型并非为内置支持的文件类型.将以文本格式进行加载
             * @returns string
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._dataformat;
            },
            /**
             * @language zh_CN
             * 控制以哪种方式接收加载的数据.
             * 如果未赋值则通过加载文件的后缀名来判断加载的类型以解析.
             * 如果未赋值且加载的类型并非为内置支持的文件类型.将以文本格式进行加载
             * @param value
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this._dataformat = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 释放所有数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        ILoader.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        ILoader.prototype.processFileFormat = function () {
            var fileFormat = egret3d.StringUtil.getFileFormat(this.url);
            switch (fileFormat) {
                case "rar":
                    this._dataformat = ILoader.DATAFORMAT_BINARY;
                case "7z":
                    this._dataformat = ILoader.DATAFORMAT_BINARY;
                case "lzma":
                    this._dataformat = ILoader.DATAFORMAT_BINARY;
                    break;
                case "dds":
                    this._dataformat = ILoader.DATAFORMAT_DDS;
                    break;
                case "tga":
                    this._dataformat = ILoader.DATAFORMAT_TGA;
                    break;
                case "bmp":
                    this._dataformat = ILoader.DATAFORMAT_BITMAP;
                    break;
                case "png":
                    this._dataformat = ILoader.DATAFORMAT_BITMAP;
                    break;
                case "jpg":
                    this._dataformat = ILoader.DATAFORMAT_BITMAP;
                    break;
                case "hdr":
                    this._dataformat = ILoader.DATAFORMAT_HDR;
                    break;
                case "glsl":
                    this._dataformat = ILoader.DATAFORMAT_TEXT;
                    break;
                case "pvr":
                    this._dataformat = ILoader.DATAFORMAT_PVR;
                    break;
                case "esm":
                    this._dataformat = ILoader.DATAFORMAT_ESM;
                    break;
                case "eam":
                    this._dataformat = ILoader.DATAFORMAT_EAM;
                    break;
                case "e3dpack":
                    this._dataformat = ILoader.DATAFORMAT_E3DPACK;
                    break;
                case "eum":
                    this._dataformat = egret3d.URLLoader.DATAFORMAT_EUM;
                    break;
                case "eca":
                    this._dataformat = ILoader.DATAFORMAT_ECA;
                    break;
                case "epa":
                    this._dataformat = ILoader.DATAFORMAT_EPA;
                    break;
                case "json":
                    this._dataformat = ILoader.DATAFORMAT_JSON;
                    break;
                case "xml":
                    this._dataformat = ILoader.DATAFORMAT_XML;
                    break;
            }
        };
        /**
         * @language zh_CN
         * 以二进制方式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        ILoader.DATAFORMAT_BINARY = "binary";
        /**
         * @language zh_CN
         * 以文本的方式接收加载的数据
         * 默认方式
         * @version Egret 3.0
         * @platform Web,Native
         */
        ILoader.DATAFORMAT_TEXT = "text";
        /**
         * @language zh_CN
         * 以音频的方式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        ILoader.DATAFORMAT_SOUND = "sound";
        /**
         * @language zh_CN
         * 以图像的方式接收加载的数据
         * 支持jpg.png.等格式
         * @version Egret 3.0
         * @platform Web,Native
         */
        ILoader.DATAFORMAT_BITMAP = "bitmap";
        /**
         * @language zh_CN
         * 以DDS的方式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        ILoader.DATAFORMAT_DDS = "dds";
        /**
         * @language zh_CN
         * 以TGA的方式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        ILoader.DATAFORMAT_TGA = "tga";
        /**
         * @language zh_CN
         * 以ESM格式接收加载的数据
         * Egret3D独有的格式 模型+蒙皮
         * @version Egret 3.0
         * @platform Web,Native
         */
        ILoader.DATAFORMAT_ESM = "esm";
        /**
         * @language zh_CN
         * 以EAM格式接收加载的数据
         * Egret3D独有的格式 动作文件
         * @version Egret 3.0
         * @platform Web,Native
         */
        ILoader.DATAFORMAT_EAM = "eam";
        /**
       * @language zh_CN
       * 以ERM格式接收加载的数据
       * Egret3D独有的格式 整个场景资源
       * @version Egret 3.0
       * @platform Web,Native
       */
        ILoader.DATAFORMAT_E3DPACK = "e3dpack";
        /**
        * @language zh_CN
        * 以EUM格式接收加载的数据
        * Egret3D独有的格式 导出场景地第二UV信息
        * @version Egret 3.0
        * @platform Web,Native
        */
        ILoader.DATAFORMAT_EUM = "eum";
        /**
         * @language zh_CN
         * 以ECA格式接收加载的数据
         * Egret3D独有的格式 相机动画文件
         * @version Egret 3.0
         * @platform Web,Native
         */
        ILoader.DATAFORMAT_ECA = "eca";
        /**
         * @language zh_CN
         * 以EPA格式接收加载的数据
         * Egret3D独有的格式 属性动画文件
         * @version Egret 3.0
         * @platform Web,Native
         */
        ILoader.DATAFORMAT_EPA = "epa";
        /**
         * @private
         * @language zh_CN
         * 以pvr格式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        ILoader.DATAFORMAT_PVR = "pvr";
        /**
        * @private
        * @language zh_CN
        * 以pvr格式接收加载的数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        ILoader.DATAFORMAT_HDR = "hdr";
        /**
        * @private
        * @language zh_CN
        * 以json格式接收加载的数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        ILoader.DATAFORMAT_JSON = "json";
        /**
        * @private
        * @language zh_CN
        * 以xml格式接收加载的数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        ILoader.DATAFORMAT_XML = "xml";
        return ILoader;
    }(egret3d.EventDispatcher));
    egret3d.ILoader = ILoader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.URLLoader
    * @classdesc
    * URLLoader类
    * 用于加载和解析各类3d资源.  加载完成后数据存在 data 中
    * DDS, TGA, jpg, png, hdr等格式的贴图文件. 加载完成后返回 ITexture对象
    * ESM, EAM, ECA, EPA 等egret3d独有的模型文件,动作文件,相机动画文件, 属性动画文件
    * ESM: Geometry
    * EAM: SkeletonAnimationClip
    * EPA: PropertyAnim
    * @see egret3d.ILoader
    * @see egret3d.LoaderEvent3D
    *
    * @includeExample loader/URLLoader.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var URLLoader = (function (_super) {
        __extends(URLLoader, _super);
        /**
         * @language zh_CN
         * 构造函数
         * @param url 加载数据的地址.如果参数不为空的话.将直接开始加载
         * @param dataformat 以什么方式进行加载.如果为空的话.将通过目标文件的后缀名判断,
         * 如果为空且文件后缀不为内置支持的集中文件类型的话.将以文本格式进行加载解析
         * @version Egret 3.0
         * @platform Web,Native
         */
        function URLLoader(url, dataformat) {
            if (url === void 0) { url = null; }
            if (dataformat === void 0) { dataformat = null; }
            _super.call(this);
            this._event = new egret3d.LoaderEvent3D();
            /**
            * @language zh_CN
            * 加载的地址的上级目录，为了方便获取资源
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.parentUrl = "";
            if (url) {
                this.load(url, dataformat);
            }
        }
        /**
         * @language en_US
         */
        /**
         * @language zh_CN
         * 加载目标地址的数据
         * @param url 数据地址
         * @param dataformat 以什么方式进行加载.如果为空的话.将通过目标文件的后缀名判断,
         * 如果为空且文件后缀不为内置支持的集中文件类型的话.将以文本格式进行加载解析
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.prototype.load = function (url, dataformat) {
            var _this = this;
            if (dataformat === void 0) { dataformat = null; }
            this.data = null;
            this.url = url;
            this.resourceName = egret3d.StringUtil.getURLName(this.url);
            this.dataformat = dataformat;
            if (null == this._dataformat) {
                this.processFileFormat();
            }
            if (this._xhr == null) {
                this._xhr = this.getXHR();
            }
            if (this._xhr == null) {
                alert("Your browser does not support XMLHTTP.");
                return;
            }
            if (this._xhr.readyState > 0) {
                this._xhr.abort();
                this.disposeXhrEventListener();
            }
            this._xhr.open("GET", this.url, true);
            this.progress = function (e) { return _this.onProgress(e); };
            this.readystatechange = function (e) { return _this.onReadyStateChange(e); };
            this.error = function (e) { return _this.onError(e); };
            this._xhr.addEventListener("progress", this.progress, false);
            this._xhr.addEventListener("readystatechange", this.readystatechange, false);
            this._xhr.addEventListener("error", this.error, false);
            if (this.dataformat == URLLoader.DATAFORMAT_BITMAP) {
                this._xhr.responseType = "blob";
            }
            else if (this.dataformat != URLLoader.DATAFORMAT_TEXT &&
                this.dataformat != URLLoader.DATAFORMAT_JSON &&
                this.dataformat != URLLoader.DATAFORMAT_XML) {
                this._xhr.responseType = "arraybuffer";
            }
            this._xhr.send();
        };
        Object.defineProperty(URLLoader.prototype, "bytesLoaded", {
            /**
            * @language zh_CN
            * 已经获取到的字节数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._progressEvent ? this._progressEvent.loaded : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URLLoader.prototype, "bytesTotal", {
            /**
            * @language zh_CN
            * 需要获取的总字节数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._progressEvent ? this._progressEvent.total : 0;
            },
            enumerable: true,
            configurable: true
        });
        URLLoader.prototype.onReadyStateChange = function (event) {
            if (this._xhr.readyState == 4) {
                if (this._xhr.status >= 400 /*|| this._xhr.status == 0*/) {
                    console.log(this.url, "load fail");
                }
                else {
                    this.loadComplete();
                }
            }
        };
        URLLoader.prototype.loadComplete = function () {
            var _this = this;
            switch (this.dataformat) {
                case egret3d.ILoader.DATAFORMAT_BINARY:
                    this.data = new egret3d.ByteArray(this._xhr.response);
                    break;
                case egret3d.ILoader.DATAFORMAT_SOUND:
                    this.data = this._xhr.responseText;
                    break;
                case egret3d.ILoader.DATAFORMAT_TEXT:
                    this.data = this._xhr.responseText;
                    break;
                case egret3d.ILoader.DATAFORMAT_BITMAP:
                    var img = document.createElement("img");
                    if (window['createObjectURL'] != undefined) {
                        img.src = window['createObjectURL'](this._xhr.response);
                    }
                    else if (window['URL'] != undefined) {
                        img.src = window['URL'].createObjectURL(this._xhr.response);
                    }
                    else if (window['webkitURL'] != undefined) {
                        img.src = window['webkitURL'].createObjectURL(this._xhr.response);
                    }
                    img.onload = function () { return _this.onLoad(img); };
                    return;
                case egret3d.ILoader.DATAFORMAT_DDS:
                    this.data = egret3d.DDSParser.parse(this._xhr.response);
                    this.checkTexture(this.data);
                    break;
                case egret3d.ILoader.DATAFORMAT_TGA:
                    this.data = egret3d.TGAParser.parse(this._xhr.response);
                    this.checkTexture(this.data);
                    break;
                case egret3d.ILoader.DATAFORMAT_HDR:
                    this.data = egret3d.HDRParser.parse(this._xhr.response);
                    this.checkTexture(this.data);
                    break;
                case egret3d.ILoader.DATAFORMAT_ESM:
                    this.data = egret3d.ESMParser.parse(this._xhr.response, this.unitNodeData);
                    break;
                case egret3d.ILoader.DATAFORMAT_EAM:
                    this.data = egret3d.EAMParser.parse(this._xhr.response);
                    break;
                case egret3d.ILoader.DATAFORMAT_ECA:
                    this.data = egret3d.ECAParser.parse(this._xhr.response);
                    break;
                case egret3d.ILoader.DATAFORMAT_EPA:
                    this.data = egret3d.EPAParser.parse(this._xhr.response);
                    break;
                case egret3d.ILoader.DATAFORMAT_E3DPACK:
                    this.data = egret3d.E3dPackParser.parse(this._xhr.response, this.url);
                    break;
                case URLLoader.DATAFORMAT_EUM:
                    this.data = egret3d.EUMParser.parse(this._xhr.response);
                    break;
                case egret3d.ILoader.DATAFORMAT_XML:
                    this.data = egret3d.XMLParser.parse(this._xhr.responseText);
                    break;
                case egret3d.ILoader.DATAFORMAT_JSON:
                    this.data = eval("(" + this._xhr.responseText + ")");
                    break;
                default:
                    this.data = this._xhr.response;
                    break;
            }
            this.doLoadComplete();
        };
        URLLoader.prototype.onProgress = function (event) {
            this._event.eventType = egret3d.LoaderEvent3D.LOADER_PROGRESS;
            this._event.loader = this;
            this._event.total = event.total;
            this._event.loaded = event.loaded;
            this._progressEvent = event;
            this.currentProgress = event.loaded / event.total;
            if (this.currentProgress < 1.0) {
                this._event.currentProgress = this.currentProgress;
                this.dispatchEvent(this._event);
            }
        };
        URLLoader.prototype.onError = function (event) {
            this._event.eventType = egret3d.LoaderEvent3D.LOADER_ERROR;
            this._event.target = this;
            this._event.loader = this;
            this.dispatchEvent(this._event);
            console.log("load error", event);
            this.disposeXhrEventListener();
        };
        URLLoader.prototype.getXHR = function () {
            var xhr = null;
            if (window["XMLHttpRequest"]) {
                xhr = new window["XMLHttpRequest"]();
            }
            else {
                xhr = new ActiveXObject("MSXML2.XMLHTTP");
            }
            return xhr;
        };
        URLLoader.prototype.onLoad = function (img) {
            this.data = new egret3d.ImageTexture(img);
            this.checkTexture(this.data);
            this.doLoadComplete();
            if (window['createObjectURL'] != undefined) {
                window['revokeObjectURL'](img.src);
            }
            else if (window['URL'] != undefined) {
                window['URL'].revokeObjectURL(img.src);
            }
            else if (window['webkitURL'] != undefined) {
                window['webkitURL'].revokeObjectURL(img.src);
            }
            //window.URL.revokeObjectURL(img.src);
            img.onload = null;
        };
        URLLoader.prototype.checkTexture = function (texture) {
            if ((texture.width & (texture.width - 1)) != 0 ||
                (texture.height & (texture.height - 1)) != 0) {
                egret3d.Egret3DLog.outError("<" + this.url + ">" + "<贴图宽高不是2的N次方>");
            }
        };
        URLLoader.prototype.doLoadComplete = function () {
            this.currentProgress = 1.0;
            this.disposeXhrEventListener();
            this._event.loader = this;
            this._event.data = this.data;
            this._event.total = this._progressEvent.total;
            this._event.loaded = this._progressEvent.loaded;
            this._event.currentProgress = this.currentProgress;
            this._event.eventType = egret3d.LoaderEvent3D.LOADER_ONCE_COMPLETE;
            this.dispatchEvent(this._event);
            this._event.eventType = egret3d.LoaderEvent3D.LOADER_PROGRESS;
            this.dispatchEvent(this._event);
            this._event.eventType = egret3d.LoaderEvent3D.LOADER_COMPLETE;
            this.dispatchEvent(this._event);
        };
        URLLoader.prototype.disposeXhrEventListener = function () {
            if (this.progress) {
                this._xhr.removeEventListener("progress", this.progress, false);
                this.progress = null;
            }
            if (this.readystatechange) {
                this._xhr.removeEventListener("readystatechange", this.readystatechange, false);
                this.readystatechange = null;
            }
            if (this.error) {
                this._xhr.removeEventListener("error", this.error, false);
                this.error = null;
            }
        };
        /**
        * @language zh_CN
        * 释放所有数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        URLLoader.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.data && this.data.dispose) {
                this.data.dispose();
            }
            this.data = null;
            this._event = null;
            this.disposeXhrEventListener();
            this._xhr = null;
        };
        return URLLoader;
    }(egret3d.ILoader));
    egret3d.URLLoader = URLLoader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.BinaryLoader
    * @classdesc
    * @see egret3d.ILoader
    *
    * @version Egret 3.0
    * @platform Web,Native
    */
    var BinaryLoader = (function (_super) {
        __extends(BinaryLoader, _super);
        function BinaryLoader(url) {
            if (url === void 0) { url = null; }
            _super.call(this);
            this._event = new egret3d.LoaderEvent3D();
            if (url) {
                this.load(url);
            }
        }
        BinaryLoader.prototype.load = function (url) {
            this.data = null;
            this.url = url;
            this.resourceName = egret3d.StringUtil.getURLName(this.url);
            this.processFileFormat();
            this.loadComplete();
        };
        BinaryLoader.prototype.loadComplete = function () {
            var _this = this;
            var byte = egret3d.assetMgr.getByteArray(this.url);
            switch (this.dataformat) {
                case egret3d.ILoader.DATAFORMAT_BINARY:
                    this.data = byte;
                    break;
                case egret3d.ILoader.DATAFORMAT_BITMAP:
                    var blob = new Blob([byte.buffer]);
                    var img = document.createElement("img");
                    if (window['createObjectURL'] != undefined) {
                        img.src = window['createObjectURL'](blob);
                    }
                    else if (window['URL'] != undefined) {
                        img.src = window['URL'].createObjectURL(blob);
                    }
                    else if (window['webkitURL'] != undefined) {
                        img.src = window['webkitURL'].createObjectURL(blob);
                    }
                    img.onload = function () { return _this.onLoad(img); };
                    return;
                case egret3d.ILoader.DATAFORMAT_DDS:
                    this.data = egret3d.DDSParser.parse(byte.buffer);
                    this.checkTexture(this.data);
                    break;
                case egret3d.ILoader.DATAFORMAT_TGA:
                    this.data = egret3d.TGAParser.parse(byte.buffer);
                    this.checkTexture(this.data);
                    break;
                case egret3d.ILoader.DATAFORMAT_HDR:
                    this.data = egret3d.HDRParser.parse(byte.buffer);
                    this.checkTexture(this.data);
                    break;
                case egret3d.ILoader.DATAFORMAT_ESM:
                    this.data = egret3d.ESMParser.parse(byte.buffer);
                    break;
                case egret3d.ILoader.DATAFORMAT_EAM:
                    this.data = egret3d.EAMParser.parse(byte.buffer);
                    break;
                case egret3d.ILoader.DATAFORMAT_ECA:
                    this.data = egret3d.ECAParser.parse(byte.buffer);
                    break;
                case egret3d.ILoader.DATAFORMAT_EPA:
                    this.data = egret3d.EPAParser.parse(byte.buffer);
                    break;
                case egret3d.ILoader.DATAFORMAT_E3DPACK:
                    this.data = egret3d.E3dPackParser.parse(byte.buffer, this.url);
                    break;
                case egret3d.URLLoader.DATAFORMAT_EUM:
                    this.data = egret3d.EUMParser.parse(byte.buffer);
                    break;
                case egret3d.ILoader.DATAFORMAT_XML:
                    this.data = egret3d.XMLParser.parse(egret3d.StringUtil.ab2str(byte));
                    break;
                case egret3d.ILoader.DATAFORMAT_JSON:
                    this.data = eval("(" + egret3d.StringUtil.ab2str(byte) + ")");
                    break;
                default:
                    this.data = byte.buffer;
                    break;
            }
            setTimeout(function () {
                _this.doLoadComplete();
            }, 0);
        };
        BinaryLoader.prototype.onLoad = function (img) {
            this.data = new egret3d.ImageTexture(img);
            this.checkTexture(this.data);
            this.doLoadComplete();
            if (window['createObjectURL'] != undefined) {
                window['revokeObjectURL'](img.src);
            }
            else if (window['URL'] != undefined) {
                window['URL'].revokeObjectURL(img.src);
            }
            else if (window['webkitURL'] != undefined) {
                window['webkitURL'].revokeObjectURL(img.src);
            }
            //window.URL.revokeObjectURL(img.src);
            img.onload = null;
        };
        BinaryLoader.prototype.checkTexture = function (texture) {
            if ((texture.width & (texture.width - 1)) != 0 ||
                (texture.height & (texture.height - 1)) != 0) {
                egret3d.Egret3DLog.outError("<" + this.url + ">" + "<贴图宽高不是2的N次方>");
            }
        };
        BinaryLoader.prototype.doLoadComplete = function () {
            this.currentProgress = 1;
            this._event.loader = this;
            this._event.data = this.data;
            this._event.currentProgress = this.currentProgress;
            this._event.eventType = egret3d.LoaderEvent3D.LOADER_PROGRESS;
            this.dispatchEvent(this._event);
            this._event.eventType = egret3d.LoaderEvent3D.LOADER_ONCE_COMPLETE;
            this.dispatchEvent(this._event);
            this._event.eventType = egret3d.LoaderEvent3D.LOADER_COMPLETE;
            this.dispatchEvent(this._event);
        };
        return BinaryLoader;
    }(egret3d.ILoader));
    egret3d.BinaryLoader = BinaryLoader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.AssetManager
    * @classdesc
    * 资源加载统一管理类
    * @see egret3d.URLLoader
    * @version Egret 3.0
    * @platform Web,Native
    */
    var AssetManager = (function () {
        function AssetManager() {
            this._loaderDict = {};
            this._queueLoader = [];
            this._loaderEvent = new egret3d.LoaderEvent3D();
            this._binaryDict = {};
            this._binaryUrlDict = {};
        }
        /**
        * @language zh_CN
        * 加载资源接口
        * @param url 资源路径
        * @param callback 加载完成后的回调
        * @param thisObject 回调函数的this对象
        * @param param 附带参数
        * @returns URLLoader 反回当前加载的URLLoader对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        AssetManager.prototype.loadAsset = function (url, callback, thisObject, param) {
            if (param === void 0) { param = null; }
            return this.addEventListener(url, egret3d.LoaderEvent3D.LOADER_COMPLETE, callback, thisObject, param);
        };
        /**
        * @language zh_CN
        * 加载资源接口 并监听事件接口
        * @param url 资源路径
        * @param type 事件类型
        * @param callback 加载完成后的回调
        * @param thisObject 回调函数的this对象
        * @param param 附带参数
        * @returns URLLoader 反回当前加载的URLLoader对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        AssetManager.prototype.addEventListener = function (url, type, callback, thisObject, param) {
            var _this = this;
            if (param === void 0) { param = null; }
            var asset = this._loaderDict[url];
            if (!asset) {
                asset = {};
                this._loaderDict[url] = asset;
                if (this.getByteArray(url)) {
                    asset.loader = new egret3d.BinaryLoader();
                }
                else {
                    asset.loader = new egret3d.URLLoader();
                }
                asset.objects = [];
                var loader = asset.loader;
                loader.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onComplete, this);
                this._queueLoader.push(url);
                if (!this._currentLoader) {
                    this._currentLoader = loader;
                    this._currentLoader.load(url);
                }
            }
            var loader = asset.loader;
            loader.param = param;
            if (param instanceof egret3d.UnitNodeData) {
                loader.unitNodeData = param;
            }
            if (loader.data) {
                setTimeout(function () {
                    _this._loaderEvent.eventType = type;
                    _this._loaderEvent.target = loader;
                    _this._loaderEvent.loader = loader;
                    _this._loaderEvent.data = loader.data;
                    _this._loaderEvent.param = param;
                    if (callback) {
                        callback.call(thisObject, _this._loaderEvent);
                    }
                    _this._loaderEvent.target = null;
                    _this._loaderEvent.loader = null;
                    _this._loaderEvent.data = null;
                    _this._loaderEvent.param = null;
                }, 0);
            }
            else {
                if (callback) {
                    loader.addEventListener(type, callback, thisObject, param);
                }
            }
            if (asset.objects.indexOf(thisObject) < 0) {
                asset.objects.push(thisObject);
            }
            return loader;
        };
        /**
        * @language zh_CN
        * 查找资源数据
        * @param url 资源路径
        * @param thisObject 资源引用对象 默认为null
        * @returns URLLoader  加载对象
        * @see egret3d.URLLoader
        * @version Egret 3.0
        * @platform Web,Native
        */
        AssetManager.prototype.findAsset = function (url, thisObject) {
            if (thisObject === void 0) { thisObject = null; }
            var asset = this._loaderDict[url];
            if (asset) {
                if (thisObject) {
                    if (asset.objects.indexOf(thisObject) < 0) {
                        asset.objects.push(thisObject);
                    }
                }
                return asset.loader;
            }
            return null;
        };
        /**
        * @language zh_CN
        * 释放资源引用 没有引用的资源将会被进行释放
        * @param object 对象使用的资源的引用进行释放
        * @version Egret 3.0
        * @platform Web,Native
        */
        AssetManager.prototype.dispose = function (object) {
            var keys = [];
            for (var key in this._loaderDict) {
                var data = this._loaderDict[key];
                var index = data.objects.indexOf(object);
                if (index >= 0) {
                    data.objects.splice(index, 1);
                }
                if (data.objects.length <= 0) {
                    keys.push(key);
                }
            }
            for (var i = 0; i < keys.length; ++i) {
                var data = this._loaderDict[keys[i]];
                data.loader.dispose();
                data.loader = null;
                data.objects = null;
                delete this._loaderDict[keys[i]];
            }
            keys = null;
        };
        AssetManager.prototype.onComplete = function (e) {
            this._queueLoader.shift();
            if (this._queueLoader.length > 0) {
                var data = this._loaderDict[this._queueLoader[0]];
                var loader = data.loader;
                loader.load(this._queueLoader[0]);
                this._currentLoader = loader;
            }
            else {
                this._currentLoader = null;
            }
        };
        AssetManager.prototype.addByteArray = function (url, byte, parentUrl) {
            this._binaryDict[url] = byte;
            var urlArray = this._binaryUrlDict[parentUrl];
            if (!urlArray) {
                urlArray = [];
                this._binaryUrlDict[parentUrl] = urlArray;
            }
            urlArray.push(url);
        };
        AssetManager.prototype.removeByteArray = function (parentUrl) {
            var urlArray = this._binaryUrlDict[parentUrl];
            if (urlArray) {
                for (var i = 0; i < urlArray.length; ++i) {
                    delete this._binaryDict[urlArray[i]];
                }
                delete this._binaryUrlDict[parentUrl];
            }
        };
        AssetManager.prototype.getByteArray = function (url) {
            return this._binaryDict[url];
        };
        return AssetManager;
    }());
    egret3d.AssetManager = AssetManager;
    /**
    * @private
    * @language zh_CN
    * 资源管理对象 内部资源管理直接使用此对象
    * @version Egret 3.0
    * @platform Web,Native
    */
    egret3d.assetMgr = new AssetManager();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.gui.TextureResourceManager
    * @classdesc
    * gui贴图资源加载管理器,</p>
    * 用于加载由TexturePacker生成的贴图资源</p>
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TextureResourceManager = (function (_super) {
        __extends(TextureResourceManager, _super);
        function TextureResourceManager() {
            _super.call(this);
            this._textureDic = {};
            this._urlTextureDic = {};
            this._bigTextureDic = {};
            this._count = 0;
            this.resetCount();
        }
        Object.defineProperty(TextureResourceManager.prototype, "guiStage", {
            get: function () {
                return this._guiStage;
            },
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (guiStage) {
                this._guiStage = guiStage;
            },
            enumerable: true,
            configurable: true
        });
        //重置加载计数
        TextureResourceManager.prototype.resetCount = function () {
            this._totalCount = 0;
            this._loadedCount = 0;
        };
        Object.defineProperty(TextureResourceManager.prototype, "totalCount", {
            /**
           * @language zh_CN
           * 获取当前总的加载数量
           * @version Egret 3.0
           * @platform Web,Native
           */
            get: function () {
                return this._totalCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureResourceManager.prototype, "loadedCount", {
            /**
         * @language zh_CN
         * 获取当前已加载完成的数量
         * @version Egret 3.0
         * @platform Web,Native
         */
            get: function () {
                return this._loadedCount;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
        * @language zh_CN
        * 加载由texturePack生成的资源文件.</p>
        * 连续调用时. 将会队列加载文件.
        * 全部加载完成时会抛出LoaderEvent3D.LOADER_COMPLETE事件.
        * 单个加载完成会抛出LoaderEvent3D.LOADER_PROGRESS事件
        * @param jsonUrl 由TexturePack生成的json配置文件
        * @param bitmapUrl 由TexturePack生成的png图片文件
        * @param gui view3d中的quadStage对象.一般不用传, 在调用View3d.openGUI时就已经初始化了.
        * @version Egret 3.0
        * @platform Web,Native
        */
        TextureResourceManager.prototype.loadTexture = function (jsonUrl, bitmapUrl) {
            var _this = this;
            var jsonArrayParser = function (sourceTexture, jsonData) {
                var frames = jsonData["frames"];
                for (var i = 0; i < frames.length; i++) {
                    var frame = frames[i];
                    var name = frame["filename"];
                    var frameRect = frame["frame"];
                    var tex = new egret3d.Texture();
                    tex.copyFromTexture(sourceTexture, frameRect["x"] / sourceTexture.width, frameRect["y"] / sourceTexture.height, frameRect["w"] / sourceTexture.width, frameRect["h"] / sourceTexture.height);
                    tex.width = frameRect['w'];
                    tex.height = frameRect["h"];
                    if (_this._textureDic[name]) {
                        console.log("TextureResourceManager::loadTexture, 贴图缓存池里已经有相同名字的贴图. 请检查, name: " + name + " url:" + jsonUrl);
                    }
                    _this._textureDic[name] = tex;
                }
            };
            this._count++;
            this._totalCount++;
            var loadJsonFun = function (sourceTex) {
                var jsonLoader = new egret3d.URLLoader(jsonUrl);
                jsonLoader.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, function (e) {
                    sourceTex.useMipmap = false;
                    egret3d.registGUITexture(sourceTex);
                    jsonArrayParser(sourceTex, JSON.parse(jsonLoader.data));
                    _this._count--;
                    _this._loadedCount++;
                    _this.dispatchEvent(new egret3d.LoaderEvent3D(egret3d.LoaderEvent3D.LOADER_PROGRESS));
                    if (_this._count === 0) {
                        _this.resetCount();
                        setTimeout(function () {
                            _this.dispatchEvent(new egret3d.LoaderEvent3D(egret3d.LoaderEvent3D.LOADER_COMPLETE));
                        }, 0);
                    }
                }, _this);
            };
            var texLoader = new egret3d.URLLoader(bitmapUrl);
            texLoader.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, function (e) {
                loadJsonFun(texLoader.data);
            }, this);
        };
        /**
         *
         * @private
         * @returns {}
         */
        TextureResourceManager.prototype.getTextureDic = function () {
            return this._textureDic;
        };
        /**
               * @language zh_CN
               * 获取贴图
               * @param name 贴图名,由json中的名字获得
               *
               * @version Egret 3.0
               * @platform Web,Native
               */
        TextureResourceManager.prototype.getTexture = function (name) {
            return this._textureDic[name];
        };
        //       
        //        public static getInstance(): TextureResourceManager {
        //            if (!this._instance) {
        //                this._instance = new TextureResourceManager();
        //            }
        //            return this._instance;
        //        }
        TextureResourceManager.prototype.addTexture = function (url, json, texture) {
            egret3d.registGUITexture(texture);
            this._bigTextureDic[url] = texture;
            var tempNameAry = [];
            this._urlTextureDic[url] = tempNameAry;
            var frames = json["frames"];
            var name;
            for (var i = 0; i < frames.length; i++) {
                var frame = frames[i];
                name = frame["filename"];
                var frameRect = frame["frame"];
                var tex = new egret3d.Texture();
                tex.copyFromTexture(texture, frameRect["x"] / texture.width, frameRect["y"] / texture.height, frameRect["w"] / texture.width, frameRect["h"] / texture.height);
                tex.width = frameRect['w'];
                tex.height = frameRect["h"];
                if (this._textureDic[name]) {
                    console.log("TextureResourceManager::loadTexture, 贴图缓存池里已经有相同名字的贴图. 请检查, url: " + url);
                }
                this._textureDic[name] = tex;
                tempNameAry.push(name);
            }
        };
        TextureResourceManager.prototype.removeTexture = function (url) {
            var ary = this._urlTextureDic[url];
            if (ary) {
                for (var i = 0; i < ary.length; i++) {
                    delete this._textureDic[ary[i]];
                }
            }
        };
        return TextureResourceManager;
    }(egret3d.EventDispatcher));
    egret3d.TextureResourceManager = TextureResourceManager;
    /*
    * @private
    */
    egret3d.textureResMgr = new TextureResourceManager();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * dds / st3c compressed texture formats
     */
    (function (DDSFormat) {
        DDSFormat[DDSFormat["RGB_S3TC_DXT1_FORMAT"] = 2001] = "RGB_S3TC_DXT1_FORMAT";
        DDSFormat[DDSFormat["RGBA_S3TC_DXT1_FORMAT"] = 2002] = "RGBA_S3TC_DXT1_FORMAT";
        DDSFormat[DDSFormat["RGBA_S3TC_DXT3_FORMAT"] = 2003] = "RGBA_S3TC_DXT3_FORMAT";
        DDSFormat[DDSFormat["RGBA_S3TC_DXT5_FORMAT"] = 2003] = "RGBA_S3TC_DXT5_FORMAT";
    })(egret3d.DDSFormat || (egret3d.DDSFormat = {}));
    var DDSFormat = egret3d.DDSFormat;
    ;
    /**
     * @private
     * @language zh_CN
     * @class egret3d.DDSParser
     * @classdesc
     * 用 DDSParser 类 解析.dds 文件
     */
    var DDSParser = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function DDSParser() {
        }
        /**
         * @language zh_CN
         * @param buffer 二进制
         * @param loadMipmaps 是否加载mipmaps
         * @returns DDSTexture
         */
        DDSParser.parse = function (buffer, loadMipmaps) {
            if (loadMipmaps === void 0) { loadMipmaps = true; }
            var headerLengthInt = 31; // The header length in 32 bit ints
            var off_magic = 0;
            var DDS_MAGIC = 0x20534444;
            var DDSD_CAPS = 0x1, DDSD_HEIGHT = 0x2, DDSD_WIDTH = 0x4, DDSD_PITCH = 0x8, DDSD_PIXELFORMAT = 0x1000, DDSD_MIPMAPCOUNT = 0x20000, DDSD_LINEARSIZE = 0x80000, DDSD_DEPTH = 0x800000;
            var DDSCAPS_COMPLEX = 0x8, DDSCAPS_MIPMAP = 0x400000, DDSCAPS_TEXTURE = 0x1000;
            var DDSCAPS2_CUBEMAP = 0x200, DDSCAPS2_CUBEMAP_POSITIVEX = 0x400, DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800, DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000, DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000, DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000, DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000, DDSCAPS2_VOLUME = 0x200000;
            var DDPF_ALPHAPIXELS = 0x1, DDPF_ALPHA = 0x2, DDPF_FOURCC = 0x4, DDPF_RGB = 0x40, DDPF_YUV = 0x200, DDPF_LUMINANCE = 0x20000;
            var FOURCC_DXT1 = DDSParser.fourCCToInt32("DXT1");
            var FOURCC_DXT3 = DDSParser.fourCCToInt32("DXT3");
            var FOURCC_DXT5 = DDSParser.fourCCToInt32("DXT5");
            //Pixel formats
            var RGBA_FORMAT = 1021;
            var off_magic = 0;
            var off_size = 1;
            var off_flags = 2;
            var off_height = 3;
            var off_width = 4;
            var off_mipmapCount = 7;
            var off_pfFlags = 20;
            var off_pfFourCC = 21;
            var off_RGBBitCount = 22;
            var off_RBitMask = 23;
            var off_GBitMask = 24;
            var off_BBitMask = 25;
            var off_ABitMask = 26;
            var off_caps = 27;
            var off_caps2 = 28;
            var off_caps3 = 29;
            var off_caps4 = 30;
            var header = new Int32Array(buffer, 0, headerLengthInt);
            if (header[off_magic] !== DDS_MAGIC) {
                console.error('DDSParser.parse: Invalid magic number in DDS header.');
                return null;
            }
            if (!(header[off_pfFlags] & DDPF_FOURCC)) {
                console.error('DDSParser.parse: Unsupported format, must contain a FourCC code.');
                return null;
            }
            var blockBytes;
            var fourCC = header[off_pfFourCC];
            var isRGBAUncompressed = false;
            var mipmapCount = 1;
            var format;
            var isCubemap;
            var width;
            var height;
            switch (fourCC) {
                case FOURCC_DXT1:
                    blockBytes = 8;
                    format = DDSFormat.RGB_S3TC_DXT1_FORMAT;
                    break;
                case FOURCC_DXT3:
                    blockBytes = 16;
                    format = DDSFormat.RGBA_S3TC_DXT3_FORMAT;
                    break;
                case FOURCC_DXT5:
                    blockBytes = 16;
                    format = DDSFormat.RGBA_S3TC_DXT5_FORMAT;
                    break;
                default:
                    if (header[off_RGBBitCount] == 32
                        && header[off_RBitMask] & 0xff0000
                        && header[off_GBitMask] & 0xff00
                        && header[off_BBitMask] & 0xff
                        && header[off_ABitMask] & 0xff000000) {
                        isRGBAUncompressed = true;
                        blockBytes = 64;
                        format = RGBA_FORMAT;
                    }
                    else {
                        console.error('DDSParser.parse: Unsupported FourCC code ', DDSParser.int32ToFourCC(fourCC));
                        return null;
                    }
            }
            if ((header[off_flags] & DDSD_MIPMAPCOUNT) && loadMipmaps !== false) {
                mipmapCount = Math.max(1, header[off_mipmapCount]);
            }
            isCubemap = header[off_caps2] & DDSCAPS2_CUBEMAP ? true : false;
            width = header[off_width];
            height = header[off_height];
            var dataOffset = header[off_size] + 4;
            // Extract mipmaps buffers
            var faces = isCubemap ? 6 : 1;
            var mipmaps = new Array();
            //是否软解DXT;
            var useSoftwareSolution = false;
            if (format == DDSFormat.RGB_S3TC_DXT1_FORMAT && egret3d.ContextConfig.ColorFormat_DXT1_RGB == 0)
                useSoftwareSolution = true;
            else if (format == DDSFormat.RGBA_S3TC_DXT3_FORMAT && egret3d.ContextConfig.ColorFormat_DXT3_RGBA == 0)
                useSoftwareSolution = true;
            else if (format == DDSFormat.RGBA_S3TC_DXT5_FORMAT && egret3d.ContextConfig.ColorFormat_DXT5_RGBA == 0)
                useSoftwareSolution = true;
            var texture = new egret3d.Texture();
            texture.width = width;
            texture.height = height;
            for (var face = 0; face < faces; face++) {
                for (var i = 0; i < mipmapCount; i++) {
                    var byteArray;
                    if (isRGBAUncompressed) {
                        byteArray = DDSParser.loadARGBMip(buffer, dataOffset, width, height);
                        var dataLength = byteArray.length;
                    }
                    else {
                        var dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
                        byteArray = new Uint8Array(buffer, dataOffset, dataLength);
                        if (useSoftwareSolution) {
                            byteArray = DDSParser.softSolutionDXT(width, height, format, byteArray);
                        }
                    }
                    var mipmap = new egret3d.MipmapData(byteArray, width, height);
                    mipmaps.push(mipmap);
                    dataOffset += dataLength;
                    width = Math.max(width * 0.5, 1);
                    height = Math.max(height * 0.5, 1);
                }
                width = width;
                height = height;
            }
            if (useSoftwareSolution) {
                texture.internalFormat = egret3d.InternalFormat.PixelArray;
                texture.colorFormat = egret3d.ContextConfig.ColorFormat_RGBA8888;
            }
            else {
                texture.internalFormat = egret3d.InternalFormat.CompressData;
                if (FOURCC_DXT1 == fourCC)
                    texture.colorFormat = egret3d.ContextConfig.ColorFormat_DXT1_RGB;
                else if (FOURCC_DXT3 == fourCC)
                    texture.colorFormat = egret3d.ContextConfig.ColorFormat_DXT3_RGBA;
                else if (FOURCC_DXT5 == fourCC)
                    texture.colorFormat = egret3d.ContextConfig.ColorFormat_DXT5_RGBA;
            }
            texture.mimapData = mipmaps;
            return texture;
        };
        DDSParser.loadARGBMip = function (buffer, dataOffset, width, height) {
            var dataLength = width * height * 4;
            var srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);
            var byteArray = new Uint8Array(dataLength);
            var dst = 0;
            var src = 0;
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var b = srcBuffer[src];
                    src++;
                    var g = srcBuffer[src];
                    src++;
                    var r = srcBuffer[src];
                    src++;
                    var a = srcBuffer[src];
                    src++;
                    byteArray[dst] = r;
                    dst++; //r
                    byteArray[dst] = g;
                    dst++; //g
                    byteArray[dst] = b;
                    dst++; //b
                    byteArray[dst] = a;
                    dst++; //a
                }
            }
            return byteArray;
        };
        DDSParser.fourCCToInt32 = function (value) {
            return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
        };
        DDSParser.int32ToFourCC = function (value) {
            return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff69);
        };
        //软解DXT数据块到像素组;
        DDSParser.softSolutionDXT = function (width, height, format, byteArray) {
            var nCount;
            var colorArray = new Uint8Array(width * height * 4);
            //色彩表;
            var colorTab = [new egret3d.Color(), new egret3d.Color(), new egret3d.Color(), new egret3d.Color()];
            //索引表;
            var indexTab = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            switch (format) {
                case DDSFormat.RGB_S3TC_DXT1_FORMAT:
                case DDSFormat.RGBA_S3TC_DXT1_FORMAT:
                    {
                        nCount = byteArray.length / 8;
                        for (var blockIndex = 0; blockIndex < nCount; blockIndex++) {
                            var _16bit_0 = byteArray[blockIndex * 8 + 0] | (byteArray[blockIndex * 8 + 1] << 8);
                            var _16bit_1 = byteArray[blockIndex * 8 + 2] | (byteArray[blockIndex * 8 + 3] << 8);
                            //极端颜色1;
                            colorTab[0].r = (_16bit_0 >> 11) & 0x1F;
                            colorTab[0].g = (_16bit_0 >> 5) & 0x3F;
                            colorTab[0].b = _16bit_0 & 0x1F;
                            colorTab[0].a = 0xFF;
                            //极端颜色2;
                            colorTab[1].r = (_16bit_1 >> 11) & 0x1F;
                            colorTab[1].g = (_16bit_1 >> 5) & 0x3F;
                            colorTab[1].b = _16bit_1 & 0x1F;
                            colorTab[1].a = 0xFF;
                            if (_16bit_0 > _16bit_1) {
                                //线性插值计算出剩下的两个颜色;
                                colorTab[2].lerp(colorTab[0], colorTab[1], 0.33);
                                colorTab[3].lerp(colorTab[0], colorTab[1], 0.66);
                            }
                            else {
                                //线性插值计算出剩下的一个颜色;
                                colorTab[2].lerp(colorTab[0], colorTab[1], 0.5);
                            }
                            //取出16个2位索引;
                            for (var i = 0; i < 4; i++) {
                                indexTab[(i * 4) + 0] = byteArray[blockIndex * 8 + 4 + i] & 0x03;
                                indexTab[(i * 4) + 1] = (byteArray[blockIndex * 8 + 4 + i] >> 2) & 0x03;
                                indexTab[(i * 4) + 2] = (byteArray[blockIndex * 8 + 4 + i] >> 4) & 0x03;
                                indexTab[(i * 4) + 3] = (byteArray[blockIndex * 8 + 4 + i] >> 6) & 0x03;
                            }
                            for (var ci = 0; ci < colorTab.length; ci++) {
                                colorTab[ci].r = colorTab[ci].r * 8;
                                colorTab[ci].g = colorTab[ci].g * 4;
                                colorTab[ci].b = colorTab[ci].b * 8;
                            }
                            //填充像素数组;
                            var globalX = (blockIndex % (width / 4)) * 4;
                            var globalY = Math.floor(blockIndex / (width / 4)) * 4;
                            if (globalY + 0 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[0]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[0]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[0]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 3] = colorTab[indexTab[0]].a;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[1]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[1]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[1]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 3] = colorTab[indexTab[1]].a;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[2]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[2]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[2]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 3] = colorTab[indexTab[2]].a;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[3]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[3]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[3]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 3] = colorTab[indexTab[3]].a;
                                }
                            }
                            if (globalY + 1 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[4]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[4]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[4]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 3] = colorTab[indexTab[4]].a;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[5]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[5]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[5]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 3] = colorTab[indexTab[5]].a;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[6]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[6]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[6]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 3] = colorTab[indexTab[6]].a;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[7]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[7]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[7]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 3] = colorTab[indexTab[7]].a;
                                }
                            }
                            if (globalY + 2 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[8]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[8]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[8]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 3] = colorTab[indexTab[8]].a;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[9]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[9]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[9]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 3] = colorTab[indexTab[9]].a;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[10]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[10]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[10]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 3] = colorTab[indexTab[10]].a;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[11]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[11]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[11]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 3] = colorTab[indexTab[11]].a;
                                }
                            }
                            if (globalY + 3 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[12]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[12]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[12]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 3] = colorTab[indexTab[12]].a;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[13]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[13]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[13]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 3] = colorTab[indexTab[13]].a;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[14]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[14]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[14]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 3] = colorTab[indexTab[14]].a;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[15]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[15]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[15]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 3] = colorTab[indexTab[15]].a;
                                }
                            }
                        }
                    }
                    break;
                case DDSFormat.RGBA_S3TC_DXT3_FORMAT:
                    {
                        nCount = byteArray.length / 16;
                        for (var blockIndex = 0; blockIndex < nCount; blockIndex++) {
                            var _16bit_0 = byteArray[blockIndex * 16 + 8] | (byteArray[blockIndex * 16 + 9] << 8);
                            var _16bit_1 = byteArray[blockIndex * 16 + 10] | (byteArray[blockIndex * 16 + 11] << 8);
                            //极端颜色1;
                            colorTab[0].r = (_16bit_0 >> 11) & 0x1F;
                            colorTab[0].g = (_16bit_0 >> 5) & 0x3F;
                            colorTab[0].b = _16bit_0 & 0x1F;
                            colorTab[0].a = 0xFF;
                            //极端颜色2;
                            colorTab[1].r = (_16bit_1 >> 11) & 0x1F;
                            colorTab[1].g = (_16bit_1 >> 5) & 0x3F;
                            colorTab[1].b = _16bit_1 & 0x1F;
                            colorTab[1].a = 0xFF;
                            if (_16bit_0 > _16bit_1) {
                                //线性插值计算出剩下的两个颜色;
                                colorTab[2].lerp(colorTab[0], colorTab[1], 0.33);
                                colorTab[3].lerp(colorTab[0], colorTab[1], 0.66);
                            }
                            else {
                                //线性插值计算出剩下的一个颜色;
                                colorTab[2].lerp(colorTab[0], colorTab[1], 0.5);
                                colorTab[3].a = 0;
                            }
                            //取出16个2位索引;
                            for (var i = 0; i < 4; i++) {
                                indexTab[(i * 4) + 0] = byteArray[blockIndex * 16 + 12 + i] & 0x03;
                                indexTab[(i * 4) + 1] = (byteArray[blockIndex * 16 + 12 + i] >> 2) & 0x03;
                                indexTab[(i * 4) + 2] = (byteArray[blockIndex * 16 + 12 + i] >> 4) & 0x03;
                                indexTab[(i * 4) + 3] = (byteArray[blockIndex * 16 + 12 + i] >> 6) & 0x03;
                            }
                            for (var ci = 0; ci < colorTab.length; ci++) {
                                colorTab[ci].r = colorTab[ci].r * 8;
                                colorTab[ci].g = colorTab[ci].g * 4;
                                colorTab[ci].b = colorTab[ci].b * 8;
                            }
                            //填充像素数组;
                            var globalX = (blockIndex % (width / 4)) * 4;
                            var globalY = Math.floor(blockIndex / (width / 4)) * 4;
                            if (globalY + 0 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[0]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[0]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[0]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 3] = (byteArray[blockIndex * 16 + 0] & 0x0F) * 17;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[1]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[1]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[1]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 3] = ((byteArray[blockIndex * 16 + 0] >> 4) & 0x0F) * 17;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[2]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[2]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[2]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 3] = (byteArray[blockIndex * 16 + 1] & 0x0F) * 17;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[3]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[3]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[3]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 3] = ((byteArray[blockIndex * 16 + 1] >> 4) & 0x0F) * 17;
                                }
                            }
                            if (globalY + 1 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[4]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[4]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[4]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 3] = (byteArray[blockIndex * 16 + 2] & 0x0F) * 17;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[5]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[5]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[5]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 3] = ((byteArray[blockIndex * 16 + 2] >> 4) & 0x0F) * 17;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[6]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[6]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[6]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 3] = (byteArray[blockIndex * 16 + 3] & 0x0F) * 17;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[7]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[7]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[7]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 3] = ((byteArray[blockIndex * 16 + 3] >> 4) & 0x0F) * 17;
                                }
                            }
                            if (globalY + 2 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[8]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[8]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[8]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 3] = (byteArray[blockIndex * 16 + 4] & 0x0F) * 17;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[9]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[9]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[9]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 3] = ((byteArray[blockIndex * 16 + 4] >> 4) & 0x0F) * 17;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[10]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[10]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[10]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 3] = (byteArray[blockIndex * 16 + 5] & 0x0F) * 17;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[11]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[11]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[11]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 3] = ((byteArray[blockIndex * 16 + 5] >> 4) & 0x0F) * 17;
                                }
                            }
                            if (globalY + 3 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[12]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[12]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[12]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 3] = (byteArray[blockIndex * 16 + 6] & 0x0F) * 17;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[13]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[13]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[13]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 3] = ((byteArray[blockIndex * 16 + 6] >> 4) & 0x0F) * 17;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[14]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[14]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[14]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 3] = (byteArray[blockIndex * 16 + 7] & 0x0F) * 17;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[15]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[15]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[15]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 3] = ((byteArray[blockIndex * 16 + 7] >> 4) & 0x0F) * 17;
                                }
                            }
                        }
                    }
                    break;
                case DDSFormat.RGBA_S3TC_DXT5_FORMAT:
                    break;
            }
            return colorArray;
        };
        return DDSParser;
    }());
    egret3d.DDSParser = DDSParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    (function (PVRFormat) {
        PVRFormat[PVRFormat["RGB_PVRTC_4BPPV1_Format"] = 2100] = "RGB_PVRTC_4BPPV1_Format";
        PVRFormat[PVRFormat["RGB_PVRTC_2BPPV1_Format"] = 2101] = "RGB_PVRTC_2BPPV1_Format";
        PVRFormat[PVRFormat["RGBA_PVRTC_4BPPV1_Format"] = 2102] = "RGBA_PVRTC_4BPPV1_Format";
        PVRFormat[PVRFormat["RGBA_PVRTC_2BPPV1_Format"] = 2103] = "RGBA_PVRTC_2BPPV1_Format";
    })(egret3d.PVRFormat || (egret3d.PVRFormat = {}));
    var PVRFormat = egret3d.PVRFormat;
    ;
    /**
     * @private
     * @language zh_CN
     * @class egret3d.PVRParser
     * @classdesc
     * �� PVRParser �� ����.pvr �ļ�
     */
    var PVRParser = (function () {
        function PVRParser() {
        }
        /**
         * @language zh_CN
         * @param buffer
         */
        PVRParser.parse = function (buffer) {
            var texture;
            var headerLengthInt = 13;
            var header = new Uint32Array(buffer, 0, headerLengthInt);
            var pvrDatas = {
                buffer: buffer,
                header: header
            };
            // PVR v3
            if (header[0] === 0x03525650) {
                texture = PVRParser._parseV3(pvrDatas);
            }
            else if (header[11] === 0x21525650) {
                texture = PVRParser._parseV2(pvrDatas);
            }
            else {
                console.log("PVRParser unknow pvr format. PVRParser::parse");
                return texture;
            }
            texture.internalFormat = egret3d.InternalFormat.PixelArray;
            texture.colorFormat = egret3d.ContextConfig.ColorFormat_RGBA8888;
            texture.useMipmap = false;
            return texture;
        };
        PVRParser._parseV2 = function (pvrDatas) {
            var header = pvrDatas.header;
            var headerLength = header[0], height = header[1], width = header[2], numMipmaps = header[3], flags = header[4], dataLength = header[5], bpp = header[6], bitmaskRed = header[7], bitmaskGreen = header[8], bitmaskBlue = header[9], bitmaskAlpha = header[10], pvrTag = header[11], numSurfs = header[12];
            var TYPE_MASK = 0xff;
            var PVRTC_2 = 24, PVRTC_4 = 25;
            var formatFlags = flags & TYPE_MASK;
            var bpp, format;
            var _hasAlpha = bitmaskAlpha > 0;
            if (formatFlags === PVRTC_4) {
                format = _hasAlpha ? PVRFormat.RGBA_PVRTC_4BPPV1_Format : PVRFormat.RGB_PVRTC_4BPPV1_Format;
                bpp = 4;
            }
            else if (formatFlags === PVRTC_2) {
                format = _hasAlpha ? PVRFormat.RGBA_PVRTC_2BPPV1_Format : PVRFormat.RGB_PVRTC_2BPPV1_Format;
                bpp = 2;
            }
            else
                throw new Error("pvrtc - unknown format " + formatFlags);
            pvrDatas.dataPtr = headerLength;
            pvrDatas.bpp = bpp;
            pvrDatas.format = format;
            pvrDatas.width = width;
            pvrDatas.height = height;
            pvrDatas.numSurfaces = numSurfs;
            pvrDatas.numMipmaps = numMipmaps + 1;
            // guess cubemap type seems tricky in v2
            // it juste a pvr containing 6 surface (no explicit cubemap type)
            pvrDatas.isCubemap = (numSurfs === 6);
            return PVRParser._extract(pvrDatas);
        };
        PVRParser._parseV3 = function (pvrDatas) {
            var header = pvrDatas.header;
            var bpp, format;
            var metaLen = header[12], pixelFormat = header[2], height = header[6], width = header[7], numSurfs = header[9], numFaces = header[10], numMipmaps = header[11];
            switch (pixelFormat) {
                case 0:
                    bpp = 2;
                    format = PVRFormat.RGB_PVRTC_2BPPV1_Format;
                    break;
                case 1:
                    bpp = 2;
                    format = PVRFormat.RGBA_PVRTC_2BPPV1_Format;
                    break;
                case 2:
                    bpp = 4;
                    format = PVRFormat.RGB_PVRTC_4BPPV1_Format;
                    break;
                case 3:
                    bpp = 4;
                    format = PVRFormat.RGBA_PVRTC_4BPPV1_Format;
                    break;
                default:
                    throw new Error("pvrtc - unsupported PVR format " + pixelFormat);
            }
            pvrDatas.dataPtr = 52 + metaLen;
            pvrDatas.bpp = bpp;
            pvrDatas.format = format;
            pvrDatas.width = width;
            pvrDatas.height = height;
            pvrDatas.numSurfaces = numFaces;
            pvrDatas.numMipmaps = numMipmaps;
            pvrDatas.isCubemap = (numFaces === 6);
            return PVRParser._extract(pvrDatas);
        };
        PVRParser._extract = function (pvrDatas) {
            var texture = new egret3d.Texture();
            texture.width = pvrDatas.width;
            texture.height = pvrDatas.height;
            var buffer = pvrDatas.buffer;
            var dataOffset = pvrDatas.dataPtr, bpp = pvrDatas.bpp, numSurfs = pvrDatas.numSurfaces, dataSize = 0, blockSize = 0, blockWidth = 0, blockHeight = 0, widthBlocks = 0, heightBlocks = 0;
            if (bpp === 2) {
                blockWidth = 8;
                blockHeight = 4;
            }
            else {
                blockWidth = 4;
                blockHeight = 4;
            }
            blockSize = (blockWidth * blockHeight) * bpp / 8;
            texture.mimapData = [];
            //pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;
            var mipLevel = 0;
            while (mipLevel < pvrDatas.numMipmaps) {
                var sWidth = pvrDatas.width >> mipLevel;
                var sHeight = pvrDatas.height >> mipLevel;
                widthBlocks = sWidth / blockWidth;
                heightBlocks = sHeight / blockHeight;
                // Clamp to minimum number of blocks
                if (widthBlocks < 2) {
                    widthBlocks = 2;
                }
                if (heightBlocks < 2) {
                    heightBlocks = 2;
                }
                dataSize = widthBlocks * heightBlocks * blockSize;
                for (var surfIndex = 0; surfIndex < numSurfs; surfIndex++) {
                    var byteArray = new Uint8Array(buffer, dataOffset, dataSize);
                    var mipmap = {
                        data: byteArray,
                        width: sWidth,
                        height: sHeight
                    };
                    texture.mimapData[surfIndex * pvrDatas.numMipmaps + mipLevel] = mipmap;
                    dataOffset += dataSize;
                }
                mipLevel++;
            }
            return texture;
        };
        return PVRParser;
    }());
    egret3d.PVRParser = PVRParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.TGAParser
     * @classdesc
     * 用 TGAParser 类 解析.tga 文件
     */
    var TGAParser = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function TGAParser() {
        }
        /**
         * @language zh_CN
         * @param buffer 二进制流
         * @returns MimapTexture
         */
        TGAParser.parse = function (buffer) {
            var TGA_TYPE_NO_DATA = 0, TGA_TYPE_INDEXED = 1, TGA_TYPE_RGB = 2, TGA_TYPE_GREY = 3, TGA_TYPE_RLE_INDEXED = 9, TGA_TYPE_RLE_RGB = 10, TGA_TYPE_RLE_GREY = 11, TGA_ORIGIN_MASK = 0x30, TGA_ORIGIN_SHIFT = 0x04, TGA_ORIGIN_BL = 0x00, TGA_ORIGIN_BR = 0x01, TGA_ORIGIN_UL = 0x02, TGA_ORIGIN_UR = 0x03;
            if (buffer.byteLength < 19) {
                console.error('TGAParser.parse: Not enough data to contain header.');
            }
            var content = new Uint8Array(buffer), offset = 0, header = {
                id_length: content[offset++],
                colormap_type: content[offset++],
                image_type: content[offset++],
                colormap_index: content[offset++] | content[offset++] << 8,
                colormap_length: content[offset++] | content[offset++] << 8,
                colormap_size: content[offset++],
                origin: [
                    content[offset++] | content[offset++] << 8,
                    content[offset++] | content[offset++] << 8
                ],
                width: content[offset++] | content[offset++] << 8,
                height: content[offset++] | content[offset++] << 8,
                pixel_size: content[offset++],
                flags: content[offset++]
            };
            function tgaCheckHeader(header) {
                switch (header.image_type) {
                    // Check indexed type
                    case TGA_TYPE_INDEXED:
                    case TGA_TYPE_RLE_INDEXED:
                        if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {
                            console.error('TGAParser.parse.tgaCheckHeader: Invalid type colormap data for indexed type');
                        }
                        break;
                    // Check colormap type
                    case TGA_TYPE_RGB:
                    case TGA_TYPE_GREY:
                    case TGA_TYPE_RLE_RGB:
                    case TGA_TYPE_RLE_GREY:
                        if (header.colormap_type) {
                            console.error('TGAParser.parse.tgaCheckHeader: Invalid type colormap data for colormap type');
                        }
                        break;
                    // What the need of a file without data ?
                    case TGA_TYPE_NO_DATA:
                        console.error('TGAParser.parse.tgaCheckHeader: No data');
                        break;
                    // Invalid type ?
                    default:
                        console.error('TGAParser.parse.tgaCheckHeader: Invalid type " ' + header.image_type + '"');
                }
                // Check image width and height
                if (header.width <= 0 || header.height <= 0) {
                    console.error('TGAParser.parse.tgaCheckHeader: Invalid image size');
                }
                // Check image pixel size
                if (header.pixel_size !== 8 &&
                    header.pixel_size !== 16 &&
                    header.pixel_size !== 24 &&
                    header.pixel_size !== 32) {
                    console.error('TGAParser.parse.tgaCheckHeader: Invalid pixel size "' + header.pixel_size + '"');
                }
            }
            // Check tga if it is valid format
            tgaCheckHeader(header);
            if (header.id_length + offset > buffer.byteLength) {
                console.error('TGAParser.parse: No data');
            }
            // Skip the needn't data
            offset += header.id_length;
            // Get targa information about RLE compression and palette
            var use_rle = false, use_pal = false, use_grey = false;
            switch (header.image_type) {
                case TGA_TYPE_RLE_INDEXED:
                    use_rle = true;
                    use_pal = true;
                    break;
                case TGA_TYPE_INDEXED:
                    use_pal = true;
                    break;
                case TGA_TYPE_RLE_RGB:
                    use_rle = true;
                    break;
                case TGA_TYPE_RGB:
                    break;
                case TGA_TYPE_RLE_GREY:
                    use_rle = true;
                    use_grey = true;
                    break;
                case TGA_TYPE_GREY:
                    use_grey = true;
                    break;
            }
            // Parse tga image buffer
            function tgaParse(use_rle, use_pal, header, offset, data) {
                var pixel_data, pixel_size, pixel_total, palettes;
                pixel_size = header.pixel_size >> 3;
                pixel_total = header.width * header.height * pixel_size;
                // Read palettes
                if (use_pal) {
                    palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));
                }
                // Read RLE
                if (use_rle) {
                    pixel_data = new Uint8Array(pixel_total);
                    var c, count, i;
                    var shift = 0;
                    var pixels = new Uint8Array(pixel_size);
                    while (shift < pixel_total) {
                        c = data[offset++];
                        count = (c & 0x7f) + 1;
                        // RLE pixels.
                        if (c & 0x80) {
                            // Bind pixel tmp array
                            for (i = 0; i < pixel_size; ++i) {
                                pixels[i] = data[offset++];
                            }
                            // Copy pixel array
                            for (i = 0; i < count; ++i) {
                                pixel_data.set(pixels, shift + i * pixel_size);
                            }
                            shift += pixel_size * count;
                        }
                        else {
                            // Raw pixels.
                            count *= pixel_size;
                            for (i = 0; i < count; ++i) {
                                pixel_data[shift + i] = data[offset++];
                            }
                            shift += count;
                        }
                    }
                }
                else {
                    // RAW Pixels
                    pixel_data = data.subarray(offset, offset += (use_pal ? header.width * header.height : pixel_total));
                }
                return {
                    pixel_data: pixel_data,
                    palettes: palettes
                };
            }
            function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {
                var colormap = palettes;
                var color, i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i++) {
                        color = image[i];
                        imageData[(x + width * y) * 4 + 3] = 255;
                        imageData[(x + width * y) * 4 + 2] = colormap[(color * 3) + 0];
                        imageData[(x + width * y) * 4 + 1] = colormap[(color * 3) + 1];
                        imageData[(x + width * y) * 4 + 0] = colormap[(color * 3) + 2];
                    }
                }
                return imageData;
            }
            function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var color, i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i += 2) {
                        color = image[i + 0] + (image[i + 1] << 8); // Inversed ?
                        imageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;
                        imageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;
                        imageData[(x + width * y) * 4 + 2] = (color & 0x001F) >> 3;
                        imageData[(x + width * y) * 4 + 3] = (color & 0x8000) ? 0 : 255;
                    }
                }
                return imageData;
            }
            function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i += 3) {
                        imageData[(x + width * y) * 4 + 3] = 255;
                        imageData[(x + width * y) * 4 + 2] = image[i + 0];
                        imageData[(x + width * y) * 4 + 1] = image[i + 1];
                        imageData[(x + width * y) * 4 + 0] = image[i + 2];
                    }
                }
                return imageData;
            }
            function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i += 4) {
                        imageData[(x + width * y) * 4 + 2] = image[i + 0];
                        imageData[(x + width * y) * 4 + 1] = image[i + 1];
                        imageData[(x + width * y) * 4 + 0] = image[i + 2];
                        imageData[(x + width * y) * 4 + 3] = image[i + 3];
                    }
                }
                return imageData;
            }
            function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var color, i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i++) {
                        color = image[i];
                        imageData[(x + width * y) * 4 + 0] = color;
                        imageData[(x + width * y) * 4 + 1] = color;
                        imageData[(x + width * y) * 4 + 2] = color;
                        imageData[(x + width * y) * 4 + 3] = 255;
                    }
                }
                return imageData;
            }
            function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i += 2) {
                        imageData[(x + width * y) * 4 + 0] = image[i + 0];
                        imageData[(x + width * y) * 4 + 1] = image[i + 0];
                        imageData[(x + width * y) * 4 + 2] = image[i + 0];
                        imageData[(x + width * y) * 4 + 3] = image[i + 1];
                    }
                }
                return imageData;
            }
            function getTgaRGBA(width, height, image, palette) {
                var x_start, y_start, x_step, y_step, x_end, y_end, data = new Uint8Array(width * height * 4);
                switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {
                    default:
                    case TGA_ORIGIN_UL:
                        x_start = 0;
                        x_step = 1;
                        x_end = width;
                        y_start = 0;
                        y_step = 1;
                        y_end = height;
                        break;
                    case TGA_ORIGIN_BL:
                        x_start = 0;
                        x_step = 1;
                        x_end = width;
                        y_start = height - 1;
                        y_step = -1;
                        y_end = -1;
                        break;
                    case TGA_ORIGIN_UR:
                        x_start = width - 1;
                        x_step = -1;
                        x_end = -1;
                        y_start = 0;
                        y_step = 1;
                        y_end = height;
                        break;
                    case TGA_ORIGIN_BR:
                        x_start = width - 1;
                        x_step = -1;
                        x_end = -1;
                        y_start = height - 1;
                        y_step = -1;
                        y_end = -1;
                        break;
                }
                if (use_grey) {
                    switch (header.pixel_size) {
                        case 8:
                            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        case 16:
                            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        default:
                            console.error('TGAParser.parse.getTgaRGBA: not support this format');
                            break;
                    }
                }
                else {
                    switch (header.pixel_size) {
                        case 8:
                            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);
                            break;
                        case 16:
                            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        case 24:
                            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        case 32:
                            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        default:
                            console.error('TGAParser.parse.getTgaRGBA: not support this format');
                            break;
                    }
                }
                // Load image data according to specific method
                // var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';
                // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );
                return data;
            }
            var result = tgaParse(use_rle, use_pal, header, offset, content);
            var rgbaData = getTgaRGBA(header.width, header.height, result.pixel_data, result.palettes);
            var texture = new egret3d.Texture();
            texture.width = header.width;
            texture.height = header.height;
            texture.internalFormat = egret3d.InternalFormat.PixelArray;
            texture.colorFormat = egret3d.ContextConfig.ColorFormat_RGBA8888;
            texture.mimapData = [new egret3d.MipmapData(rgbaData, header.width, header.height)];
            return texture;
        };
        return TGAParser;
    }());
    egret3d.TGAParser = TGAParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var HDRParser = (function () {
        function HDRParser() {
        }
        //http://croquetweak.blogspot.co.uk/2014/08/deconstructing-floats-frexp-and-ldexp.html
        HDRParser.ldexp = function (mantissa, exponent) {
            return exponent > 1023 // avoid multiplying by infinity
                ? mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023)
                : exponent < -1074 // avoid multiplying by zero
                    ? mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074)
                    : mantissa * Math.pow(2, exponent);
        };
        HDRParser.readPixelsRawRLE = function (buffer, data, offset, fileOffset, scanline_width, num_scanlines) {
            var rgbe = new Array(4);
            var scanline_buffer = null;
            var ptr;
            var ptr_end;
            var count;
            var buf = new Array(2);
            var bufferLength = buffer.length;
            function readBuf(buf) {
                var bytesRead = 0;
                do {
                    buf[bytesRead++] = buffer[fileOffset];
                } while (++fileOffset < bufferLength && bytesRead < buf.length);
                return bytesRead;
            }
            function readBufOffset(buf, offset, length) {
                var bytesRead = 0;
                do {
                    buf[offset + bytesRead++] = buffer[fileOffset];
                } while (++fileOffset < bufferLength && bytesRead < length);
                return bytesRead;
            }
            function readPixelsRaw(buffer, data, offset, numpixels) {
                var numExpected = 4 * numpixels;
                var numRead = readBufOffset(data, offset, numExpected);
                if (numRead < numExpected) {
                    throw new Error('Error reading raw pixels: got ' + numRead + ' bytes, expected ' + numExpected);
                }
            }
            while (num_scanlines > 0) {
                if (readBuf(rgbe) < rgbe.length) {
                    throw new Error("Error reading bytes: expected " + rgbe.length);
                }
                if ((rgbe[0] != 2) || (rgbe[1] != 2) || ((rgbe[2] & 0x80) != 0)) {
                    //this file is not run length encoded
                    data[offset++] = rgbe[0];
                    data[offset++] = rgbe[1];
                    data[offset++] = rgbe[2];
                    data[offset++] = rgbe[3];
                    readPixelsRaw(buffer, data, offset, scanline_width * num_scanlines - 1);
                    return;
                }
                if ((((rgbe[2] & 0xFF) << 8) | (rgbe[3] & 0xFF)) != scanline_width) {
                    throw new Error("Wrong scanline width " + (((rgbe[2] & 0xFF) << 8) | (rgbe[3] & 0xFF)) + ", expected " + scanline_width);
                }
                if (scanline_buffer == null) {
                    scanline_buffer = new Array(4 * scanline_width);
                }
                ptr = 0;
                /* read each of the four channels for the scanline into the buffer */
                for (var i = 0; i < 4; i++) {
                    ptr_end = (i + 1) * scanline_width;
                    while (ptr < ptr_end) {
                        if (readBuf(buf) < buf.length) {
                            throw new Error("Error reading 2-byte buffer");
                        }
                        if ((buf[0] & 0xFF) > 128) {
                            /* a run of the same value */
                            count = (buf[0] & 0xFF) - 128;
                            if ((count == 0) || (count > ptr_end - ptr)) {
                                throw new Error("Bad scanline data");
                            }
                            while (count-- > 0)
                                scanline_buffer[ptr++] = buf[1];
                        }
                        else {
                            /* a non-run */
                            count = buf[0] & 0xFF;
                            if ((count == 0) || (count > ptr_end - ptr)) {
                                throw new Error("Bad scanline data");
                            }
                            scanline_buffer[ptr++] = buf[1];
                            if (--count > 0) {
                                if (readBufOffset(scanline_buffer, ptr, count) < count) {
                                    throw new Error("Error reading non-run data");
                                }
                                ptr += count;
                            }
                        }
                    }
                }
                /* copy byte data to output */
                for (var i = 0; i < scanline_width; i++) {
                    data[offset + 0] = scanline_buffer[i];
                    data[offset + 1] = scanline_buffer[i + scanline_width];
                    data[offset + 2] = scanline_buffer[i + 2 * scanline_width];
                    data[offset + 3] = scanline_buffer[i + 3 * scanline_width];
                    offset += 4;
                }
                num_scanlines--;
            }
        };
        //Returns data as floats and flipped along Y by default
        HDRParser.parse = function (buffer) {
            if (buffer instanceof ArrayBuffer) {
                buffer = new Uint8Array(buffer);
            }
            var fileOffset = 0;
            var bufferLength = buffer.length;
            var NEW_LINE = 10;
            function readLine() {
                var buf = "";
                do {
                    var b = buffer[fileOffset];
                    if (b == NEW_LINE) {
                        ++fileOffset;
                        break;
                    }
                    buf += String.fromCharCode(b);
                } while (++fileOffset < bufferLength);
                return buf;
            }
            var width = 0;
            var height = 0;
            var exposure = 1;
            var gamma = 1;
            var rle = false;
            for (var i = 0; i < 20; i++) {
                var line = readLine();
                var match;
                if (match = line.match(HDRParser.radiancePattern)) {
                }
                else if (match = line.match(HDRParser.formatPattern)) {
                    rle = true;
                }
                else if (match = line.match(HDRParser.exposurePattern)) {
                    exposure = Number(match[1]);
                }
                else if (match = line.match(HDRParser.commentPattern)) {
                }
                else if (match = line.match(HDRParser.widthHeightPattern)) {
                    height = Number(match[1]);
                    width = Number(match[2]);
                    break;
                }
            }
            if (!rle) {
                throw new Error("File is not run length encoded!");
            }
            var data = new Uint8Array(width * height * 4);
            var scanline_width = width;
            var num_scanlines = height;
            this.readPixelsRawRLE(buffer, data, 0, fileOffset, scanline_width, num_scanlines);
            var mipmapCount = 1;
            var mipmap = new egret3d.MipmapData(data, width, height);
            var texture = new egret3d.Texture();
            texture.internalFormat = egret3d.InternalFormat.PixelArray;
            texture.colorFormat = egret3d.ContextConfig.ColorFormat_RGBA8888;
            texture.mimapData = [mipmap];
            texture.useMipmap = false;
            texture.width = width;
            texture.height = height;
            return texture;
        };
        HDRParser.radiancePattern = "#\\?RADIANCE";
        HDRParser.commentPattern = "#.*";
        HDRParser.gammaPattern = "GAMMA=";
        HDRParser.exposurePattern = "EXPOSURE=\\s*([0-9]*[.][0-9]*)";
        HDRParser.formatPattern = "FORMAT=32-bit_rle_rgbe";
        HDRParser.widthHeightPattern = "-Y ([0-9]+) \\+X ([0-9]+)";
        return HDRParser;
    }());
    egret3d.HDRParser = HDRParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.EAMParser
     * @classdesc
     * 用 EAMParser 类 解析.eam 文件
     */
    var EAMParser = (function () {
        function EAMParser() {
        }
        /**
         * @language zh_CN
         * @param datas 加载的二进制流
         * @returns SkeletonAnimationClip
         */
        EAMParser.parse = function (datas) {
            var bytes = new egret3d.ByteArray(datas);
            var fileFormatBytes = new egret3d.ByteArray();
            bytes.readBytes(fileFormatBytes, 0, 3);
            var version = bytes.readUnsignedInt();
            if (!egret3d.EAMVersion.versionDictionary[version]) {
                console.log("egret3d engine not found " + version + " version");
                return null;
            }
            return egret3d.EAMVersion.versionDictionary[version](bytes);
        };
        return EAMParser;
    }());
    egret3d.EAMParser = EAMParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.EAMVersion
     * @classdesc
     *
     */
    var EAMVersion = (function () {
        function EAMVersion() {
        }
        EAMVersion.findNameIndex = function (nameArray, name) {
            if ("" == name) {
                return -1;
            }
            for (var i = 0; i < nameArray.length; ++i) {
                if (name == nameArray[i]) {
                    return i;
                }
            }
            return -1;
        };
        EAMVersion.parserVersion_1 = function (bytes) {
            var boneCount = bytes.readUnsignedByte();
            var sampling = bytes.readUnsignedByte();
            if (boneCount <= 0)
                return null;
            var skeletonAnimationClip = new egret3d.SkeletonAnimationClip();
            var boneNameArray = skeletonAnimationClip.boneNameArray;
            var parentBoneNameArray = new Array();
            for (var i = 0; i < boneCount; i++) {
                boneNameArray.push(bytes.readUTF());
                parentBoneNameArray.push(bytes.readUTF());
            }
            var frameCount = bytes.readInt();
            var nCount = bytes.readInt();
            var orientation = new egret3d.Quaternion();
            var scale = new egret3d.Vector3D();
            var translation = new egret3d.Vector3D();
            for (var i = 0; i < nCount; i++) {
                var skeletonPose = new egret3d.SkeletonPose();
                skeletonPose.frame = bytes.readInt() / 60 / 80 * 1000;
                for (var j = 0; j < boneCount; j++) {
                    var jointPose = new egret3d.Joint();
                    //jointPose.name = boneNameArray[j];
                    //jointPose.parent = parentBoneNameArray[j];
                    jointPose.index = j;
                    jointPose.parentIndex = EAMVersion.findNameIndex(boneNameArray, parentBoneNameArray[j]);
                    orientation.fromEulerAngles(bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES, bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES, bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES);
                    scale.x = bytes.readFloat();
                    scale.y = bytes.readFloat();
                    scale.z = bytes.readFloat();
                    translation.x = bytes.readFloat();
                    translation.y = bytes.readFloat();
                    translation.z = bytes.readFloat();
                    jointPose.buildLocalMatrix(scale, orientation, translation);
                    skeletonPose.joints.push(jointPose);
                }
                skeletonPose.calculateJointWorldMatrix();
                skeletonAnimationClip.addSkeletonPose(skeletonPose);
            }
            return skeletonAnimationClip;
        };
        EAMVersion.parserVersion_2 = function (bytes) {
            //读取骨骼数;
            var boneCount = bytes.readUnsignedByte();
            //读取采样率;
            var sampling = bytes.readUnsignedByte();
            if (boneCount <= 0)
                return null;
            var skeletonAnimationClip = new egret3d.SkeletonAnimationClip();
            var boneNameArray = skeletonAnimationClip.boneNameArray;
            var parentBoneNameArray = new Array();
            //读取骨骼名称;
            for (var i = 0; i < boneCount; i++) {
                boneNameArray.push(bytes.readUTF());
                parentBoneNameArray.push(bytes.readUTF());
            }
            //读取帧数;
            var frameCount = bytes.readInt();
            //读取数量;
            var nCount = bytes.readInt();
            //流数据;
            if (boneCount * frameCount >= 10000 && false) {
                skeletonAnimationClip.sampling = sampling;
                skeletonAnimationClip.boneCount = boneCount;
                skeletonAnimationClip.frameDataOffset = bytes.position;
                skeletonAnimationClip.sourceData = bytes;
                skeletonAnimationClip.buildInitialSkeleton(boneNameArray, parentBoneNameArray, nCount);
            }
            else {
                var orientation = new egret3d.Quaternion();
                var scale = new egret3d.Vector3D();
                var translation = new egret3d.Vector3D();
                var maxFrame = 0;
                for (var i = 0; i < nCount; i++) {
                    var skeletonPose = new egret3d.SkeletonPose();
                    skeletonPose.boneNameArray = boneNameArray;
                    //读取该帧时刻;
                    skeletonPose.frame = bytes.readInt();
                    maxFrame = Math.max(skeletonPose.frameTime, maxFrame);
                    for (var j = 0; j < boneCount; j++) {
                        var jointPose = new egret3d.Joint();
                        jointPose.index = j;
                        jointPose.parentIndex = EAMVersion.findNameIndex(boneNameArray, parentBoneNameArray[j]);
                        //读取旋转四元数分量;
                        orientation.x = bytes.readFloat();
                        orientation.y = bytes.readFloat();
                        orientation.z = bytes.readFloat();
                        orientation.w = bytes.readFloat();
                        //读取缩放分量;
                        scale.x = bytes.readFloat();
                        scale.y = bytes.readFloat();
                        scale.z = bytes.readFloat();
                        //读取平移分量;
                        translation.x = bytes.readFloat();
                        translation.y = bytes.readFloat();
                        translation.z = bytes.readFloat();
                        jointPose.buildLocalMatrix(scale, orientation, translation);
                        skeletonPose.joints.push(jointPose);
                    }
                    skeletonAnimationClip.addSkeletonPose(skeletonPose);
                }
                //这里要检查
                skeletonAnimationClip.totalTime = nCount * skeletonAnimationClip.frameRate;
                skeletonAnimationClip.totalFrame = nCount;
            }
            return skeletonAnimationClip;
        };
        EAMVersion.parserVersion_3 = function (bytes) {
            //读取骨骼数;
            var boneCount = bytes.readUnsignedByte();
            //读取采样率;
            var sampling = bytes.readUnsignedByte();
            //读取帧数;
            var frameRate = bytes.readInt();
            //总帧数;
            var totalFrame = bytes.readInt();
            //读取数量;
            var samplingFrame = bytes.readInt();
            var skeletonAnimationClip = new egret3d.SkeletonAnimationClip();
            var boneNameArray = skeletonAnimationClip.boneNameArray;
            var parentBoneNameArray = new Array();
            //读取骨骼名称;
            for (var i = 0; i < boneCount; i++) {
                boneNameArray.push(bytes.readUTF());
                parentBoneNameArray.push(bytes.readUTF());
            }
            //流数据;
            if (boneCount * samplingFrame >= 10000 && false) {
                skeletonAnimationClip.sampling = sampling;
                skeletonAnimationClip.boneCount = boneCount;
                skeletonAnimationClip.frameDataOffset = bytes.position;
                skeletonAnimationClip.sourceData = bytes;
                skeletonAnimationClip.buildInitialSkeleton(boneNameArray, parentBoneNameArray, samplingFrame);
            }
            else {
                var orientation = new egret3d.Quaternion();
                var scale = new egret3d.Vector3D();
                var translation = new egret3d.Vector3D();
                var maxFrame = 0;
                for (var i = 0; i < samplingFrame; i++) {
                    var skeletonPose = new egret3d.SkeletonPose();
                    skeletonPose.boneNameArray = boneNameArray;
                    //读取该帧时刻;
                    skeletonPose.frame = bytes.readInt();
                    maxFrame = Math.max(skeletonPose.frameTime, maxFrame);
                    for (var j = 0; j < boneCount; j++) {
                        var jointPose = new egret3d.Joint();
                        jointPose.index = j;
                        jointPose.parentIndex = EAMVersion.findNameIndex(boneNameArray, parentBoneNameArray[j]);
                        //读取旋转四元数分量;
                        orientation.x = bytes.readFloat();
                        orientation.y = bytes.readFloat();
                        orientation.z = bytes.readFloat();
                        orientation.w = bytes.readFloat();
                        //读取缩放分量;
                        scale.x = bytes.readFloat();
                        scale.y = bytes.readFloat();
                        scale.z = bytes.readFloat();
                        //读取平移分量;
                        translation.x = bytes.readFloat();
                        translation.y = bytes.readFloat();
                        translation.z = bytes.readFloat();
                        jointPose.buildLocalMatrix(scale, orientation, translation);
                        skeletonPose.joints.push(jointPose);
                    }
                    skeletonAnimationClip.addSkeletonPose(skeletonPose);
                }
                //这里要检查
                skeletonAnimationClip.totalTime = totalFrame * skeletonAnimationClip.frameRate;
                skeletonAnimationClip.totalFrame = totalFrame;
            }
            return skeletonAnimationClip;
        };
        EAMVersion.versionDictionary = {
            1: function (bytes) { return EAMVersion.parserVersion_1(bytes); },
            2: function (bytes) { return EAMVersion.parserVersion_2(bytes); },
            3: function (bytes) { return EAMVersion.parserVersion_3(bytes); },
        };
        return EAMVersion;
    }());
    egret3d.EAMVersion = EAMVersion;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ECAParser
     * @classdesc
     * 用 EAMParser 类 解析.eca 文件
     */
    var ECAParser = (function () {
        function ECAParser() {
        }
        /**
         * @language zh_CN
         * @param datas 加载的二进制流
         * @returns CameraAnimationController
         */
        ECAParser.parse = function (datas) {
            var bytes = new egret3d.ByteArray(datas);
            var fileFormatBytes = new egret3d.ByteArray();
            bytes.readBytes(fileFormatBytes, 0, 3);
            var version = bytes.readUnsignedInt();
            if (!egret3d.ECAVersion.versionDictionary[version]) {
                console.log("egret3d engine not found " + version + " version");
                return null;
            }
            return egret3d.ECAVersion.versionDictionary[version](bytes);
        };
        return ECAParser;
    }());
    egret3d.ECAParser = ECAParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ECAVersion
     * @classdesc
     */
    var ECAVersion = (function () {
        function ECAVersion() {
        }
        ECAVersion.parserVersion_1 = function (bytes) {
            var cameraAnimationController = new egret3d.CameraAnimationController();
            var nFrame = bytes.readUnsignedInt();
            var cameraAnimationFrame = null;
            var scaling = new egret3d.Vector3D(1, 1, 1, 1);
            while (nFrame--) {
                cameraAnimationFrame = new egret3d.CameraAnimationFrame();
                cameraAnimationFrame.time = bytes.readInt();
                cameraAnimationFrame.fov = bytes.readFloat();
                cameraAnimationFrame.rotation = new egret3d.Vector3D(bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES + 90, bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES, bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES);
                cameraAnimationFrame.translation = new egret3d.Vector3D(bytes.readFloat(), bytes.readFloat(), bytes.readFloat());
                cameraAnimationFrame.matrix = new egret3d.Matrix4_4();
                cameraAnimationFrame.matrix.recompose([cameraAnimationFrame.translation, cameraAnimationFrame.rotation, scaling]);
                cameraAnimationController.cameraAnimationFrames.push(cameraAnimationFrame);
            }
            return cameraAnimationController;
        };
        ECAVersion.versionDictionary = {
            1: function (bytes) { return ECAVersion.parserVersion_1(bytes); },
        };
        return ECAVersion;
    }());
    egret3d.ECAVersion = ECAVersion;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ESMParser
     * @classdesc
     * 用 ESMParser 类 解析.esm 文件
     */
    var ESMParser = (function () {
        function ESMParser() {
        }
        /**
          * @language zh_CN
          * 从二进制流中解析出模型Geometry信息
          * @param datas 加载的二进制流
          * @returns Geometry
          */
        ESMParser.parse = function (datas, param) {
            if (param === void 0) { param = null; }
            var bytes = new egret3d.ByteArray(datas);
            var fileFormatBytes = new egret3d.ByteArray();
            bytes.readBytes(fileFormatBytes, 0, 3);
            var version = bytes.readUnsignedInt();
            if (!egret3d.ESMVersion.versionDictionary[version]) {
                console.log("egret3d engine not found " + version + " version");
                return null;
            }
            var geomtryData = new egret3d.GeometryData();
            egret3d.ESMVersion.versionDictionary[version](bytes, geomtryData, param);
            var geomtry;
            var vertexFormat = 0;
            if (geomtryData.source_skinData.length > 0) {
                vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_SKIN;
                geomtry = egret3d.GeometryData.buildGeomtry(geomtryData, vertexFormat);
            }
            else {
                vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL | egret3d.VertexFormat.VF_TANGENT | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_UV1;
                geomtry = egret3d.GeometryData.buildGeomtry(geomtryData, vertexFormat);
            }
            geomtryData = null;
            return geomtry;
        };
        return ESMParser;
    }());
    egret3d.ESMParser = ESMParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ESMVersion
     * @classdesc
     *
     */
    var ESMVersion = (function () {
        function ESMVersion() {
        }
        ESMVersion.parserVersion_1 = function (bytes, geomtry, param) {
            var description = bytes.readInt();
            geomtry.matCount = bytes.readInt();
            for (var i = 0; i < geomtry.matCount; ++i) {
                geomtry.material[i] = {};
                geomtry.material[i].matID = bytes.readInt();
                geomtry.material[i].start = bytes.readInt();
                geomtry.material[i].count = bytes.readInt();
                geomtry.material[i].textureDiffuse = bytes.readUTF();
                geomtry.material[i].textureNormal = bytes.readUTF();
                geomtry.material[i].textureSpecular = bytes.readUTF();
            }
            if (description & egret3d.VertexFormat.VF_POSITION) {
                var vertexCount = bytes.readInt();
                for (var i = 0; i < vertexCount; i++) {
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_NORMAL) {
                var vertexNormalCount = bytes.readInt();
                for (var i = 0; i < vertexNormalCount; i++) {
                    geomtry.source_normalData.push(bytes.readFloat());
                    geomtry.source_normalData.push(bytes.readFloat());
                    geomtry.source_normalData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_COLOR) {
                var vertexColorCount = bytes.readInt();
                for (var i = 0; i < vertexColorCount; i++) {
                    geomtry.source_vertexColorData.push(bytes.readFloat());
                    geomtry.source_vertexColorData.push(bytes.readFloat());
                    geomtry.source_vertexColorData.push(bytes.readFloat());
                    geomtry.source_vertexColorData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_UV0) {
                var uvCount = bytes.readInt();
                for (var i = 0; i < uvCount; i++) {
                    geomtry.source_uvData.push(bytes.readFloat());
                    geomtry.source_uvData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_UV1) {
                var uvCount = bytes.readInt();
                for (var i = 0; i < uvCount; i++) {
                    geomtry.source_uv2Data.push(bytes.readFloat());
                    geomtry.source_uv2Data.push(bytes.readFloat());
                }
            }
            geomtry.faces = bytes.readInt();
            for (var i = 0; i < geomtry.faces; i++) {
                geomtry.vertexIndices.push(bytes.readUnsignedInt());
                geomtry.vertexIndices.push(bytes.readUnsignedInt());
                geomtry.vertexIndices.push(bytes.readUnsignedInt());
                if (description & egret3d.VertexFormat.VF_NORMAL) {
                    geomtry.normalIndices.push(bytes.readUnsignedInt());
                    geomtry.normalIndices.push(bytes.readUnsignedInt());
                    geomtry.normalIndices.push(bytes.readUnsignedInt());
                }
                if (description & egret3d.VertexFormat.VF_COLOR) {
                    geomtry.colorIndices.push(bytes.readUnsignedInt());
                    geomtry.colorIndices.push(bytes.readUnsignedInt());
                    geomtry.colorIndices.push(bytes.readUnsignedInt());
                }
                if (description & egret3d.VertexFormat.VF_UV0) {
                    geomtry.uvIndices.push(bytes.readUnsignedInt());
                    geomtry.uvIndices.push(bytes.readUnsignedInt());
                    geomtry.uvIndices.push(bytes.readUnsignedInt());
                }
                if (description & egret3d.VertexFormat.VF_UV1) {
                    geomtry.uv2Indices.push(bytes.readUnsignedInt());
                    geomtry.uv2Indices.push(bytes.readUnsignedInt());
                    geomtry.uv2Indices.push(bytes.readUnsignedInt());
                }
            }
            var nBoneCount = bytes.readUnsignedByte();
            if (nBoneCount > 0) {
                geomtry.skeleton = new egret3d.Skeleton();
            }
            var orientation = new egret3d.Quaternion();
            var rotation = new egret3d.Vector3D();
            var scaling = new egret3d.Vector3D();
            var translation = new egret3d.Vector3D();
            for (var i = 0; i < nBoneCount; ++i) {
                var joint = new egret3d.Joint();
                bytes.readInt();
                joint.parentIndex = bytes.readInt();
                joint.name = bytes.readUTF();
                rotation.x = bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES;
                rotation.y = bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES;
                rotation.z = bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES;
                scaling.x = bytes.readFloat();
                scaling.y = bytes.readFloat();
                scaling.z = bytes.readFloat();
                translation.x = bytes.readFloat();
                translation.y = bytes.readFloat();
                translation.z = bytes.readFloat();
                joint.buildInverseMatrix(scaling, rotation, translation);
                geomtry.skeleton.joints.push(joint);
            }
            var nVertsCount = bytes.readInt();
            for (var i = 0; i < nVertsCount; i++) {
                var nCount = bytes.readUnsignedByte();
                for (var j = 0; j < nCount; j++) {
                    geomtry.source_skinData.push(bytes.readUnsignedByte());
                    geomtry.source_skinData.push(bytes.readFloat());
                }
                for (var j = nCount; j < 4; j++) {
                    geomtry.source_skinData.push(0);
                    geomtry.source_skinData.push(0);
                }
            }
        };
        ESMVersion.parserVersion_2 = function (bytes, geomtry, param) {
            var description = bytes.readInt();
            geomtry.matCount = bytes.readInt();
            for (var i = 0; i < geomtry.matCount; ++i) {
                geomtry.material[i] = {};
                geomtry.material[i].matID = bytes.readInt();
                geomtry.material[i].start = bytes.readInt();
                geomtry.material[i].count = bytes.readInt();
                geomtry.material[i].textureDiffuse = bytes.readUTF();
                geomtry.material[i].textureNormal = bytes.readUTF();
                geomtry.material[i].textureSpecular = bytes.readUTF();
            }
            if (description & egret3d.VertexFormat.VF_POSITION) {
                var vertexCount = bytes.readInt();
                for (var i = 0; i < vertexCount; i++) {
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_NORMAL) {
                var vertexNormalCount = bytes.readInt();
                for (var i = 0; i < vertexNormalCount; i++) {
                    geomtry.source_normalData.push(bytes.readFloat());
                    geomtry.source_normalData.push(bytes.readFloat());
                    geomtry.source_normalData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_COLOR) {
                var vertexColorCount = bytes.readInt();
                for (var i = 0; i < vertexColorCount; i++) {
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                }
            }
            if (description & egret3d.VertexFormat.VF_UV0) {
                var uvCount = bytes.readInt();
                for (var i = 0; i < uvCount; i++) {
                    geomtry.source_uvData.push(bytes.readFloat());
                    geomtry.source_uvData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_UV1) {
                var uvCount = bytes.readInt();
                for (var i = 0; i < uvCount; i++) {
                    geomtry.source_uv2Data.push(bytes.readFloat());
                    geomtry.source_uv2Data.push(bytes.readFloat());
                }
            }
            geomtry.faces = bytes.readInt();
            for (var i = 0; i < geomtry.faces; i++) {
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                if (description & egret3d.VertexFormat.VF_NORMAL) {
                    geomtry.normalIndices.push(bytes.readUnsignedShort());
                    geomtry.normalIndices.push(bytes.readUnsignedShort());
                    geomtry.normalIndices.push(bytes.readUnsignedShort());
                }
                if (description & egret3d.VertexFormat.VF_COLOR) {
                    geomtry.colorIndices.push(bytes.readUnsignedShort());
                    geomtry.colorIndices.push(bytes.readUnsignedShort());
                    geomtry.colorIndices.push(bytes.readUnsignedShort());
                }
                if (description & egret3d.VertexFormat.VF_UV0) {
                    geomtry.uvIndices.push(bytes.readUnsignedShort());
                    geomtry.uvIndices.push(bytes.readUnsignedShort());
                    geomtry.uvIndices.push(bytes.readUnsignedShort());
                }
                if (description & egret3d.VertexFormat.VF_UV1) {
                    geomtry.uv2Indices.push(bytes.readUnsignedShort());
                    geomtry.uv2Indices.push(bytes.readUnsignedShort());
                    geomtry.uv2Indices.push(bytes.readUnsignedShort());
                }
            }
            var nBoneCount = bytes.readUnsignedByte();
            if (nBoneCount > 0) {
                geomtry.skeleton = new egret3d.Skeleton();
            }
            var orientation = new egret3d.Quaternion();
            var rotation = new egret3d.Vector3D();
            var scaling = new egret3d.Vector3D();
            var translation = new egret3d.Vector3D();
            for (var i = 0; i < nBoneCount; ++i) {
                var joint = new egret3d.Joint();
                bytes.readInt();
                joint.parentIndex = bytes.readInt();
                joint.name = bytes.readUTF();
                rotation.x = bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES;
                rotation.y = bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES;
                rotation.z = bytes.readFloat() * egret3d.MathUtil.RADIANS_TO_DEGREES;
                scaling.x = bytes.readFloat();
                scaling.y = bytes.readFloat();
                scaling.z = bytes.readFloat();
                translation.x = bytes.readFloat();
                translation.y = bytes.readFloat();
                translation.z = bytes.readFloat();
                joint.buildInverseMatrix(scaling, rotation, translation);
                geomtry.skeleton.joints.push(joint);
            }
            var nVertsCount = bytes.readInt();
            for (var i = 0; i < nVertsCount; i++) {
                var nCount = bytes.readUnsignedByte();
                for (var j = 0; j < nCount; j++) {
                    geomtry.source_skinData.push(bytes.readUnsignedByte());
                    geomtry.source_skinData.push(bytes.readFloat());
                }
                for (var j = nCount; j < 4; j++) {
                    geomtry.source_skinData.push(0);
                    geomtry.source_skinData.push(0);
                }
            }
        };
        ESMVersion.parserVersion_3 = function (bytes, geomtry, param) {
            var description = bytes.readInt();
            geomtry.matCount = bytes.readInt();
            var vertexNormalCount = 0;
            var vertexColorCount = 0;
            var uvCount0 = 0;
            var uvCount1 = 0;
            for (var i = 0; i < geomtry.matCount; ++i) {
                geomtry.material[i] = {};
                geomtry.material[i].matID = bytes.readInt();
                geomtry.material[i].start = bytes.readInt();
                geomtry.material[i].count = bytes.readInt();
                geomtry.material[i].textureDiffuse = bytes.readUTF();
                geomtry.material[i].textureNormal = bytes.readUTF();
                geomtry.material[i].textureSpecular = bytes.readUTF();
            }
            if (description & egret3d.VertexFormat.VF_POSITION) {
                var vertexCount = bytes.readInt();
                for (var i = 0; i < vertexCount; i++) {
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_NORMAL) {
                vertexNormalCount = bytes.readInt();
                for (var i = 0; i < vertexNormalCount; i++) {
                    geomtry.source_normalData.push(bytes.readFloat());
                    geomtry.source_normalData.push(bytes.readFloat());
                    geomtry.source_normalData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_COLOR) {
                vertexColorCount = bytes.readInt();
                for (var i = 0; i < vertexColorCount; i++) {
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                }
            }
            if (description & egret3d.VertexFormat.VF_UV0) {
                uvCount0 = bytes.readInt();
                for (var i = 0; i < uvCount0; i++) {
                    geomtry.source_uvData.push(bytes.readFloat());
                    geomtry.source_uvData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_UV1) {
                uvCount1 = bytes.readInt();
                for (var i = 0; i < uvCount1; i++) {
                    geomtry.source_uv2Data.push(bytes.readFloat());
                    geomtry.source_uv2Data.push(bytes.readFloat());
                }
            }
            geomtry.faces = bytes.readInt();
            for (var i = 0; i < geomtry.faces; i++) {
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                if (description & egret3d.VertexFormat.VF_NORMAL) {
                    geomtry.normalIndices.push(bytes.readUnsignedShort());
                    geomtry.normalIndices.push(bytes.readUnsignedShort());
                    geomtry.normalIndices.push(bytes.readUnsignedShort());
                }
                if (description & egret3d.VertexFormat.VF_COLOR) {
                    geomtry.colorIndices.push(bytes.readUnsignedShort());
                    geomtry.colorIndices.push(bytes.readUnsignedShort());
                    geomtry.colorIndices.push(bytes.readUnsignedShort());
                }
                if (description & egret3d.VertexFormat.VF_UV0) {
                    geomtry.uvIndices.push(bytes.readUnsignedShort());
                    geomtry.uvIndices.push(bytes.readUnsignedShort());
                    geomtry.uvIndices.push(bytes.readUnsignedShort());
                }
                if (description & egret3d.VertexFormat.VF_UV1) {
                    geomtry.uv2Indices.push(bytes.readUnsignedShort());
                    geomtry.uv2Indices.push(bytes.readUnsignedShort());
                    geomtry.uv2Indices.push(bytes.readUnsignedShort());
                }
            }
            var nBoneCount = bytes.readUnsignedByte();
            if (nBoneCount > 0) {
                geomtry.skeleton = new egret3d.Skeleton();
            }
            var orientation = new egret3d.Quaternion();
            var rotation = new egret3d.Vector3D();
            var scaling = new egret3d.Vector3D();
            var translation = new egret3d.Vector3D();
            for (var i = 0; i < nBoneCount; ++i) {
                var joint = new egret3d.Joint();
                bytes.readInt();
                joint.parentIndex = bytes.readInt();
                joint.name = bytes.readUTF();
                orientation.x = bytes.readFloat();
                orientation.y = bytes.readFloat();
                orientation.z = bytes.readFloat();
                orientation.w = bytes.readFloat();
                scaling.x = bytes.readFloat();
                scaling.y = bytes.readFloat();
                scaling.z = bytes.readFloat();
                translation.x = bytes.readFloat();
                translation.y = bytes.readFloat();
                translation.z = bytes.readFloat();
                joint.buildInverseMatrix(scaling, orientation, translation);
                geomtry.skeleton.joints.push(joint);
            }
            var nVertsCount = bytes.readInt();
            for (var i = 0; i < nVertsCount; i++) {
                var nCount = bytes.readUnsignedByte();
                for (var j = 0; j < nCount; j++) {
                    geomtry.source_skinData.push(bytes.readUnsignedByte());
                    geomtry.source_skinData.push(bytes.readFloat());
                }
                for (var j = nCount; j < 4; j++) {
                    geomtry.source_skinData.push(0);
                    geomtry.source_skinData.push(0);
                }
            }
        };
        ESMVersion.parserVersion_4 = function (bytes, geomtry, param) {
            var description = bytes.readInt();
            geomtry.matCount = bytes.readInt();
            var vertexNormalCount = 0;
            var vertexColorCount = 0;
            var uvCount0 = 0;
            var uvCount1 = 0;
            for (var i = 0; i < geomtry.matCount; ++i) {
                geomtry.material[i] = {};
                geomtry.material[i].matID = bytes.readInt();
                geomtry.material[i].start = bytes.readInt();
                geomtry.material[i].count = bytes.readInt();
                geomtry.material[i].textureDiffuse = bytes.readUTF();
                geomtry.material[i].textureNormal = bytes.readUTF();
                geomtry.material[i].textureSpecular = bytes.readUTF();
            }
            if (description & egret3d.VertexFormat.VF_POSITION) {
                var vertexCount = bytes.readInt();
                for (var i = 0; i < vertexCount; i++) {
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_NORMAL) {
                vertexNormalCount = bytes.readInt();
                for (var i = 0; i < vertexNormalCount; i++) {
                    geomtry.source_normalData.push(bytes.readFloat());
                    geomtry.source_normalData.push(bytes.readFloat());
                    geomtry.source_normalData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_COLOR) {
                vertexColorCount = bytes.readInt();
                for (var i = 0; i < vertexColorCount; i++) {
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                }
            }
            if (description & egret3d.VertexFormat.VF_UV0) {
                uvCount0 = bytes.readInt();
                for (var i = 0; i < uvCount0; i++) {
                    geomtry.source_uvData.push(bytes.readFloat());
                    geomtry.source_uvData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_UV1) {
                uvCount1 = bytes.readInt();
                for (var i = 0; i < uvCount1; i++) {
                    geomtry.source_uv2Data.push(bytes.readFloat());
                    geomtry.source_uv2Data.push(bytes.readFloat());
                }
            }
            geomtry.faces = bytes.readInt();
            for (var i = 0; i < geomtry.faces; i++) {
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                geomtry.vertexIndices.push(bytes.readUnsignedShort());
                if (vertexNormalCount > 0) {
                    if (description & egret3d.VertexFormat.VF_NORMAL) {
                        geomtry.normalIndices.push(bytes.readUnsignedShort());
                        geomtry.normalIndices.push(bytes.readUnsignedShort());
                        geomtry.normalIndices.push(bytes.readUnsignedShort());
                    }
                }
                if (vertexColorCount > 0) {
                    if (description & egret3d.VertexFormat.VF_COLOR) {
                        geomtry.colorIndices.push(bytes.readUnsignedShort());
                        geomtry.colorIndices.push(bytes.readUnsignedShort());
                        geomtry.colorIndices.push(bytes.readUnsignedShort());
                    }
                }
                if (uvCount0 > 0) {
                    if (description & egret3d.VertexFormat.VF_UV0) {
                        geomtry.uvIndices.push(bytes.readUnsignedShort());
                        geomtry.uvIndices.push(bytes.readUnsignedShort());
                        geomtry.uvIndices.push(bytes.readUnsignedShort());
                    }
                }
                if (uvCount1 > 0) {
                    if (description & egret3d.VertexFormat.VF_UV1) {
                        geomtry.uv2Indices.push(bytes.readUnsignedShort());
                        geomtry.uv2Indices.push(bytes.readUnsignedShort());
                        geomtry.uv2Indices.push(bytes.readUnsignedShort());
                    }
                }
            }
            var nBoneCount = bytes.readUnsignedByte();
            if (nBoneCount > 0) {
                geomtry.skeleton = new egret3d.Skeleton();
            }
            var orientation = new egret3d.Quaternion();
            var rotation = new egret3d.Vector3D();
            var scaling = new egret3d.Vector3D();
            var translation = new egret3d.Vector3D();
            for (var i = 0; i < nBoneCount; ++i) {
                var joint = new egret3d.Joint();
                bytes.readInt();
                joint.parentIndex = bytes.readInt();
                joint.name = bytes.readUTF();
                orientation.x = bytes.readFloat();
                orientation.y = bytes.readFloat();
                orientation.z = bytes.readFloat();
                orientation.w = bytes.readFloat();
                scaling.x = bytes.readFloat();
                scaling.y = bytes.readFloat();
                scaling.z = bytes.readFloat();
                translation.x = bytes.readFloat();
                translation.y = bytes.readFloat();
                translation.z = bytes.readFloat();
                joint.buildInverseMatrix(scaling, orientation, translation);
                geomtry.skeleton.joints.push(joint);
            }
            var nVertsCount = bytes.readInt();
            for (var i = 0; i < nVertsCount; i++) {
                var nCount = bytes.readUnsignedByte();
                for (var j = 0; j < nCount; j++) {
                    geomtry.source_skinData.push(bytes.readUnsignedByte());
                    geomtry.source_skinData.push(bytes.readFloat());
                }
                for (var j = nCount; j < 4; j++) {
                    geomtry.source_skinData.push(0);
                    geomtry.source_skinData.push(0);
                }
            }
        };
        ESMVersion.parserVersion_5 = function (bytes, geomtry, param) {
            var description = bytes.readInt();
            geomtry.matCount = bytes.readInt();
            var vertexNormalCount = 0;
            var vertexColorCount = 0;
            var uvCount0 = 0;
            var uvCount1 = 0;
            for (var i = 0; i < geomtry.matCount; ++i) {
                geomtry.material[i] = {};
                geomtry.material[i].matID = bytes.readInt();
                geomtry.material[i].start = bytes.readInt();
                geomtry.material[i].count = bytes.readInt();
                geomtry.material[i].textureDiffuse = bytes.readUTF();
                geomtry.material[i].textureNormal = bytes.readUTF();
                geomtry.material[i].textureSpecular = bytes.readUTF();
            }
            if (description & egret3d.VertexFormat.VF_POSITION) {
                var vertexCount = bytes.readInt();
                for (var i = 0; i < vertexCount; i++) {
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                    geomtry.source_vertexData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_NORMAL) {
                vertexNormalCount = bytes.readInt();
                for (var i = 0; i < vertexNormalCount; i++) {
                    geomtry.source_normalData.push(bytes.readByte() / 125);
                    geomtry.source_normalData.push(bytes.readByte() / 125);
                    geomtry.source_normalData.push(bytes.readByte() / 125);
                }
            }
            if (description & egret3d.VertexFormat.VF_COLOR) {
                vertexColorCount = bytes.readInt();
                for (var i = 0; i < vertexColorCount; i++) {
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                    geomtry.source_vertexColorData.push(bytes.readUnsignedByte() / 255);
                }
            }
            if (description & egret3d.VertexFormat.VF_UV0) {
                uvCount0 = bytes.readInt();
                for (var i = 0; i < uvCount0; i++) {
                    geomtry.source_uvData.push(bytes.readFloat());
                    geomtry.source_uvData.push(bytes.readFloat());
                }
            }
            if (description & egret3d.VertexFormat.VF_UV1) {
                uvCount1 = bytes.readInt();
                for (var i = 0; i < uvCount1; i++) {
                    geomtry.source_uv2Data.push(bytes.readFloat());
                    geomtry.source_uv2Data.push(bytes.readFloat());
                }
            }
            geomtry.faces = bytes.readInt();
            for (var i = 0; i < geomtry.faces; i++) {
                var index_0 = bytes.readUnsignedShort();
                var index_1 = bytes.readUnsignedShort();
                var index_2 = bytes.readUnsignedShort();
                geomtry.vertexIndices.push(index_0);
                geomtry.vertexIndices.push(index_1);
                geomtry.vertexIndices.push(index_2);
                if (vertexNormalCount > 0) {
                    if (description & egret3d.VertexFormat.VF_NORMAL) {
                        geomtry.normalIndices.push(index_0);
                        geomtry.normalIndices.push(index_1);
                        geomtry.normalIndices.push(index_2);
                    }
                }
                if (vertexColorCount > 0) {
                    if (description & egret3d.VertexFormat.VF_COLOR) {
                        geomtry.colorIndices.push(index_0);
                        geomtry.colorIndices.push(index_1);
                        geomtry.colorIndices.push(index_2);
                    }
                }
                if (uvCount0 > 0) {
                    if (description & egret3d.VertexFormat.VF_UV0) {
                        geomtry.uvIndices.push(index_0);
                        geomtry.uvIndices.push(index_1);
                        geomtry.uvIndices.push(index_2);
                    }
                }
                if (uvCount1 > 0) {
                    if (description & egret3d.VertexFormat.VF_UV1) {
                        geomtry.uv2Indices.push(index_0);
                        geomtry.uv2Indices.push(index_1);
                        geomtry.uv2Indices.push(index_2);
                    }
                }
            }
            var nBoneCount = bytes.readUnsignedByte();
            if (nBoneCount > 0) {
                geomtry.skeleton = new egret3d.Skeleton();
            }
            var orientation = new egret3d.Quaternion();
            var rotation = new egret3d.Vector3D();
            var scaling = new egret3d.Vector3D();
            var translation = new egret3d.Vector3D();
            for (var i = 0; i < nBoneCount; ++i) {
                var joint = new egret3d.Joint();
                bytes.readInt();
                joint.parentIndex = bytes.readInt();
                joint.name = bytes.readUTF();
                orientation.x = bytes.readFloat();
                orientation.y = bytes.readFloat();
                orientation.z = bytes.readFloat();
                orientation.w = bytes.readFloat();
                scaling.x = bytes.readFloat();
                scaling.y = bytes.readFloat();
                scaling.z = bytes.readFloat();
                translation.x = bytes.readFloat();
                translation.y = bytes.readFloat();
                translation.z = bytes.readFloat();
                joint.buildInverseMatrix(scaling, orientation, translation);
                geomtry.skeleton.joints.push(joint);
            }
            var nVertsCount = bytes.readInt();
            for (var i = 0; i < nVertsCount; i++) {
                var nCount = bytes.readUnsignedByte();
                for (var j = 0; j < nCount; j++) {
                    geomtry.source_skinData.push(bytes.readUnsignedByte());
                    geomtry.source_skinData.push(bytes.readFloat());
                }
                for (var j = nCount; j < 4; j++) {
                    geomtry.source_skinData.push(0);
                    geomtry.source_skinData.push(0);
                }
            }
        };
        ESMVersion.versionDictionary = {
            1: function (bytes, geomtry, param) { return ESMVersion.parserVersion_1(bytes, geomtry, param); },
            2: function (bytes, geomtry, param) { return ESMVersion.parserVersion_2(bytes, geomtry, param); },
            3: function (bytes, geomtry, param) { return ESMVersion.parserVersion_3(bytes, geomtry, param); },
            4: function (bytes, geomtry, param) { return ESMVersion.parserVersion_4(bytes, geomtry, param); },
            5: function (bytes, geomtry, param) { return ESMVersion.parserVersion_5(bytes, geomtry, param); },
        };
        return ESMVersion;
    }());
    egret3d.ESMVersion = ESMVersion;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ERMParser
     * @classdesc
     * 用 EPMParser 类 解析.erm 文件
     */
    var E3dPackParser = (function () {
        function E3dPackParser() {
        }
        /**
         * @language zh_CN
         * @param datas 加载的二进制流
         * @returns PropertyAnim
         */
        E3dPackParser.parse = function (datas, url) {
            var bytes = new egret3d.ByteArray(datas);
            var iscompress = bytes.readByte();
            if (iscompress == 1) {
                var len = bytes.readInt();
                var context = new egret3d.ByteArray();
                bytes.readBytes(context, 0, len);
                context.uncompress();
                bytes = context;
            }
            var fileFormatBytes = new egret3d.ByteArray();
            bytes.readBytes(fileFormatBytes, 0, 7);
            //版本号;
            var version = bytes.readUnsignedShort();
            if (!egret3d.E3dPackVersion.versionDictionary[version]) {
                console.log("egret3d engine not found " + version + " version");
                return null;
            }
            var path = url.replace(".e3dPack", "/");
            return egret3d.E3dPackVersion.versionDictionary[version](bytes, path);
        };
        return E3dPackParser;
    }());
    egret3d.E3dPackParser = E3dPackParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ERMVersion
     * @classdesc
     */
    var E3dPackVersion = (function () {
        function E3dPackVersion() {
        }
        E3dPackVersion.parserVersion_1 = function (bytes, url) {
            var data = {};
            var name = bytes.readUTF();
            var len = bytes.readUnsignedShort();
            for (var i = 0; i < len; i++) {
                var path = bytes.readUTF();
                var count = bytes.readUnsignedInt();
                var array = new egret3d.ByteArray();
                bytes.readBytes(array, 0, count);
                data[path] = array;
                var assetPath = url + path;
                egret3d.assetMgr.addByteArray(assetPath, array, url);
            }
            return data;
        };
        E3dPackVersion.versionDictionary = {
            1: function (bytes, url) { return E3dPackVersion.parserVersion_1(bytes, url); },
        };
        return E3dPackVersion;
    }());
    egret3d.E3dPackVersion = E3dPackVersion;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.EPAParser
     * @classdesc
     * 用 EPMParser 类 解析.epa 文件
     */
    var EPAParser = (function () {
        function EPAParser() {
        }
        /**
         * @language zh_CN
         * @param datas 加载的二进制流
         * @returns PropertyAnim
         */
        EPAParser.parse = function (datas) {
            var bytes = new egret3d.ByteArray(datas);
            //验证标识头：'E' 'P' 'A' '\0'
            if (bytes.readUnsignedInt() != 0x65706100) {
                return null;
            }
            //版本号;
            var version = bytes.readUnsignedInt();
            if (!egret3d.EPAVersion.versionDictionary[version]) {
                console.log("egret3d engine not found " + version + " version");
                return null;
            }
            return egret3d.EPAVersion.versionDictionary[version](bytes);
        };
        return EPAParser;
    }());
    egret3d.EPAParser = EPAParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.EPAVersion
     * @classdesc
     */
    var EPAVersion = (function () {
        function EPAVersion() {
        }
        EPAVersion.parserVersion_1 = function (bytes) {
            var propertyAnim = new egret3d.PropertyAnim();
            //属性个数;
            var propertyCount = bytes.readUnsignedShort();
            for (var i = 0; i < propertyCount; i++) {
                //属性名称;
                var propertyName = bytes.readUTF();
                var keyFrames = [];
                //曲线数量;
                var curveCount = bytes.readUnsignedShort();
                for (var j = 0; j < curveCount; j++) {
                    var animCurve = new egret3d.AnimCurve();
                    animCurve.type = bytes.readUnsignedInt();
                    if (animCurve.type & EPAVersion.VALUE_TYPE_UINT) {
                        animCurve.frame = bytes.readFloat(); //ms
                        animCurve.frame = Math.floor(animCurve.frame / 16);
                        animCurve.value = bytes.readUnsignedInt();
                        bytes.readFloat();
                        bytes.readUnsignedInt();
                        bytes.readFloat();
                        bytes.readFloat();
                        bytes.readFloat();
                        bytes.readFloat();
                    }
                    else {
                        animCurve.frame = bytes.readFloat(); //ms
                        animCurve.frame = Math.floor(animCurve.frame / 16);
                        animCurve.value = bytes.readFloat();
                        bytes.readFloat();
                        bytes.readFloat();
                        bytes.readFloat();
                        bytes.readFloat();
                        bytes.readFloat();
                        bytes.readFloat();
                    }
                    keyFrames.push(animCurve);
                }
                propertyAnim.addAnimCurve(propertyName, keyFrames);
            }
            return propertyAnim;
        };
        EPAVersion.parserVersion_2 = function (bytes) {
            var propertyAnim = new egret3d.PropertyAnim();
            ///总时长
            var time = bytes.readFloat();
            //读取采样率;
            var sampling = bytes.readUnsignedByte();
            //属性个数;
            var propertyCount = bytes.readUnsignedShort();
            for (var i = 0; i < propertyCount; i++) {
                //属性名称;
                var propertyName = bytes.readUTF();
                var keyFrames = [];
                //曲线数量;
                var curveCount = bytes.readUnsignedShort();
                for (var j = 0; j < curveCount; j++) {
                    var animCurve = new egret3d.AnimCurve();
                    animCurve.type = bytes.readUnsignedInt();
                    if (animCurve.type & EPAVersion.VALUE_TYPE_UINT) {
                        animCurve.frame = bytes.readFloat(); //ms
                        animCurve.frame = Math.floor(animCurve.frame / 16);
                        animCurve.value = bytes.readUnsignedInt();
                        bytes.readFloat();
                        bytes.readUnsignedInt();
                        bytes.readFloat();
                        bytes.readFloat();
                        bytes.readFloat();
                        bytes.readFloat();
                    }
                    else {
                        animCurve.frame = bytes.readFloat(); //ms
                        animCurve.frame = Math.floor(animCurve.frame / 16);
                        animCurve.value = bytes.readFloat();
                        bytes.readFloat();
                        bytes.readFloat();
                        bytes.readFloat();
                        bytes.readFloat();
                        bytes.readFloat();
                        bytes.readFloat();
                    }
                    keyFrames.push(animCurve);
                }
                propertyAnim.addAnimCurve(propertyName, keyFrames);
            }
            return propertyAnim;
        };
        EPAVersion.versionDictionary = {
            1: function (bytes) { return EPAVersion.parserVersion_1(bytes); },
            2: function (bytes) { return EPAVersion.parserVersion_2(bytes); },
        };
        EPAVersion.VALUE_TYPE_UINT = 0x40000000;
        return EPAVersion;
    }());
    egret3d.EPAVersion = EPAVersion;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.EUMParser
     * @classdesc
     * 用 EUMParser 类 解析.eum 文件
     */
    var EUMParser = (function () {
        function EUMParser() {
        }
        /**
         * @language zh_CN
         * @param datas 加载的二进制流
         * @returns { [key: number]: ByteArray }
         */
        EUMParser.parse = function (datas) {
            var bytes = new egret3d.ByteArray(datas);
            var fileFormatBytes = new egret3d.ByteArray();
            bytes.readBytes(fileFormatBytes, 0, 3);
            //版本号;
            var version = bytes.readUnsignedShort();
            if (!egret3d.EUMVersion.versionDictionary[version]) {
                console.log("egret3d engine not found " + version + " version");
                return null;
            }
            egret3d.EUMVersion.versionValue = version;
            return egret3d.EUMVersion.versionDictionary[version](bytes);
        };
        return EUMParser;
    }());
    egret3d.EUMParser = EUMParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.EUMVersion
     * @classdesc
     */
    var EUMVersion = (function () {
        function EUMVersion() {
        }
        EUMVersion.parserVersion_1 = function (bytes) {
            var source = {};
            var len = bytes.readUnsignedInt();
            for (var i = 0; i < len; i++) {
                var id = bytes.readUnsignedInt();
                var arrayLen = bytes.readUnsignedInt();
                var array = new egret3d.ByteArray();
                bytes.readBytes(array, 0, arrayLen);
                source[id] = array;
            }
            return source;
        };
        EUMVersion.parserVersion_2 = function (bytes) {
            var source = {};
            var len = bytes.readUnsignedInt();
            for (var i = 0; i < len; i++) {
                var id = bytes.readUnsignedInt();
                var arrayLen = bytes.readUnsignedInt();
                var array = new egret3d.ByteArray();
                bytes.readBytes(array, 0, arrayLen);
                source[id] = array;
            }
            return source;
        };
        EUMVersion.fillGeometryUv2 = function (id, uv2Dict, geo) {
            switch (EUMVersion.versionValue) {
                case 1:
                    return EUMVersion.fillGeometryUv2_1(id, uv2Dict, geo);
                case 2:
                    return EUMVersion.fillGeometryUv2_2(id, uv2Dict, geo);
                default:
                    return null;
            }
        };
        EUMVersion.fillGeometryUv2_1 = function (id, uv2Dict, geo) {
            if (!uv2Dict || !uv2Dict[id]) {
                return;
            }
            var array = uv2Dict[id];
            array.position = 0;
            var uv2Array = [];
            var uvCount = array.readUnsignedInt();
            for (var i = 0; i < uvCount; i++) {
                uv2Array.push(array.readFloat());
                uv2Array.push(array.readFloat());
            }
            var uertexIndex = 0;
            var faceCount = array.readUnsignedInt();
            for (var i = 0; i < faceCount; i++) {
                for (var j = 0; j < 3; ++j) {
                    uertexIndex = i * 3 + j;
                    var uv2Index = array.readUnsignedShort();
                    var u = uv2Array[uv2Index * egret3d.Geometry.uv2Size + 0];
                    var v = uv2Array[uv2Index * egret3d.Geometry.uv2Size + 1];
                    geo.setVerticesForIndex(uertexIndex, egret3d.VertexFormat.VF_UV1, [u, v]);
                }
            }
        };
        EUMVersion.fillGeometryUv2_2 = function (id, uv2Dict, geo) {
            if (!uv2Dict || !uv2Dict[id]) {
                return;
            }
            var array = uv2Dict[id];
            array.position = 0;
            var x = array.readFloat();
            var y = array.readFloat();
            var z = array.readFloat();
            var w = array.readFloat();
            var uertexIndex = 0;
            var faceCount = geo.faceCount;
            for (var i = 0; i < faceCount; i++) {
                for (var j = 0; j < 3; ++j) {
                    uertexIndex = i * 3 + j;
                    var uv1 = geo.getVertexForIndex(uertexIndex, egret3d.VertexFormat.VF_UV1);
                    var u = uv1[0] * x + z;
                    var v = 1 - (uv1[1] * y + w);
                    geo.setVerticesForIndex(uertexIndex, egret3d.VertexFormat.VF_UV1, [u, v]);
                }
            }
        };
        EUMVersion.versionDictionary = {
            1: function (bytes) { return EUMVersion.parserVersion_1(bytes); },
            2: function (bytes) { return EUMVersion.parserVersion_2(bytes); },
        };
        return EUMVersion;
    }());
    egret3d.EUMVersion = EUMVersion;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.XMLParser
    * @classdesc
    * 解析XML文件格式
    * @version Egret 3.0
    * @platform Web,Native
    */
    var XMLParser = (function () {
        function XMLParser() {
        }
        /**
        * @language zh_CN
        *
        * @param xml xml文件
        * @returns any
        */
        XMLParser.parse = function (xml) {
            var xmlDoc = null;
            ///判断浏览器的类型
            ///支持IE浏览器 
            if (!window["DOMParser"] && window["ActiveXObject"]) {
                var xmlDomVersions = ['MSXML.2.DOMDocument.6.0', 'MSXML.2.DOMDocument.3.0', 'Microsoft.XMLDOM'];
                for (var i = 0; i < xmlDomVersions.length; i++) {
                    try {
                        xmlDoc = new ActiveXObject(xmlDomVersions[i]);
                        xmlDoc.async = false;
                        xmlDoc.loadXML(xml); ///loadXML方法载入xml字符串
                        break;
                    }
                    catch (e) {
                    }
                }
            }
            else if (window["DOMParser"] && document.implementation && document.implementation.createDocument) {
                try {
                    /* DOMParser 对象解析 XML 文本并返回一个 XML Document 对象。
                     * 要使用 DOMParser，使用不带参数的构造函数来实例化它，然后调用其 parseFromString() 方法
                     * parseFromString(text, contentType) 参数text:要解析的 XML 标记 参数contentType文本的内容类型
                     * 可能是 "text/xml" 、"application/xml" 或 "application/xhtml+xml" 中的一个。注意，不支持 "text/html"。
                     */
                    var domParser = new DOMParser();
                    xmlDoc = domParser.parseFromString(xml, 'text/xml');
                }
                catch (e) {
                }
            }
            else {
                return null;
            }
            return xmlDoc;
        };
        /**
        * @private
        * @language zh_CN
        * 解析node节点的属性值
        * @version Egret 3.0
        * @platform Web,Native
        */
        XMLParser.eachXmlAttr = function (item, fun) {
            if (item == null || fun == null)
                return;
            var attr;
            for (var i = 0, count = item.attributes.length; i < count; i++) {
                attr = item.attributes[i];
                fun(attr.name, attr.value);
            }
        };
        return XMLParser;
    }());
    egret3d.XMLParser = XMLParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UnitParserUtils = (function () {
        function UnitParserUtils() {
        }
        UnitParserUtils.parserType = function (data, type) {
            switch (type) {
                case "xml":
                    break;
                case "json":
                    if (data.type) {
                        return data.type;
                    }
                    if (data.meta) {
                        if (data.meta.smartupdate) {
                            data.meta.smartupdate.indexOf(egret3d.IConfigParser.TYPE_TEXTUREPACKER);
                            return egret3d.IConfigParser.TYPE_TEXTUREPACKER;
                        }
                    }
                    if (data.property && data.emission && data.life) {
                        return egret3d.IConfigParser.TYPE_PARTICLE;
                    }
                    return "";
            }
            return "";
        };
        UnitParserUtils.parserConfig = function (dataConfig, type) {
            var fileType = UnitParserUtils.parserType(dataConfig, type);
            switch (fileType) {
                case egret3d.IConfigParser.TYPE_SCENE:
                case egret3d.IConfigParser.TYPE_SKIN_MESH:
                case egret3d.IConfigParser.TYPE_EFFECT_GROUP:
                    return new egret3d.UnitConfigParser(dataConfig, type, fileType);
                case egret3d.IConfigParser.TYPE_PARTICLE:
                    return new egret3d.ParticleParser(dataConfig, type, fileType);
                case egret3d.IConfigParser.TYPE_TEXTUREPACKER:
                    return new egret3d.TexturePackerParser(dataConfig, type, fileType);
            }
            return null;
        };
        UnitParserUtils.mapParser = function (type, data, mapConfigParser) {
            var mapParser;
            switch (type) {
                case "xml":
                    mapParser = new egret3d.UnitXmlParser(data, mapConfigParser);
                    break;
                case "json":
                    mapParser = new egret3d.UnitJsonParser(data, mapConfigParser);
                    break;
            }
            if (mapParser) {
                mapParser.parser();
            }
        };
        UnitParserUtils.particleParser = function (type, text) {
            return new egret3d.ParticleParser(text, type).data;
        };
        UnitParserUtils.jsonVersion = function (version, data, mapConfigParser) {
            var parser;
            switch (version) {
                case 1:
                    parser = new egret3d.UnitJsonParser_1(data, mapConfigParser);
                    break;
                default:
                    parser = new egret3d.UnitJsonParser_1(data, mapConfigParser);
                    break;
            }
            return parser;
        };
        UnitParserUtils.xmlVersion = function (version, data, mapConfigParser) {
            var parser;
            switch (version) {
                case 1:
                    parser = new egret3d.UnitXmlParser_1(data, mapConfigParser);
                    break;
            }
            return parser;
        };
        UnitParserUtils.binVersion = function (version, data, mapConfigParser) {
            return null;
        };
        return UnitParserUtils;
    }());
    egret3d.UnitParserUtils = UnitParserUtils;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var MethodUtils = (function () {
        function MethodUtils() {
        }
        MethodUtils.doMethod = function (material, method, loader) {
            var defaultTexture = egret3d.CheckerboardTexture.texture;
            var methodBase = null;
            switch (method.type) {
                case egret3d.UnitMatMethodData.methodType.lightmapMethod:
                    var lightmapMethod = new egret3d.LightmapMethod(method.usePower);
                    methodBase = lightmapMethod;
                    material.diffusePass.addMethod(lightmapMethod);
                    lightmapMethod.lightTexture = defaultTexture;
                    var textureData = method.texturesData[0];
                    loader.addMethodImgTask(textureData.path, lightmapMethod, textureData.attributeName);
                    break;
                case egret3d.UnitMatMethodData.methodType.uvRollMethod:
                    var uvScrollMethod = new egret3d.UVRollMethod();
                    methodBase = uvScrollMethod;
                    material.diffusePass.addMethod(uvScrollMethod);
                    uvScrollMethod.speedU = method.uSpeed;
                    uvScrollMethod.speedV = method.vSpeed;
                    material.repeat = true;
                    break;
                case egret3d.UnitMatMethodData.methodType.uvSpriteSheetMethod:
                    var uvSpriteSheetMethod = new egret3d.UVSpriteSheetMethod(method.frameNum, method.row, method.col, method.totalTime);
                    methodBase = uvSpriteSheetMethod;
                    material.diffusePass.addMethod(uvSpriteSheetMethod);
                    uvSpriteSheetMethod.isLoop = method.loop;
                    uvSpriteSheetMethod.delayTime = method.delayTime;
                    break;
                case egret3d.UnitMatMethodData.methodType.mulUvRollMethod:
                    var uvMethod = new egret3d.MulUVRollMethod();
                    methodBase = uvMethod;
                    material.diffusePass.addMethod(uvMethod);
                    uvMethod.diffuseTexture1 = defaultTexture;
                    uvMethod.setSpeedU(0, method.uSpeed);
                    uvMethod.setSpeedV(0, method.vSpeed);
                    var textureData = method.texturesData[0];
                    uvMethod.setSpeedU(1, textureData.uSpeed);
                    uvMethod.setSpeedV(1, textureData.vSpeed);
                    loader.addMethodImgTask(textureData.path, uvMethod, textureData.attributeName);
                    material.repeat = true;
                    break;
                case egret3d.UnitMatMethodData.methodType.alphaMaskMethod:
                    var maskmapMethod = new egret3d.AlphaMaskMethod();
                    methodBase = maskmapMethod;
                    material.diffusePass.addMethod(maskmapMethod);
                    maskmapMethod.maskTexture = defaultTexture;
                    var textureData = method.texturesData[0];
                    loader.addMethodImgTask(textureData.path, maskmapMethod, textureData.attributeName);
                    break;
                case egret3d.UnitMatMethodData.methodType.streamerMethod:
                    var streamerMethod = new egret3d.StreamerMethod();
                    methodBase = streamerMethod;
                    material.diffusePass.addMethod(streamerMethod);
                    streamerMethod.steamerTexture = defaultTexture;
                    var textureData = method.texturesData[0];
                    loader.addMethodImgTask(textureData.path, streamerMethod, textureData.attributeName);
                    streamerMethod.speedU = method.uSpeed;
                    streamerMethod.speedV = method.vSpeed;
                    break;
                case egret3d.UnitMatMethodData.methodType.terrainARGBMethod:
                    var terrainARGBMethod = new egret3d.TerrainARGBMethod(defaultTexture, defaultTexture, defaultTexture, defaultTexture, defaultTexture);
                    methodBase = terrainARGBMethod;
                    material.diffusePass.addMethod(terrainARGBMethod);
                    var textureData = null;
                    for (var i = 0; i < method.texturesData.length; ++i) {
                        textureData = method.texturesData[i];
                        loader.addMethodImgTask(textureData.path, terrainARGBMethod, textureData.attributeName);
                        if (i != 0) {
                            terrainARGBMethod.setUVTitling(i - 1, Number(textureData.uvTitlingX), Number(textureData.uvTitlingY));
                        }
                    }
                    break;
                case egret3d.UnitMatMethodData.methodType.waterWaveMethod:
                    var waterWaveMethod = new egret3d.WaterWaveMethod();
                    methodBase = waterWaveMethod;
                    material.diffusePass.addMethod(waterWaveMethod);
                    if (method["deepWaterColor"]) {
                        waterWaveMethod.deepWaterColor = Number(method["deepWaterColor"]);
                    }
                    if (method["shallowWaterColor"]) {
                        waterWaveMethod.shallowWaterColor = Number(method["shallowWaterColor"]);
                    }
                    material.repeat = true;
                    break;
                case egret3d.UnitMatMethodData.methodType.waterNormalMethod:
                    var waterNormalMethod = new egret3d.WaterNormalMethod();
                    methodBase = waterNormalMethod;
                    material.diffusePass.addMethod(waterNormalMethod);
                    waterNormalMethod.normalTextureA = defaultTexture;
                    waterNormalMethod.normalTextureB = defaultTexture;
                    if (method["uScale"] && method["vScale"]) {
                        waterNormalMethod.setUvScale(Number(method["uScale"]), Number(method["vScale"]));
                    }
                    var textureData = null;
                    for (var i = 0; i < method.texturesData.length; ++i) {
                        textureData = method.texturesData[i];
                        waterNormalMethod.setUvSpeed(i, Number(textureData.uSpeed), Number(textureData.vSpeed));
                        loader.addMethodImgTask(textureData.path, waterNormalMethod, textureData.attributeName);
                    }
                    break;
            }
            if (method.play) {
                if (methodBase["start"]) {
                    loader.addAutoAnimation(methodBase);
                }
            }
        };
        return MethodUtils;
    }());
    egret3d.MethodUtils = MethodUtils;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UnitParser = (function () {
        function UnitParser(data, mapConfigParser) {
            this._data = data;
            this._mapConfigParser = mapConfigParser;
            this._versionParser = null;
        }
        UnitParser.prototype.parser = function () {
        };
        UnitParser.prototype.parseTexture = function (node) {
        };
        UnitParser.prototype.parseMethod = function (node) {
            return null;
        };
        UnitParser.prototype.parseMat = function (node) {
            return null;
        };
        UnitParser.prototype.parseNode = function (node) {
            return null;
        };
        UnitParser.prototype.parseEnvironment = function (environment) {
        };
        UnitParser.prototype.parseHud = function (node) {
            return null;
        };
        UnitParser.prototype.parseLight = function (node) {
            return null;
        };
        return UnitParser;
    }());
    egret3d.UnitParser = UnitParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UnitBinParser = (function (_super) {
        __extends(UnitBinParser, _super);
        function UnitBinParser(data, mapConfigParser) {
            _super.call(this, data, mapConfigParser);
        }
        return UnitBinParser;
    }(egret3d.UnitParser));
    egret3d.UnitBinParser = UnitBinParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UnitJsonParser = (function (_super) {
        __extends(UnitJsonParser, _super);
        function UnitJsonParser(data, mapConfigParser) {
            _super.call(this, data, mapConfigParser);
            this._mapConfigParser.version = Number(data.version);
            this._mapConfigParser.engineVersion = String(data.egret3DVersion);
        }
        UnitJsonParser.prototype.parser = function () {
            if (this._mapConfigParser.engineVersion == undefined) {
                console.log("the resource engine Version is old , but the current engine Version is " + egret3d.Egret3DPolicy.engineVersion);
            }
            var index = egret3d.Egret3DPolicy.exportToolsVersion.indexOf(this._mapConfigParser.engineVersion);
            if (index == -1) {
                console.log("the resource engine Version is " + this._mapConfigParser.engineVersion + ", but the current engine Version is " + egret3d.Egret3DPolicy.engineVersion);
            }
            this._versionParser = egret3d.UnitParserUtils.jsonVersion(this._mapConfigParser.version, this._data, this._mapConfigParser);
            this._versionParser.parseEnvironment(this._data.env);
            if (this._data.auto) {
                this._mapConfigParser.auto = this._data.auto == "true" ? true : false;
            }
            if (this._data.loop) {
                this._mapConfigParser.loop = this._data.loop == "true" ? true : false;
            }
            if (this._data.uv2) {
                this._mapConfigParser.uv2 = this._data.uv2;
            }
            this._mapConfigParser.calculateTask();
            if (this._data.propertyAnimations) {
                for (var i = 0; i < this._data.propertyAnimations.length; i++) {
                    var proAnimation = this._data.propertyAnimations[i];
                    var id = Number(proAnimation.id);
                    if (proAnimation) {
                        this._mapConfigParser.proAnimationDict[id] = proAnimation;
                        this._mapConfigParser.calculateProAnimationTask(proAnimation);
                    }
                }
            }
            if (this._data.skeletonAnimations) {
                for (var i = 0; i < this._data.skeletonAnimations.length; i++) {
                    var skeletonAnimation = this._data.skeletonAnimations[i];
                    var id = Number(skeletonAnimation.id);
                    if (skeletonAnimation) {
                        this._mapConfigParser.skeletonAnimationDict[id] = skeletonAnimation;
                        this._mapConfigParser.calculateSkeletonAnimationTask(skeletonAnimation);
                    }
                }
            }
            if (this._data.mats) {
                for (var i = 0; i < this._data.mats.length; i++) {
                    var matNodeData = this._versionParser.parseMat(this._data.mats[i]);
                    if (matNodeData) {
                        this._mapConfigParser.matDict[matNodeData.id] = matNodeData;
                        this._mapConfigParser.calculateMatTask(matNodeData);
                    }
                }
            }
            if (this._data.nodes) {
                for (var i = 0; i < this._data.nodes.length; i++) {
                    var mapNodeData = this._versionParser.parseNode(this._data.nodes[i]);
                    if (mapNodeData) {
                        this._mapConfigParser.nodeList.push(mapNodeData);
                        this._mapConfigParser.calculateNodeTask(mapNodeData);
                    }
                }
            }
            if (this._data.textures) {
                for (var i = 0; i < this._data.textures.length; i++) {
                    this._versionParser.parseTexture(this._data.textures[i]);
                }
            }
            if (this._data.huds) {
                for (var i = 0; i < this._data.huds.length; i++) {
                    var hudNodeData = this._versionParser.parseHud(this._data.huds[i]);
                    if (hudNodeData) {
                        this._mapConfigParser.hudList.push(hudNodeData);
                        this._mapConfigParser.calculateHudTask(hudNodeData);
                    }
                }
            }
        };
        return UnitJsonParser;
    }(egret3d.UnitParser));
    egret3d.UnitJsonParser = UnitJsonParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UnitJsonParser_1 = (function (_super) {
        __extends(UnitJsonParser_1, _super);
        function UnitJsonParser_1() {
            _super.apply(this, arguments);
        }
        UnitJsonParser_1.prototype.parseMethod = function (node) {
            var list = [];
            var method;
            for (var key in node) {
                method = new egret3d.UnitMatMethodData();
                method.type = key;
                var item = node[key];
                for (var met in item) {
                    if (met == "textures") {
                        for (var varKey in item.textures) {
                            var textureData = {};
                            for (var texKey in item.textures[varKey]) {
                                textureData[texKey] = item.textures[varKey][texKey];
                            }
                            method.texturesData.push(textureData);
                        }
                    }
                    else {
                        var v = typeof method[met];
                        if (v == "string") {
                            method[met] = item[met];
                        }
                        else if (v == "number") {
                            method[met] = Number(item[met]);
                        }
                        else if (v == "boolean") {
                            method[met] = (item[met] == "true" ? true : false);
                        }
                        else {
                            method[met] = item[met];
                        }
                    }
                }
                list.push(method);
            }
            return list;
        };
        UnitJsonParser_1.prototype.parseMat = function (node) {
            var data = new egret3d.UnitMatSphereData();
            for (var key in node) {
                switch (key) {
                    case "uvRectangle":
                        data.uvRectangle.x = Number(node.uvRectangle.x);
                        data.uvRectangle.y = Number(node.uvRectangle.y);
                        data.uvRectangle.width = Number(node.uvRectangle.width);
                        data.uvRectangle.height = Number(node.uvRectangle.height);
                        break;
                    case "methods":
                        data.methods = this.parseMethod(node.methods);
                        break;
                    case "blendMode":
                        data.blendMode = Number(egret3d.BlendMode[node[key]]);
                        break;
                    case "lightIds":
                        var splits = node[key].split(",");
                        for (var j = 0; j < splits.length; ++j) {
                            data.lightIds.push(Number(splits[j]));
                        }
                        break;
                    default:
                        var type = typeof data[key];
                        if (type == "number") {
                            data[key] = Number(node[key]);
                        }
                        else if (type == "boolean") {
                            data[key] = (node[key] == "true");
                        }
                        else if (type == "string") {
                            data[key] = node[key];
                        }
                        break;
                }
            }
            return data;
        };
        UnitJsonParser_1.prototype.parseNode = function (node) {
            var data = new egret3d.UnitNodeData();
            for (var key in node) {
                if (key == "pos" || key == "rot" || key == "scale") {
                    for (var tKey in node[key]) {
                        data[tKey] = Number(node[key][tKey]);
                    }
                }
                else if (key == "geometry") {
                    for (var gKey in node[key]) {
                        if (gKey == "type") {
                            data.geometry[gKey] = node[key][gKey];
                        }
                        else {
                            data.geometry[gKey] = Number(node[key][gKey]);
                        }
                    }
                }
                else if (key == "skinClips") {
                    for (var i = 0; i < node.skinClips.length; ++i) {
                        data.skinClips.push(node.skinClips[i]);
                    }
                }
                else if (key == "propertyAnims") {
                    for (var i = 0; i < node.propertyAnims.length; ++i) {
                        data.propertyAnims.push(node.propertyAnims[i]);
                    }
                }
                else if (key == "grass") {
                    for (var i = 0; i < node.grass.length; ++i) {
                        data.grass.push(node.grass[i]);
                    }
                }
                else if (key == "mats") {
                    data.materialIDs = (node[key] + "").split(",");
                }
                else if (key == "subs") {
                    for (var i = 0; i < node.subs.length; ++i) {
                        data.childs.push(node.subs[i]);
                    }
                }
                else if (key == "boneBind") {
                    data.boneBind = node.boneBind;
                }
                else if (key == "lightInfo") {
                    data.lightData = this.parseLight(node.lightInfo);
                }
                else if (key == "lightIds") {
                    data.lightIds = (node[key] + "").split(",");
                }
                else {
                    var v = typeof data[key];
                    if (v == "number") {
                        data[key] = Number(node[key]);
                    }
                    else if (v == "boolean") {
                        data[key] = (node[key] == "true") ? true : false;
                    }
                    else {
                        data[key] = node[key];
                    }
                }
            }
            return data;
        };
        UnitJsonParser_1.prototype.parseEnvironment = function (environment) {
            if (!environment) {
                return;
            }
            if (environment) {
                this._mapConfigParser.isFogOpen = Boolean(environment.isFogOpen);
                if (this._mapConfigParser.isFogOpen) {
                    this._mapConfigParser.fogColor = Number(environment.fogColor);
                    this._mapConfigParser.fogMode = String(environment.fogMode);
                    this._mapConfigParser.fogDensity = Number(environment.fogDensity);
                    this._mapConfigParser.linearFogStart = Number(environment.linearFogStart);
                    this._mapConfigParser.linearFogEnd = Number(environment.linearFogEnd);
                }
            }
            if (environment.directLight) {
                this._mapConfigParser.directLight = (environment.directLight == "open");
            }
            if (environment.pointLight) {
                this._mapConfigParser.pointLight = (environment.pointLight == "open");
            }
            if (!environment.lightList) {
                return;
            }
            for (var i = 0; i < environment.lightList.length; ++i) {
                var lightData = this.parseLight(environment.lightList[i]);
                this._mapConfigParser.lightDict[lightData.id] = lightData;
            }
        };
        UnitJsonParser_1.prototype.parseHud = function (node) {
            var hudData = new egret3d.UnitHUDData();
            for (var key in node) {
                if (key == "pos" || key == "rot" || key == "size") {
                    for (var tKey in node[key]) {
                        hudData[tKey] = Number(node[key][tKey]);
                    }
                }
                else if (key == "bothside") {
                    hudData[key] = (node[key] == "true");
                }
                else {
                    hudData[key] = node[key];
                }
            }
            return hudData;
        };
        UnitJsonParser_1.prototype.parseTexture = function (node) {
            this._mapConfigParser.textures.push(node);
            this._mapConfigParser.calculateTextureTask(node);
        };
        UnitJsonParser_1.prototype.parseLight = function (node) {
            var lightData = new egret3d.UnitLightData();
            for (var key in node) {
                switch (key) {
                    case "id":
                    case "diffuseColor":
                    case "ambientColor":
                    case "intensity":
                    case "halfIntensity":
                    case "falloff":
                    case "radius":
                        lightData[key] = Number(node[key]);
                        break;
                    case "type":
                        lightData.type = Number(egret3d.LightType[node.type]);
                        break;
                    case "direction":
                        lightData.direction.x = Number(node[key].x);
                        lightData.direction.y = Number(node[key].y);
                        lightData.direction.z = Number(node[key].z);
                        break;
                    case "position":
                        lightData.position.x = Number(node[key].x);
                        lightData.position.y = Number(node[key].y);
                        lightData.position.z = Number(node[key].z);
                        break;
                }
            }
            return lightData;
        };
        return UnitJsonParser_1;
    }(egret3d.UnitJsonParser));
    egret3d.UnitJsonParser_1 = UnitJsonParser_1;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UnitXmlParser = (function (_super) {
        __extends(UnitXmlParser, _super);
        function UnitXmlParser(data, mapConfigParser) {
            _super.call(this, data, mapConfigParser);
            var versionList = data.getElementsByTagName("version");
            this._mapConfigParser.version = Number(versionList[0].textContent);
        }
        UnitXmlParser.prototype.parser = function () {
            this._versionParser = egret3d.UnitParserUtils.xmlVersion(this._mapConfigParser.version, this._data, this._mapConfigParser);
            var matList = this._data.getElementsByTagName("mat");
            var nodeList = this._data.getElementsByTagName("node");
            var environment = this._data.getElementsByTagName("env");
            var cameraAnimList = this._data.getElementsByTagName("cameraAnims");
            var hudList = this._data.getElementsByTagName("hud");
            var textureList = this._data.getElementsByTagName("texture");
            this.parseEnvironment(environment);
            for (var i = 0; i < matList.length; i++) {
                var matNodeData = this._versionParser.parseMat(matList[i]);
                if (matNodeData) {
                    this._mapConfigParser.matDict[matNodeData.id] = matNodeData;
                    this._mapConfigParser.calculateMatTask(matNodeData);
                }
            }
            for (var i = 0; i < nodeList.length; i++) {
                var mapNodeData = this._versionParser.parseNode(nodeList[i]);
                if (mapNodeData) {
                    this._mapConfigParser.nodeList.push(mapNodeData);
                    this._mapConfigParser.calculateNodeTask(mapNodeData);
                }
            }
            for (var i = 0; i < textureList.length; i++) {
                this.parseTexture(textureList[i]);
            }
            for (var i = 0; i < hudList.length; i++) {
                var hudNodeData = this._versionParser.parseHud(hudList[i]);
                if (hudNodeData) {
                    this._mapConfigParser.hudList.push(hudNodeData);
                    this._mapConfigParser.calculateHudTask(hudNodeData);
                }
            }
        };
        UnitXmlParser.prototype.nodeFilter = function (node) {
            return node.nodeName == "#text" || node.nodeName == "#comment";
        };
        return UnitXmlParser;
    }(egret3d.UnitParser));
    egret3d.UnitXmlParser = UnitXmlParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UnitXmlParser_1 = (function (_super) {
        __extends(UnitXmlParser_1, _super);
        function UnitXmlParser_1() {
            _super.apply(this, arguments);
        }
        UnitXmlParser_1.prototype.parseTexture = function (node) {
            if (node.childNodes.length == 1)
                return null;
            var attr = null;
            var item;
            var i = 0;
            var count = 0;
            for (i = 0, count = node.childNodes.length; i < count; i++) {
                item = node.childNodes[i];
                if (this.nodeFilter(item))
                    continue;
                var data = {};
                for (var j = 0; j < item.attributes.length; ++j) {
                    attr = item.attributes[j];
                    data[attr.name] = attr.value;
                }
                this._mapConfigParser.textures.push(data);
                this._mapConfigParser.calculateTextureTask(data);
            }
        };
        UnitXmlParser_1.prototype.parseMethod = function (node) {
            if (node.childNodes.length <= 1)
                return null;
            var list = [];
            var item;
            var nodeName;
            var count = 0;
            var method;
            var attr = null;
            for (var i = 0, count = node.childNodes.length; i < count; i++) {
                item = node.childNodes[i];
                nodeName = item.nodeName;
                if (this.nodeFilter(item))
                    continue;
                method = new egret3d.UnitMatMethodData();
                method.type = nodeName;
                for (var j = 0; j < item.attributes.length; ++j) {
                    attr = item.attributes[j];
                    var v = typeof method[attr.name];
                    if (v == "string") {
                        method[attr.name] = attr.value;
                    }
                    else if (v == "number") {
                        method[attr.name] = Number(attr.value);
                    }
                    else if (v == "boolean") {
                        method[attr.name] = (attr.value == "true" ? true : false);
                    }
                    else {
                        method[attr.name] = attr.value;
                    }
                }
                for (var j = 0; j < item.childNodes.length; ++j) {
                    var textureItem = item.childNodes[j];
                    if (this.nodeFilter(textureItem)) {
                        continue;
                    }
                    var textureData = {};
                    for (var k = 0; k < textureItem.attributes.length; ++k) {
                        attr = textureItem.attributes[k];
                        textureData[attr.name] = attr.value;
                    }
                    method.texturesData.push(textureData);
                }
                list.push(method);
            }
            return list;
        };
        UnitXmlParser_1.prototype.parseMat = function (node) {
            if (node.childNodes.length == 0)
                return null;
            var data = new egret3d.UnitMatSphereData();
            var attr = null;
            for (var i = 0; i < node.attributes.length; ++i) {
                attr = node.attributes[i];
                data[attr.name] = attr.value;
            }
            var item;
            var nodeName;
            var count = 0;
            for (var i = 0, count = node.childNodes.length; i < count; i++) {
                item = node.childNodes[i];
                nodeName = item.nodeName;
                if (this.nodeFilter(item)) {
                    continue;
                }
                if (nodeName == "methods") {
                    data.methods = this.parseMethod(item);
                }
                else if (nodeName == "uvRectangle") {
                    for (var j = 0; j < item.attributes.length; ++j) {
                        data.uvRectangle[item.attributes[j].name] = Number(item.attributes[j].value);
                    }
                }
                else if (nodeName == "blendMode") {
                    data[item.nodeName] = egret3d.BlendMode[item.textContent];
                }
                else if (nodeName == "lightIds") {
                    if (item.textContent) {
                        var splits = item.textContent.split(",");
                        for (var j = 0; j < splits.length; ++j) {
                            data.lightIds.push(Number(splits[j]));
                        }
                    }
                }
                else {
                    var v = typeof data[item.nodeName];
                    if (v == "string") {
                        data[item.nodeName] = item.textContent;
                    }
                    else if (v == "number") {
                        data[item.nodeName] = Number(item.textContent);
                    }
                    else if (v == "boolean") {
                        data[item.nodeName] = (item.textContent == "true" ? true : false);
                    }
                }
            }
            return data;
        };
        UnitXmlParser_1.prototype.parseNode = function (node) {
            if (node.childNodes.length == 1)
                return null;
            var attr = null;
            var data = new egret3d.UnitNodeData();
            for (var i = 0; i < node.attributes.length; ++i) {
                attr = node.attributes[i];
                var v = typeof data[attr.name];
                if (v == "number") {
                    data[attr.name] = Number(attr.value);
                }
                else if (v == "boolean") {
                    data[attr.name] = (attr.value == "true") ? true : false;
                }
                else {
                    data[attr.name] = attr.value;
                }
            }
            var item;
            var nodeName;
            var i = 0;
            var count = 0;
            for (i = 0, count = node.childNodes.length; i < count; i++) {
                item = node.childNodes[i];
                nodeName = item.nodeName;
                if (this.nodeFilter(item)) {
                    continue;
                }
                if (nodeName == "pos") {
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        data[attr.nodeName] = Number(attr.value);
                    }
                }
                else if (nodeName == "rot") {
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        data[attr.nodeName] = Number(attr.value);
                    }
                }
                else if (nodeName == "scale") {
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        data[attr.nodeName] = Number(attr.value);
                    }
                }
                else if (nodeName == "mat") {
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        if (attr.nodeName == "id") {
                            data.materialIDs = (attr.value + "").split(",");
                        }
                    }
                }
                else if (nodeName == "skinClip") {
                    var skinClipData = {};
                    data.skinClips.push(skinClipData);
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        skinClipData[attr.nodeName] = attr.value;
                    }
                }
                else if (nodeName == "propertyAnim") {
                    var propertyAnimsData = {};
                    data.propertyAnims.push(propertyAnimsData);
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        propertyAnimsData[attr.nodeName] = attr.value;
                    }
                }
                else if (nodeName == "geometry") {
                    var geo = {};
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        if (attr.name == "type") {
                            geo[attr.name] = attr.value;
                        }
                        else {
                            geo[attr.name] = Number(attr.value);
                        }
                    }
                    data.geometry = geo;
                }
                else if (nodeName == "sub") {
                    var childData = {};
                    for (var j = 0; j < item.attributes.length; ++j) {
                        attr = item.attributes[j];
                        childData[attr.name] = attr.value;
                    }
                    data.childs.push(childData);
                }
            }
            return data;
        };
        UnitXmlParser_1.prototype.parseEnvironment = function (environment) {
            if (environment.length <= 0) {
                return;
            }
            //解析灯光
            var item;
            var item0;
            var item1;
            var attr = null;
            for (var iii = 0; iii < environment[0].attributes.length; ++iii) {
                attr = environment[0].attributes[iii];
                this._mapConfigParser[attr.name] = (attr.value == "open");
            }
            for (var i = 0, count = environment.length; i < count; i++) {
                item = environment[i];
                for (var ii = 0; ii < item.childNodes.length; ++ii) {
                    item0 = item.childNodes[ii];
                    if (this.nodeFilter(item0))
                        continue;
                    if (item0.nodeName == "light") {
                        var lightData = new egret3d.UnitLightData();
                        for (var iii = 0; iii < item0.attributes.length; ++iii) {
                            attr = item0.attributes[iii];
                            if (attr.name == "id") {
                                lightData[attr.name] = Number(attr.value);
                            }
                            else {
                                lightData[attr.name] = attr.value;
                            }
                        }
                        this._mapConfigParser.lightDict[lightData.id] = lightData;
                        for (var iii = 0; iii < item0.childNodes.length; ++iii) {
                            item1 = item0.childNodes[iii];
                            if (this.nodeFilter(item1)) {
                                continue;
                            }
                            if (item1.nodeName == "direction") {
                                for (var iiii = 0; iiii < item1.attributes.length; ++iiii) {
                                    attr = item1.attributes[iiii];
                                    lightData.direction[attr.name] = Number(attr.value);
                                }
                            }
                            else if (item1.nodeName == "position") {
                                for (var iiii = 0; iiii < item1.attributes.length; ++iiii) {
                                    attr = item1.attributes[iiii];
                                    lightData.position[attr.name] = Number(attr.value);
                                }
                            }
                            else if (item1.nodeName == "type") {
                                lightData.type = egret3d.LightType[item1.textContent];
                            }
                            else {
                                lightData[item1.nodeName] = Number(item1.textContent);
                            }
                        }
                    }
                    else if (item0.nodeName == "fog") {
                    }
                }
            }
        };
        UnitXmlParser_1.prototype.parseHud = function (node) {
            if (node.childNodes.length == 1)
                return null;
            var attr = null;
            var hudData = new egret3d.UnitHUDData();
            for (var i = 0; i < node.attributes.length; ++i) {
                attr = node.attributes[i];
                if (attr.nodeName == "bothside") {
                    hudData[attr.nodeName] = (attr.value == "true");
                }
                else {
                    hudData[attr.nodeName] = attr.value;
                }
            }
            var item;
            var nodeName;
            var i = 0;
            var count = 0;
            for (i = 0, count = node.childNodes.length; i < count; i++) {
                item = node.childNodes[i];
                nodeName = item.nodeName;
                if (this.nodeFilter(item)) {
                    continue;
                }
                for (var j = 0; j < item.attributes.length; ++j) {
                    attr = item.attributes[j];
                    if (nodeName == "shader") {
                        hudData[attr.nodeName] = attr.value;
                    }
                    else {
                        hudData[attr.nodeName] = Number(attr.value);
                    }
                }
            }
            return hudData;
        };
        return UnitXmlParser_1;
    }(egret3d.UnitXmlParser));
    egret3d.UnitXmlParser_1 = UnitXmlParser_1;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UnitLoader
    * @classdesc
    * 单个资源 加载器</p>
    * 主要封装了esm/jpg/png/eam/epa/uinty3d导出的配置文件/的加载和组装</p>
    * 以及mesh的render method相关信息，和灯光数据的生效.</p>
    * 加载完毕后，会派发事件</p>
    * 1.LoaderEvent3D.LOADER_COMPLETE 加载完成后事件响应</p>
    * 1.LoaderEvent3D.LOADER_PROGRESS 加载过程中事件响应</p>
    *
    * @see egret3d.ILoader
    * @see egret3d.LoaderEvent3D
    *
    * @includeExample loader/UnitLoader.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UnitLoader = (function (_super) {
        __extends(UnitLoader, _super);
        /**
        * @language zh_CN
        * 加载配置文件 .json 或 .xml,
        * 如果是配置文件 暂时只能支持.json (Unity3d 中的egret3d插件可以直接导出)
        * @param url 默认参数为null  文件路径
        * @version Egret 3.0
        * @platform Web,Native
        */
        function UnitLoader(url) {
            if (url === void 0) { url = null; }
            _super.call(this);
            /**
            * @language zh_CN
            * 场景对象的所有根节点.
            * 如果是配置文件，加载完后将后有值
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.container = null;
            /**
            * @private
            * @language zh_CN
            * 加载资源的URLLoader对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.loader = null;
            /**
            * @language zh_CN
            * 是否自动播放动画  默认不自动播放
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.autoPlayAnimation = false;
            this._pathRoot = "";
            this._configParser = null;
            this._mapParser = null;
            this._particleParser = null;
            this._texturePackerParser = null;
            this._taskCount = 0;
            this._event = new egret3d.LoaderEvent3D();
            this._type = "";
            this._taskDict = {};
            this._textures = {};
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.skinClipDict = {};
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.proAnimDict = {};
            this.unitLoaderList = [];
            this._dictUnitLoader = {};
            this._unitQueue = [];
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.huds = [];
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lightDict = {};
            this.autoAnimationList = [];
            this.continueProgressEvent = [];
            if (url) {
                this.load(url);
            }
        }
        Object.defineProperty(UnitLoader.prototype, "configParser", {
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._configParser;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UnitLoader.prototype, "pathRoot", {
            /**
            * @language zh_CN
            * 获取根目录
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pathRoot;
            },
            /**
            * @language zh_CN
            * 设置根目录
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (path) {
                this._pathRoot = path;
            },
            enumerable: true,
            configurable: true
        });
        /*
        * @private
        */
        UnitLoader.prototype.addAutoAnimation = function (animation, speed, reset, prewarm, name) {
            if (speed === void 0) { speed = 1.0; }
            if (reset === void 0) { reset = false; }
            if (prewarm === void 0) { prewarm = false; }
            if (name === void 0) { name = ""; }
            var auto = {};
            auto.animation = animation;
            auto.speed = speed;
            auto.reset = reset;
            auto.prewarm = prewarm;
            auto.name = name;
            this.autoAnimationList.push(auto);
        };
        /**
        * @language zh_CN
        * 获取每个资源的URLLoader对象
        * 如果获取的是配置文件会返回配置文件的源数据，而不是解释后的数据
        * @param url 文件路径
        * @returns URLLoader  URLLoader对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        UnitLoader.prototype.getAssetURLLoader = function (url) {
            return egret3d.assetMgr.findAsset(url, this);
        };
        UnitLoader.prototype.createObject = function () {
            return new egret3d.Object3D();
        };
        /**
        * @language zh_CN
        * 查找贴图
        * @param name 贴图名字
        * @version Egret 3.0
        * @platform Web,Native
        */
        UnitLoader.prototype.findTexture = function (name) {
            return this._textures[name];
        };
        /**
        * @language zh_CN
        * 加载文件
        * @param url 文件路径
        * @version Egret 3.0
        * @platform Web,Native
        */
        UnitLoader.prototype.load = function (url) {
            this.reset();
            this.resourceName = egret3d.StringUtil.getURLName(url);
            this.url = url;
            this.pathRoot = egret3d.StringUtil.getPath(url);
            this._type = egret3d.StringUtil.getFileFormat(url);
            this.taskTotal++;
            this._taskDict[this.url] = {};
            this._taskDict[this.url].status = 1;
            this._taskDict[this.url].currentProgress = 0;
            if (this._type == egret3d.ILoader.DATAFORMAT_E3DPACK) {
                this.loader = this.doAssetLoader(this.url, this.onE3dPack);
                var path = this.pathRoot + "MapConfig.json";
                this.processUrlContinue(path);
            }
            else {
                this.loader = this.doAssetLoader(this.url, this.onConfigLoad);
            }
            this.processUrlContinue(url);
        };
        UnitLoader.prototype.onE3dPack = function (e) {
            var loader = e.loader;
            this._type = egret3d.ILoader.DATAFORMAT_JSON;
            this.pathRoot += this.resourceName + "/";
            var path = this.pathRoot + "MapConfig.json";
            if (egret3d.assetMgr.getByteArray(path)) {
                this.taskTotal++;
                this._taskDict[path] = {};
                this._taskDict[path].status = 1;
                this._taskDict[path].currentProgress = 0;
                this.doAssetLoader(path, this.onConfigLoad, this);
            }
            this.processTask(loader);
        };
        // 是否跳过
        UnitLoader.prototype.processUrlContinue = function (url) {
            var format = egret3d.StringUtil.getFileFormat(url);
            if (format == egret3d.ILoader.DATAFORMAT_E3DPACK) {
                this.continueProgressEvent.push(url);
            }
            if (format == egret3d.ILoader.DATAFORMAT_JSON) {
                this.continueProgressEvent.push(url);
            }
        };
        /**
        * @language zh_CN
        * 释放所有数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        UnitLoader.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.reset();
            this.container = null;
        };
        UnitLoader.prototype.onProgress = function (e) {
            var targetLoader = e.target;
            if (this._taskDict[targetLoader.url]) {
                //for (var i: number = 0; i < this.continueProgressEvent.length; ++i) {
                //    if (targetLoader.url == this.continueProgressEvent[i]) {
                //        return;
                //    }
                //}
                this._taskDict[targetLoader.url].currentProgress = targetLoader.currentProgress;
                this.currentProgress = this.calculateProgress();
                if (this.currentProgress < 1.0) {
                    var loader = e.loader;
                    this._event.eventType = egret3d.LoaderEvent3D.LOADER_PROGRESS;
                    this._event.loader = loader;
                    this._event.data = loader.data;
                    this._event.currentProgress = this.currentProgress;
                    this.dispatchEvent(this._event);
                }
            }
        };
        UnitLoader.prototype.reset = function () {
            egret3d.assetMgr.dispose(this);
            if (this.url) {
                egret3d.assetMgr.removeByteArray(this.url);
                egret3d.textureResMgr.removeTexture(this.url);
                this.url = null;
            }
            this.taskTotal = 0;
            this.taskCurrent = 0;
            this._taskCount = 0;
            this._taskDict = {};
            this._textures = {};
            this.skinClipDict = {};
            this.huds = [];
            this.lightDict = {};
            this._mapParser = null;
            this._configParser = null;
            this._event.target = null;
            this._event.loader = null;
            this._event.data = null;
            for (var i = 0; i < this.unitLoaderList.length; ++i) {
                this.unitLoaderList[i].dispose();
            }
            this.unitLoaderList.length = 0;
            this._dictUnitLoader = {};
            this._unitQueue.length = 0;
            this._currentUnitLoader = null;
            this.continueProgressEvent.length = 0;
        };
        UnitLoader.prototype.parseParticle = function () {
            this.data = this._particleParser.data;
            if (!this._particleParser.data.shape.meshFile && !this._particleParser.data.property.meshFile) {
                return;
            }
            if (this._particleParser.data.shape.meshFile) {
                var path = this._pathRoot + this._particleParser.data.shape.meshFile;
                var parData = {};
                parData.particle = this._particleParser.data;
                parData.type = "shape";
                this.doAssetLoader(path, this.onParticleEsmLoad1, parData);
            }
            if (this._particleParser.data.property.meshFile) {
                var path = this._pathRoot + this._particleParser.data.property.meshFile;
                var parData = {};
                parData.particle = this._particleParser.data;
                parData.type = "property";
                this.doAssetLoader(path, this.onParticleEsmLoad1, parData);
            }
        };
        UnitLoader.prototype.parseUnit = function () {
            this.processNode();
            this.processSkinClip();
            this.processProAnim();
            this.createLight();
            if (this._mapParser.uv2) {
                var path = this.pathRoot + this._mapParser.uv2;
                this.doAssetLoader(path, this.onCompleteUv2);
            }
            else {
                this.onProcessNodeLoad();
            }
        };
        UnitLoader.prototype.onCompleteUv2 = function (e) {
            var load = e.loader;
            this.uv2Dict = e.data;
            this.onProcessNodeLoad();
            this.processTask(load);
        };
        UnitLoader.prototype.onProcessNodeLoad = function () {
            for (var i = 0; i < this._mapParser.nodeList.length; i++) {
                var mapNodeData = this._mapParser.nodeList[i];
                if (!mapNodeData.object3d.parent) {
                    this.container.addChild(mapNodeData.object3d);
                }
                switch (mapNodeData.type) {
                    case "Object3D":
                    case "Camera3D":
                    case "DirectLight":
                    case "PointLight":
                        this.doLoadEpa(mapNodeData);
                        break;
                    case "CubeSky":
                    case "SphereSky":
                    case "Mesh":
                        if (mapNodeData.path) {
                            var path = this._pathRoot + mapNodeData.path;
                            this.doAssetLoader(path, this.onEsmLoad, mapNodeData);
                        }
                        else if (mapNodeData.geometry) {
                            this.processMesh(mapNodeData, egret3d.GeometryUtil.createGemetryForType(mapNodeData.geometry.type, mapNodeData.geometry));
                        }
                        break;
                    case "Terrain":
                        if (mapNodeData.path) {
                            var path = this._pathRoot + mapNodeData.path;
                            this.doAssetLoader(path, this.onHeightImg, mapNodeData);
                        }
                        break;
                    case "ParticleEmitter":
                        if (mapNodeData.path) {
                            var path = this._pathRoot + mapNodeData.path;
                            var loader = this.doUnitLoader(path, this.onUnitLoader, mapNodeData);
                            if (this._configParser.version == 1) {
                                loader.pathRoot = this._pathRoot;
                            }
                        }
                        break;
                    case "EffectGroup":
                        if (mapNodeData.path) {
                            var path = this._pathRoot + mapNodeData.path;
                            this.doUnitLoader(path, this.onUnitLoader, mapNodeData);
                        }
                        break;
                }
            }
            for (var i = 0; i < this._mapParser.textures.length; ++i) {
                var data = this._mapParser.textures[i];
                var path = this._pathRoot + data.path;
                this.doAssetLoader(path, this.onTexture, data.name);
            }
            for (var i = 0; i < this._mapParser.hudList.length; ++i) {
                var hudData = this._mapParser.hudList[i];
                var hud = new egret3d.HUD();
                hud.name = hudData.name;
                hud.bothside = hudData.bothside;
                hud.x = hudData.x;
                hud.y = hudData.y;
                hud.rotationX = hudData.rx;
                hud.rotationY = hudData.ry;
                hud.rotationZ = hudData.rz;
                hud.width = hudData.width;
                hud.height = hudData.height;
                if (hudData.vs) {
                    hud.vsShader = hudData.vs;
                }
                if (hudData.fs) {
                    hud.fsShader = hudData.fs;
                }
                this.huds.push(hud);
                hudData.hud = hud;
                if (!hudData.texture) {
                    continue;
                }
                var path = this._pathRoot + hudData.texture;
                this.doAssetLoader(path, this.onHudTexture, hudData);
            }
        };
        UnitLoader.prototype.parseTexturePacker = function () {
            if (this._texturePackerParser.data.meta && this._texturePackerParser.data.meta.image) {
                var path = this._pathRoot + this._texturePackerParser.data.meta.image;
                this.doAssetLoader(path, this.onTexturePackerLoad);
            }
        };
        UnitLoader.prototype.onTexturePackerLoad = function (e) {
            var load = e.loader;
            this.data = load.data;
            egret3d.textureResMgr.addTexture(this.url, this._texturePackerParser.data, load.data);
            this.processTask(load);
        };
        UnitLoader.prototype.parseConfig = function (dataConfig, type) {
            this._configParser = egret3d.UnitParserUtils.parserConfig(dataConfig, type);
            if (!this._configParser) {
                return false;
            }
            var path = "";
            for (var v in this._configParser.taskDict) {
                this.taskTotal++;
                path = this._pathRoot + v;
                this._taskDict[path] = {};
                this._taskDict[path].status = 1;
                this._taskDict[path].currentProgress = 0;
            }
            switch (this._configParser.type) {
                case egret3d.IConfigParser.TYPE_SCENE:
                    this._mapParser = this._configParser;
                    this.container = this.container || new egret3d.Scene3D();
                    this.parseUnit();
                    break;
                case egret3d.IConfigParser.TYPE_SKIN_MESH:
                    this.container = this.container || new egret3d.Role();
                    this._mapParser = this._configParser;
                    this.parseUnit();
                    break;
                case egret3d.IConfigParser.TYPE_EFFECT_GROUP:
                    this.container = this.container || new egret3d.EffectGroup();
                    this._mapParser = this._configParser;
                    this.parseUnit();
                    break;
                case egret3d.IConfigParser.TYPE_PARTICLE:
                    this._particleParser = this._configParser;
                    this.parseParticle();
                    break;
                case egret3d.IConfigParser.TYPE_TEXTUREPACKER:
                    this._texturePackerParser = this._configParser;
                    this.parseTexturePacker();
                    break;
                default:
                    return false;
            }
            if (this.container) {
                this.data = this.container;
            }
            return true;
        };
        UnitLoader.prototype.processParticle = function (particleData, nodeData) {
            if (!particleData.shape.meshFile && !particleData.property.meshFile) {
                this.processParticleGeometry(particleData, nodeData);
            }
            else {
                if (particleData.shape.meshFile) {
                    var path = this._pathRoot + particleData.shape.meshFile;
                    var parData = {};
                    parData.particle = particleData;
                    parData.nodeData = nodeData;
                    parData.type = "shape";
                    this.doAssetLoader(path, this.onParticleEsmLoad, parData);
                }
                if (particleData.property.meshFile) {
                    var path = this._pathRoot + particleData.property.meshFile;
                    var parData = {};
                    parData.particle = particleData;
                    parData.nodeData = nodeData;
                    parData.type = "property";
                    this.doAssetLoader(path, this.onParticleEsmLoad, parData);
                }
            }
            return null;
        };
        UnitLoader.prototype.processParticleGeometry = function (particleData, nodeData) {
            particleData.materialData = this._mapParser.matDict[nodeData.materialIDs[0]];
            var particleNode = new egret3d.ParticleEmitter(particleData, new egret3d.TextureMaterial());
            nodeData.visible = egret3d.Egret3DPolicy.useParticle;
            this.processObject3d(nodeData, particleNode);
            if (this.autoPlayAnimation || particleData.property.playOnAwake) {
                this.addAutoAnimation(particleNode, 1, false, particleData.property.prewarm);
            }
            this.processMat(nodeData);
        };
        UnitLoader.prototype.processObject3d = function (nodeData, object3d) {
            object3d.name = nodeData.object3d.name;
            object3d.visible = nodeData.visible;
            object3d.position = nodeData.object3d.position;
            object3d.orientation = nodeData.object3d.orientation;
            object3d.scale = nodeData.object3d.scale;
            if (nodeData.tagName != "") {
                object3d.tag.name = nodeData.object3d.tag.name;
            }
            nodeData.object3d.swapObject(object3d);
            nodeData.object3d = object3d;
        };
        UnitLoader.prototype.onConfigLoad = function (e) {
            var loader = e.loader;
            switch (this._type) {
                case egret3d.ILoader.DATAFORMAT_XML:
                case egret3d.ILoader.DATAFORMAT_JSON:
                    if (!this.parseConfig(loader.data, this._type)) {
                        this.data = loader.data;
                    }
                    break;
                //case ILoader.DATAFORMAT_E3DPACK:
                //    this._type = ILoader.DATAFORMAT_JSON;
                //    this.pathRoot += this.resourceName + "/";
                //    var path: string = this.pathRoot + "MapConfig.json";
                //    if (assetMgr.getByteArray(path)) {
                //        this.taskTotal++;
                //        this._taskDict[path] = {};
                //        this._taskDict[path].status = 1;
                //        this._taskDict[path].currentProgress = 0;
                //        this.doAssetLoader(path, this.onConfigLoad, this);
                //        this.processUrlContinue(path);
                //    }
                //    break;
                default:
                    this.data = loader.data;
                    break;
            }
            this.processTask(loader);
            //loader.removeEventListener(LoaderEvent3D.LOADER_COMPLETE, this.onConfigLoad, this);
        };
        UnitLoader.prototype.onHeightImg = function (e) {
            var load = e.loader;
            var mapNodeData = e.param;
            var geometry = mapNodeData.geometry;
            var mesh = new egret3d.Terrain(load.data, geometry.width, geometry.height, geometry.depth, geometry.segmentsW, geometry.segmentsH, false, new egret3d.TextureMaterial(load.data));
            this.processHeightMesh(mapNodeData, mesh);
            var grass = mapNodeData.grass;
            if (grass) {
                for (var i = 0; i < grass.length; ++i) {
                    var grassData = grass[i];
                    var path = this._pathRoot + grassData.detailTexture;
                    var paramData = {};
                    paramData.grassData = grassData;
                    paramData.mapNodeData = mapNodeData;
                    this.doAssetLoader(path, this.onGrassDetailTexture, paramData);
                }
            }
            this.processTask(load);
        };
        UnitLoader.prototype.doAssetLoader = function (url, callback, param) {
            if (param === void 0) { param = null; }
            this.addTask();
            var loader = egret3d.assetMgr.loadAsset(url, callback, this, param);
            egret3d.assetMgr.addEventListener(url, egret3d.LoaderEvent3D.LOADER_PROGRESS, this.onProgress, this);
            return loader;
        };
        UnitLoader.prototype.doUnitLoader = function (url, callback, param) {
            var _this = this;
            if (param === void 0) { param = null; }
            this.addTask();
            var loader = this._dictUnitLoader[url];
            if (!loader) {
                loader = { pathRoot: null, loader: new UnitLoader() };
                this._dictUnitLoader[url] = loader;
                loader.loader.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onUnitComplete, this, param);
                this.unitLoaderList.push(loader.loader);
                this._unitQueue.push(url);
                if (!this._currentUnitLoader) {
                    this._currentUnitLoader = loader.loader;
                    this._currentUnitLoader.load(url);
                }
            }
            if (loader.loader.data) {
                setTimeout(function () {
                    if (callback) {
                        var loaderEvent = new egret3d.LoaderEvent3D();
                        loaderEvent.eventType = egret3d.LoaderEvent3D.LOADER_COMPLETE;
                        loaderEvent.target = loader.loader;
                        loaderEvent.loader = loader.loader;
                        loaderEvent.data = loader.loader.data;
                        loaderEvent.param = param;
                        callback.call(_this, loaderEvent);
                    }
                }, 0);
            }
            else {
                loader.loader.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, callback, this, param);
                loader.loader.addEventListener(egret3d.LoaderEvent3D.LOADER_PROGRESS, this.onProgress, this);
            }
            return loader;
        };
        UnitLoader.prototype.onUnitComplete = function (e) {
            this._unitQueue.shift();
            if (this._unitQueue.length > 0) {
                var url = this._unitQueue[0];
                var loader = this._dictUnitLoader[url];
                this._currentUnitLoader = loader.loader;
                this._currentUnitLoader.load(url);
                if (loader.pathRoot) {
                    this._currentUnitLoader.pathRoot = loader.pathRoot;
                }
            }
            else {
                this._currentUnitLoader = null;
            }
        };
        UnitLoader.prototype.onTexture = function (e) {
            var load = e.loader;
            var name = e.param;
            this._textures[name] = load.data;
            this.processTask(load);
        };
        UnitLoader.prototype.onHudTexture = function (e) {
            var load = e.loader;
            var hudData = e.param;
            hudData.hud.diffuseTexture = load.data;
            this.processTask(load);
        };
        UnitLoader.prototype.onMaterialTexture = function (e) {
            var load = e.loader;
            var textureData = e.param;
            var mesh = null;
            var mat = null;
            var mapNodeData = textureData.mapNodeData;
            mesh = mapNodeData.object3d;
            mat = mesh.getMaterial(textureData.matID);
            mat[textureData.type] = load.data;
            this.processTask(load);
        };
        UnitLoader.prototype.onMethodTexture = function (e) {
            var load = e.loader;
            var methodData = e.param;
            methodData.method[methodData.textureName] = load.data;
            this.processTask(load);
        };
        UnitLoader.prototype.onGrassDetailTexture = function (e) {
            var load = e.loader;
            var paramData = e.param;
            var grassData = paramData.grassData;
            var mapNodeData = paramData.mapNodeData;
            var terrain = mapNodeData.object3d;
            var list = this.getGrassPositions(terrain, load.data);
            if (list.length > 0) {
                var mat = new egret3d.TextureMaterial();
                mat.ambientColor = 0xffffff;
                mat.blendMode = egret3d.BlendMode.NORMAL;
                mat.cutAlpha = 0.4;
                //todo草的lightmap需要后期加入
                var rect = new egret3d.Rectangle(terrain.x, terrain.z, terrain.x * 2, terrain.z * 2);
                var grassMesh = new egret3d.GrassMesh(list, mat, grassData);
                grassMesh.method.setLightMapData(egret3d.CheckerboardTexture.texture, rect);
                //end
                terrain.addChild(grassMesh);
                terrain.x;
                terrain.y;
                var data = paramData.grassData;
                if (data.grassTexture) {
                    var path = this._pathRoot + data.grassTexture;
                    this.doAssetLoader(path, this.onGrassDiffuseTexture, grassMesh.material);
                }
            }
            this.processTask(load);
        };
        UnitLoader.prototype.getGrassPositions = function (terrain, texture) {
            var elevationGeometry = terrain.geometry;
            var image = texture.readPixels(0, 0, texture.width, texture.height);
            var width = image.width;
            var height = image.height;
            var color;
            var offset;
            var ratio = 1 / 16;
            var positions = [];
            var pos;
            var xFloat;
            var yFloat;
            for (var i = 0; i < height; i++) {
                for (var j = 0; j < width; j++) {
                    offset = i * width + j;
                    offset *= 4;
                    color = image.data[offset] * ratio;
                    color = Math.round(color);
                    if (color > 0) {
                        for (var k = 0; k < color; k++) {
                            xFloat = j + Math.random() - 0.5;
                            yFloat = i + Math.random() - 0.5;
                            if (xFloat < 0) {
                                xFloat = 0;
                            }
                            else if (xFloat >= width) {
                                xFloat = width - 0.01;
                            }
                            if (yFloat < 0) {
                                yFloat = 0;
                            }
                            else if (yFloat >= height) {
                                yFloat -= 0.01;
                            }
                            pos = elevationGeometry.get3DCoordAtPixel(xFloat, yFloat, width, height);
                            positions.push(pos);
                        }
                    }
                }
            }
            return positions;
        };
        UnitLoader.prototype.onGrassDiffuseTexture = function (e) {
            var load = e.loader;
            e.param.diffuseTexture = load.data;
            this.processTask(load);
        };
        UnitLoader.prototype.doLoadEpa = function (mapNodeData) {
            if (mapNodeData.propertyAnims) {
                for (var j = 0; j < mapNodeData.propertyAnims.length; ++j) {
                    if (!mapNodeData.object3d.proAnimation) {
                        mapNodeData.object3d.proAnimation = new egret3d.PropertyAnimController(mapNodeData.object3d);
                    }
                    var propertyAnimsData = mapNodeData.propertyAnims[j];
                    var path = this._pathRoot + propertyAnimsData["path"];
                    this.doAssetLoader(path, this.onEpaLoad, mapNodeData);
                }
            }
            var propertyAnimController = this.proAnimDict[mapNodeData.propertyAnimsId];
            if (propertyAnimController) {
                mapNodeData.object3d.proAnimation = propertyAnimController;
            }
        };
        UnitLoader.prototype.processEpa = function (mapNodeData, pro) {
            mapNodeData.object3d.proAnimation.propertyAnimController.addPropertyAnim(pro);
            if (this.autoPlayAnimation) {
                if (mapNodeData.object3d.proAnimation) {
                    this.addAutoAnimation(mapNodeData.object3d.proAnimation);
                }
            }
        };
        UnitLoader.prototype.processHeightMesh = function (mapNodeData, mesh) {
            this.processObject3d(mapNodeData, mesh);
            this.processMat(mapNodeData);
            this.doLoadEpa(mapNodeData);
        };
        UnitLoader.prototype.processMesh = function (mapNodeData, geometry) {
            var animation = this.skinClipDict[mapNodeData.skeletonAnimation];
            var mesh = null;
            if (mapNodeData.type == "Mesh") {
                //var hasMirrorX: boolean = false;
                //var hasMirrorY: boolean = false;
                //var hasMirrorZ: boolean = false;
                //if (mapNodeData.sx < 0) {
                //    hasMirrorX = true;
                //    mapNodeData.sx = Math.abs(mapNodeData.sx);
                //    mapNodeData.object3d.scaleX = mapNodeData.sx;
                //}
                //if (mapNodeData.sy < 0) {
                //    hasMirrorY = true;
                //    mapNodeData.sy = Math.abs(mapNodeData.sy);
                //    mapNodeData.object3d.scaleY = mapNodeData.sy;
                //}
                //if (mapNodeData.sz < 0) {
                //    hasMirrorZ = true;
                //    mapNodeData.sz = Math.abs(mapNodeData.sz);
                //    mapNodeData.object3d.scaleZ = mapNodeData.sz;
                //}
                //if (hasMirrorX || hasMirrorY || hasMirrorZ) {
                //    geometry = geometry.cloneMirror(hasMirrorX, hasMirrorY, hasMirrorZ);
                //}
                mesh = new egret3d.Mesh(geometry, new egret3d.TextureMaterial(), animation);
            }
            else if (mapNodeData.type == "CubeSky") {
                mesh = new egret3d.Sky(geometry, new egret3d.CubeTextureMaterial());
            }
            else if (mapNodeData.type == "SphereSky") {
                mesh = new egret3d.Sky(geometry, new egret3d.TextureMaterial());
            }
            egret3d.EUMVersion.fillGeometryUv2(mapNodeData.uv2Id, this.uv2Dict, mesh.geometry);
            this.processObject3d(mapNodeData, mesh);
            this.processMat(mapNodeData);
            for (var j = 0; j < mapNodeData.skinClips.length; j++) {
                var eamData = mapNodeData.skinClips[j];
                var path = this._pathRoot + eamData["path"];
                var loadData = {};
                loadData.eamData = eamData;
                loadData.mapNodeData = mapNodeData;
                this.doAssetLoader(path, this.onEamLoad, loadData);
            }
            this.doLoadEpa(mapNodeData);
        };
        UnitLoader.prototype.onEsmLoad = function (e) {
            var load = e.loader;
            var mapNodeData = e.param;
            if (mapNodeData) {
                var geo = load.data;
                if (this.uv2Dict && this.uv2Dict[mapNodeData.uv2Id]) {
                    geo = new egret3d.Geometry();
                    geo.copy(load.data);
                }
                this.processMesh(mapNodeData, geo);
            }
            this.processTask(load);
        };
        UnitLoader.prototype.onParticleEsmLoad = function (e) {
            var load = e.loader;
            var parData = e.param;
            var particle = parData.particle;
            var nodeData = parData.nodeData;
            switch (parData.type) {
                case "shape":
                    particle.shape.geometry = load.data;
                    break;
                case "property":
                    particle.property.geometry = load.data;
                    break;
            }
            var needLoad = 0;
            var loaded = 0;
            if (particle.shape.meshFile) {
                needLoad++;
            }
            if (particle.property.meshFile) {
                needLoad++;
            }
            if (particle.shape.geometry) {
                loaded++;
            }
            if (particle.property.geometry) {
                loaded++;
            }
            if (loaded == needLoad) {
                this.processParticleGeometry(particle, nodeData);
            }
            this.processTask(load);
        };
        UnitLoader.prototype.onParticleEsmLoad1 = function (e) {
            var load = e.loader;
            var parData = e.param;
            var particle = parData.particle;
            switch (parData.type) {
                case "shape":
                    particle.shape.geometry = load.data;
                    break;
                case "property":
                    particle.property.geometry = load.data;
                    break;
            }
            var needLoad = 0;
            var loaded = 0;
            if (particle.shape.meshFile) {
                needLoad++;
            }
            if (particle.property.meshFile) {
                needLoad++;
            }
            if (particle.shape.geometry) {
                loaded++;
            }
            if (particle.property.geometry) {
                loaded++;
            }
            if (loaded == needLoad) {
                this.data = particle;
            }
            this.processTask(load);
        };
        UnitLoader.prototype.onEamLoad = function (e) {
            var load = e.loader;
            var loadData = e.param;
            var clip = load.data;
            clip.animationName = loadData.eamData.name;
            var mesh = loadData.mapNodeData.object3d;
            mesh.animation.skeletonAnimationController.state.addAnimClip(clip);
            if (this.autoPlayAnimation) {
                this.addAutoAnimation(mesh.animation, 1, false, false, clip.animationName);
            }
            this.processTask(load);
        };
        UnitLoader.prototype.onSkinClip = function (e) {
            var load = e.loader;
            var loadData = e.param;
            var skeletonAnimation = loadData.skinClip;
            var skinData = loadData.skinData;
            var clipData = loadData.clip;
            var clip = load.data;
            clip.animationName = clipData.name;
            //clip = clip.clone();
            if (clipData.loop) {
                clip.isLoop = (clipData.loop == "true" ? true : false);
            }
            skeletonAnimation.state.addAnimClip(clip);
            if (this.autoPlayAnimation) {
                this.addAutoAnimation(skeletonAnimation, 1, false, false, clip.animationName);
            }
            else {
                if (skinData.auto && skinData.auto != "") {
                    //skeletonAnimation.play(skinData.auto, 1.0, false, false);
                    this.addAutoAnimation(skeletonAnimation, 1, false, false, clip.animationName);
                }
            }
            this.processTask(load);
        };
        UnitLoader.prototype.onProAnim = function (e) {
            var load = e.loader;
            var loadData = e.param;
            var proAnimation = loadData.proAnimation;
            var proData = loadData.proData;
            var clipData = loadData.clip;
            var clip = load.data;
            clip = clip.clone();
            if (clipData.loop) {
                clip.isLoop = (clipData.loop == "true" ? true : false);
            }
            if (clipData.name) {
                clip.name = clipData.name;
            }
            proAnimation.addPropertyAnim(clip);
            if (this.autoPlayAnimation) {
                //proAnimation.play(clipData.name);
                this.addAutoAnimation(proAnimation, 1, false, false, clipData.name);
            }
            else {
                if (proData.auto && proData.auto != "") {
                    this.addAutoAnimation(proAnimation, 1, false, false, proData.auto);
                }
            }
            this.processTask(load);
        };
        UnitLoader.prototype.onEpaLoad = function (e) {
            var load = e.loader;
            var mapNodeData = e.param;
            var pa = load.data;
            var clonePa = pa.clone();
            this.processEpa(mapNodeData, clonePa);
            this.processTask(load);
        };
        UnitLoader.prototype.addTask = function () {
            this._taskCount++;
        };
        UnitLoader.prototype.calculateProgress = function () {
            var progress = 0;
            for (var key in this._taskDict) {
                var has = false;
                for (var i = 0; i < this.continueProgressEvent.length; ++i) {
                    if (key == this.continueProgressEvent[i]) {
                        has = true;
                        break;
                    }
                }
                if (has) {
                    progress += 0.1 / this.continueProgressEvent.length * this._taskDict[key].currentProgress;
                }
                else {
                    progress += 0.9 / (this.taskTotal - this.continueProgressEvent.length) * this._taskDict[key].currentProgress;
                }
            }
            return progress;
        };
        UnitLoader.prototype.processTaskCurrent = function (load) {
            if (this._taskDict[load.url]) {
                if (this._taskDict[load.url].status == 1) {
                    this.taskCurrent++;
                    this._taskDict[load.url].status = 2;
                    this._taskDict[load.url].currentProgress = 1;
                    this._event.loader = load;
                    this._event.data = load.data;
                    var isDisEventProgress = true;
                    //for (var i: number = 0; i < this.continueProgressEvent.length; ++i) {
                    //    if (load.url == this.continueProgressEvent[i]) {
                    //        isDisEventProgress = false;
                    //        break;
                    //    }
                    //}
                    // 触发 LOADER_PROGRESS
                    this.currentProgress = this.calculateProgress();
                    if (this.currentProgress < 1.0) {
                        this._event.eventType = egret3d.LoaderEvent3D.LOADER_PROGRESS;
                        this._event.currentProgress = this.currentProgress;
                        this.dispatchEvent(this._event);
                    }
                    this._event.currentProgress = this.currentProgress;
                    // 某一个文件加载完成  
                    this._event.eventType = egret3d.LoaderEvent3D.LOADER_ONCE_COMPLETE;
                    this.dispatchEvent(this._event);
                }
            }
        };
        UnitLoader.prototype.processTask = function (load) {
            this.processTaskCurrent(load);
            this._taskCount--;
            if (this._taskCount <= 0) {
                this.currentProgress = 1.0;
                this.onLoaderComplete();
                this._event.loader = this;
                this._event.data = this.data;
                this._event.currentProgress = this.currentProgress;
                // 触发 LOADER_PROGRESS
                this._event.eventType = egret3d.LoaderEvent3D.LOADER_PROGRESS;
                this.dispatchEvent(this._event);
                // 全部文件加载完成
                this._event.eventType = egret3d.LoaderEvent3D.LOADER_COMPLETE;
                this.dispatchEvent(this._event);
            }
        };
        UnitLoader.prototype.onLoaderComplete = function () {
            if (!this._configParser) {
                return;
            }
            if (this._mapParser) {
                this.data = this.container;
                var subEmitters = [];
                for (var i = 0; i < this._mapParser.nodeList.length; i++) {
                    var mapNodeData = this._mapParser.nodeList[i];
                    if (mapNodeData.object3d instanceof egret3d.ParticleEmitter) {
                        var patEmitter = mapNodeData.object3d;
                        for (var j = 0; j < mapNodeData.childs.length; ++j) {
                            var childData = mapNodeData.childs[j];
                            var childPatEmitter = this.container.findObject3D(childData.name);
                            subEmitters.push(childPatEmitter);
                            if (childPatEmitter instanceof egret3d.ParticleEmitter) {
                                patEmitter.addSubEmitter(Number(egret3d.ParticleDataSubEmitterPhase[childData.phase]), childPatEmitter);
                            }
                        }
                    }
                    if (mapNodeData.boneBind.skeletonAnimation) {
                        var id = Number(mapNodeData.boneBind.skeletonAnimation);
                        var skeletonAnimation = this.skinClipDict[id];
                        skeletonAnimation.bindToJointPose(mapNodeData.boneBind.boneName, mapNodeData.object3d);
                    }
                }
                var tempEmitter;
                for (var i = 0; i < subEmitters.length; i++) {
                    tempEmitter = subEmitters[i];
                    if (tempEmitter && tempEmitter.parent) {
                        tempEmitter.parent.removeChild(tempEmitter);
                    }
                }
                //**********场景加载完毕 自动 merge ****************
                var auto = true;
                if (auto) {
                    var meshs = egret3d.StaticMergeUtil.bacthingMesh(this._mapParser);
                    for (var m in meshs) {
                        this.container.addChild(meshs[m]);
                    }
                }
            }
            if (this.view3d) {
                for (var i = 0; i < this.huds.length; ++i) {
                    this.view3d.addHUD(this.huds[i]);
                }
            }
            for (var i = 0; i < this.autoAnimationList.length; ++i) {
                var autoPlayData = this.autoAnimationList[i];
                if (autoPlayData.animation instanceof egret3d.SkeletonAnimation) {
                    autoPlayData.animation.play(autoPlayData.name, autoPlayData.speed, autoPlayData.reset, autoPlayData.prewarm);
                }
                else if (autoPlayData.animation instanceof egret3d.PropertyAnimController) {
                    autoPlayData.animation.play(autoPlayData.name);
                }
                else if (autoPlayData.animation instanceof egret3d.MethodBase) {
                    autoPlayData.animation.start(true);
                }
                else if (autoPlayData.animation instanceof egret3d.ParticleEmitter) {
                    autoPlayData.animation.play(autoPlayData.speed, autoPlayData.reset, autoPlayData.prewarm);
                }
                else if (autoPlayData.animation instanceof egret3d.EffectGroup) {
                    autoPlayData.animation.play();
                }
            }
            if (this._configParser.type == egret3d.IConfigParser.TYPE_EFFECT_GROUP) {
                var effect = this.data;
                if (effect) {
                    effect.init(this._mapParser.loop);
                    if (this._mapParser.auto) {
                        effect.play();
                    }
                }
            }
            if (this._configParser.type == egret3d.IConfigParser.TYPE_SKIN_MESH) {
                var role = this.data;
                for (var key in this.skinClipDict) {
                    role.skeletonAnimation = this.skinClipDict[key];
                    break;
                }
            }
        };
        UnitLoader.prototype.addImaTask = function (name, type, matID, mapNodeData, material) {
            var load = null;
            var path = this._pathRoot + name;
            var textureData = {};
            textureData.type = type;
            textureData.matID = matID;
            textureData.mapNodeData = mapNodeData;
            this.doAssetLoader(path, this.onMaterialTexture, textureData);
            return load;
        };
        /*
        * @private
        */
        UnitLoader.prototype.addMethodImgTask = function (name, method, textureName) {
            var path = this._pathRoot + name;
            var methodData = {};
            methodData.method = method;
            methodData.textureName = textureName;
            var loader = this.doAssetLoader(path, this.onMethodTexture, methodData);
            return loader;
        };
        UnitLoader.prototype.processMat = function (mapNodeData) {
            var mesh = mapNodeData.object3d;
            for (var i = 0; i < mapNodeData.materialIDs.length; ++i) {
                var matData = this._mapParser.matDict[mapNodeData.materialIDs[i]];
                if (!matData) {
                    continue;
                }
                var material = mesh.getMaterial(i);
                if (!material) {
                    material = new egret3d.TextureMaterial();
                    mesh.addSubMaterial(i, material);
                }
                var load = null;
                if (matData.diffuseTextureName != "") {
                    load = this.addImaTask(matData.diffuseTextureName, "diffuseTexture", i, mapNodeData, material);
                }
                if (matData.normalTextureName != "") {
                    load = this.addImaTask(matData.normalTextureName, "normalTexture", i, mapNodeData, material);
                }
                if (matData.specularTextureName != "") {
                    load = this.addImaTask(matData.specularTextureName, "specularTexture", i, mapNodeData, material);
                }
                if (matData.matcapTextureName != "") {
                    load = this.addImaTask(matData.matcapTextureName, "matcapTexture", i, mapNodeData, material);
                }
                material.diffuseColor = matData.diffuseColor;
                material.ambientColor = matData.ambientColor;
                material.specularColor = matData.specularColor;
                material.tintColor = matData.tintColor;
                material.alpha = matData.alpha;
                material.specularLevel = matData.specularLevel;
                material.gloss = matData.gloss;
                material.gamma = matData.gamma;
                material.refraction = matData.refraction;
                material.refractionintensity = matData.refractionintensity;
                material.castShadow = matData.castShadow;
                material.acceptShadow = matData.acceptShadow;
                material.repeat = matData.repeat;
                material.bothside = matData.bothside;
                material.drawMode = matData.drawMode;
                material.cullMode = matData.cullMode;
                material.blendMode = matData.blendMode;
                material.cutAlpha = matData.cutAlpha;
                material.uvRectangle.copyFrom(matData.uvRectangle);
                var lightGroup = new egret3d.LightGroup();
                for (var j = 0; j < matData.lightIds.length; ++j) {
                    var light = this.lightDict[matData.lightIds[j]];
                    if (light) {
                        lightGroup.addLight(light);
                    }
                }
                if (lightGroup.lightNum > 0) {
                    material.lightGroup = lightGroup;
                }
                this.processMethod(material, matData);
            }
            var lg = mesh.lightGroup || new egret3d.LightGroup();
            for (var i = 0; i < mapNodeData.lightIds.length; ++i) {
                var light = this.lightDict[mapNodeData.lightIds[i]];
                if (light) {
                    lg.addLight(light);
                }
            }
            if (lg.lightNum > 0) {
                mesh.lightGroup = lg;
            }
            //if (typeof mesh != "ParticleEmitter") {
            //    if (this.lightGroup.lightNum > 0) {
            //        mesh.lightGroup = this.lightGroup;
            //    }
            //}
        };
        UnitLoader.prototype.processMethod = function (material, matData) {
            var load = null;
            var method = null;
            for (var _i = 0, _a = matData.methods; _i < _a.length; _i++) {
                method = _a[_i];
                egret3d.MethodUtils.doMethod(material, method, this);
            }
        };
        UnitLoader.prototype.processNode = function () {
            for (var i = 0; i < this._mapParser.nodeList.length; i++) {
                var mapNodeData = this._mapParser.nodeList[i];
                if (mapNodeData.type == "Camera3D") {
                    var camera = new egret3d.Camera3D();
                    camera.fieldOfView = mapNodeData.fov;
                    camera.near = mapNodeData.clipNear;
                    camera.far = mapNodeData.clipFar;
                    mapNodeData.object3d = camera;
                }
                else if (mapNodeData.type == "Billboard") {
                    mapNodeData.object3d = new egret3d.Billboard(new egret3d.TextureMaterial(egret3d.CheckerboardTexture.texture));
                }
                else if (mapNodeData.type == "Terrain") {
                    mapNodeData.object3d = new egret3d.Object3D();
                }
                else if (mapNodeData.type == "DirectLight") {
                    var dirLight = new egret3d.DirectLight();
                    mapNodeData.object3d = dirLight;
                    dirLight.lightId = mapNodeData.lightData.id;
                    dirLight.diffuse = mapNodeData.lightData.diffuseColor;
                    dirLight.ambient = mapNodeData.lightData.ambientColor;
                    dirLight.halfIntensity = mapNodeData.lightData.halfIntensity;
                    dirLight.intensity = mapNodeData.lightData.intensity;
                    this.lightDict[mapNodeData.lightData.id] = dirLight;
                }
                else if (mapNodeData.type == "PointLight") {
                    var pLight = new egret3d.PointLight();
                    mapNodeData.object3d = pLight;
                    pLight.lightId = mapNodeData.lightData.id;
                    pLight.ambient = mapNodeData.lightData.ambientColor;
                    pLight.diffuse = mapNodeData.lightData.diffuseColor;
                    pLight.radius = mapNodeData.lightData.radius;
                    pLight.cutoff = mapNodeData.lightData.falloff;
                    pLight.intensity = mapNodeData.lightData.intensity;
                    this.lightDict[mapNodeData.lightData.id] = pLight;
                }
                else {
                    mapNodeData.object3d = new egret3d.Object3D();
                }
                mapNodeData.object3d.name = mapNodeData.name;
                mapNodeData.object3d.visible = mapNodeData.visible;
                mapNodeData.object3d.position = new egret3d.Vector3D(mapNodeData.x, mapNodeData.y, mapNodeData.z);
                mapNodeData.object3d.orientation = new egret3d.Quaternion(mapNodeData.rx, mapNodeData.ry, mapNodeData.rz, mapNodeData.rw);
                mapNodeData.object3d.scale = new egret3d.Vector3D(mapNodeData.sx, mapNodeData.sy, mapNodeData.sz);
                if (mapNodeData.tagName != "") {
                    mapNodeData.object3d.tag.name = mapNodeData.tagName;
                }
            }
            for (var i = 0; i < this._mapParser.nodeList.length; i++) {
                var mapNodeData0 = this._mapParser.nodeList[i];
                for (var j = 0; j < this._mapParser.nodeList.length; j++) {
                    var mapNodeData1 = this._mapParser.nodeList[j];
                    if (mapNodeData0.parent == mapNodeData1.insID) {
                        mapNodeData1.object3d.addChild(mapNodeData0.object3d);
                        break;
                    }
                }
            }
        };
        UnitLoader.prototype.processSkinClip = function () {
            for (var key in this._mapParser.skeletonAnimationDict) {
                var skinClip = this._mapParser.skeletonAnimationDict[key];
                var id = Number(key);
                var skeletonAnimation = new egret3d.SkeletonAnimation(new egret3d.SkeletonAnimationState());
                this.skinClipDict[id] = skeletonAnimation;
                for (var i = 0; i < skinClip.clips.length; ++i) {
                    var clip = skinClip.clips[i];
                    var path = this._pathRoot + clip.path;
                    var clipData = {};
                    clipData.skinClip = skeletonAnimation;
                    clipData.skinData = skinClip;
                    clipData.clip = clip;
                    this.doAssetLoader(path, this.onSkinClip, clipData);
                }
            }
        };
        UnitLoader.prototype.processProAnim = function () {
            for (var key in this._mapParser.proAnimationDict) {
                var proData = this._mapParser.proAnimationDict[key];
                var id = Number(key);
                var proAnimation = new egret3d.PropertyAnimController();
                this.proAnimDict[id] = proAnimation;
                for (var i = 0; i < proData.clips.length; ++i) {
                    var clip = proData.clips[i];
                    var path = this._pathRoot + clip.path;
                    var clipData = {};
                    clipData.proAnimation = proAnimation;
                    clipData.proData = proData;
                    clipData.clip = clip;
                    this.doAssetLoader(path, this.onProAnim, clipData);
                }
            }
        };
        //灯光
        UnitLoader.prototype.createLight = function () {
            var mapLightData = null;
            for (var key in this._mapParser.lightDict) {
                mapLightData = this._mapParser.lightDict[key];
                if (mapLightData.type == egret3d.LightType.directlight && this._mapParser.directLight) {
                    var dirLight = new egret3d.DirectLight(mapLightData.direction);
                    dirLight.lightId = mapLightData.id;
                    dirLight.diffuse = mapLightData.diffuseColor;
                    dirLight.ambient = mapLightData.ambientColor;
                    dirLight.halfIntensity = mapLightData.halfIntensity;
                    dirLight.intensity = mapLightData.intensity;
                    this.lightDict[mapLightData.id] = dirLight;
                }
                else if (mapLightData.type == egret3d.LightType.pointlight && this._mapParser.pointLight) {
                    var pLight = new egret3d.PointLight(0);
                    pLight.lightId = mapLightData.id;
                    pLight.position = mapLightData.position;
                    pLight.ambient = mapLightData.ambientColor;
                    pLight.diffuse = mapLightData.diffuseColor;
                    pLight.radius = mapLightData.radius;
                    pLight.cutoff = mapLightData.falloff;
                    pLight.intensity = mapLightData.intensity;
                    this.lightDict[mapLightData.id] = pLight;
                }
            }
        };
        UnitLoader.prototype.onUnitLoader = function (e) {
            var mapNodeData = e.param;
            var unitLoader = e.target;
            unitLoader.removeEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onUnitLoader, this);
            switch (mapNodeData.type) {
                case UnitLoader.NODE_TYPE_EffectGroup:
                    this.processObject3d(mapNodeData, unitLoader.container);
                    var effectGroup = unitLoader.container;
                    if (effectGroup) {
                        if (mapNodeData.auto) {
                            this.addAutoAnimation(effectGroup);
                        }
                    }
                    break;
                case UnitLoader.NODE_TYPE_ParticleEmitter:
                    var particleData = unitLoader.data;
                    particleData.materialData = this._mapParser.matDict[mapNodeData.materialIDs[0]];
                    var particleNode = new egret3d.ParticleEmitter(particleData, new egret3d.TextureMaterial());
                    mapNodeData.visible = egret3d.Egret3DPolicy.useParticle;
                    this.processObject3d(mapNodeData, particleNode);
                    if (this.autoPlayAnimation || particleData.property.playOnAwake) {
                        this.addAutoAnimation(particleNode, 1, false, particleData.property.prewarm);
                    }
                    this.processMat(mapNodeData);
                    break;
            }
            this.doLoadEpa(mapNodeData);
            this.processTask(unitLoader);
        };
        /**
        * @language zh_CN
        * Object3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        UnitLoader.NODE_TYPE_Object3D = "Object3D";
        /**
        * @language zh_CN
        * Camera3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        UnitLoader.NODE_TYPE_Camera3D = "Camera3D";
        /**
        * @language zh_CN
        * @private
        * CubeSky
        * @version Egret 3.0
        * @platform Web,Native
        */
        UnitLoader.NODE_TYPE_CubeSky = "CubeSky";
        /**
        * @language zh_CN
        * @private
        * SphereSky
        * @version Egret 3.0
        * @platform Web,Native
        */
        UnitLoader.NODE_TYPE_SphereSky = "SphereSky";
        /**
        * @language zh_CN
        * Mesh
        * @version Egret 3.0
        * @platform Web,Native
        */
        UnitLoader.NODE_TYPE_MESH = "Mesh";
        /**
        * @language zh_CN
        * Terrain
        * @version Egret 3.0
        * @platform Web,Native
        */
        UnitLoader.NODE_TYPE_Terrain = "Terrain";
        /**
        * @language zh_CN
        * ParticleEmitter
        * @version Egret 3.0
        * @platform Web,Native
        */
        UnitLoader.NODE_TYPE_ParticleEmitter = "ParticleEmitter";
        /**
        * @language zh_CN
        * EffectGroup
        * @version Egret 3.0
        * @platform Web,Native
        */
        UnitLoader.NODE_TYPE_EffectGroup = "EffectGroup";
        return UnitLoader;
    }(egret3d.ILoader));
    egret3d.UnitLoader = UnitLoader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.UnitNodeData
    * @classdesc
    * 节点数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UnitNodeData = (function () {
        function UnitNodeData() {
            this.type = "";
            this.insID = 0;
            this.parent = 0;
            this.name = "";
            this.staticType = "";
            this.path = "";
            this.fov = 0.0;
            this.clipNear = 0.0;
            this.clipFar = 0.0;
            this.tagName = "";
            /**
             * @language zh_CN
             * 对应的材质球id
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.materialIDs = [];
            /**
             * @language zh_CN
             * 拥有的动画剪辑名的列表
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.skinClips = [];
            /**
             * @language zh_CN
             * 拥有的动画剪辑名的列表
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.propertyAnims = [];
            /**
             * @language zh_CN
             * 是否启用公告板模式
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.billboard = false;
            this.visible = true;
            /**
             * @language zh_CN
             * 坐标x
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.x = 0;
            /**
             * @language zh_CN
             * 坐标y
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.y = 0;
            /**
             * @language zh_CN
             * 坐标z
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.z = 0;
            /**
             * @language zh_CN
             * 旋转x分量
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.rx = 0;
            /**
             * @language zh_CN
             * 旋转y分量
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.ry = 0;
            /**
             * @language zh_CN
             * 旋转z分量
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.rz = 0;
            /**
             * @language zh_CN
             * 旋转w分量
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.rw = 0;
            /**
             * @language zh_CN
             * x轴缩放
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.sx = 1;
            /**
             * @language zh_CN
             * y轴缩放
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.sy = 1;
            /**
             * @language zh_CN
             * z轴缩放
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.sz = 1;
            this.skeletonAnimation = -1;
            this.propertyAnimsId = -1;
            //public texture: string = "";
            //public width: number = 0;
            //public height: number = 0;
            //public depth: number = 0;
            //public segmentsW: number = 0;
            //public segmentsH: number = 0;
            this.geometry = [];
            this.grass = [];
            this.childs = [];
            this.boneBind = {};
            this.lightIds = [];
            this.auto = false;
            this.loop = false;
            this.uv2Id = -1;
        }
        return UnitNodeData;
    }());
    egret3d.UnitNodeData = UnitNodeData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var IConfigParser = (function () {
        function IConfigParser(type) {
            /**
            * @language zh_CN
            * 资源列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.taskDict = {};
            this.type = type;
        }
        IConfigParser.TYPE_SCENE = "scene";
        IConfigParser.TYPE_SKIN_MESH = "ShinnedMesh";
        IConfigParser.TYPE_EFFECT_GROUP = "EffectGroup";
        IConfigParser.TYPE_PARTICLE = "ParticleConfig";
        IConfigParser.TYPE_TEXTUREPACKER = "TexturePacker";
        return IConfigParser;
    }());
    egret3d.IConfigParser = IConfigParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UnitConfigParser = (function (_super) {
        __extends(UnitConfigParser, _super);
        function UnitConfigParser(data, type, fileType) {
            _super.call(this, fileType);
            /**
             * @language zh_CN
             * 节点列表
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.nodeList = new Array();
            this.hudList = new Array();
            this.auto = false;
            this.loop = false;
            this.matDict = {};
            this.lightDict = {};
            this.skeletonAnimationDict = {};
            this.proAnimationDict = {};
            this.directLight = false;
            this.pointLight = false;
            this.textures = [];
            egret3d.UnitParserUtils.mapParser(type, data, this);
        }
        UnitConfigParser.prototype.calculateTask = function () {
            if (this.uv2) {
                this.taskDict[this.uv2] = 0;
            }
        };
        UnitConfigParser.prototype.calculateProAnimationTask = function (data) {
            for (var i = 0; i < data.clips; ++i) {
                var clip = data.clips[i];
                if (clip.path) {
                    this.taskDict[data.path] = 0;
                }
            }
        };
        UnitConfigParser.prototype.calculateSkeletonAnimationTask = function (data) {
            for (var i = 0; i < data.clips; ++i) {
                var clip = data.clips[i];
                if (clip.path) {
                    this.taskDict[data.path] = 0;
                }
            }
        };
        UnitConfigParser.prototype.calculateMatTask = function (data) {
            if (data.diffuseTextureName != "") {
                this.taskDict[data.diffuseTextureName] = 0;
            }
            if (data.normalTextureName != "") {
                this.taskDict[data.normalTextureName] = 0;
            }
            if (data.specularTextureName != "") {
                this.taskDict[data.specularTextureName] = 0;
            }
            for (var i = 0; i < data.methods.length; ++i) {
                var methodData = data.methods[i];
                for (var j = 0; j < methodData.texturesData.length; ++j) {
                    var texData = methodData.texturesData[j];
                    if (texData.path) {
                        this.taskDict[texData.path] = 0;
                    }
                }
            }
        };
        UnitConfigParser.prototype.calculateNodeTask = function (data) {
            if (data.path) {
                this.taskDict[data.path] = 0;
            }
            for (var j = 0; j < data.skinClips.length; j++) {
                var eamData = data.skinClips[j];
                if (eamData.path) {
                    this.taskDict[eamData.path] = 0;
                }
            }
            for (var j = 0; j < data.propertyAnims.length; ++j) {
                var propertyAnimsData = data.propertyAnims[j];
                if (propertyAnimsData.path) {
                    this.taskDict[propertyAnimsData.path] = 0;
                }
            }
            for (var j = 0; j < data.grass.length; ++j) {
                var grassData = data.grass[j];
                if (grassData.detailTexture) {
                    this.taskDict[grassData.detailTexture] = 0;
                }
                if (grassData.grassTexture) {
                    this.taskDict[grassData.detailTexture] = 0;
                }
            }
        };
        UnitConfigParser.prototype.calculateHudTask = function (data) {
            if (data.texture) {
                this.taskDict[data.texture] = 0;
            }
        };
        UnitConfigParser.prototype.calculateTextureTask = function (data) {
            if (data.path) {
                this.taskDict[data.path] = 0;
            }
        };
        return UnitConfigParser;
    }(egret3d.IConfigParser));
    egret3d.UnitConfigParser = UnitConfigParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.MaterialMethodData
    * @classdesc
    * 材质球的特效数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UnitMatMethodData = (function () {
        function UnitMatMethodData() {
            /**
             * @language zh_CN
             * 特效的类型
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.type = "";
            /**
             * @language zh_CN
             * 是否增强specular的强度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.usePower = false;
            /**
             * @language zh_CN
             * 贴图索引数据（name）
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.texturesData = [];
            /**
             * @language zh_CN
             * u的滚动速度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.uSpeed = 0;
            /**
             * @language zh_CN
             * v的滚动速度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.vSpeed = 0;
            this.play = true;
            this.loop = true;
            this.frameNum = 0;
            this.row = 0;
            this.col = 0;
            this.delayTime = 0;
            this.totalTime = 0;
        }
        UnitMatMethodData.methodType = {
            lightmapMethod: "lightmapMethod",
            uvRollMethod: "uvRollMethod",
            uvSpriteSheetMethod: "uvSpriteSheetMethod",
            mulUvRollMethod: "mulUvRollMethod",
            alphaMaskMethod: "alphaMaskMethod",
            streamerMethod: "streamerMethod",
            terrainARGBMethod: "terrainARGBMethod",
            waterWaveMethod: "waterWaveMethod",
            waterNormalMethod: "waterNormalMethod",
            particleUVRoll: "particleUVRoll",
        };
        return UnitMatMethodData;
    }());
    egret3d.UnitMatMethodData = UnitMatMethodData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.UnitMatSphereData
    * @classdesc
    * 材质球的特效数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UnitMatSphereData = (function () {
        function UnitMatSphereData() {
            /**
             * @language zh_CN
             * diffuse贴图的索引（name）
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.id = 0;
            /**
             * @language zh_CN
             * diffuse贴图的索引（name）
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.diffuseTextureName = "";
            /**
             * @language zh_CN
             * normal贴图的索引（name）
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.normalTextureName = "";
            /**
             * @language zh_CN
             * specular贴图的索引（name）
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.specularTextureName = "";
            /**
            * @language zh_CN
            * matcap贴图的索引（name）
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.matcapTextureName = "";
            /**
             * @language zh_CN
             * diffuse的颜色，0xffffff格式
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.diffuseColor = 0;
            /**
             * @language zh_CN
             * ambient的颜色，0xffffff格式
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.ambientColor = 0;
            /**
             * @language zh_CN
             * specular的颜色，0xffffff格式
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.specularColor = 0;
            /**
             * @language zh_CN
             * tintColor的颜色，0xaarrggbb格式
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.tintColor = 0x80808080;
            /**
             * @language zh_CN
             * 透明度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.alpha = 0;
            /**
             * @language zh_CN
             * specular增强等级
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.specularLevel = 0;
            /**
             * @language zh_CN
             * 光泽系数
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.gloss = 0;
            this.gamma = 1.0;
            this.refraction = 1.9;
            this.refractionintensity = 2.0;
            /**
             * @language zh_CN
             * ambient的强度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.ambientPower = 0;
            /**
             * @language zh_CN
             * diffuse的强度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.diffusePower = 0;
            /**
             * @language zh_CN
             * normal的强度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.normalPower = 0;
            /**
             * @language zh_CN
             * 是否产生阴影
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.castShadow = false;
            /**
             * @language zh_CN
             * 是否接受阴影
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.acceptShadow = false;
            /**
             * @language zh_CN
             * 是否平滑采样贴图
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.smooth = false;
            /**
             * @language zh_CN
             * 采样贴图的边缘是否重复
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.repeat = false;
            /**
             * @language zh_CN
             * 是否开启双面渲染
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.bothside = false;
            /**
             * @language zh_CN
             * 绘制模式设定
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.drawMode = 0;
            /**
             * @language zh_CN
             * 剔除模式设定
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.cullMode = 0;
            /**
             * @language zh_CN
             * 叠加模式
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.blendMode = 0;
            /**
             * @language zh_CN
             * alpha裁切值
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.cutAlpha = 0.7;
            /**
             * @language zh_CN
             * 材质球拥有的特效
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.methods = [];
            this.lightIds = [];
            /**
             * @language zh_CN
             * 材质球uv区域
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.uvRectangle = new egret3d.Rectangle(0, 0, 1, 1);
        }
        return UnitMatSphereData;
    }());
    egret3d.UnitMatSphereData = UnitMatSphereData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.UnitLightData
    * @classdesc
    * 顶光数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UnitLightData = (function () {
        function UnitLightData() {
            this.id = 0;
            /**
             * @language zh_CN
             * 灯光类型
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.type = 0;
            /**
             * @language zh_CN
             * diffuseColor
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.diffuseColor = 0xffffff;
            /**
             * @language zh_CN
             * ambientColor
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.ambientColor = 0xffffff;
            /**
             * @language zh_CN
             * 强度
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.intensity = 1.0;
            /**
             * @language zh_CN
             * 强度的一半
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.halfIntensity = 0.0;
            this.direction = new egret3d.Vector3D(-0.5, -0.6, 0.2);
            this.position = new egret3d.Vector3D();
            /**
             * @language zh_CN
             * 衰减值
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.falloff = 0.0;
            /**
             * @language zh_CN
             * 半径数据
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.radius = 100;
        }
        return UnitLightData;
    }());
    egret3d.UnitLightData = UnitLightData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var UnitHUDData = (function () {
        function UnitHUDData() {
            this.bothside = false;
        }
        return UnitHUDData;
    }());
    egret3d.UnitHUDData = UnitHUDData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.MapLoader
    * @classdesc
    * 注意：当前还能使用 但是之后版本会被弃用 会直接使用 UnitLoader 来替换这个类的功能
    * 加载egret地图类
    * 用于加载和解析egret地图文件的类，加载完毕后，mesh内容已经添加到了container中.
    * 主要封装了esm/eca/png/eam的加载和组装，以及mesh的render method相关信息，和灯光数据的生效.
    * 加载完毕后，会派发事件LoaderEvent3D.LOADER_COMPLETE
    * @see egret3d.UnitLoader
    *
    * @includeExample loader/parser/map/MapLoader.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MapLoader = (function (_super) {
        __extends(MapLoader, _super);
        /**
        * @language zh_CN
        * 加载场景配置文件 .json 或 .xml
        * @param url 默认参数为null  场景文件路径
        * @version Egret 3.0
        * @platform Web,Native
        */
        function MapLoader(url) {
            if (url === void 0) { url = null; }
            _super.call(this, url);
            this.container = this.createObject();
        }
        MapLoader.prototype.createObject = function () {
            this.scene = new egret3d.Scene3D();
            return this.scene;
        };
        MapLoader.prototype.onLoaderComplete = function () {
            _super.prototype.onLoaderComplete.call(this);
        };
        return MapLoader;
    }(egret3d.UnitLoader));
    egret3d.MapLoader = MapLoader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Role
    * @classdesc
    * 角色对象多个Mesh可能共用这个SkeletonAnimation
    * @see egret3d.Object3D
    *
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Role = (function (_super) {
        __extends(Role, _super);
        /**
        * @language zh_CN
        * 构造对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Role() {
            _super.call(this);
            /**
            * @language zh_CN
            * 骨骼动画 avatar
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.avatar = {};
        }
        /**
        * @language zh_CN
        * @private
        * 设置 avatar
        * @param part
        * @param mesh
        * @version Egret 3.0
        * @platform Web,Native
        */
        Role.prototype.setAvatar = function (part, mesh) {
            var tmp = this.avatar[part];
            if (tmp) {
                tmp.parent.removeChild(tmp);
            }
            this.avatar[part] = mesh;
            _super.prototype.addChild.call(this, mesh);
        };
        /**
        * @language zh_CN
        * @private
        * 删除 avatar
        * @param part
        * @version Egret 3.0
        * @platform Web,Native
        */
        Role.prototype.delAvatar = function (part) {
            if (this.avatar[part]) {
                delete this.avatar[part];
            }
        };
        Role.prototype.play = function (anim, speed, reset) {
            this.skeletonAnimation.play(anim, speed, reset);
        };
        /**
        * @language zh_CN
        * @param child
        * @returns Object3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        Role.prototype.addChild = function (child) {
            if (child instanceof egret3d.Mesh) {
                this.setAvatar(child.name, child);
            }
            else {
                _super.prototype.addChild.call(this, child);
            }
            return child;
        };
        /**
        * @language zh_CN
        * 增加一个子对象,并返回当前子对象
        * 在容器中添加子对象，如果有显示接口的，将会放到场景显示树种进行渲染逻辑运算，及渲染
        * @param child 增加的子对象
        * @param index 子对象的下标
        * @returns 子对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Role.prototype.addChildAt = function (child, index) {
            if (child instanceof egret3d.Mesh) {
                this.setAvatar(child.name, child);
            }
            else {
                _super.prototype.addChildAt.call(this, child, index);
            }
            return child;
        };
        /**
        * @language zh_CN
        * 移除child子对象 并返回
        * 移除显示列表中的指定对象，如果为空将会返回
        * @param child 子对象
        * @returns Object3D 如果成功就返回child,否则返回null
        * @version Egret 3.0
        * @platform Web,Native
        */
        Role.prototype.removeChild = function (child) {
            this.delAvatar(child.name);
            return _super.prototype.removeChild.call(this, child);
        };
        /**
        * @language zh_CN
        * 移除下标为index的子对象 并返回
        * @param index 子对象的下标
        * @returns 如果成功就返回child,否则返回null
        * @version Egret 3.0
        * @platform Web,Native
        */
        Role.prototype.removeChildAt = function (index) {
            var object3d = this.getChild(index);
            if (object3d) {
                this.delAvatar(object3d.name);
            }
            return _super.prototype.removeChildAt.call(this, index);
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        Role.prototype.update = function (time, delay) {
        };
        /**
        * @language zh_CN
        * @private
        * @param other copy对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Role.prototype.copy = function (other) {
            _super.prototype.copy.call(this, other);
            //this.skeletonAnimation = other.skeletonAnimation.clone();
        };
        /**
        * @language zh_CN
        * @private
        * 克隆当前Role
        * @returns Role 克隆后的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Role.prototype.clone = function () {
            var cloneRole = new Role();
            var skeletonAnimation = this.skeletonAnimation.clone();
            cloneRole.skeletonAnimation = skeletonAnimation;
            for (var i = 0; i < this.childs.length; i++) {
                if (this.childs[i] instanceof egret3d.Mesh) {
                    var mesh = this.childs[i].clone();
                    mesh.animation = skeletonAnimation;
                    cloneRole.setAvatar(mesh.name, mesh);
                }
            }
            return cloneRole;
        };
        return Role;
    }(egret3d.Object3D));
    egret3d.Role = Role;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.RoleLoader
    * @classdesc
    * 加载角色
    * @see egret3d.UnitLoader
    * @version Egret 3.0
    * @platform Web,Native
    */
    var RoleLoader = (function (_super) {
        __extends(RoleLoader, _super);
        /**
        * @language zh_CN
        * 构造
        * @param url 角色文件路径
        * @version Egret 3.0
        * @platform Web,Native
        */
        function RoleLoader(url) {
            if (url === void 0) { url = null; }
            _super.call(this, url);
            this.container = this.createObject();
        }
        RoleLoader.prototype.createObject = function () {
            this.role = new egret3d.Role();
            return this.role;
        };
        return RoleLoader;
    }(egret3d.UnitLoader));
    egret3d.RoleLoader = RoleLoader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ParticleXmlParser
     * @classdesc
     * 用 ParticleXmlParser 解析粒子文件
     */
    var ParticleXmlParser = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function ParticleXmlParser() {
        }
        /**
         * @language zh_CN
         * @param xml 粒子特效的数据解析
         * @returns ParticleData
         */
        ParticleXmlParser.prototype.parse = function (xml, data) {
            this._particleData = data;
            this.version = this.getNode(xml, "version").textContent;
            //property
            var propertyNode = this.getNode(xml, "property");
            this.parseProperty(propertyNode);
            //emission
            var emissionNode = this.getNode(xml, "emission");
            this.parseEmission(emissionNode);
            //life
            var life = this.getNode(xml, "life");
            this.parseLife(life);
            //shape
            var shape = this.getNode(xml, "shape");
            this.parseShape(shape);
            //rotationBirth
            var rotationBirth = this.getNode(xml, "rotationBirth");
            this.parseRotationBirth(rotationBirth);
            //scaleBirth
            var scaleBirth = this.getNode(xml, "scaleBirth");
            this.parseScaleBirth(scaleBirth);
            //geometry
            var geometry = this.getNode(xml, "geometry");
            this.parseGeometry(geometry);
            //moveSpeed
            var moveSpeed = this.getNode(xml, "moveSpeed");
            this.parseMoveSpeed(moveSpeed);
            //followTarget
            var followTarget = this.getNode(xml, "followTarget");
            this.parseFollowTarget(followTarget);
            //parseBezierNode
            var scaleBezier = this.getNode(xml, "scaleBezier");
            this.parseScaleBeizer(scaleBezier);
            //rotationSpeed
            var rotationSpeed = this.getNode(xml, "rotationSpeed");
            this.parseRotationSpeed(rotationSpeed);
            //colorOffset
            var colorOffset = this.getNode(xml, "colorOffset");
            this.parseColorOffset(colorOffset);
            //material
            var material = this.getNode(xml, "mat");
            //textureSheet
            var textureSheet = this.getNode(xml, "textureSheet");
            this.parseTextureSheet(textureSheet);
        };
        /**
         * @private
         * 解析基础属性
         */
        ParticleXmlParser.prototype.parseProperty = function (node) {
            var property = this._particleData.property;
            property.particleCount = Number(this.getNode(node, "particleCount").textContent);
            property.prewarm = this.getNode(node, "prewarm").textContent == "true";
            property.playOnAwake = this.getNode(node, "playOnAwake").textContent == "true";
            var bounds = this.getNode(node, "bounds");
            property.bounds = this.parseVector3D(bounds, property.bounds);
            //color
            property.colorType = egret3d.ParticleBirthColorType[this.getNode(node, "colorType").textContent];
            var colorConst1 = this.getNode(node, "colorConst1");
            var colorConst2 = this.getNode(node, "colorConst2");
            var gradients1 = this.getNode(node, "colorGradients1");
            var gradients2 = this.getNode(node, "colorGradients2");
            this.parseColorProperty(property, colorConst1, colorConst2, gradients1, gradients2);
            //gravity
            property.gravity = Number(this.getNode(node, "gravity").textContent);
            //transform
            var transform = this.getNode(node, "transform");
            var rotation = this.getNode(transform, "rotation");
            var scale = this.getNode(transform, "scale");
            var position = this.getNode(transform, "position");
            property.rotation = this.parseVector3D(rotation, property.rotation);
            property.scale = this.parseVector3D(scale, property.scale);
            property.position = this.parseVector3D(position, property.position);
            //render
            var render = this.getNode(node, "render");
            var renderMode = this.getNode(render, "renderMode");
            if (renderMode) {
                property.renderMode = egret3d.ParticleRenderModeType[renderMode.textContent];
            }
            var lengthScale = this.getNode(render, "lengthScale");
            if (lengthScale) {
                property.lengthScale = Number(lengthScale.textContent);
            }
            var cameraScale = this.getNode(render, "cameraScale");
            if (cameraScale) {
                property.cameraScale = Number(cameraScale.textContent);
            }
            var speedScale = this.getNode(render, "speedScale");
            if (speedScale) {
                property.speedScale = Number(speedScale.textContent);
            }
            //meshFile
            var meshFile = this.getNode(render, "meshFile");
            if (meshFile && meshFile.textContent != "") {
                property.meshFile = meshFile.textContent;
            }
            //fudge
            var sortingFudge = this.getNode(node, "sortingFudge");
            if (sortingFudge) {
                property.sortingFudge = Number(sortingFudge.textContent);
            }
        };
        /**
         * @private
         * 解析颜色属性
         */
        ParticleXmlParser.prototype.parseColorProperty = function (property, c1, c2, cg1, cg2) {
            if (c1) {
                property.colorConst1 = egret3d.Color.createColor(Number(c1.textContent));
            }
            if (c2) {
                property.colorConst2 = egret3d.Color.createColor(Number(c2.textContent));
            }
            if (cg1) {
                var itemList = this.getNodeList(cg1, "item");
                property.colorGradients1 = this.parseGradientsColor(itemList, property.colorGradients1);
            }
            if (cg2) {
                var itemList = this.getNodeList(cg2, "item");
                property.colorGradients2 = this.parseGradientsColor(itemList, property.colorGradients2);
            }
        };
        /**
         * @private
         * 解析发射器数据
         */
        ParticleXmlParser.prototype.parseEmission = function (node) {
            var emission = this._particleData.emission;
            emission.type = egret3d.ParticleValueType[this.getNode(node, "type").textContent];
            emission.rate = Number(this.getNode(node, "rate").textContent);
            var bursts = this.getNode(node, "bursts");
            var item;
            var nodeName;
            var i = 0;
            var count = 0;
            var pt;
            if (bursts) {
                emission.bursts = [];
                var itemList = this.getNodeList(bursts, "item");
                for (i = 0, count = itemList ? itemList.length : 0; i < count; i++) {
                    item = itemList[i];
                    pt = new egret3d.Point();
                    emission.bursts.push(pt);
                    this.eachAttr(item, function (label, value) {
                        if (label == "time") {
                            pt.x = Number(value);
                        }
                        else if (label == "count") {
                            pt.y = Number(value);
                        }
                    });
                }
            }
            var bezier = this.getNode(node, "bezier");
            if (emission.type == egret3d.ParticleValueType.OneBezier) {
                emission.bezier = this.parseBezierData(bezier);
            }
        };
        /**
         * @private
         * 解析生命周期相关数据
         */
        ParticleXmlParser.prototype.parseLife = function (node) {
            var life = this._particleData.life;
            life.type = egret3d.ParticleValueType[this.getNode(node, "type").textContent];
            life.min = Number(this.getNode(node, "min").textContent);
            life.max = Number(this.getNode(node, "max").textContent);
            life.bezier1 = this.parseBezierData(this.getNode(node, "bezier1"));
            life.bezier2 = this.parseBezierData(this.getNode(node, "bezier2"));
            life.duration = Number(this.getNode(node, "duration").textContent);
            life.delay = Number(this.getNode(node, "delay").textContent);
            life.loop = this.getNode(node, "loop").textContent == "true";
        };
        /**
         * @private
         * 解析发射器的范围类型
         */
        ParticleXmlParser.prototype.parseShape = function (node) {
            if (node == null)
                return;
            var shape = this._particleData.shape;
            shape.type = egret3d.ParticleDataShapeType[this.getNode(node, "type").textContent];
            shape.randomDirection = this.getNode(node, "randomDirection").textContent == "true";
            var emitFromShell = this.getNode(node, "emitFromShell");
            shape.emitFromShell = emitFromShell && emitFromShell.textContent == "true";
            //cube
            var cube = this.getNode(node, "cube");
            this.eachAttr(cube, function (label, value) {
                if (label == "width") {
                    shape.cubeW = Number(value);
                }
                else if (label == "height") {
                    shape.cubeH = Number(value);
                }
                else if (label == "depth") {
                    shape.cubeD = Number(value);
                }
            });
            //sphere
            var sphereRadius = this.getNode(node, "sphereRadius");
            if (sphereRadius) {
                shape.sphereRadius = Number(sphereRadius.textContent);
            }
            //hemiSphereRadius
            var hemiSphereRadius = this.getNode(node, "hemiSphereRadius");
            if (hemiSphereRadius) {
                shape.hemiSphereRadius = Number(hemiSphereRadius.textContent);
            }
            //cone
            var cone = this.getNode(node, "cone");
            this.eachAttr(cone, function (label, value) {
                if (label == "type") {
                    shape.coneType = egret3d.ParticleConeShapeType[value];
                }
                else if (label == "length") {
                    shape.coneLength = Number(value);
                }
                else if (label == "radius") {
                    shape.coneRadius = Number(value);
                }
                else if (label == "angle") {
                    shape.coneAngle = Number(value);
                }
            });
            //meshType
            var meshType = this.getNode(node, "meshType");
            if (meshType) {
                shape.meshType = egret3d.ParticleMeshShapeType[meshType.textContent];
            }
            //meshFile
            var meshFile = this.getNode(node, "meshFile");
            if (meshFile && meshFile.textContent != "") {
                shape.meshFile = meshFile.textContent;
            }
        };
        /**
         * @private
         * 解析粒子出生的旋转信息
         */
        ParticleXmlParser.prototype.parseRotationBirth = function (node) {
            var rotationBirth = this._particleData.rotationBirth;
            rotationBirth.type = egret3d.ParticleValueType[this.getNode(node, "type").textContent];
            rotationBirth.min = Number(this.getNode(node, "min").textContent);
            rotationBirth.max = Number(this.getNode(node, "max").textContent);
            rotationBirth.bezier1 = this.parseBezierData(this.getNode(node, "bezier1"));
            rotationBirth.bezier2 = this.parseBezierData(this.getNode(node, "bezier2"));
        };
        /**
         * @private
         * 解析粒子出生的缩放信息
         */
        ParticleXmlParser.prototype.parseScaleBirth = function (node) {
            var scaleBirth = this._particleData.scaleBirth;
            scaleBirth.type = egret3d.ParticleValueType[this.getNode(node, "type").textContent];
            scaleBirth.min = Number(this.getNode(node, "min").textContent);
            scaleBirth.max = Number(this.getNode(node, "max").textContent);
            scaleBirth.bezier1 = this.parseBezierData(this.getNode(node, "bezier1"));
            scaleBirth.bezier2 = this.parseBezierData(this.getNode(node, "bezier2"));
        };
        /**
         * @private
         * 解析粒子的几何形状
         */
        ParticleXmlParser.prototype.parseGeometry = function (node) {
            var geometry = this._particleData.geometry;
            var plane = this.getNode(node, "plane");
            this.eachAttr(plane, function (label, value) {
                if (label == "width") {
                    geometry.planeW = Number(value);
                }
                else if (label == "height") {
                    geometry.planeH = Number(value);
                }
            });
        };
        /**
         * @private
         * 解析粒子速度相关信息
         */
        ParticleXmlParser.prototype.parseMoveSpeed = function (node) {
            var moveSpeed = this._particleData.moveSpeed;
            moveSpeed.type = egret3d.ParticleValueType[this.getNode(node, "type").textContent];
            moveSpeed.min = Number(this.getNode(node, "min").textContent);
            moveSpeed.max = Number(this.getNode(node, "max").textContent);
            moveSpeed.bezier1 = this.parseBezierData(this.getNode(node, "bezier1"));
            moveSpeed.bezier2 = this.parseBezierData(this.getNode(node, "bezier2"));
            var velocityOverNode = this.getNode(node, "velocityOver");
            if (velocityOverNode) {
                var velocityOver = new egret3d.VelocityOverLifeTimeData();
                velocityOver.type = egret3d.ParticleValueType[this.getNode(velocityOverNode, "type").textContent];
                var min = this.getNode(velocityOverNode, "min");
                var max = this.getNode(velocityOverNode, "max");
                velocityOver.min = this.parseVector3D(min, velocityOver.min);
                velocityOver.max = this.parseVector3D(max, velocityOver.max);
                velocityOver.worldSpace = this.getNode(velocityOverNode, "worldSpace").textContent == "true";
                velocityOver.xBezier1 = this.parseBezierData(this.getNode(velocityOverNode, "xBezier1"));
                velocityOver.yBezier1 = this.parseBezierData(this.getNode(velocityOverNode, "yBezier1"));
                velocityOver.zBezier1 = this.parseBezierData(this.getNode(velocityOverNode, "zBezier1"));
                velocityOver.xBezier2 = this.parseBezierData(this.getNode(velocityOverNode, "xBezier2"));
                velocityOver.yBezier2 = this.parseBezierData(this.getNode(velocityOverNode, "yBezier2"));
                velocityOver.zBezier2 = this.parseBezierData(this.getNode(velocityOverNode, "zBezier2"));
                moveSpeed.velocityOver = velocityOver;
            }
            var velocityForceNode = this.getNode(node, "velocityForce");
            if (velocityForceNode) {
                var velocityForce = new egret3d.VelocityForceLifeTimeData();
                velocityForce.type = egret3d.ParticleValueType[this.getNode(velocityForceNode, "type").textContent];
                var min = this.getNode(velocityForceNode, "min");
                var max = this.getNode(velocityForceNode, "max");
                velocityForce.min = this.parseVector3D(min, velocityForce.min);
                velocityForce.max = this.parseVector3D(max, velocityForce.max);
                velocityForce.worldSpace = this.getNode(velocityForceNode, "worldSpace").textContent == "true";
                velocityForce.xBezier1 = this.parseBezierData(this.getNode(velocityForceNode, "xBezier1"));
                velocityForce.yBezier1 = this.parseBezierData(this.getNode(velocityForceNode, "yBezier1"));
                velocityForce.zBezier1 = this.parseBezierData(this.getNode(velocityForceNode, "zBezier1"));
                velocityForce.xBezier2 = this.parseBezierData(this.getNode(velocityForceNode, "xBezier2"));
                velocityForce.yBezier2 = this.parseBezierData(this.getNode(velocityForceNode, "yBezier2"));
                velocityForce.zBezier2 = this.parseBezierData(this.getNode(velocityForceNode, "zBezier2"));
                moveSpeed.velocityForce = velocityForce;
            }
            var velocityLimitNode = this.getNode(node, "velocityLimit");
            if (velocityLimitNode) {
                var velocityLimit = new egret3d.VelocityLimitLifeTimeData();
                velocityLimit.type = egret3d.ParticleValueType[this.getNode(velocityLimitNode, "type").textContent];
                var min = this.getNode(velocityLimitNode, "min");
                var max = this.getNode(velocityLimitNode, "max");
                var dampen = this.getNode(velocityLimitNode, "dampen");
                velocityLimit.min = Number(min.textContent);
                velocityLimit.max = Number(max.textContent);
                velocityLimit.dampen = dampen ? Number(dampen.textContent) : 0;
                velocityLimit.bezier1 = this.parseBezierData(this.getNode(velocityLimitNode, "bezier1"));
                velocityLimit.bezier2 = this.parseBezierData(this.getNode(velocityLimitNode, "bezier2"));
                moveSpeed.velocityLimit = velocityLimit;
            }
        };
        /**
         * @private
         * 解析全局位置or本地位置类型
         */
        ParticleXmlParser.prototype.parseFollowTarget = function (node) {
            if (node == null)
                return;
            var followTarget = this._particleData.followTarget = new egret3d.ParticleDataFollowTarget();
            followTarget.followRotation = this.getNode(node, "followRotation").textContent == "true";
            followTarget.followScale = this.getNode(node, "followScale").textContent == "true";
        };
        /**
         * @private
         * 解析粒子生命过程中缩放变化信息
         */
        ParticleXmlParser.prototype.parseScaleBeizer = function (node) {
            if (node == null)
                return;
            var scaleBezier = this._particleData.scaleSize = new egret3d.ParticleDataScaleSize();
            scaleBezier.bezier1 = this.parseBezierData(this.getNode(node, "bezier"));
        };
        /**
        * @private
        * 解析粒子旋转角速度
        */
        ParticleXmlParser.prototype.parseRotationSpeed = function (node) {
            if (node == null)
                return;
            var rotationSpeed = this._particleData.rotationSpeed = new egret3d.ParticleDataRotationSpeed();
            rotationSpeed.type = egret3d.ParticleValueType[this.getNode(node, "type").textContent];
            var min = this.getNode(node, "min");
            var max = this.getNode(node, "max");
            rotationSpeed.min = this.parseVector3D(min, rotationSpeed.min);
            rotationSpeed.max = this.parseVector3D(max, rotationSpeed.max);
            rotationSpeed.bezier1 = this.parseBezierData(this.getNode(node, "bezier1"));
            rotationSpeed.bezier2 = this.parseBezierData(this.getNode(node, "bezier2"));
        };
        /**
        * @private
        * 解析粒子生命过程中颜色渐变信息
        */
        ParticleXmlParser.prototype.parseColorOffset = function (node) {
            if (node == null)
                return;
            var colorOffset = this._particleData.colorOffset = new egret3d.ParticleDataColorOffset();
            var itemList = this.getNodeList(node, "item");
            colorOffset.data = this.parseGradientsColor(itemList, colorOffset.data);
        };
        /**
        * @private
        * 解析材质球
        */
        ParticleXmlParser.prototype.parseTextureSheet = function (node) {
            if (node == null)
                return null;
            var textureSheet = this._particleData.textureSheet = new egret3d.ParticleDataTextureSheet();
            textureSheet.frameType = egret3d.ParticleValueType[this.getNode(node, "frameType").textContent];
            textureSheet.tileX = Number(this.getNode(node, "tileX").textContent);
            textureSheet.tileY = Number(this.getNode(node, "tileY").textContent);
            textureSheet.whole = this.getNode(node, "whole").textContent == "true";
            textureSheet.row = Number(this.getNode(node, "row").textContent);
            textureSheet.min = Number(this.getNode(node, "min").textContent);
            textureSheet.max = Number(this.getNode(node, "max").textContent);
            textureSheet.circles = Number(this.getNode(node, "circles").textContent);
            textureSheet.bezier1 = this.parseBezierData(this.getNode(node, "bezier1"));
            textureSheet.bezier2 = this.parseBezierData(this.getNode(node, "bezier2"));
            return textureSheet;
        };
        /**
        * @private
        * 解析渐变数据
        */
        ParticleXmlParser.prototype.parseGradientsColor = function (itemList, dst) {
            dst || (dst = new egret3d.ColorGradients);
            var item;
            var i = 0;
            var count = 0;
            var pt;
            var color;
            var time;
            for (i = 0, count = itemList ? itemList.length : 0; i < count; i++) {
                item = itemList[i];
                this.eachAttr(item, function (label, value) {
                    if (label == "time") {
                        dst.times.push(Number(value));
                    }
                    else if (label == "color") {
                        color = egret3d.Color.createColor(Number(value));
                        dst.colors.push(color);
                    }
                });
            }
            //排序
            var sortTimes = dst.times.slice();
            var sortColors = dst.colors.slice();
            sortTimes.sort(function (a, b) {
                return a - b;
            });
            for (i = 0, count = dst ? dst.times.length : 0; i < count; i++) {
                var index = sortTimes.indexOf(dst.times[i]);
                dst.colors[i] = sortColors[index];
            }
            dst.times = sortTimes;
            return dst;
        };
        /**
        * @private
        * 解析一条贝塞尔曲线数据
        */
        ParticleXmlParser.prototype.parseBezierData = function (node) {
            var bzData = new egret3d.BezierData();
            if (node == null)
                return bzData;
            var posList = this.getNodeList(node, "pos");
            var ctrlList = this.getNodeList(node, "ctrl");
            var item;
            var i = 0;
            var count = 0;
            var pt;
            for (i = 0, count = posList ? posList.length : 0; i < count; i++) {
                item = posList[i];
                pt = new egret3d.Point();
                bzData.posPoints.push(pt);
                this.eachAttr(item, function (label, value) {
                    if (label == "x") {
                        pt.x = Number(value);
                    }
                    else if (label == "y") {
                        pt.y = Number(value);
                    }
                });
            }
            for (i = 0, count = ctrlList ? ctrlList.length : 0; i < count; i++) {
                item = ctrlList[i];
                pt = new egret3d.Point();
                bzData.ctrlPoints.push(pt);
                this.eachAttr(item, function (label, value) {
                    if (label == "x") {
                        pt.x = Number(value);
                    }
                    else if (label == "y") {
                        pt.y = Number(value);
                    }
                });
            }
            return bzData;
        };
        /**
        * @private
        * 解析一个vector3D数据
        */
        ParticleXmlParser.prototype.parseVector3D = function (node, vector) {
            if (vector == null)
                vector = new egret3d.Vector3D();
            this.eachAttr(node, function (label, value) {
                if (label == "x") {
                    vector.x = Number(value);
                }
                else if (label == "y") {
                    vector.y = Number(value);
                }
                else if (label == "z") {
                    vector.z = Number(value);
                }
            });
            return vector;
        };
        /**
        * @private
        * 在obj中，获取name的元素，第一个
        */
        ParticleXmlParser.prototype.getNode = function (obj, name) {
            if (obj == null)
                return null;
            var list = obj.getElementsByTagName(name);
            if (list == null || list.length == 0)
                return null;
            return list[0];
        };
        /**
         * @private
         * 在obj中，获取name的元素列表
         */
        ParticleXmlParser.prototype.getNodeList = function (obj, name) {
            if (obj == null)
                return null;
            var list = obj.getElementsByTagName(name);
            if (list == null || list.length == 0)
                return null;
            return list;
        };
        ParticleXmlParser.prototype.eachAttr = function (item, fun) {
            egret3d.XMLParser.eachXmlAttr(item, fun);
        };
        return ParticleXmlParser;
    }());
    egret3d.ParticleXmlParser = ParticleXmlParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ParticleJsonParser
     * @classdesc
     * 用 ParticleJsonParser 解析粒子文件
     */
    var ParticleJsonParser = (function () {
        function ParticleJsonParser() {
        }
        /**
         * @language zh_CN
         * @param json 粒子特效的数据解析
         * @returns ParticleData
         */
        ParticleJsonParser.prototype.parse = function (json, data) {
            this._particleData = data;
            this.engineVersion = json.engineVersion + "";
            this.version = json.version + "";
            //property
            var propertyNode = json.property;
            this.parseProperty(propertyNode);
            //emission
            var emissionNode = json.emission;
            this.parseEmission(emissionNode);
            //life
            var life = json.life;
            this.parseLife(life);
            //shape
            var shape = json.shape;
            this.parseShape(shape);
            //rotationBirth
            var rotationBirth = json.rotationBirth;
            this.parseRotationBirth(rotationBirth);
            //scaleBirth
            var scaleBirth = json.scaleBirth;
            this.parseScaleBirth(scaleBirth);
            //geometry
            var geometry = json.geometry;
            this.parseGeometry(geometry);
            //moveSpeed
            var moveSpeed = json.moveSpeed;
            this.parseMoveSpeed(moveSpeed);
            //followTarget
            var followTarget = json.followTarget;
            this.parseFollowTarget(followTarget);
            //parseBezierNode
            var scaleSize = json.scaleSize;
            var scaleBezier = json.scaleBezier;
            if (scaleSize) {
                this.parseScaleSize(scaleSize);
            }
            else {
                this.parseScaleBeizer(scaleBezier);
            }
            //rotationSpeed
            var rotationSpeed = json.rotationSpeed;
            this.parseRotationSpeed(rotationSpeed);
            //colorOffset
            var colorOffset = json.colorOffset;
            this.parseColorOffset(colorOffset);
            //material
            var material = json.mat;
            //textureSheet
            var textureSheet = json.textureSheet;
            this.parseTextureSheet(textureSheet);
        };
        /**
         * @private
         * 解析基础属性
         */
        ParticleJsonParser.prototype.parseProperty = function (node) {
            var property = this._particleData.property;
            property.particleCount = Number(node.particleCount);
            property.prewarm = node.prewarm;
            if (node.playOnAwake != undefined) {
                property.playOnAwake = node.playOnAwake;
            }
            property.bounds = this.parseVector3D(node.bounds, property.bounds);
            //color
            property.colorType = egret3d.ParticleBirthColorType[node.colorType + ""];
            var colorConst1 = node.colorConst1;
            var colorConst2 = node.colorConst2;
            var gradients1 = node.colorGradients1;
            var gradients2 = node.colorGradients2;
            this.parseColorProperty(property, colorConst1, colorConst2, gradients1, gradients2);
            //gravity
            property.gravity = Number(node.gravity);
            //transform
            var transform = node.transform;
            var rotation = transform.rotation;
            var scale = transform.scale;
            var position = transform.position;
            property.rotation = this.parseVector3D(rotation, property.rotation);
            property.scale = this.parseVector3D(scale, property.scale);
            property.position = this.parseVector3D(position, property.position);
            //render
            var render = node.render;
            property.renderMode = egret3d.ParticleRenderModeType[render.renderMode + ""];
            property.lengthScale = Number(render.lengthScale);
            property.cameraScale = Number(render.cameraScale);
            property.speedScale = Number(render.speedScale);
            //meshFile
            property.meshFile = render.meshFile;
            if (property.meshFile == "") {
                property.meshFile = null;
            }
            //fudge
            property.sortingFudge = Number(node.sortingFudge);
        };
        /**
         * @private
         * 解析颜色属性
         */
        ParticleJsonParser.prototype.parseColorProperty = function (property, c1, c2, cg1, cg2) {
            if (c1) {
                property.colorConst1 = egret3d.Color.createColor(Number(c1));
            }
            if (c2) {
                property.colorConst2 = egret3d.Color.createColor(Number(c2));
            }
            if (cg1) {
                property.colorGradients1 = this.parseGradientsColor(cg1, property.colorGradients1);
            }
            if (cg2) {
                property.colorGradients2 = this.parseGradientsColor(cg2, property.colorGradients2);
            }
        };
        /**
         * @private
         * 解析发射器数据
         */
        ParticleJsonParser.prototype.parseEmission = function (node) {
            var emission = this._particleData.emission;
            emission.type = egret3d.ParticleValueType[node.type + ""];
            emission.rate = Number(node.rate);
            //bursts
            var bursts = node.bursts;
            var i = 0;
            var count = 0;
            var pt;
            var item;
            if (bursts) {
                emission.bursts = [];
                for (i = 0, count = bursts ? bursts.length : 0; i < count; i++) {
                    item = bursts[i];
                    pt = new egret3d.Point();
                    pt.x = Number(item[0]);
                    pt.y = Number(item[1]);
                    emission.bursts.push(pt);
                }
            }
            //bezier
            if (emission.type == egret3d.ParticleValueType.OneBezier) {
                emission.bezier = this.parseFoldLine(node.line) || this.parseBezierData(node.bezier);
            }
        };
        /**
         * @private
         * 解析生命周期相关数据
         */
        ParticleJsonParser.prototype.parseLife = function (node) {
            var life = this._particleData.life;
            life.type = egret3d.ParticleValueType[node.type + ""];
            life.min = Number(node.min);
            life.max = Number(node.max);
            life.bezier1 = this.parseFoldLine(node.line1) || this.parseBezierData(node.bezier1);
            life.bezier2 = this.parseFoldLine(node.line2) || this.parseBezierData(node.bezier2);
            life.duration = Number(node.duration);
            life.delay = Number(node.delay);
            life.loop = node.loop;
        };
        /**
         * @private
         * 解析发射器的范围类型
         */
        ParticleJsonParser.prototype.parseShape = function (node) {
            if (node == null)
                return;
            var shape = this._particleData.shape;
            shape.type = egret3d.ParticleDataShapeType[node.type + ""];
            shape.randomDirection = node.randomDirection;
            shape.emitFromShell = node.emitFromShell;
            //cube
            var cube = node.cube;
            if (cube) {
                shape.cubeW = Number(cube[0]);
                shape.cubeH = Number(cube[1]);
                shape.cubeD = Number(cube[2]);
            }
            //sphere
            shape.sphereRadius = Number(node.sphereRadius);
            //hemiSphereRadius
            shape.hemiSphereRadius = Number(node.hemiSphereRadius);
            //cone
            if (shape.type == egret3d.ParticleDataShapeType.Cone) {
                var cone = node.cone;
                shape.coneType = egret3d.ParticleConeShapeType[cone.type + ""];
                shape.coneLength = Number(cone.length);
                shape.coneRadius = Number(cone.radius);
                shape.coneAngle = Number(cone.angle);
            }
            //meshType
            shape.meshType = egret3d.ParticleMeshShapeType[node.meshType + ""];
            //meshFile
            shape.meshFile = node.meshFile;
            if (shape.meshFile == "") {
                shape.meshFile = null;
            }
        };
        /**
         * @private
         * 解析粒子出生的旋转信息
         */
        ParticleJsonParser.prototype.parseRotationBirth = function (node) {
            var rotationBirth = this._particleData.rotationBirth;
            rotationBirth.type = egret3d.ParticleValueType[node.type + ""];
            rotationBirth.min = Number(node.min);
            rotationBirth.max = Number(node.max);
            rotationBirth.bezier1 = this.parseFoldLine(node.line1) || this.parseBezierData(node.bezier1);
            rotationBirth.bezier2 = this.parseFoldLine(node.line2) || this.parseBezierData(node.bezier2);
        };
        /**
         * @private
         * 解析粒子出生的缩放信息
         */
        ParticleJsonParser.prototype.parseScaleBirth = function (node) {
            var scaleBirth = this._particleData.scaleBirth;
            scaleBirth.type = egret3d.ParticleValueType[node.type + ""];
            scaleBirth.min = Number(node.min);
            scaleBirth.max = Number(node.max);
            scaleBirth.bezier1 = this.parseFoldLine(node.line1) || this.parseBezierData(node.bezier1);
            scaleBirth.bezier2 = this.parseFoldLine(node.line2) || this.parseBezierData(node.bezier2);
        };
        /**
         * @private
         * 解析粒子的几何形状
         */
        ParticleJsonParser.prototype.parseGeometry = function (node) {
            var geometry = this._particleData.geometry;
            var plane = node.plane;
            geometry.planeW = Number(plane[0]);
            geometry.planeH = Number(plane[1]);
        };
        /**
         * @private
         * 解析粒子速度相关信息
         */
        ParticleJsonParser.prototype.parseMoveSpeed = function (node) {
            var moveSpeed = this._particleData.moveSpeed;
            moveSpeed.type = egret3d.ParticleValueType[node.type + ""];
            moveSpeed.min = Number(node.min);
            moveSpeed.max = Number(node.max);
            moveSpeed.bezier1 = this.parseFoldLine(node.line1) || this.parseBezierData(node.bezier1);
            moveSpeed.bezier2 = this.parseFoldLine(node.line2) || this.parseBezierData(node.bezier2);
            var velocityOverNode = node.velocityOver;
            if (velocityOverNode) {
                var velocityOver = new egret3d.VelocityOverLifeTimeData();
                velocityOver.type = egret3d.ParticleValueType[velocityOverNode.type + ""];
                velocityOver.min = this.parseVector3D(velocityOverNode.min, velocityOver.min);
                velocityOver.max = this.parseVector3D(velocityOverNode.max, velocityOver.max);
                velocityOver.worldSpace = velocityOverNode.worldSpace;
                velocityOver.xBezier1 = this.parseFoldLine(node.xLine1) || this.parseBezierData(velocityOverNode.xBezier1);
                velocityOver.yBezier1 = this.parseFoldLine(node.yLine1) || this.parseBezierData(velocityOverNode.yBezier1);
                velocityOver.zBezier1 = this.parseFoldLine(node.zLine1) || this.parseBezierData(velocityOverNode.zBezier1);
                velocityOver.xBezier2 = this.parseFoldLine(node.xLine2) || this.parseBezierData(velocityOverNode.xBezier2);
                velocityOver.yBezier2 = this.parseFoldLine(node.yLine2) || this.parseBezierData(velocityOverNode.yBezier2);
                velocityOver.zBezier2 = this.parseFoldLine(node.zLine2) || this.parseBezierData(velocityOverNode.zBezier2);
                moveSpeed.velocityOver = velocityOver;
            }
            var velocityForceNode = node.velocityForce;
            if (velocityForceNode) {
                var velocityForce = new egret3d.VelocityForceLifeTimeData();
                velocityForce.type = egret3d.ParticleValueType[velocityForceNode.type + ""];
                velocityForce.min = this.parseVector3D(velocityForceNode.min, velocityForce.min);
                velocityForce.max = this.parseVector3D(velocityForceNode.max, velocityForce.max);
                velocityForce.worldSpace = velocityForceNode.worldSpace;
                velocityForce.xBezier1 = this.parseFoldLine(node.xLine1) || this.parseBezierData(velocityForceNode.xBezier1);
                velocityForce.yBezier1 = this.parseFoldLine(node.yLine1) || this.parseBezierData(velocityForceNode.yBezier1);
                velocityForce.zBezier1 = this.parseFoldLine(node.zLine1) || this.parseBezierData(velocityForceNode.zBezier1);
                velocityForce.xBezier2 = this.parseFoldLine(node.xLine2) || this.parseBezierData(velocityForceNode.xBezier2);
                velocityForce.yBezier2 = this.parseFoldLine(node.yLine2) || this.parseBezierData(velocityForceNode.yBezier2);
                velocityForce.zBezier2 = this.parseFoldLine(node.zLine2) || this.parseBezierData(velocityForceNode.zBezier2);
                moveSpeed.velocityForce = velocityForce;
            }
            var velocityLimitNode = node.velocityLimit;
            if (velocityLimitNode) {
                var velocityLimit = new egret3d.VelocityLimitLifeTimeData();
                velocityLimit.type = egret3d.ParticleValueType[velocityLimitNode.type + ""];
                velocityLimit.min = Number(velocityLimitNode.min);
                velocityLimit.max = Number(velocityLimitNode.max);
                velocityLimit.dampen = Number(velocityLimitNode.dampen);
                velocityLimit.bezier1 = this.parseFoldLine(node.line1) || this.parseBezierData(velocityLimitNode.bezier1);
                velocityLimit.bezier2 = this.parseFoldLine(node.line2) || this.parseBezierData(velocityLimitNode.bezier2);
                moveSpeed.velocityLimit = velocityLimit;
            }
        };
        /**
         * @private
         * 解析全局位置or本地位置类型
         */
        ParticleJsonParser.prototype.parseFollowTarget = function (node) {
            if (node == null)
                return;
            var followTarget = this._particleData.followTarget = new egret3d.ParticleDataFollowTarget();
            followTarget.followRotation = node.followRotation;
            followTarget.followScale = node.followScale;
        };
        /**
         * @private
         * 解析粒子生命过程中缩放变化信息(早期版本，只支持一个贝塞尔曲线形势)
         */
        ParticleJsonParser.prototype.parseScaleBeizer = function (node) {
            if (node == null)
                return;
            var scaleBezier = this._particleData.scaleSize = new egret3d.ParticleDataScaleSize();
            scaleBezier.type = egret3d.ParticleValueType.OneBezier;
            scaleBezier.bezier1 = this.parseFoldLine(node.line) || this.parseBezierData(node.bezier);
        };
        /**
         * @private
         * 解析粒子生命过程中缩放变化信息
         */
        ParticleJsonParser.prototype.parseScaleSize = function (node) {
            if (node == null)
                return;
            var scaleSize = this._particleData.scaleSize = new egret3d.ParticleDataScaleSize();
            scaleSize.type = egret3d.ParticleValueType[node.type + ""];
            scaleSize.min = Number(node.min);
            scaleSize.max = Number(node.max);
            scaleSize.bezier1 = this.parseFoldLine(node.line1) || this.parseBezierData(node.bezier1);
            scaleSize.bezier2 = this.parseFoldLine(node.line2) || this.parseBezierData(node.bezier2);
        };
        /**
        * @private
        * 解析粒子旋转角速度
        */
        ParticleJsonParser.prototype.parseRotationSpeed = function (node) {
            if (node == null)
                return;
            var rotationSpeed = this._particleData.rotationSpeed = new egret3d.ParticleDataRotationSpeed();
            rotationSpeed.type = egret3d.ParticleValueType[node.type + ""];
            rotationSpeed.min = this.parseVector3D(node.min, rotationSpeed.min);
            rotationSpeed.max = this.parseVector3D(node.max, rotationSpeed.max);
            rotationSpeed.bezier1 = this.parseFoldLine(node.line1) || this.parseBezierData(node.bezier1);
            rotationSpeed.bezier2 = this.parseFoldLine(node.line2) || this.parseBezierData(node.bezier2);
        };
        /**
        * @private
        * 解析粒子生命过程中颜色渐变信息
        */
        ParticleJsonParser.prototype.parseColorOffset = function (node) {
            if (node == null)
                return;
            var colorOffset = this._particleData.colorOffset = new egret3d.ParticleDataColorOffset();
            colorOffset.data = this.parseGradientsColor(node.item, colorOffset.data);
        };
        /**
        * @private
        * 解析材质球
        */
        ParticleJsonParser.prototype.parseTextureSheet = function (node) {
            if (node == null)
                return null;
            var textureSheet = this._particleData.textureSheet = new egret3d.ParticleDataTextureSheet();
            textureSheet.frameType = egret3d.ParticleValueType[node.frameType + ""];
            textureSheet.tileX = Number(node.tileX);
            textureSheet.tileY = Number(node.tileY);
            textureSheet.whole = node.whole;
            textureSheet.row = Number(node.row);
            textureSheet.min = Number(node.min);
            textureSheet.max = Number(node.max);
            textureSheet.circles = Number(node.circles);
            textureSheet.bezier1 = this.parseFoldLine(node.line1) || this.parseBezierData(node.bezier1);
            textureSheet.bezier2 = this.parseFoldLine(node.line2) || this.parseBezierData(node.bezier2);
            return textureSheet;
        };
        /**
        * @private
        * 解析渐变数据
        */
        ParticleJsonParser.prototype.parseGradientsColor = function (itemList, dst) {
            dst || (dst = new egret3d.ColorGradients);
            var item;
            var i = 0;
            var count = 0;
            var color;
            for (i = 0, count = itemList ? itemList.length : 0; i < count; i++) {
                item = itemList[i];
                dst.times.push(Number(item[0]));
                color = egret3d.Color.createColor(Number(item[1]));
                dst.colors.push(color);
            }
            //排序
            var sortTimes = dst.times.slice();
            var sortColors = dst.colors.slice();
            sortTimes.sort(function (a, b) {
                return a - b;
            });
            for (i = 0, count = dst ? dst.times.length : 0; i < count; i++) {
                var index = sortTimes.indexOf(dst.times[i]);
                dst.colors[i] = sortColors[index];
            }
            dst.times = sortTimes;
            return dst;
        };
        /**
        * @private
        * 解析一条贝塞尔曲线数据
        */
        ParticleJsonParser.prototype.parseBezierData = function (node) {
            var bzData = new egret3d.BezierData();
            bzData.lineMode = false;
            if (node == null)
                return bzData;
            var item;
            var i = 0;
            var count = 0;
            var pt;
            for (i = 0, count = node ? node.length : 0; i < count; i++) {
                item = node[i];
                pt = new egret3d.Point();
                pt.x = Number(item[1]);
                pt.y = Number(item[2]);
                if (item[0] == "pos") {
                    bzData.posPoints.push(pt);
                }
                else {
                    bzData.ctrlPoints.push(pt);
                }
            }
            return bzData;
        };
        /**
        * @private
        * 解析一条折线数据
        */
        ParticleJsonParser.prototype.parseFoldLine = function (node) {
            if (node == null)
                return null;
            var bzData = new egret3d.BezierData();
            bzData.lineMode = true;
            var item;
            var i = 0;
            var count = 0;
            var pt;
            for (i = 0, count = node ? node.length : 0; i < count; i++) {
                item = node[i];
                pt = new egret3d.Point();
                pt.x = Number(item[0]);
                pt.y = Number(item[1]);
                bzData.linePoints.push(pt);
            }
            return bzData;
        };
        /**
        * @private
        * 解析一个vector3D数据
        */
        ParticleJsonParser.prototype.parseVector3D = function (node, vector) {
            if (vector == null)
                vector = new egret3d.Vector3D();
            if (node) {
                vector.x = Number(node[0]);
                vector.y = Number(node[1]);
                vector.z = Number(node[2]);
            }
            return vector;
        };
        return ParticleJsonParser;
    }());
    egret3d.ParticleJsonParser = ParticleJsonParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ParticleParser
     * @classdesc
     * 用 ParticleParser 解析粒子文件
     */
    var ParticleParser = (function (_super) {
        __extends(ParticleParser, _super);
        function ParticleParser(data, type, fileType) {
            if (fileType === void 0) { fileType = egret3d.IConfigParser.TYPE_PARTICLE; }
            _super.call(this, fileType);
            switch (type) {
                case "xml":
                    this.data = this.parseXml(data);
                    break;
                case "json":
                    this.data = this.parseJson(data);
                    break;
            }
            if (this.data.shape.meshFile) {
                this.taskDict[this.data.shape.meshFile] = 0;
            }
            if (this.data.property.meshFile) {
                this.taskDict[this.data.property.meshFile] = 0;
            }
        }
        /**
         * @language zh_CN
         * @param xml 粒子特效的数据解析
         * @returns ParticleData
         */
        ParticleParser.prototype.parseJson = function (text) {
            this.data = new egret3d.ParticleData();
            var parser = new egret3d.ParticleJsonParser();
            parser.parse(text, this.data);
            this.version = Number(parser.version);
            this.engineVersion = String(parser.engineVersion);
            this.data.validate();
            return this.data;
        };
        ParticleParser.prototype.parseXml = function (text) {
            this.data = new egret3d.ParticleData();
            var parser = new egret3d.ParticleXmlParser();
            parser.parse(text, this.data);
            this.version = Number(parser.version);
            this.data.validate();
            return this.data;
        };
        return ParticleParser;
    }(egret3d.IConfigParser));
    egret3d.ParticleParser = ParticleParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var TexturePackerParser = (function (_super) {
        __extends(TexturePackerParser, _super);
        function TexturePackerParser(data, type, fileType) {
            _super.call(this, fileType);
            this.data = data;
            switch (type) {
                case "json":
                    if (this.data.meta && this.data.meta.image) {
                        this.taskDict[this.data.meta.image] = 0;
                    }
                    break;
            }
        }
        return TexturePackerParser;
    }(egret3d.IConfigParser));
    egret3d.TexturePackerParser = TexturePackerParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.ParserUtils
    * @classdesc
    * 用 ParserUtils 类 解析所有egret自定义 文件
    * @see egret3d.EventDispatcher
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParserUtils = (function (_super) {
        __extends(ParserUtils, _super);
        function ParserUtils() {
            _super.apply(this, arguments);
            this._event = new egret3d.ParserEvent3D();
        }
        /**
        * @language zh_CN
        * 传入数据流对象，解析出相应的数据对象.
        * 解析dds tga jpg png esm eam eca
        * @param buffer 需要解析的数据流
        * @returns 是否解析成功
        */
        ParserUtils.prototype.parser = function (buffer) {
            var _this = this;
            var bytes = new egret3d.ByteArray(buffer);
            var fileFormatBytes = new egret3d.ByteArray();
            bytes.readBytes(fileFormatBytes, 0, 3);
            bytes.position = 0;
            var fileFormat = 0;
            fileFormat |= fileFormatBytes.readUnsignedByte() << 16;
            fileFormat |= fileFormatBytes.readUnsignedByte() << 8;
            fileFormat |= fileFormatBytes.readUnsignedByte();
            switch (fileFormat) {
                case 0x00444453:
                    this.datas = egret3d.DDSParser.parse(buffer);
                    this.dataFormat = ".dds";
                    this.doLoadComplete();
                    break;
                case 0x00000002:
                case 0x00000010:
                    this.datas = egret3d.TGAParser.parse(buffer);
                    this.dataFormat = ".tga";
                    this.doLoadComplete();
                    break;
                case 0x00FFD8FF:
                    var blob = new Blob([buffer]);
                    this.dataFormat = ".jpg";
                    var img = document.createElement("img");
                    if (window['createObjectURL'] != undefined) {
                        img.src = window['createObjectURL'](blob);
                    }
                    else if (window['URL'] != undefined) {
                        img.src = window['URL'].createObjectURL(blob);
                    }
                    else if (window['webkitURL'] != undefined) {
                        img.src = window['webkitURL'].createObjectURL(blob);
                    }
                    img.onload = function () { return _this.onLoad(img); };
                    break;
                case 0x0089504E:
                    var blob = new Blob([buffer]);
                    this.dataFormat = ".png";
                    var img = document.createElement("img");
                    if (window['createObjectURL'] != undefined) {
                        img.src = window['createObjectURL'](blob);
                    }
                    else if (window['URL'] != undefined) {
                        img.src = window['URL'].createObjectURL(blob);
                    }
                    else if (window['webkitURL'] != undefined) {
                        img.src = window['webkitURL'].createObjectURL(blob);
                    }
                    img.onload = function () { return _this.onLoad(img); };
                    break;
                case 0x0065736D:
                    this.dataFormat = ".esm";
                    this.datas = egret3d.ESMParser.parse(buffer);
                    this.doLoadComplete();
                    break;
                case 0x0065616D:
                    this.dataFormat = ".eam";
                    this.datas = egret3d.EAMParser.parse(buffer);
                    this.doLoadComplete();
                    break;
                case 0x00656361:
                    this.dataFormat = ".eca";
                    this.datas = egret3d.ECAParser.parse(buffer);
                    this.doLoadComplete();
                    break;
                default:
                    return false;
            }
            return true;
        };
        ParserUtils.prototype.onLoad = function (img) {
            this.datas = new egret3d.ImageTexture(img);
            this.doLoadComplete();
            window.URL.revokeObjectURL(img.src);
            img.onload = null;
        };
        ParserUtils.prototype.doLoadComplete = function () {
            this._event.eventType = egret3d.ParserEvent3D.PARSER_COMPLETE;
            this._event.data = this;
            this._event.parser = this;
            this.dispatchEvent(this._event);
        };
        return ParserUtils;
    }(egret3d.EventDispatcher));
    egret3d.ParserUtils = ParserUtils;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.QueueLoader
    * @classdesc
    * 队列加载器。</p>
    * 每个加载对象都是一个 UnitLoader。</p>
    * 可以进行多个资源形成队列加载。</p>
    * 可加载文件。</p>
    * *.text|*.txt|*.xml|*.json 文本类型          ----- <string>转换 </p>
    * * MapConfig.json 加载的 由unity3d插件导出文件 ----- <Object3D></p>
    * *.png|*.jpg                                 ----- <ImageTexture>转换 </p>
    * *.dds|*.hdr|*.tga                           ----- <Texture>转换 </p>
    * *.esm                                       ----- <Geometry>转换 </p>
    * *.eam                                       ----- <SkeletonAnimationClip>转换 </p>
    * *.epa                                       ----- <PropertyAnim>转换 </p>
    * 加载后会触发事件。</p>
    * @see egret3d.EventDispatcher
    * @see egret3d.UnitLoader
    * @see egret3d.ILoader
    * @see egret3d.LoaderEvent3D
    *
    * @includeExample loader/QueueLoader.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var QueueLoader = (function (_super) {
        __extends(QueueLoader, _super);
        /**
        * @language zh_CN
        * 加载文件  可以为任意文件
        * @param url 默认参数为null  文件路径
        * @version Egret 3.0
        * @platform Web,Native
        */
        function QueueLoader(url) {
            if (url === void 0) { url = null; }
            _super.call(this);
            this.dictLoader = {};
            this.currentLoader = null;
            this.dictProgress = {};
            this.queueLoader = [];
            this._event = new egret3d.LoaderEvent3D();
            /**
            * @language zh_CN
            * 任务总数
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.taskTotal = 0;
            /**
            * @language zh_CN
            * 当前完成的任务个数
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.taskCurrent = 0;
            /**
            * @language zh_CN
            * 当前进度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.currentProgress = 0;
            this.lastProgress = 0;
            if (url) {
                this.load(url);
            }
        }
        /**
        * @language zh_CN
        * 加载文件
        * 多次调用 代表加载多个资源文件
        * @param url 文件路径
        * @returns UnitLoader
        * @version Egret 3.0
        * @platform Web,Native
        */
        QueueLoader.prototype.load = function (url) {
            if (this.dictLoader[url]) {
                egret3d.Egret3DLog.outWarn("已经加载过[" + url + "]");
                return this.dictLoader[url];
            }
            this.taskTotal++;
            var loader = new egret3d.UnitLoader();
            this.dictLoader[url] = loader;
            loader.addEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onComplete, this);
            loader.addEventListener(egret3d.LoaderEvent3D.LOADER_PROGRESS, this.onProgress, this);
            this.dictProgress[url] = 0;
            this.queueLoader.push(url);
            if (!this.currentLoader) {
                this.currentLoader = this.dictLoader[url];
                this.currentLoader.load(url);
            }
            return loader;
        };
        /**
        * @language zh_CN
        * @private
        * 对某个文件进行事件侦听
        * @param url {string} 文件路径。
        * @param type {string} 事件的类型标识符。
        * @param callback {Function} 处理事件的侦听器函数。此函数必须接受 Event3D 对象作为其唯一的参数，并且不能返回任何结果，
        * @param thisObject {any} 当前注册对象。
        * @param param {any} 事件携带参数，默认为空。
        * @param priority {number} 事件侦听器的优先级。
        * @returns {number} 注册事件位置标识id
        * @version Egret 3.0
        * @platform Web,Native
        */
        QueueLoader.prototype.addAssetEventListener = function (url, type, callback, thisObject, param, priority) {
            if (param === void 0) { param = null; }
            if (priority === void 0) { priority = 0; }
            var loader = this.dictLoader[url];
            if (loader) {
                return loader.addEventListener(type, callback, thisObject, param, priority);
            }
            return 0;
        };
        /**
        * @language zh_CN
        * @private
        * 对文件进行移除事件侦听器。
        * @param url {string} 文件路径。
        * @param type {string} 事件名。
        * @param callback {Function} 侦听函数。
        * @param thisObject {any} 当前注册对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        QueueLoader.prototype.removeAssetEventListener = function (url, type, callback, thisObject, param, priority) {
            if (param === void 0) { param = null; }
            if (priority === void 0) { priority = 0; }
            var loader = this.dictLoader[url];
            if (loader) {
                loader.removeEventListener(type, callback, thisObject);
            }
        };
        /**
        * @language zh_CN
        * 获取资源数据</p>
        * *.text|*.txt|*.xml|*.json 文本类型          ----- <string>转换 </p>
        * *MapConfig.json 加载的 由unity3d插件导出文件 ----- <Object3D>   根据导出类型 Scene3D Role EffectGroup </p>
        * *.png|*.jpg                                 ----- <ImageTexture>转换 </p>
        * *.dds|*.hdr|*.tga                           ----- <Texture>转换 </p>
        * *.esm                                       ----- <Geometry>转换 </p>
        * *.eam                                       ----- <SkeletonAnimationClip>转换 </p>
        * *.epa                                       ----- <PropertyAnim>转换 </p>
        * @param url 文件路径
        * @returns any 加载完成后对应的数据
        * @see egret3d.ILoader.data
        * @version Egret 3.0
        * @platform Web,Native
        */
        QueueLoader.prototype.getAsset = function (url) {
            if (this.dictLoader[url]) {
                return this.dictLoader[url].data;
            }
            return egret3d.textureResMgr.getTexture(url);
        };
        /**
         * @language zh_CN
         * 获取安装配置好的动画，通过插件导出的数据 </p>
         * @param url 文件路径
         * @returns Mesh 配置好的动画
         * @see egret3d.ILoader.data
         * @version Egret 3.0
         * @platform Web,Native
         */
        QueueLoader.prototype.getAnim = function (url) {
            var obj = this.getAsset(url);
            if (obj instanceof egret3d.Mesh)
                return this.getAsset(url);
            return null;
        };
        /**
         * @language zh_CN
         * 获取加载的贴图纹理 *.png|*.jpg|*.dds|*.hdr|*.tga  </p>
         * @param url 文件路径
         * @returns ITexture *.png|*.jpg|*.dds|*.hdr|*.tga 贴图纹理
         * @see egret3d.ILoader.data
         * @version Egret 3.0
         * @platform Web,Native
         */
        QueueLoader.prototype.getTexture = function (url) {
            var obj = this.getAsset(url);
            if (obj instanceof egret3d.ITexture)
                return this.getAsset(url);
            return null;
        };
        /**
       * @language zh_CN
       * 获取加载的场景 对应 MapConfig.json 场景容器</p>
       * @param url 文件路径
       * @returns Object3D 场景容器
       * @see egret3d.ILoader.data
       * @version Egret 3.0
       * @platform Web,Native
       */
        QueueLoader.prototype.getScene = function (url) {
            var obj = this.getAsset(url);
            if (obj instanceof egret3d.Object3D)
                return this.getAsset(url);
            return null;
        };
        /**
        * @language zh_CN
        * 获取加载的动画 对应 *.text|*.txt|*.xml|*.json 文本类型</p>
        * @param url 文件路径
        * @returns string *.text|*.txt|*.xml|*.json 文本类型
        * @see egret3d.ILoader.data
        * @version Egret 3.0
        * @platform Web,Native
        */
        QueueLoader.prototype.getText = function (url) {
            var obj = this.getAsset(url);
            return this.getAsset(url);
        };
        /**
         * @language zh_CN
         * 获取加载的模型，对应 *.esm 文件</p>
         * @param url 文件路径
         * @returns Geometry 获取加载的模型
         * @see egret3d.ILoader.data
         * @version Egret 3.0
         * @platform Web,Native
         */
        QueueLoader.prototype.getGeometry = function (url) {
            var obj = this.getAsset(url);
            if (obj instanceof egret3d.Geometry)
                return this.getAsset(url);
            return null;
        };
        /**
       * @language zh_CN
       * 获取加载的动画 对应 *.eam </p>
       * @param url 文件路径
       * @returns SkeletonAnimationClip 获取加载的模型
       * @see egret3d.ILoader.data
       * @version Egret 3.0
       * @platform Web,Native
       */
        QueueLoader.prototype.getAnimClip = function (url) {
            var obj = this.getAsset(url);
            if (obj instanceof egret3d.SkeletonAnimationClip)
                return this.getAsset(url);
            return null;
        };
        /**
        * @language zh_CN
        * 获取每个资源的URLLoader对象
        * 如果获取的是配置文件会返回配置文件的源数据，而不是解释后的数据
        * @param url 文件路径
        * @returns URLLoader  URLLoader对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        QueueLoader.prototype.getAssetURLLoader = function (url) {
            return egret3d.assetMgr.findAsset(url, this);
        };
        /**
        * @language zh_CN
        * 获取每个资源的UnitLoader对象
        * @param url 文件路径
        * @returns UnitLoader  UnitLoader对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        QueueLoader.prototype.getUnitLoader = function (url) {
            return this.dictLoader[url];
        };
        QueueLoader.prototype.onComplete = function (e) {
            var loader = e.loader;
            loader.removeEventListener(egret3d.LoaderEvent3D.LOADER_COMPLETE, this.onComplete, this);
            loader.removeEventListener(egret3d.LoaderEvent3D.LOADER_PROGRESS, this.onProgress, this);
            this.taskCurrent++;
            this.queueLoader.shift();
            this._event.eventType = egret3d.LoaderEvent3D.LOADER_ONCE_COMPLETE;
            this._event.loader = loader;
            this._event.data = loader.data;
            this._event.currentProgress = this.currentProgress;
            this.dispatchEvent(this._event);
            if (this.queueLoader.length > 0) {
                var url = this.queueLoader[0];
                this.currentLoader = this.dictLoader[url];
                this.currentLoader.load(url);
            }
            else {
                this.guiComplete();
                this.currentLoader = null;
                this.currentProgress = 1.0;
                this._event.eventType = egret3d.LoaderEvent3D.LOADER_PROGRESS;
                this._event.currentProgress = this.currentProgress;
                this.dispatchEvent(this._event);
                var currentLoader = this.currentLoader;
                var taskTotal = this.taskTotal;
                var taskCurrent = this.taskCurrent;
                var removeList = [];
                for (var key in this.dictProgress) {
                    removeList.push(key);
                }
                var currentProgress = this.currentProgress;
                var lastProgress = this.lastProgress;
                this._event.eventType = egret3d.LoaderEvent3D.LOADER_COMPLETE;
                this._event.currentProgress = this.currentProgress;
                this.dispatchEvent(this._event);
                this.taskTotal = this.taskTotal - taskTotal;
                this.taskCurrent = this.taskCurrent - taskCurrent;
                for (var i = 0; i < removeList.length; ++i) {
                    if (this.dictProgress[removeList[i]] > 0) {
                        delete this.dictProgress[removeList[i]];
                    }
                }
                this.currentProgress = 0;
                this.lastProgress = 0;
            }
        };
        QueueLoader.prototype.onProgress = function (e) {
            var load = e.target;
            if (this.dictProgress[load.url] != undefined) {
                this.dictProgress[load.url] = load.currentProgress;
                this.currentProgress = 0;
                for (var key in this.dictProgress) {
                    this.currentProgress += 1 / (this.taskTotal) * this.dictProgress[key];
                }
                if (this.lastProgress < this.currentProgress) {
                    this.lastProgress = this.currentProgress;
                    this._event.eventType = egret3d.LoaderEvent3D.LOADER_PROGRESS;
                    this._event.loader = load;
                    this._event.data = load.data;
                    this._event.currentProgress = this.currentProgress;
                    this.dispatchEvent(this._event);
                }
            }
        };
        /**
        * @language zh_CN
        * 加载默认的GUI皮肤
        * @version Egret 3.0
        * @platform Web,Native
        */
        QueueLoader.prototype.loadDefaultGUISkin = function () {
            var fontsLoader = this.load("resource/ui/fonts.json");
            var guiLoader = this.load("resource/ui/GUI.json");
        };
        QueueLoader.prototype.guiComplete = function () {
            egret3d.gui.BitmapFont.load(egret3d.textureResMgr.getTextureDic());
            egret3d.gui.GUISkinManager.instance.initDefaultSkin();
        };
        /**
        * @language zh_CN
        * 释放所有数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        QueueLoader.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            for (var key in this.dictLoader) {
                this.dictLoader[key].dispose();
            }
            egret3d.assetMgr.dispose(this);
            this.dictLoader = {};
        };
        /**
        * @language zh_CN
        * 释放UnitLoader
        * @prame url 资源路径
        * @version Egret 3.0
        * @platform Web,Native
        */
        QueueLoader.prototype.disposeUnitLoader = function (url) {
            if (this.dictLoader[url]) {
                this.dictLoader[url].dispose();
                delete this.dictLoader[url];
            }
        };
        return QueueLoader;
    }(egret3d.EventDispatcher));
    egret3d.QueueLoader = QueueLoader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.MethodBase
    * @classdesc
    * 增加多种渲染效果的方法基类

    * @version Egret 3.0
    * @platform Web,Native
    */
    var MethodBase = (function () {
        function MethodBase() {
            /**
            * @private
            * @language zh_CN
            */
            this.vsShaderList = [];
            /**
            * @private
            * @language zh_CN
            */
            this.fsShaderList = [];
        }
        /**
        * @private
        * @language zh_CN
        */
        MethodBase.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D, renderQuen) {
        };
        /**
        * @private
        * @language zh_CN
        */
        MethodBase.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D, renderQuen) {
        };
        /**
        * @private
        * @language zh_CN
        */
        MethodBase.prototype.dispose = function () {
        };
        return MethodBase;
    }());
    egret3d.MethodBase = MethodBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.AlphaMaskMethod
    * @classdesc
    * 实现alpha遮罩渲染方法。
    * 该贴图的r通道被用于赋值到diffuse数据的alpha上面。
     * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/GUIMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var GUIMethod = (function (_super) {
        __extends(GUIMethod, _super);
        /**
        * @language zh_CN
        * 创建一个AlphaMaskMethod对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function GUIMethod() {
            _super.call(this);
            this.vsShaderList[egret3d.ShaderPhaseType.base_vertex] = this.vsShaderList[egret3d.ShaderPhaseType.base_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.base_vertex].push("gui_vs");
            this.fsShaderList[egret3d.ShaderPhaseType.base_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.base_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.base_fragment].push("gui_fs");
        }
        /**
        * @language zh_CN
        * 设置lightmap贴图
        * @param texture lightmap贴图
        * @version Egret 3.0
        * @platform Web,Native
        */
        GUIMethod.prototype.setTextures = function (index, texture) {
            var textureName = "uiTexture_" + index.toString();
            this.materialData[textureName] = texture;
            this.materialData[textureName].useMipmap = false;
        };
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        GUIMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        /**
        * @private
        * @language zh_CN
        */
        GUIMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        return GUIMethod;
    }(egret3d.MethodBase));
    egret3d.GUIMethod = GUIMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.TerrainARGBMethod
    * @classdesc
    * 地形贴图混合渲染方法。
    * 使用一张贴图中的ARGB色来进行4张贴图进行混合。
    * 总的需要5张纹理贴图，4张地表纹理，一张融合图
    * 地表最大支持4张地表纹理混合，后期如果需要更多，还可以增加额外的Pass来增加融合地表的纹理数量。
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/TerrainARGBMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TerrainARGBMethod = (function (_super) {
        __extends(TerrainARGBMethod, _super);
        /**
        * @language zh_CN
        * 创建地形贴图混合渲染方法
        * @param controlTex 混合贴图
        * @param splat_0 第一张贴图
        * @param splat_1 第二张贴图
        * @param splat_2 第三张贴图
        * @param splat_3 第四张贴图
        * @version Egret 3.0
        * @platform Web,Native
        */
        function TerrainARGBMethod(controlTex, splat_0, splat_1, splat_2, splat_3) {
            if (controlTex === void 0) { controlTex = egret3d.CheckerboardTexture.texture; }
            if (splat_0 === void 0) { splat_0 = egret3d.CheckerboardTexture.texture; }
            if (splat_1 === void 0) { splat_1 = egret3d.CheckerboardTexture.texture; }
            if (splat_2 === void 0) { splat_2 = egret3d.CheckerboardTexture.texture; }
            if (splat_3 === void 0) { splat_3 = egret3d.CheckerboardTexture.texture; }
            _super.call(this);
            this.uvs = new Float32Array(8);
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("terrainRGBA_fragment");
            this.controlTex = controlTex;
            this.splat_0 = splat_0;
            this.splat_1 = splat_1;
            this.splat_2 = splat_2;
            this.splat_3 = splat_3;
            this.uvs[0] = 1.0;
            this.uvs[1] = 1.0;
            this.uvs[2] = 1.0;
            this.uvs[3] = 1.0;
            this.uvs[4] = 1.0;
            this.uvs[5] = 1.0;
            this.uvs[6] = 1.0;
            this.uvs[7] = 1.0;
        }
        /**
        * @language zh_CN
        * 设置 UVTitling。
        * @param index {Number} 图层索引
        * @param x {Number} u 的重复次数
        * @param y {Number} v 的重复次数
        * @version Egret 3.0
        * @platform Web,Native
        */
        TerrainARGBMethod.prototype.setUVTitling = function (index, x, y) {
            this.uvs[index * 2] = x;
            this.uvs[index * 2 + 1] = y;
        };
        Object.defineProperty(TerrainARGBMethod.prototype, "splat_0_Texture", {
            /**
            * @language zh_CN
            * 设置第一张贴图
            * @param texture 贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                this.splat_0 = texture;
                this.materialData.splat_0Tex = texture;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainARGBMethod.prototype, "splat_1_Texture", {
            /**
            * @language zh_CN
            * 设置第二张贴图
            * @param texture 贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                this.splat_1 = texture;
                this.materialData.splat_1Tex = texture;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainARGBMethod.prototype, "splat_2_Texture", {
            /**
            * @language zh_CN
            * 设置第三张贴图
            * @version Egret 3.0
            * @platform Web,Native
            * @param texture 贴图
            */
            set: function (texture) {
                this.splat_2 = texture;
                this.materialData.splat_2Tex = texture;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainARGBMethod.prototype, "splat_3_Texture", {
            /**
            * @language zh_CN
            * 设置第四张贴图
            * @param texture 贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                this.splat_3 = texture;
                this.materialData.splat_3Tex = texture;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainARGBMethod.prototype, "controlTexture", {
            /**
            * @language zh_CN
            * 设置混合贴图
            * @param texture 贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                this.controlTex = texture;
                this.materialData.blendMaskTexture = texture;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        TerrainARGBMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uvs"] = context3DProxy.getUniformLocation(usage.program3D, "uvs");
        };
        /**
        * @language zh_CN
        * @private
        */
        TerrainARGBMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            context3DProxy.uniform1fv(usage["uvs"], this.uvs);
        };
        /**
        * @language zh_CN
        * @private
        */
        TerrainARGBMethod.prototype.dispose = function () {
        };
        return TerrainARGBMethod;
    }(egret3d.MethodBase));
    egret3d.TerrainARGBMethod = TerrainARGBMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.FogMethod
    * @classdesc
    * 继承自 MethodBase,为材质球附加特效的共有基类.
    * 3D物体雾化模式,继续像素的顶点雾化模式 提供几种显示方式
    * 如果要给场景添加雾化,务必需要将此方法赋予场景中的所有材质中
    * Exponential Height Fog渲染方法。
    * 实现3种fog类型： line、exp、exp height
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/FogMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var FogMethod = (function (_super) {
        __extends(FogMethod, _super);
        /**
        * @language zh_CN
        * 创建一个雾的渲染方法
        * @param fogType 雾的类型 line/exp/expHeightFog
        * @version Egret 3.0
        * @platform Web,Native
        */
        function FogMethod(fogType) {
            if (fogType === void 0) { fogType = "expHeightFog_fs"; }
            _super.call(this);
            this.uniform_globalFog = new Float32Array(7);
            this._fogColor = 0x0000cc;
            this._globalDensity = 1.0;
            this._fogStartDistance = 1000;
            this._fogDistanceScale = 0.5;
            this._height = 500;
            this._fogAlpha = 1.0;
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] = this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex].push("vertexPos_vs");
            if (fogType == "line") {
                this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment].push("lineFog");
            }
            else if (fogType == "exp") {
                this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment].push("expFog_fs");
            }
            else if (fogType == "expHeightFog_fs") {
                this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment] || [];
                this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment].push("expHeightFog_fs");
            }
            //0.5, 0.6, 0.7
            this.uniform_globalFog[0] = 0.5;
            this.uniform_globalFog[1] = 0.6;
            this.uniform_globalFog[2] = 0.7;
            this.uniform_globalFog[3] = this._globalDensity;
            this.uniform_globalFog[4] = this._fogStartDistance;
            this.uniform_globalFog[5] = this._height;
            this.uniform_globalFog[6] = this._fogAlpha;
        }
        Object.defineProperty(FogMethod.prototype, "fogColor", {
            /**
            * @language zh_CN
            * 获取雾颜色
            * @returns 雾颜色 rgb  0xffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.fogColor;
            },
            /**
            * @language zh_CN
            * 设置雾颜色
            * @param value 雾颜色 rgb  0xffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._fogColor = value;
                this.uniform_globalFog[0] = (this._fogColor >> 16 & 0xff) / 255.0;
                this.uniform_globalFog[1] = (this._fogColor >> 8 & 0xff) / 255.0;
                this.uniform_globalFog[2] = (this._fogColor & 0xff) / 255.0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FogMethod.prototype, "globalDensity", {
            /**
            * @language zh_CN
            * 获取雾的全局浓度
            * @returns number 雾的全局浓度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._globalDensity;
            },
            /**
            * @language zh_CN
            * 设置雾的全局浓度
            * @param value 雾的全局浓度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._globalDensity = value;
                this.uniform_globalFog[3] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FogMethod.prototype, "fogStartDistance", {
            /**
            * @language zh_CN
            * 获取雾的开始距离
            * @returns number 雾的开始距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._fogStartDistance;
            },
            /**
            * @language zh_CN
            * 设置雾的开始距离
            * @param value 雾的开始距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._fogStartDistance = value;
                this.uniform_globalFog[4] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FogMethod.prototype, "fogHeight", {
            /**
            * @language zh_CN
            * 获取雾的高度值
            * @returns number 雾的高度值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._height;
            },
            //public set fogDistanceScale(value: number) {
            //    this._fogDistanceScale = value;
            //    this.uniform_globalFog[5] = value;
            //}
            //public get fogDistanceScale(): number {
            //    return this._fogDistanceScale;
            //}
            /**
            * @language zh_CN
            * 设置雾的高度值
            * @param value 雾的高度值
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._height = value;
                this.uniform_globalFog[5] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FogMethod.prototype, "fogAlpha", {
            /**
            * @language zh_CN
            * 获取雾的Alpha值
            * @returns number 雾的Alpha值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._height;
            },
            /**
            * @language zh_CN
            * 设置雾的Alpha值
            * @param value 雾的Alpha值
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._height = value;
                this.uniform_globalFog[6] = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        FogMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uniform_globalFog"] = context3DProxy.getUniformLocation(usage.program3D, "uniform_globalFog");
        };
        /**
         * @language zh_CN
         * @private
         */
        FogMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            context3DProxy.uniform1fv(usage["uniform_globalFog"], this.uniform_globalFog);
        };
        /**
         * @language zh_CN
         * @private
         */
        FogMethod.prototype.dispose = function () {
        };
        return FogMethod;
    }(egret3d.MethodBase));
    egret3d.FogMethod = FogMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.FogMethod
    * @classdesc
    * Exponential Height Fog渲染方法。
    * 实现3种fog类型： line、exp、exp height
     * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/LineFogMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var LineFogMethod = (function (_super) {
        __extends(LineFogMethod, _super);
        /**
        * @language zh_CN
        * 创建一个雾的渲染方法
        * @param fogType 雾的类型 line/exp/expHeightFog
        * @version Egret 3.0
        * @platform Web,Native
        */
        function LineFogMethod() {
            _super.call(this);
            this.uniform_globalFog = new Float32Array(7);
            this._fogColor = 0x0000cc;
            this._fogStartDistance = 100;
            this._fogFarDistance = 1000;
            this._fogAlpha = 1.0;
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] = this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex].push("vertexPos_vs");
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment].push("lineFog");
            //0.5, 0.6, 0.7
            this.uniform_globalFog[0] = 0.5;
            this.uniform_globalFog[1] = 0.6;
            this.uniform_globalFog[2] = 0.7;
            this.uniform_globalFog[3] = 1.0;
            this.uniform_globalFog[4] = this._fogStartDistance;
            this.uniform_globalFog[5] = this._fogFarDistance;
            this.uniform_globalFog[6] = this._fogAlpha;
        }
        Object.defineProperty(LineFogMethod.prototype, "fogColor", {
            /**
            * @language zh_CN
            * 获取雾颜色
            * @returns 雾颜色 rgb  0xffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.fogColor;
            },
            /**
            * @language zh_CN
            * 设置雾颜色
            * @param value 雾颜色 rgb  0xffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._fogColor = value;
                this.uniform_globalFog[0] = (this._fogColor >> 16 & 0xff) / 255.0;
                this.uniform_globalFog[1] = (this._fogColor >> 8 & 0xff) / 255.0;
                this.uniform_globalFog[2] = (this._fogColor & 0xff) / 255.0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LineFogMethod.prototype, "fogStartDistance", {
            /**
            * @language zh_CN
            * 获取雾的开始距离
            * @returns number 雾的开始距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._fogStartDistance;
            },
            /**
            * @language zh_CN
            * 设置雾的开始距离
            * @param value 雾的开始距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._fogStartDistance = value;
                this.uniform_globalFog[4] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LineFogMethod.prototype, "fogFarDistance", {
            /**
            * @language zh_CN
            * 获取雾的结束距离
            * @returns number 雾的结束距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._fogFarDistance;
            },
            /**
            * @language zh_CN
            * 设置雾的结束距离
            * @param value 雾的结束距离
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._fogFarDistance = value;
                this.uniform_globalFog[5] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LineFogMethod.prototype, "fogAlpha", {
            /**
            * @language zh_CN
            * 获取雾的Alpha值
            * @returns number 雾的Alpha值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._fogAlpha;
            },
            /**
            * @language zh_CN
            * 设置雾的Alpha值
            * @param value 雾的Alpha值
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._fogAlpha = value;
                this.uniform_globalFog[6] = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        LineFogMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uniform_globalFog"] = context3DProxy.getUniformLocation(usage.program3D, "uniform_globalFog");
        };
        /**
         * @language zh_CN
         * @private
         */
        LineFogMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            context3DProxy.uniform1fv(usage["uniform_globalFog"], this.uniform_globalFog);
        };
        /**
         * @language zh_CN
         * @private
         */
        LineFogMethod.prototype.dispose = function () {
        };
        return LineFogMethod;
    }(egret3d.MethodBase));
    egret3d.LineFogMethod = LineFogMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVRollMethod
    * @classdesc
    * 用来实现UV滚动效果的渲染方法。
    * 可实现地图滚轴动画。
    * 可实现水流动画。
    * 可实现流动的岩浆特效。
    * 可实现扩散波纹特效。
    * 可实现吸血特效。
    * 根据美术的特效风格使用情况利用 uv roll 动画特效方法
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/UVRollMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UVRollMethod = (function (_super) {
        __extends(UVRollMethod, _super);
        /**
        * @private
        * @language zh_CN
        */
        function UVRollMethod() {
            _super.call(this);
            this._uvRoll = new Float32Array(2);
            this._speedU = 0.00005;
            this._speedV = 0.0;
            this._time = 0.0;
            this._start = false;
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("uvRoll_fs");
        }
        Object.defineProperty(UVRollMethod.prototype, "speedU", {
            /**
            * @language zh_CN
            * 获取UV u的滚动速度
            * @returns number u的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._speedU;
            },
            /**
            * @language zh_CN
            * 用来UV u的滚动速度
            * @param value u的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._speedU = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVRollMethod.prototype, "speedV", {
            /**
            * @language zh_CN
            * 获取UV v的滚动速度
            * @returns number v的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._speedV;
            },
            /**
            * @language zh_CN
            * 用来UV v的滚动速度
            * @param value v的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._speedV = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 开始播放uv动画
        * @param rest 如果为ture就是重置播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        UVRollMethod.prototype.start = function (rest) {
            if (rest === void 0) { rest = false; }
            if (rest)
                this._time = 0;
            this._start = true;
        };
        /**
        * @language zh_CN
        * 停止播放uv动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        UVRollMethod.prototype.stop = function () {
            this._start = false;
        };
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        UVRollMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uvRoll"] = context3DProxy.getUniformLocation(usage.program3D, "uvRoll");
        };
        /**
        * @private
        * @language zh_CN
        */
        UVRollMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (this._start) {
                this._time += delay;
            }
            this._uvRoll[0] = this._time * this._speedU;
            this._uvRoll[1] = this._time * this._speedV;
            context3DProxy.uniform1fv(usage["uvRoll"], this._uvRoll);
        };
        return UVRollMethod;
    }(egret3d.MethodBase));
    egret3d.UVRollMethod = UVRollMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVRollMethod
    * @classdesc
    * 用来实现多UV滚动效果的渲染方法
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/MulUVRollMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MulUVRollMethod = (function (_super) {
        __extends(MulUVRollMethod, _super);
        /**
        * @private
        * @language zh_CN
        */
        function MulUVRollMethod() {
            _super.call(this);
            this._uvRoll = new Float32Array(4);
            this._uvSpeed = new Float32Array(4);
            this._time = 0.0;
            this._start = false;
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("mulUvRoll_fs");
            this._uvSpeed[0] = 0.00005;
            this._uvSpeed[1] = 0.0;
            this._uvSpeed[2] = 0.00005;
            this._uvSpeed[3] = 0.0;
        }
        /**
        * @language zh_CN
        * 用来设置UV u的滚动速度
        * @param index 下标
        * @param value u的滚动速度
        * @version Egret 3.0
        * @platform Web,Native
        */
        MulUVRollMethod.prototype.setSpeedU = function (index, value) {
            this._uvSpeed[index * 2 + 0] = value;
        };
        /**
        * @language zh_CN
        * 获取UV u的滚动速度
        * @param index 下标
        * @returns number u的滚动速度
        * @version Egret 3.0
        * @platform Web,Native
        */
        MulUVRollMethod.prototype.getSpeedU = function (index) {
            return this._uvSpeed[index * 2 + 0];
        };
        /**
        * @language zh_CN
        * 用来设置UV v的滚动速度
        * @param index 下标
        * @param value v的滚动速度
        * @version Egret 3.0
        * @platform Web,Native
        */
        MulUVRollMethod.prototype.setSpeedV = function (index, value) {
            this._uvSpeed[index * 2 + 1] = value;
        };
        /**
        * @language zh_CN
        * 获取UV v的滚动速度
        * @param index 下标
        * @returns number v的滚动速度
        * @version Egret 3.0
        * @platform Web,Native
        */
        MulUVRollMethod.prototype.getSpeedV = function (index) {
            return this._uvSpeed[index * 2 + 1];
        };
        /**
        * @language zh_CN
        * 开始播放uv动画
        * @param rest 如果为ture就是重置播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        MulUVRollMethod.prototype.start = function (rest) {
            if (rest === void 0) { rest = false; }
            if (rest)
                this._time = 0;
            this._start = true;
        };
        /**
        * @language zh_CN
        * 停止播放uv动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        MulUVRollMethod.prototype.stop = function () {
            this._start = false;
        };
        Object.defineProperty(MulUVRollMethod.prototype, "diffuseTexture1", {
            /**
            * @language zh_CN
            * 获取流动贴图
            * @returns ITexture 流动贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._diffuseTexture1;
            },
            /**
            * @language zh_CN
            * 设置流动贴图
            * @param tex 流动贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (tex) {
                this._diffuseTexture1 = tex;
                this.materialData["diffuseTexture1"] = tex;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        MulUVRollMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["mulUvRoll"] = context3DProxy.getUniformLocation(usage.program3D, "mulUvRoll");
        };
        /**
        * @private
        * @language zh_CN
        */
        MulUVRollMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (this._start) {
                this._time += delay;
            }
            for (var i = 0; i < 4; ++i) {
                this._uvRoll[i] = this._time * this._uvSpeed[i];
            }
            context3DProxy.uniform1fv(usage["mulUvRoll"], this._uvRoll);
        };
        return MulUVRollMethod;
    }(egret3d.MethodBase));
    egret3d.MulUVRollMethod = MulUVRollMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.LightmapMethod
    * @classdesc
    * 实现lightmap渲染方法。
    * 在三维软件里实现打好光，然后渲染把场景各表面的光照输出到贴图上。
    * 然后使用模型的第2UV，渲染出Lightmap效果，lightmap贴图需要自己烘焙。
     * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/MultiUVSpriteMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MultiUVSpriteMethod = (function (_super) {
        __extends(MultiUVSpriteMethod, _super);
        /**
        * @language zh_CN
        * 创建一个MultiUVSpriteMethod对象
        * 构造函数
        * @param row 行数
        * @param column 列数
        * @param sum 序列帧的总数
        * @param isRandom 是否随机序列帧
        * @version Egret 3.0
        * @platform Web,Native
        */
        function MultiUVSpriteMethod(row, column, sum, isRandom) {
            if (isRandom === void 0) { isRandom = true; }
            _super.call(this);
            this._isRandom = true;
            this._multiData = new Float32Array(4);
            this._multiData[0] = row;
            this._multiData[1] = column;
            this._multiData[2] = sum;
            this._isRandom = isRandom;
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("MultiUVSprite_fs");
        }
        Object.defineProperty(MultiUVSpriteMethod.prototype, "row", {
            get: function () {
                return this._multiData[0];
            },
            set: function (v) {
                this._multiData[0] = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MultiUVSpriteMethod.prototype, "column", {
            get: function () {
                return this._multiData[1];
            },
            set: function (v) {
                this._multiData[1] = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MultiUVSpriteMethod.prototype, "sum", {
            get: function () {
                return this._multiData[2];
            },
            set: function (v) {
                this._multiData[2] = v;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        MultiUVSpriteMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["multiUV"] = context3DProxy.getUniformLocation(usage.program3D, "multiUV");
            if (this._isRandom)
                this._multiData[3] = Math.floor(Math.random() * this.sum);
        };
        /**
        * @private
        * @language zh_CN
        */
        MultiUVSpriteMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            context3DProxy.uniform4fv(usage["multiUV"], this._multiData);
        };
        return MultiUVSpriteMethod;
    }(egret3d.MethodBase));
    egret3d.MultiUVSpriteMethod = MultiUVSpriteMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVSpriteSheetMethod
    * @classdesc
    * 用来实现UV精灵动画的渲染方法 。
    * 一整张贴图中用行列来分割帧动画，然后实现每帧播放。
    * row * col 是总帧数， frameNum是只播放的帧数.
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/UVSpriteSheetMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var UVSpriteSheetMethod = (function (_super) {
        __extends(UVSpriteSheetMethod, _super);
        /**
        * @language zh_CN
        * 创建一个UV精灵动画的渲染方法对象
        * @param frameNum  帧数量
        * @param row 行数
        * @param column 列数
        * @param numTime 播放总时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        function UVSpriteSheetMethod(frameNum, row, column, numTime) {
            _super.call(this);
            this._uvSpriteSheet = new Float32Array(4);
            this._uvRectangle = new egret3d.Rectangle();
            this._speed = 0.0;
            this._time = 0.0;
            this._numTime = 0.4;
            this._start = false;
            this._frameNum = 12;
            this._row = 4;
            this._column = 4;
            this._currentFrame = 0;
            this.frameList = [];
            this._change = true;
            this._delayTime = 0.0;
            this._isLoop = true;
            this._currentDelay = 0.0;
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("uvSpriteSheet_fs");
            this.frameNum = frameNum;
            this.row = row;
            this.column = column;
            this.numTime = numTime;
        }
        UVSpriteSheetMethod.prototype.caculate = function () {
            this._change = false;
            this._speed = (this._numTime * 1000) / this._frameNum;
            this._uvRectangle.x = 0.0;
            this._uvRectangle.y = 0.0;
            this._uvRectangle.width = 1.0 / this._row;
            this._uvRectangle.height = 1.0 / this._column;
            this.frameList.length = this._frameNum;
            var rowIndex = 0;
            var columnIndex = 0;
            for (var i = 0; i < this._frameNum; i++) {
                rowIndex = i % this._row;
                columnIndex = Math.floor(i / this._column);
                var rec = new egret3d.Rectangle();
                rec.x = rowIndex * this._uvRectangle.width + this._uvRectangle.x;
                rec.y = columnIndex * this._uvRectangle.height + this._uvRectangle.y;
                rec.width = this._uvRectangle.width;
                rec.height = this._uvRectangle.height;
                this.frameList[i] = rec;
            }
        };
        Object.defineProperty(UVSpriteSheetMethod.prototype, "numTime", {
            /**
            * @language zh_CN
            * 获取动画播放总时间
            * @returns number 播放总时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._numTime;
            },
            /**
            * @language zh_CN
            * 设置动画播放总时间
            * @param value 播放总时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._numTime != value) {
                    this._change = true;
                    this._numTime = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVSpriteSheetMethod.prototype, "frameNum", {
            /**
            * @language zh_CN
            * 获取动画帧数
            * @returns number  动画帧数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._frameNum;
            },
            /**
            * @language zh_CN
            * 设置动画帧数
            * @param value 动画帧数
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._frameNum != value) {
                    this._change = true;
                    this._frameNum = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVSpriteSheetMethod.prototype, "row", {
            /**
            * @language zh_CN
            * 获取动画行数
            * @returns number  动画行数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._row;
            },
            /**
            * @language zh_CN
            * 设置动画行数
            * @param value 动画行数
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._row != value) {
                    this._change = true;
                    this._row = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVSpriteSheetMethod.prototype, "column", {
            /**
            * @language zh_CN
            * 获取动画列数
            * @returns number  动画列数
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._column;
            },
            /**
            * @language zh_CN
            * 设置动画列数
            * @param value 动画列数
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._column != value) {
                    this._change = true;
                    this._column = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 开始播放uv精灵动画
        * @param rest 如果为ture就是重置播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        UVSpriteSheetMethod.prototype.start = function (rest) {
            if (rest === void 0) { rest = false; }
            if (rest) {
                this._time = 0;
                this._currentDelay = 0.0;
                this._currentFrame = 0;
            }
            this._start = true;
        };
        /**
        * @language zh_CN
        * 停止播放uv精灵动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        UVSpriteSheetMethod.prototype.stop = function () {
            this._start = false;
        };
        Object.defineProperty(UVSpriteSheetMethod.prototype, "delayTime", {
            /**
            * @language zh_CN
            * 获取播放延时时间
            * @returns number 时间 秒
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._delayTime / 1000.0;
            },
            /**
            * @language zh_CN
            * 设置播放延时时间
            * @param value 时间 秒
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._delayTime != value) {
                    this._change = true;
                    this._delayTime = value * 1000.0;
                    this._currentDelay = 0.0;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVSpriteSheetMethod.prototype, "isLoop", {
            /**
            * @language zh_CN
            * 获取是否循环播放
            * @returns boolean 是否循环
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._isLoop;
            },
            /**
            * @language zh_CN
            * 设置是否循环播放
            * @param value 是否循环
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._isLoop != value) {
                    this._change = true;
                    this._isLoop = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UVSpriteSheetMethod.prototype, "currentFrame", {
            /**
            * @language zh_CN
            * 获取当前帧
            * @param value currentFrame
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._currentFrame;
            },
            /**
            * @language zh_CN
            * 设置当前帧
            * @param value 0 - frameNum
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._currentFrame = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        UVSpriteSheetMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uvSpriteSheet"] = context3DProxy.getUniformLocation(usage.program3D, "uvSpriteSheet");
        };
        /**
        * @private
        */
        UVSpriteSheetMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (this._change)
                this.caculate();
            if (this._start) {
                this._currentDelay += delay;
                if (this._currentDelay >= this._delayTime) {
                    this._time += delay;
                    if (this._time / this._speed > 1.0) {
                        if (this._currentFrame + 1 >= this._frameNum) {
                            if (this._isLoop) {
                                this._currentFrame = 0;
                            }
                            else {
                                this._start = false;
                            }
                        }
                        else {
                            this._currentFrame++;
                        }
                        this._time = 0;
                    }
                }
            }
            this._currentFrame = this._currentFrame % this._frameNum;
            this._uvSpriteSheet[0] = this.frameList[this._currentFrame].x;
            this._uvSpriteSheet[1] = this.frameList[this._currentFrame].y;
            this._uvSpriteSheet[2] = this.frameList[this._currentFrame].width;
            this._uvSpriteSheet[3] = this.frameList[this._currentFrame].height;
            context3DProxy.uniform1fv(usage["uvSpriteSheet"], this._uvSpriteSheet);
        };
        return UVSpriteSheetMethod;
    }(egret3d.MethodBase));
    egret3d.UVSpriteSheetMethod = UVSpriteSheetMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.LightmapMethod
    * @classdesc
    * 实现lightmap渲染方法。
    * 在三维软件里实现打好光，然后渲染把场景各表面的光照输出到贴图上。
    * 然后使用模型的第2UV，渲染出Lightmap效果，lightmap贴图需要自己烘焙。
     * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/LightmapMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var LightmapMethod = (function (_super) {
        __extends(LightmapMethod, _super);
        /**
        * @language zh_CN
        * 创建一个LightmapMethod对象
        * @param useSpecularPower 是否使用高功率，默认参数为true
        * @version Egret 3.0
        * @platform Web,Native
        */
        function LightmapMethod(useSpecularPower) {
            if (useSpecularPower === void 0) { useSpecularPower = true; }
            _super.call(this);
            this._globalColorData = new Float32Array(3);
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] = this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex].push("secondaryUV_vs");
            this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment].push("lightingBase_fs");
            if (useSpecularPower) {
                this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] || [];
                this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment].push("lightMapSpecularPower_fs");
            }
            else {
                this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] || [];
                this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment].push("lightMap_fs");
            }
        }
        Object.defineProperty(LightmapMethod.prototype, "lightTexture", {
            /**
            * @language zh_CN
            * 设置lightmap贴图
            * @param texture lightmap贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                this.texture = texture;
                if (this.materialData.lightTexture != this.texture) {
                    this.materialData.lightTexture = this.texture;
                    this.materialData.lightTexture.useMipmap = false;
                    this.materialData.lightTexture.smooth = true;
                    this.materialData.textureChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        LightmapMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        /**
        * @private
        * @language zh_CN
        */
        LightmapMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        return LightmapMethod;
    }(egret3d.MethodBase));
    egret3d.LightmapMethod = LightmapMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVRollMethod
    * @classdesc
    * 植物模拟自然风吹摇动特效方法
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/PlantDistortedMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PlantDistortedMethod = (function (_super) {
        __extends(PlantDistortedMethod, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function PlantDistortedMethod() {
            _super.call(this);
            this._speed = new egret3d.Vector3D();
            this._time = 0.0;
            this._windData = new Float32Array(4);
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] = this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex].push("detail_Bending_vs");
        }
        Object.defineProperty(PlantDistortedMethod.prototype, "windDirAndSpeed", {
            get: function () {
                return this._speed;
            },
            /**
            * @language zh_CN
            * 设置风的方向，Vector3D的长度代表其速度
            * @param dirAndStr 风向和风的强度数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (dirAndStr) {
                this._speed = dirAndStr;
                this._windData[1] = dirAndStr.x;
                this._windData[2] = dirAndStr.y;
                this._windData[3] = dirAndStr.z;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        PlantDistortedMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, moodeltransform, camera3D) {
            usage["uniformTime"] = context3DProxy.getUniformLocation(usage.program3D, "uniformTime");
        };
        /**
        * @private
        * @language zh_CN
        */
        PlantDistortedMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            this._time += delay;
            this._windData[0] = this._time;
            context3DProxy.uniform1fv(usage["uniformTime"], this._windData);
        };
        return PlantDistortedMethod;
    }(egret3d.MethodBase));
    egret3d.PlantDistortedMethod = PlantDistortedMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.AlphaMaskMethod
    * @classdesc
    * 继承自 MethodBase,为材质球附加特效的共有基类.</p>
    * 实现alpha遮罩特效渲染方法。</p>
    * 该贴图的r通道被用于赋值到diffuse数据的alpha上面,实现 细节后期处理透明效果,目前可直接使用 png texture直接实现透明细节</p>
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法</p>
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/AlphaMaskMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var AlphaMaskMethod = (function (_super) {
        __extends(AlphaMaskMethod, _super);
        /**
        * @language zh_CN
        * 创建一个AlphaMaskMethod对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function AlphaMaskMethod() {
            _super.call(this);
            this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment].push("alphaMask_fs");
        }
        Object.defineProperty(AlphaMaskMethod.prototype, "maskTexture", {
            /**
            * @language zh_CN
            * 设置maskTexture贴图
            * @param texture maskTexture贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                this.texture = texture;
                this.materialData.maskTexture = this.texture;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        AlphaMaskMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        /**
        * @private
        * @language zh_CN
        */
        AlphaMaskMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        return AlphaMaskMethod;
    }(egret3d.MethodBase));
    egret3d.AlphaMaskMethod = AlphaMaskMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.AOMapMethod
    * @classdesc
    * 继承自 MethodBase,为材质球附加特效的共有基类.
    * AO贴图渲染方法,Ambient Occlusion texture 的简称.
    * 使用第三方软件渲染好的3D模型AO贴图进行mapping,模拟自然环境遮挡效果.增强真实感.
    * 推荐3Dmax Ambient Occlusion 渲染到贴图的功能,将模型的 AO 渲染成为一张贴图,赋给模型使用,前提需要保证模型第二UV要保证一致
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/AOMapMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var AOMapMethod = (function (_super) {
        __extends(AOMapMethod, _super);
        /**
        * @language zh_CN
        * 创建AO贴图方法
        * @version Egret 3.0
        * @platform Web,Native
        */
        function AOMapMethod() {
            _super.call(this);
            this.aoPower = 1.0;
            this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment].push("AOMap_fs");
        }
        Object.defineProperty(AOMapMethod.prototype, "lightTexture", {
            /**
            * @language zh_CN
            * 设置AO贴图
            * @param texture AO贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                this.texture = texture;
                this.materialData.aoTexture = this.texture;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        AOMapMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["aoPower"] = context3DProxy.getUniformLocation(usage.program3D, "aoPower");
        };
        /**
        * @private
        */
        AOMapMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            context3DProxy.uniform1f(usage["aoPower"], this.aoPower);
        };
        /**
        * @language zh_CN
        * @private
        */
        AOMapMethod.prototype.dispose = function () {
        };
        return AOMapMethod;
    }(egret3d.MethodBase));
    egret3d.AOMapMethod = AOMapMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.ColorTransformMethod
    * @classdesc
    * 继承自 MethodBase,为材质球附加特效的共有基类.
    * 实现偏色渲染方法。
    * 将最终渲染的argb值按照这个transform进行修正。
    * 也可以用来做颜色的变化特效,实时修改颜色变化,闪烁
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/ColorTransformMethod.ts
    * @see egret3d.texture.ColorTransform
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ColorTransformMethod = (function (_super) {
        __extends(ColorTransformMethod, _super);
        /**
        * @language zh_CN
        * 创建一个ColorTransformMethod对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ColorTransformMethod() {
            _super.call(this);
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment].push("colorTransform_fs");
        }
        Object.defineProperty(ColorTransformMethod.prototype, "colorTransform", {
            /**
            * @language zh_CN
            * 返回ColorTransform数据
            * @param trasform ColorTransform
            * @see egret3d.texture.ColorTransform
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.colorTransform;
            },
            /**
            * @language zh_CN
            * 设置ColorTransform数据
            * @param trasform ColorTransform
            * @see egret3d.texture.ColorTransform
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (trasform) {
                this.materialData.colorTransform = trasform;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        ColorTransformMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uniform_colorTransformAlpha"] = context3DProxy.getUniformLocation(usage.program3D, "uniform_colorTransformAlpha");
            usage["uniform_colorTransformM44"] = context3DProxy.getUniformLocation(usage.program3D, "uniform_colorTransformM44");
        };
        /**
        * @private
        * @language zh_CN
        */
        ColorTransformMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            context3DProxy.uniform1f(usage["uniform_colorTransformAlpha"], this.colorTransform.alpha);
            context3DProxy.uniformMatrix4fv(usage["uniform_colorTransformM44"], false, this.colorTransform.m44.rawData);
        };
        return ColorTransformMethod;
    }(egret3d.MethodBase));
    egret3d.ColorTransformMethod = ColorTransformMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.ColorGradientsMethod
    * @classdesc
    * 实现颜色渐变叠加
    * @see egret3d.MethodBase
    * @includeExample material/method/ColorGradientsMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ColorGradientsMethod = (function (_super) {
        __extends(ColorGradientsMethod, _super);
        /**
        * @language zh_CN
        * 创建一个ColorGradientsMethod对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ColorGradientsMethod() {
            _super.call(this);
            this._posStart = 0;
            this._posEnd = 0;
            this._color = new egret3d.Color();
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment].push("colorGradients_fs");
        }
        /**
        * @language zh_CN
        * 设置颜色渐变数据
        * @param posStart number 起始位置，相对小的y值
        * @param posEnd number 结束为止，相对大的y值
        * @param color Color
        * @version Egret 3.0
        * @platform Web,Native
        */
        ColorGradientsMethod.prototype.setStartData = function (posStart, posEnd, color) {
            this._color.copyFrom(color);
            this._posStart = posStart;
            this._posEnd = posEnd;
        };
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        ColorGradientsMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uniform_colorGradientsSource"] = context3DProxy.getUniformLocation(usage.program3D, "uniform_colorGradientsSource");
        };
        /**
        * @private
        * @language zh_CN
        */
        ColorGradientsMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            this.materialData.colorGradientsSource[0] = this._posStart;
            this.materialData.colorGradientsSource[1] = this._posEnd;
            //color
            this.materialData.colorGradientsSource[2] = this._color.r;
            this.materialData.colorGradientsSource[3] = this._color.g;
            this.materialData.colorGradientsSource[4] = this._color.b;
            this.materialData.colorGradientsSource[5] = this._color.a;
            context3DProxy.uniform1fv(usage["uniform_colorGradientsSource"], this.materialData.colorGradientsSource);
        };
        return ColorGradientsMethod;
    }(egret3d.MethodBase));
    egret3d.ColorGradientsMethod = ColorGradientsMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVRollMethod
    * @classdesc
    * 用来实现UV流光滚动效果的渲染方法
    * 在3D游戏中用来制作物体装备流光的特效显示，比如《奇迹》中的装备流光
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/StreamerMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var StreamerMethod = (function (_super) {
        __extends(StreamerMethod, _super);
        /**
        * @private
        * @language zh_CN
        */
        function StreamerMethod() {
            _super.call(this);
            this._uvRoll = new Float32Array(3);
            this._speedU = 0.0001;
            this._speedV = 0.0001;
            this._intensity = 0.9;
            this._time = 0.0;
            this._start = false;
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("uvStreamerRoll_fs");
            this.start();
        }
        Object.defineProperty(StreamerMethod.prototype, "speedU", {
            /**
            * @language zh_CN
            * 获取UV u的滚动速度
            * @returns number u的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._speedU;
            },
            /**
            * @language zh_CN
            * 用来UV u的滚动速度
            * @param value u的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._speedU = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StreamerMethod.prototype, "speedV", {
            /**
            * @language zh_CN
            * 获取UV v的滚动速度
            * @returns number v的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._speedV;
            },
            /**
            * @language zh_CN
            * 用来UV v的滚动速度
            * @param value v的滚动速度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._speedV = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StreamerMethod.prototype, "steamerTexture", {
            /**
            * @language zh_CN
            * 获取流动贴图
            * @returns ITexture 流动贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._steamerTexture;
            },
            /**
            * @language zh_CN
            * 设置流动贴图
            * @param tex 流动贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (tex) {
                this._steamerTexture = tex;
                this.materialData["streamerTexture"] = tex;
                this.materialData.textureChange = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 开始播放uv动画
        * @param rest 如果为ture就是重置播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        StreamerMethod.prototype.start = function (rest) {
            if (rest === void 0) { rest = false; }
            if (rest)
                this._time = 0;
            this._start = true;
        };
        /**
        * @language zh_CN
        * 停止播放uv动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        StreamerMethod.prototype.stop = function () {
            this._start = false;
        };
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        StreamerMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uvRoll"] = context3DProxy.getUniformLocation(usage.program3D, "uvRoll");
        };
        /**
        * @private
        * @language zh_CN
        */
        StreamerMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (this._start) {
                this._time += delay;
            }
            this._uvRoll[0] = this._time * this._speedU;
            this._uvRoll[1] = this._time * this._speedV;
            this._uvRoll[2] = this._intensity;
            context3DProxy.uniform1fv(usage["uvRoll"], this._uvRoll);
        };
        return StreamerMethod;
    }(egret3d.MethodBase));
    egret3d.StreamerMethod = StreamerMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.AlphaMaskMethod
    * @classdesc
    * 实现实时阴影渲染方法
    * @see egret3d.MethodBase
    * @includeExample material/method/ShadowMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ShadowMethod = (function (_super) {
        __extends(ShadowMethod, _super);
        function ShadowMethod(matData) {
            if (matData === void 0) { matData = null; }
            _super.call(this);
            if (matData)
                this.materialData = matData;
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] = this.vsShaderList[egret3d.ShaderPhaseType.local_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.local_vertex].push("shadowMapping_vs");
            this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.shadow_fragment].push("shadowMapping_fs");
        }
        Object.defineProperty(ShadowMethod.prototype, "shadowMapTexture", {
            /**
            * @language zh_CN
            * 获取阴影贴图
            * @returns ITexture 阴影贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.shadowMapTexture;
            },
            /**
            * @language zh_CN
            * 设置阴影贴图
            * @param texture 阴影贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                if (this.materialData.shadowMapTexture != texture) {
                    this.materialData.shadowMapTexture = texture;
                    this.materialData.textureChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        */
        ShadowMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D, renderQuen) {
            if (usage.uniform_ShadowMatrix) {
                usage.uniform_ShadowMatrix.uniformIndex = context3DProxy.getUniformLocation(usage.program3D, "uniform_ShadowMatrix");
            }
        };
        /**
        * @private
        */
        ShadowMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D, renderQuen) {
            var camera = renderQuen.renderDictionary[egret3d.PassType.shadowPass].camera;
            if (camera) {
                if (usage.uniform_ShadowMatrix && usage.uniform_ShadowMatrix.uniformIndex) {
                    context3DProxy.uniformMatrix4fv(usage.uniform_ShadowMatrix.uniformIndex, false, camera.viewProjectionMatrix.rawData);
                }
            }
            context3DProxy.uniform4fv(usage.uniform_ShadowColor.uniformIndex, this.materialData.shadowColor);
        };
        return ShadowMethod;
    }(egret3d.MethodBase));
    egret3d.ShadowMethod = ShadowMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.CubeMethod
    * @classdesc
    * @see egret3d.MethodBase
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CubeMethod = (function (_super) {
        __extends(CubeMethod, _super);
        /**
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        function CubeMethod() {
            _super.call(this);
            this.vsShaderList[egret3d.ShaderPhaseType.global_vertex] = this.fsShaderList[egret3d.ShaderPhaseType.global_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.global_vertex].push("cube_vertex");
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("cube_fragment");
        }
        /**
        * @private
        */
        CubeMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        /**
        * @private
        * @language zh_CN
        */
        CubeMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        return CubeMethod;
    }(egret3d.MethodBase));
    egret3d.CubeMethod = CubeMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.ColorMethod
    * @classdesc
    * 继承自 MethodBase,为材质球附加特效的共有基类.
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/ColorMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ColorMethod = (function (_super) {
        __extends(ColorMethod, _super);
        /**
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ColorMethod() {
            _super.call(this);
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("color_fragment");
        }
        /**
        * @private
        */
        ColorMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        /**
        * @private
        * @language zh_CN
        */
        ColorMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
        };
        return ColorMethod;
    }(egret3d.MethodBase));
    egret3d.ColorMethod = ColorMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.WaterWaveMethod
    * @classdesc
    * 水面模拟特效，用来实现水面顶点波动效果
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/WaterWaveMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var WaterWaveMethod = (function (_super) {
        __extends(WaterWaveMethod, _super);
        /**
        * @private
        * @language zh_CN
        */
        function WaterWaveMethod() {
            _super.call(this);
            this._waveVSData = new Float32Array(12);
            this._waveFSData = new Float32Array(8);
            this._time = 0.0;
            this._start = false;
            this._wave_xyz_intensity_0 = new egret3d.Vector3D(120.0, 50.0, 70.0);
            this._wave_xyz_intensity_1 = new egret3d.Vector3D(80.0, 40.0, 80.0);
            this._wave_xyz_speed_0 = new egret3d.Vector3D(0.001, 0.001, -0.001);
            this._wave_xyz_speed_1 = new egret3d.Vector3D(0.001, 0.001, 0.001);
            //##FilterBegin## ##Water##
            this.vsShaderList[egret3d.ShaderPhaseType.start_vertex] = this.vsShaderList[egret3d.ShaderPhaseType.start_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.start_vertex].push("wave_vs");
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment].push("wave_fs");
            this.start();
            //---------------
            this._waveVSData[0] = this._wave_xyz_intensity_0.x;
            this._waveVSData[1] = this._wave_xyz_intensity_0.y;
            this._waveVSData[2] = this._wave_xyz_intensity_0.z;
            this._waveVSData[3] = this._wave_xyz_intensity_1.x;
            this._waveVSData[4] = this._wave_xyz_intensity_1.y;
            this._waveVSData[5] = this._wave_xyz_intensity_1.z;
            this._waveVSData[6] = this._wave_xyz_speed_0.x;
            this._waveVSData[7] = this._wave_xyz_speed_0.y;
            this._waveVSData[8] = this._wave_xyz_speed_0.z;
            this._waveVSData[9] = this._wave_xyz_speed_1.x;
            this._waveVSData[10] = this._wave_xyz_speed_1.y;
            this._waveVSData[11] = this._wave_xyz_speed_1.z;
            //0.0/255.0,63.0/255.0,77.0/255.0
            //71.0/255.0,118.0/255.0,138.0/255.0
            this._waveFSData[0] = 0.0 / 255.0;
            this._waveFSData[1] = 63.0 / 255.0;
            this._waveFSData[2] = 77.0 / 255.0;
            this._waveFSData[3] = 1.0;
            this._waveFSData[4] = 71.0 / 255.0;
            this._waveFSData[5] = 118.0 / 255.0;
            this._waveFSData[6] = 138.0 / 255.0;
            this._waveFSData[7] = 1.0;
            //##FilterEnd##
        }
        Object.defineProperty(WaterWaveMethod.prototype, "deepWaterColor", {
            /**
            * @language zh_CN
            * 获取深水颜色
            * @param color 颜色 a r b g
            */
            get: function () {
                var r = this._waveFSData[0] * 255.0;
                var g = this._waveFSData[1] * 255.0;
                var b = this._waveFSData[2] * 255.0;
                var a = this._waveFSData[3] * 255.0;
                return (a << 24) | (r << 16) | (g << 8) | b;
            },
            /**
            * @language zh_CN
            * 设置深水颜色
            * @param color 颜色 a r b g
            */
            set: function (color) {
                //##FilterBegin## ##Water##
                var a = color >> 24 & 0xff;
                var r = color >> 16 & 0xff;
                var g = color >> 8 & 0xff;
                var b = color & 0xff;
                this._waveFSData[0] = r / 255.0;
                this._waveFSData[1] = g / 255.0;
                this._waveFSData[2] = b / 255.0;
                this._waveFSData[3] = a / 255.0;
                //##FilterEnd##
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterWaveMethod.prototype, "shallowWaterColor", {
            /**
            * @language zh_CN
            * 获取浅水颜色
            * @param color 颜色 a r b g
            */
            get: function () {
                var r = this._waveFSData[4] * 255.0;
                var g = this._waveFSData[5] * 255.0;
                var b = this._waveFSData[6] * 255.0;
                var a = this._waveFSData[7] * 255.0;
                return (a << 24) | (r << 16) | (g << 8) | b;
            },
            /**
            * @language zh_CN
            * 设置浅水颜色
            * @param color 颜色
            */
            set: function (color) {
                //##FilterBegin## ##Water##
                var a = color >> 24 & 0xff;
                var r = color >> 16 & 0xff;
                var g = color >> 8 & 0xff;
                var b = color & 0xff;
                this._waveFSData[4] = r / 255.0;
                this._waveFSData[5] = g / 255.0;
                this._waveFSData[6] = b / 255.0;
                this._waveFSData[7] = a / 255.0;
                //##FilterEnd##
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterWaveMethod.prototype, "waveTexture", {
            /**
            * @language zh_CN
            * 水贴图
            * @param texture  水贴图
            */
            set: function (texture) {
                //##FilterBegin## ##Water##
                this._waveTexture = texture;
                if (texture) {
                    if (this.materialData["waveTexture"] != this._waveTexture) {
                        this.materialData["waveTexture"] = texture;
                        this.materialData.textureChange = true;
                    }
                }
                //##FilterEnd##
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 开始播放uv动画
        * @param rest 如果为ture就是重置播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterWaveMethod.prototype.start = function (rest) {
            //##FilterBegin## ##Water##
            if (rest === void 0) { rest = false; }
            if (rest)
                this._time = 0;
            this._start = true;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 停止播放uv动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterWaveMethod.prototype.stop = function () {
            //##FilterBegin## ##Water##
            this._start = false;
            //##FilterEnd##
        };
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        WaterWaveMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            //##FilterBegin## ##Water##
            usage["waveVSData"] = context3DProxy.getUniformLocation(usage.program3D, "waveVSData");
            usage["waveFSData"] = context3DProxy.getUniformLocation(usage.program3D, "waveFSData");
            usage["time"] = context3DProxy.getUniformLocation(usage.program3D, "time");
            //##FilterEnd##
        };
        /**
        * @private
        * @language zh_CN
        */
        WaterWaveMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            //##FilterBegin## ##Water##
            if (this._start) {
                this._time += delay;
            }
            context3DProxy.uniform3fv(usage["waveVSData"], this._waveVSData);
            context3DProxy.uniform4fv(usage["waveFSData"], this._waveFSData);
            context3DProxy.uniform1f(usage["time"], this._time);
            //##FilterEnd##
        };
        return WaterWaveMethod;
    }(egret3d.MethodBase));
    egret3d.WaterWaveMethod = WaterWaveMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.WaterNormalMethod
    * @classdesc
    * 材质中赋予灯光后，可以添加此方法，灯光和法线的变化而产生水面波光粼粼的效果
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/WaterNormalMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var WaterNormalMethod = (function (_super) {
        __extends(WaterNormalMethod, _super);
        /**
        * @private
        * @language zh_CN
        */
        function WaterNormalMethod() {
            _super.call(this);
            this._uvData = new Float32Array(8);
            this._time = 0.0;
            this._start = false;
            this._speedU_0 = new egret3d.Point(-0.000005, 0.0);
            this._speedU_1 = new egret3d.Point(0.00001, 0.0);
            this._distion_intensity = new egret3d.Point(0.02, 0.02);
            this._normal_0_UVScale = 2.0;
            this._normal_1_UVScale = 2.0;
            //##FilterBegin## ##Water##
            this.fsShaderList[egret3d.ShaderPhaseType.normal_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.normal_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.normal_fragment].push("waterNormal_fs");
            this.start();
            //---------------
            this._uvData[0] = this._speedU_0.x * 2.5;
            this._uvData[1] = this._speedU_0.y * 2.5;
            this._uvData[2] = this._speedU_1.x * 2.5;
            this._uvData[3] = this._speedU_1.y * 2.5;
            this._uvData[4] = this._distion_intensity.x;
            this._uvData[5] = this._distion_intensity.y;
            this._uvData[6] = this._normal_0_UVScale;
            this._uvData[7] = this._normal_1_UVScale;
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 开始播放uv动画
        * @param rest 如果为ture就是重置播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterNormalMethod.prototype.start = function (rest) {
            //##FilterBegin## ##Water##
            if (rest === void 0) { rest = false; }
            if (rest)
                this._time = 0;
            this._start = true;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 停止播放uv动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterNormalMethod.prototype.stop = function () {
            //##FilterBegin## ##Water##
            this._start = false;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 设置UV 速度
        * @param index 0 或 1
        * @param u
        * @param v
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterNormalMethod.prototype.setUvSpeed = function (index, u, v) {
            //##FilterBegin## ##Water##
            switch (index) {
                case 0:
                    this._speedU_0.x = u;
                    this._speedU_0.y = v;
                    this._uvData[0] = this._speedU_0.x * 2.5;
                    this._uvData[1] = this._speedU_0.y * 2.5;
                    break;
                case 1:
                    this._speedU_1.x = u;
                    this._speedU_1.y = v;
                    this._uvData[2] = this._speedU_1.x * 2.5;
                    this._uvData[3] = this._speedU_1.y * 2.5;
                    break;
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 设置UV repat次数
        * @param u
        * @param v
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterNormalMethod.prototype.setUvScale = function (first, second) {
            //##FilterBegin## ##Water##
            this._normal_0_UVScale = first;
            this._normal_1_UVScale = second;
            this._uvData[6] = this._normal_0_UVScale;
            this._uvData[7] = this._normal_1_UVScale;
            //##FilterEnd##
        };
        Object.defineProperty(WaterNormalMethod.prototype, "normalTextureA", {
            /**
             * @language zh_CN
             * 设置lightmap贴图
             * @param texture lightmap贴图
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                //##FilterBegin## ##Water##
                this._normalTexture_0 = texture;
                if (this.materialData["normalTextureA"] != this._normalTexture_0) {
                    this.materialData["normalTextureA"] = this._normalTexture_0;
                    this.materialData.textureChange = true;
                }
                //##FilterEnd##
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterNormalMethod.prototype, "normalTextureB", {
            /**
             * @language zh_CN
             * 设置lightmap贴图
             * @param texture lightmap贴图
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                //##FilterBegin## ##Water##
                this._normalTexture_1 = texture;
                if (this.materialData["normalTextureB"] != this._normalTexture_1) {
                    this.materialData["normalTextureB"] = this._normalTexture_1;
                    this.materialData.textureChange = true;
                }
                //##FilterEnd##
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        WaterNormalMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            //##FilterBegin## ##Water##
            usage["waterNormalData"] = context3DProxy.getUniformLocation(usage.program3D, "waterNormalData");
            usage["time"] = context3DProxy.getUniformLocation(usage.program3D, "time");
            //##FilterEnd##
        };
        /**
        * @private
        * @language zh_CN
        */
        WaterNormalMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            //##FilterBegin## ##Water##
            if (this._start) {
                this._time += delay;
            }
            context3DProxy.uniform2fv(usage["waterNormalData"], this._uvData);
            context3DProxy.uniform1f(usage["time"], this._time);
            //##FilterEnd##
        };
        return WaterNormalMethod;
    }(egret3d.MethodBase));
    egret3d.WaterNormalMethod = WaterNormalMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVRollMethod
    * @classdesc
    * 继承自 MethodBase,为材质球附加特效的共有基类.
    * 环境映射是一种用来模拟光滑表面对周围环境的反射的技术，常见的如镜子、光亮漆面的金属等等。
    * 这种技术的实现主要通过将一张带有周围环境的贴图附在所需要表现的多边形表面来实现的。目前在实时3D游戏画面渲染中经常使用的有两种环境映射。
    * 球形环境映射是模拟在球体表面产生环境映射的技术，通过对普通贴图的UV坐标进行调整计算来产生在球体表面应产生的扭曲。
    * UV的计算利用球体表面的法线来计算。
    * 计算公式中的Nx和Ny是表面法线的x和y分量，除以2将区间限制在[-0.5,0.5]，+0.5将区间调整至UV坐标应在的[0,1]区间。在这个公式的计算下，当球体正中表面法线正对摄像机的地方，坐标不会有任何扭曲；周围点依次随着Nx和Ny分量的增大而产生扭曲。
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/EnvironmentMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EnvironmentMethod = (function (_super) {
        __extends(EnvironmentMethod, _super);
        /**
        * @private
        * @language zh_CN
        */
        function EnvironmentMethod() {
            _super.call(this);
            this.reflectValue = 0.3;
            this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.lighting_fragment].push("environmentMapping_fragment");
        }
        Object.defineProperty(EnvironmentMethod.prototype, "reflect", {
            /**
             * @public
             * 返回环境的强弱度
             * @returns number 环境的强弱度
             */
            get: function () {
                return this.reflectValue;
            },
            /**
             * @public
             * 设置反射 环境的强弱度,值区间在[0~1]
             * @param value 强弱度
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this.reflectValue = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentMethod.prototype, "environmentTexture", {
            /**
             * @language zh_CN
             * @public
             * 设置环境纹理,一张 cubemap,可配合天空纹理使用增强环境渲染效果
             * @see egret3d.MethodBase
             * @see egret3d.texture.CubeTexture
             * @param texture
             */
            set: function (texture) {
                this.texture = texture;
                if (texture) {
                    if (this.materialData["environmentMapTex"] != this.texture) {
                        this.materialData["environmentMapTex"] = texture;
                        this.materialData.textureChange = true;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        EnvironmentMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["reflectValue"] = context3DProxy.getUniformLocation(usage.program3D, "reflectValue");
        };
        /**
        * @private
        * @language zh_CN
        */
        EnvironmentMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            context3DProxy.uniform1f(usage["reflectValue"], this.reflectValue);
        };
        return EnvironmentMethod;
    }(egret3d.MethodBase));
    egret3d.EnvironmentMethod = EnvironmentMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.UVRollMethod
    * @classdesc
    * 边缘光特效方法
    * 利用屏幕空间法线与摄像机方向射线的夹角 进行pow ，越是物体的边缘，效果越强。
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/RimlightMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var RimlightMethod = (function (_super) {
        __extends(RimlightMethod, _super);
        function RimlightMethod() {
            _super.call(this);
            this.uniform_rimData = new Float32Array(6);
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.multi_end_fragment].push("rimlight_fs");
            //0.5, 0.6, 0.7
            this.uniform_rimData[0] = 0.99;
            this.uniform_rimData[1] = 0.0;
            this.uniform_rimData[2] = 0.0;
            this.uniform_rimData[3] = 1.0;
            this.uniform_rimData[4] = 5.0;
            this.uniform_rimData[5] = 1.0;
        }
        Object.defineProperty(RimlightMethod.prototype, "rimColor", {
            /**
            * @language zh_CN
            * 获取边缘光特效的颜色。
            * @param  val 获取边缘光特效的颜色。
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return egret3d.Color.RGBAToColor(this.uniform_rimData[0], this.uniform_rimData[1], this.uniform_rimData[2], this.uniform_rimData[3]);
            },
            /**
            * @language zh_CN
            * 设置边缘光特效的颜色 alpha值为特效的亮度,其他为颜色。
            * @param  val 设置边缘光特效的颜色 alpha值为特效的亮度,其他为颜色。
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                var color = egret3d.Color.getColor(val);
                this.uniform_rimData[0] = color.x;
                this.uniform_rimData[1] = color.y;
                this.uniform_rimData[2] = color.z;
                this.uniform_rimData[3] = color.w;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RimlightMethod.prototype, "rimPow", {
            /**
            * @language zh_CN
            * 设置边缘光特效的pow值,值越大,边缘越窄,值越小,边缘越宽.
            * @param  size 设置边缘光特效的pow值,值越大,边缘越窄,值越小,边缘越宽.
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.uniform_rimData[4];
            },
            /**
            * @language zh_CN
            * 设置边缘光特效的pow值,值越大,边缘越窄,值越小,边缘越宽.
            * @param  size 设置边缘光特效的pow值,值越大,边缘越窄,值越小,边缘越宽.
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (size) {
                this.uniform_rimData[4] = size;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RimlightMethod.prototype, "strength", {
            /**
            * @language zh_CN
            * 设置边缘光特效的强度值
            * @param  size 设置边缘光特效的强度值
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.uniform_rimData[5];
            },
            /**
            * @language zh_CN
            * 设置边缘光特效的强度值
            * @param  size 设置边缘光特效的强度值
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                this.uniform_rimData[5] = val;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        RimlightMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uniform_rimData"] = context3DProxy.getUniformLocation(usage.program3D, "uniform_rimData");
        };
        /**
         * @language zh_CN
         * @private
         */
        RimlightMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            context3DProxy.uniform1fv(usage["uniform_rimData"], this.uniform_rimData);
        };
        /**
         * @language zh_CN
         * @private
         */
        RimlightMethod.prototype.dispose = function () {
        };
        return RimlightMethod;
    }(egret3d.MethodBase));
    egret3d.RimlightMethod = RimlightMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.GrassMesh
    * @classdesc
    * 实现风吹草动，并且实现了单个角色在草丛中，挤压草的效果
    * @see egret3d.plant.GrassMethod.ts
    * @includeExample plant/GrassMesh.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var GrassMesh = (function (_super) {
        __extends(GrassMesh, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param birthPoints 草的出生位置列表
        * @param material 材质
        * @param data 草的属性
        * @version Egret 3.0
        * @platform Web,Native
        */
        function GrassMesh(birthPoints, material, data) {
            _super.call(this, null, material);
            material.bothside = true;
            this._method = new egret3d.GrassMethod(data);
            material.diffusePass.addMethod(this._method);
            this._data = data;
            this._birthPoints = birthPoints;
            this._count = birthPoints.length;
            this._plantShape = new egret3d.PlaneGeometry(1, 1, 1, 1, 1, 1, egret3d.Vector3D.Z_AXIS, true, false);
            this.initialize();
            this.initBoudBox(new egret3d.Vector3D(egret3d.MathUtil.MAX_VALUE, egret3d.MathUtil.MAX_VALUE, egret3d.MathUtil.MAX_VALUE));
        }
        Object.defineProperty(GrassMesh.prototype, "method", {
            /**
            * @language zh_CN
            * 获取GrassMethod
            * @returns 草的Method，用于外部控制
            */
            get: function () {
                return this._method;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        */
        GrassMesh.prototype.initialize = function () {
            this.geometry = new egret3d.Geometry();
            this.geometry.buildDefaultSubGeometry();
            this.geometry.subGeometrys[0].count = this._count * this._plantShape.indexCount;
            //
            var vertexIndex = 0;
            var vertexArray = [];
            //
            var vf = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_NORMAL;
            this.geometry.vertexFormat = vf;
            //
            this.initGeometryAttr(this.geometry);
            this.geometry.vertexCount = this._count * this._plantShape.vertexCount;
            this.geometry.indexCount = this._count * this._plantShape.indexCount;
            this._plantShape.getVertexForIndex(0, vf, vertexArray, this._plantShape.vertexCount);
            for (var i = 0; i < this._count; ++i) {
                vertexIndex = i * this._plantShape.vertexCount;
                this.geometry.setVerticesForIndex(vertexIndex, vf, vertexArray, this._plantShape.vertexCount);
            }
            for (var i = 0; i < this._count; ++i) {
                for (var j = 0; j < this._plantShape.indexArray.length; ++j) {
                    this.geometry.indexArray[i * this._plantShape.indexArray.length + j] = this._plantShape.indexArray[j] + i * this._plantShape.vertexCount;
                }
            }
            //最后根据节点功能，填充模型
            this.initPostionData(this.geometry, this._count);
        };
        /**
        * @language zh_CN
        * 计算节点
        * @private
        */
        GrassMesh.prototype.initGeometryAttr = function (geometry) {
            //position
            this._attrPosition = new egret3d.GLSL.VarRegister();
            this._attrPosition.name = "attribute_grassOffset";
            this._attrPosition.size = 3;
            var offsetIndex = geometry.vertexAttLength;
            this._attrPosition.offsetIndex = offsetIndex;
            geometry.vertexAttLength += this._attrPosition.size;
            geometry.vertexSizeInBytes += this._attrPosition.size * 4;
            geometry.subGeometrys[0].preAttList.push(this._attrPosition);
            //angleY
            this._attrAngleY = new egret3d.GLSL.VarRegister();
            this._attrAngleY.name = "attribute_grassAngleY";
            this._attrAngleY.size = 1;
            var offsetIndex = geometry.vertexAttLength;
            this._attrAngleY.offsetIndex = offsetIndex;
            geometry.vertexAttLength += this._attrAngleY.size;
            geometry.vertexSizeInBytes += this._attrAngleY.size * 4;
            geometry.subGeometrys[0].preAttList.push(this._attrAngleY);
        };
        /**
        * @language zh_CN
        * @private
        * 构建包围盒
        * @version Egret 3.0
        * @platform Web,Native
        */
        GrassMesh.prototype.initBoudBox = function (vector) {
            //##FilterBegin## ##Particle##
            var b = new egret3d.BoundBox(this);
            b.fillBox(new egret3d.Vector3D(-vector.x / 2, -vector.y / 2, -vector.z / 2), new egret3d.Vector3D(vector.x / 2, vector.y / 2, vector.z / 2));
            this.bound = b;
            this.initAABB();
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        GrassMesh.prototype.update = function (time, delay, camera) {
            _super.prototype.update.call(this, time, delay, camera);
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        GrassMesh.prototype.initPostionData = function (geometry, count) {
            var positionArray = this._birthPoints;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            //创建位置
            var birthPosIndex = this._attrPosition.offsetIndex;
            for (var i = 0; i < count; ++i) {
                var pos = positionArray[i];
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + birthPosIndex;
                    geometry.vertexArray[index + 0] = pos.x;
                    geometry.vertexArray[index + 1] = pos.y;
                    geometry.vertexArray[index + 2] = pos.z;
                }
            }
            //修改width height
            var width;
            var height;
            var vertexPosIndex = 0;
            if (this._data.maxWidth != 1 || this._data.minWidth != 1 || this._data.maxHeight != 1 || this._data.minHeight != 1) {
                for (var i = 0; i < count; ++i) {
                    //创建位置
                    width = egret3d.MathUtil.mix(this._data.minWidth, this._data.maxWidth, Math.random());
                    height = egret3d.MathUtil.mix(this._data.minHeight, this._data.maxHeight, Math.random());
                    for (var j = 0; j < vertices; ++j) {
                        index = i * vertices + j;
                        index = index * geometry.vertexAttLength + 0;
                        geometry.vertexArray[index + 0] *= width;
                        geometry.vertexArray[index + 1] *= height;
                    }
                }
            }
            //修改颜色
            var colorPosIndex = 6; //position + normal
            var tempColor = new egret3d.Color();
            var random;
            var r;
            var g;
            var b;
            var noiseSpread = Math.abs(this._data.noiseSpread) * 10;
            var scaleValue = 1 / 0xff;
            var healthyColor = new egret3d.Color();
            var dryColor = new egret3d.Color();
            healthyColor.setColorRGB(Number(this._data.healthyColor));
            dryColor.setColorRGB(Number(this._data.dryColor));
            for (var i = 0; i < count; ++i) {
                random = Math.random() * noiseSpread;
                if (random > 1) {
                    random = 1;
                }
                random *= random;
                tempColor.lerp(healthyColor, dryColor, random);
                tempColor.scaleBy(scaleValue);
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + colorPosIndex;
                    geometry.vertexArray[index + 0] *= tempColor.r;
                    geometry.vertexArray[index + 1] *= tempColor.g;
                    geometry.vertexArray[index + 2] *= tempColor.b;
                    geometry.vertexArray[index + 3] = 1.0;
                }
            }
            //修改旋转
            if (!this._data.billboard) {
                var rotationYIndex = this._attrAngleY.offsetIndex;
                var angleY;
                for (var i = 0; i < count; ++i) {
                    angleY = Math.random() * 2 * Math.PI;
                    for (var j = 0; j < vertices; ++j) {
                        index = i * vertices + j;
                        index = index * geometry.vertexAttLength + rotationYIndex;
                        geometry.vertexArray[index + 0] = angleY;
                    }
                }
            }
            this.billboard = this._data.billboard ? egret3d.BillboardType.Y_AXIS : egret3d.BillboardType.DISABLE;
        };
        /**
        * @language zh_CN
        * 克隆该风吹草动
        * @returns 克隆后的草
        * @version Egret 3.0
        * @platform Web,Native
        */
        GrassMesh.prototype.clone = function () {
            var newPlantGroup;
            newPlantGroup = new GrassMesh(this._birthPoints.slice(), this.material, this._data);
            newPlantGroup.position = this.position;
            newPlantGroup.orientation = this.orientation;
            newPlantGroup.scale = this.scale;
            return newPlantGroup;
        };
        /**
        * @language zh_CN
        * 释放所有数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        GrassMesh.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this._plantShape) {
                this._plantShape.dispose();
                this._plantShape = null;
            }
            this._birthPoints = null;
            this._data = null;
        };
        return GrassMesh;
    }(egret3d.Mesh));
    egret3d.GrassMesh = GrassMesh;
    /**
    * @language zh_CN
    * @class egret3d.GrassMethod
    * @classdesc
    * 构造函数，用于设置草的属性
    * @version Egret 3.0
    * @platform Web,Native
    */
    var GrassData = (function () {
        function GrassData() {
            /**
            * @language zh_CN
            * 面片的最小宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.minWidth = 100;
            /**
            * @language zh_CN
            * 面片的最大宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.maxWidth = 100;
            /**
            * @language zh_CN
            * 面片的最小高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.minHeight = 100;
            /**
            * @language zh_CN
            * 面片的最大高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.maxHeight = 100;
            /**
            * @language zh_CN
            * 草的噪波产生簇大小。越低的值意味着噪波越低。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.noiseSpread = 0;
            /**
            * @language zh_CN
            * 如果选中，草将随着摄像机一起转动，面朝主摄像机
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.billboard = true;
        }
        return GrassData;
    }());
    egret3d.GrassData = GrassData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.GrassMethod
    * @classdesc
    * 草的飘动动画实现部分,不建议单独使用，而是封装在GrassMesh中被动生成。
    * @see egret3d.GrassMesh
    * @includeExample plant/GrassMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var GrassMethod = (function (_super) {
        __extends(GrassMethod, _super);
        /**
        * @language zh_CN
        * @构造函数
        * 创建一个GrassMethod对象
        * @param data GrassData 创建该method需要用到的数据源
        * @version Egret 3.0
        * @platform Web,Native
        */
        function GrassMethod(data) {
            _super.call(this);
            this._time = 0.0;
            this._windSpeed = 200;
            this._windStrength = 0.2;
            this._shakeScale = 0.1;
            this._windDirection = new egret3d.Vector3D(1, 0, 0);
            this._windSpace = new egret3d.Vector3D(400, 0, 300);
            this._windData = new Float32Array(9);
            this._squeezeData = new Float32Array(6);
            this._lightMapData = new Float32Array(5);
            this._lightMapTexture = egret3d.CheckerboardTexture.texture;
            this._data = data;
            this.vsShaderList[egret3d.ShaderPhaseType.start_vertex] = this.vsShaderList[egret3d.ShaderPhaseType.start_vertex] || [];
            this.vsShaderList[egret3d.ShaderPhaseType.start_vertex].push("grass_vs");
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.diffuse_fragment].push("grass_fs");
            this.fillGrassData();
            this.start();
        }
        /**
        * @language zh_CN
        * 设置草用到的灯光图和数据
        * @param lightMap 灯光贴图
        * @param lightMapRect 用于计算UV的数据xy代表偏移，width/height为用于和场景xz的缩放系数
        * @version Egret 3.0
        * @platform Web,Native
        */
        GrassMethod.prototype.setLightMapData = function (lightMap, lightMapRect) {
            this._lightMapRect = lightMapRect;
            this._lightMapTexture = lightMap || egret3d.CheckerboardTexture.texture;
            this.updateLightMapData();
        };
        GrassMethod.prototype.updateLightMapData = function () {
            if (!this._lightMapTexture || this._lightMapTexture == egret3d.CheckerboardTexture.texture || !this._lightMapRect) {
                this._lightMapData[0] = 0;
            }
            else {
                this._lightMapData[0] = 1;
                this._lightMapData[1] = this._lightMapRect.x;
                this._lightMapData[2] = this._lightMapRect.y;
                this._lightMapData[3] = this._lightMapRect.width;
                this._lightMapData[4] = this._lightMapRect.height;
            }
            this.materialData["lightMapTexture"] = this._lightMapTexture;
            this.materialData.textureChange = true;
        };
        /**
        * @language zh_CN
        * 更新风的参数
        * @param direction 单位向量，xz为有效值，表示风的方向
        * @param space 一团风的体积，xz为有效值，每个朝向在单位体积内实现了一个正弦抖动循环
        * @param speed 风的移动速度，代表1秒内，风移动的单位
        * @param windStrength 风的强度，这个值用于加成到草的倾斜上面
        * @param shakeScale 草自身来回摇摆缩放系数，这个值用于加成到草的倾斜上面
        * @version Egret 3.0
        * @platform Web,Native
        */
        GrassMethod.prototype.setWind = function (direction, space, speed, windStrength, shakeScale) {
            if (speed === void 0) { speed = 100.0; }
            if (windStrength === void 0) { windStrength = 0.1; }
            if (shakeScale === void 0) { shakeScale = 1.0; }
            direction.y = 0;
            this._windDirection.copyFrom(direction);
            this._windDirection.normalize();
            this._windSpace.copyFrom(space);
            this._windStrength = windStrength;
            this._windSpeed = speed;
            this._shakeScale = shakeScale;
            this.fillGrassData();
        };
        /**
        * @language zh_CN
        * 更新草受到挤压的数据
        * @param position 挤压开始的位置
        * @param enable 是否开启挤压
        * @param radius 挤压的半价
        * @param strength 挤压的强度，会修改草倾斜的力度
        * @version Egret 3.0
        * @platform Web,Native
        */
        GrassMethod.prototype.updateSqueezeData = function (position, enable, radius, strength) {
            if (radius === void 0) { radius = 20; }
            if (strength === void 0) { strength = 1.0; }
            this._squeezeData[0] = enable ? 1 : 0;
            this._squeezeData[1] = position.x;
            this._squeezeData[2] = position.y;
            this._squeezeData[3] = position.z;
            this._squeezeData[4] = radius;
            this._squeezeData[5] = strength;
        };
        GrassMethod.prototype.fillGrassData = function () {
            this._windData[0] = this._windDirection.x;
            this._windData[1] = this._windDirection.z;
            this._windData[2] = this._windSpace.x;
            this._windData[3] = this._windSpace.z;
            this._windData[4] = this._windStrength;
            this._windData[5] = this._windSpeed;
            this._windData[6] = this._shakeScale;
        };
        /**
        * @language zh_CN
        * 开始播放动画
        * @param rest 如果为ture就是重置播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        GrassMethod.prototype.start = function (rest) {
            if (rest === void 0) { rest = false; }
            if (rest)
                this._time = 0;
            this._start = true;
        };
        /**
        * @language zh_CN
        * 停止播放uv动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        GrassMethod.prototype.stop = function () {
            this._start = false;
        };
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param camera3D
        */
        GrassMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            usage["uniform_grass_data"].uniformIndex = context3DProxy.getUniformLocation(usage.program3D, "uniform_grass_data");
            usage["uniform_squeeze_data"].uniformIndex = context3DProxy.getUniformLocation(usage.program3D, "uniform_squeeze_data");
            usage["uniform_lightMap_data"].uniformIndex = context3DProxy.getUniformLocation(usage.program3D, "uniform_lightMap_data");
        };
        /**
        * @private
        * @language zh_CN
        */
        GrassMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (this._start) {
                this._time += delay;
            }
            this._windData[7] = this._time / 1000.0;
            this._windData[8] = this._data.billboard ? 1 : 0;
            context3DProxy.uniform1fv(usage["uniform_grass_data"].uniformIndex, this._windData);
            context3DProxy.uniform1fv(usage["uniform_squeeze_data"].uniformIndex, this._squeezeData);
            context3DProxy.uniform1fv(usage["uniform_lightMap_data"].uniformIndex, this._lightMapData);
        };
        return GrassMethod;
    }(egret3d.MethodBase));
    egret3d.GrassMethod = GrassMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.WaterBumpMethod
    * @classdesc
    * 材质中赋予灯光后，可以添加此方法，灯光和法线的变化而产生水面波光粼粼的效果
    * 使用方法 需要使用 $mesh.material.diffusePass.addMethod( this ) 向材质中添加效果方法
    * @see egret3d.MethodBase
    * @see egret3d.MaterialPass
    * @includeExample material/method/WaterBumpMethod.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var WaterBumpMethod = (function (_super) {
        __extends(WaterBumpMethod, _super);
        /**
        * @private
        * @language zh_CN
        */
        function WaterBumpMethod() {
            _super.call(this);
            this._uvData = new Float32Array(8);
            this._horizonColor = new Float32Array(4);
            this._time = 0.0;
            this._start = false;
            this._distion_intensity = new egret3d.Point(0.02, 0.02);
            //##FilterBegin## ##Water##
            this.fsShaderList[egret3d.ShaderPhaseType.normal_fragment] = this.fsShaderList[egret3d.ShaderPhaseType.normal_fragment] || [];
            this.fsShaderList[egret3d.ShaderPhaseType.normal_fragment].push("waterBump_fs");
            this.start();
            this._horizonColor[0] = 217 / 255;
            this._horizonColor[1] = 235 / 255;
            this._horizonColor[2] = 255 / 255;
            this._horizonColor[3] = 255 / 255;
            //---------------
            this._uvData[0] = -0.000005 * 2.5;
            this._uvData[1] = 0.0 * 2.5;
            this._uvData[2] = 0.00001 * 2.5;
            this._uvData[3] = 0.0 * 2.5;
            this._uvData[4] = this._distion_intensity.x;
            this._uvData[5] = this._distion_intensity.y;
            this._uvData[6] = 1.0;
            this._uvData[7] = 1.0;
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 开始播放uv动画
        * @param rest 如果为ture就是重置播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterBumpMethod.prototype.start = function (rest) {
            //##FilterBegin## ##Water##
            if (rest === void 0) { rest = false; }
            if (rest)
                this._time = 0;
            this._start = true;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 停止播放uv动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterBumpMethod.prototype.stop = function () {
            //##FilterBegin## ##Water##
            this._start = false;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 设置UV 速度
        * @param index 0 或 1
        * @param u
        * @param v
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterBumpMethod.prototype.setUvSpeed = function (index, u, v) {
            //##FilterBegin## ##Water##
            switch (index) {
                case 0:
                    this._uvData[0] = u;
                    this._uvData[1] = v;
                    break;
                case 1:
                    this._uvData[2] = u;
                    this._uvData[3] = v;
                    break;
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 设置UV repat次数
        * @param u
        * @param v
        * @version Egret 3.0
        * @platform Web,Native
        */
        WaterBumpMethod.prototype.setUvScale = function (first, second) {
            //##FilterBegin## ##Water##
            //##FilterEnd##
        };
        Object.defineProperty(WaterBumpMethod.prototype, "bumpTexture", {
            /**
             * @language zh_CN
             * 设置lightmap贴图
             * @param texture lightmap贴图
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                //##FilterBegin## ##Water##
                this._bumpTexture = texture;
                if (this.materialData["bumpTexture"] != this._bumpTexture) {
                    this.materialData["bumpTexture"] = this._bumpTexture;
                    this.materialData.textureChange = true;
                }
                //##FilterEnd##
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterBumpMethod.prototype, "colorTexture", {
            /**
             * @language zh_CN
             * 设置lightmap贴图
             * @param texture lightmap贴图
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                //##FilterBegin## ##Water##
                this._colorControlTexture = texture;
                if (this.materialData["colorControlTexture"] != this._colorControlTexture) {
                    this.materialData["colorControlTexture"] = this._colorControlTexture;
                    this.materialData.textureChange = true;
                }
                //##FilterEnd##
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @param time
        * @param delay
        * @param usage
        * @param materialData
        * @param geometry
        * @param context3DProxy
        * @param modeltransform
        * @param modeltransform
        * @param camera3D
        */
        WaterBumpMethod.prototype.upload = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            //##FilterBegin## ##Water##
            usage["waterNormalData"] = context3DProxy.getUniformLocation(usage.program3D, "waterNormalData");
            usage["horizonColor"] = context3DProxy.getUniformLocation(usage.program3D, "horizonColor");
            usage["time"] = context3DProxy.getUniformLocation(usage.program3D, "time");
            //##FilterEnd##
        };
        /**
        * @private
        * @language zh_CN
        */
        WaterBumpMethod.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            //##FilterBegin## ##Water##
            if (this._start) {
                this._time += delay;
            }
            context3DProxy.uniform4fv(usage["horizonColor"], this._horizonColor);
            context3DProxy.uniform2fv(usage["waterNormalData"], this._uvData);
            context3DProxy.uniform1f(usage["time"], this._time);
            //##FilterEnd##
        };
        return WaterBumpMethod;
    }(egret3d.MethodBase));
    egret3d.WaterBumpMethod = WaterBumpMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.MethodUsageData
    * @classdesc
    * 方法中需要用到的数据。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PassUsage = (function () {
        function PassUsage() {
            /**
             * @language zh_CN
             */
            this.sampler2DList = new Array();
            /**
             * @language zh_CN
             */
            this.sampler3DList = new Array();
            //----------------------------------------------
            //public vertexShaderRegister: ver;
            this.vertexShader = new egret3d.ShaderBase(egret3d.Shader.vertex);
            this.fragmentShader = new egret3d.ShaderBase(egret3d.Shader.fragment);
            this.maxDirectLight = 0;
            this.maxSpotLight = 0;
            this.maxPointLight = 0;
            this.maxBone = 0;
            this.attributeDiry = true;
        }
        /**
         * @language zh_CN
         */
        PassUsage.prototype.dispose = function () {
            if (this.program3D) {
                this.program3D.dispose();
            }
            this.program3D = null;
            if (this.vertexShader) {
                if (this.vertexShader.shader) {
                    this.vertexShader.shader.dispose();
                }
            }
            this.vertexShader = null;
            if (this.fragmentShader) {
                if (this.fragmentShader.shader) {
                    this.fragmentShader.shader.dispose();
                }
            }
            this.fragmentShader = null;
        };
        return PassUsage;
    }());
    egret3d.PassUsage = PassUsage;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @class egret3d.MaterialData
     */
    var MaterialData = (function (_super) {
        __extends(MaterialData, _super);
        function MaterialData() {
            _super.apply(this, arguments);
            /**
            * @private
            * @language zh_CN
            * 材质类型数组。
            * @每个材质球可能会有很多种贴图方法，而这个是做为默认支持的材质方法的添加通道。要使用的方法
            * @default MaterialType.DIFFUSE
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.shaderPhaseTypes = {};
            /**
            * @language zh_CN
            * 深度 pass usage data。
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public depthPassUsageData: PassUsage = new PassUsage(); 
            /**
            * @language zh_CN
            * 法线 pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public normalPassUsageData: PassUsage = new PassUsage(); 
            /**
            * @language zh_CN
            * position pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public positionPassUsageData: PassUsage = new PassUsage(); 
            /**
            * @language zh_CN
            * post pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public postPassUsageData: PassUsage = new PassUsage(); 
            /**
            * @language zh_CN
            * 灯光 pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public lightPassUsageData: PassUsage = new PassUsage(); 
            /**
            * @language zh_CN
            * 阴影 pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public shadowPassUsageData: PassUsage = new PassUsage(); 
            /**
            * @language zh_CN
            * 材质球ID。
            * <p> 一个合成材质球，可以多维合成，用于标记 subGeometry 所用的材质方法
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.matID = 0;
            /**
            * @language zh_CN
            * 渲染模式。
            * @default DrawMode.TRIANGLES
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.drawMode = egret3d.DrawMode.TRIANGLES;
            /**
            * @language zh_CN
            * 渲染模式。
            * @default DrawMode.TRIANGLES
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.useMipmap = true;
            /**
            * @language zh_CN
            * 法线贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.normalTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * matCapTexture。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.matcapTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * 特效贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.specularTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * 灯光贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lightTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * 遮罩贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.maskTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * ao 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.aoTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * 环境贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.environmentTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * mask 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.blendMaskTexture = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * splat_0 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.splat_0Tex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * splat_1 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.splat_1Tex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * splat_2 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.splat_2Tex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * splat_3 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.splat_3Tex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * layer。
            * @default 0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.layer = 0;
            /**
            * @language zh_CN
            * 投射阴影 。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.castShadow = false;
            /**
            * @language zh_CN
            * 接受阴影。
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.acceptShadow = false;
            /**
            * @language zh_CN
            * 阴影颜色
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.shadowColor = new Float32Array([0.2, 0.2, 0.2, 0.003]);
            /**
            * @language zh_CN
            * 深度测试 。
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.depthTest = true;
            /**
            * @language zh_CN
            * 深度写入 。
            * @default true
            * @version Egret 4.0
            * @platform Web,Native
            */
            this.depthWrite = true;
            /**
            * @language zh_CN
            * 深度测试模式
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.depthMode = 0;
            /**
            * @language zh_CN
            * 混合模式 。
            * @default BlendMode.NORMAL
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.blendMode = egret3d.BlendMode.NORMAL;
            /**
            * @language zh_CN
            * alphaBlending。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.alphaBlending = false;
            /**
            * @language zh_CN
            * ambientColor 值。
            * @default 0x0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.ambientColor = 0x0;
            /**
            * @language zh_CN
            * diffuseColor 值。
            * @default 0xffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.diffuseColor = 0xffffff;
            /**
            * @language zh_CN
            * specularColor 值。
            * @default 0xffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.specularColor = 0xffffff;
            /**
            * @language zh_CN
            * 色相。
            * @default 8.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.tintColor = 0x80808080;
            /**
            * @language zh_CN
            * 材质球的高光强度。
            * @default 8.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.specularLevel = 1.0;
            /**
            * @language zh_CN
            * gama 矫正。
            * @default 8.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.gamma = 1.0;
            this.refraction = 1.9;
            this.refractionintensity = 0.0;
            /**
            * @language zh_CN
            * 材质球的光滑度。
            * @default 8.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.gloss = 10.0;
            /**
            * @language zh_CN
            * cutAlpha 值。
            * @default 0.7
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cutAlpha = 0;
            /**
            * @language zh_CN
            * 是否重复。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.repeat = false;
            /**
            * @language zh_CN
            * bothside 值。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.bothside = false;
            /**
            * @language zh_CN
            * alpha 值。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.alpha = 1.0;
            /**
            * @language zh_CN
            * 光照光滑程度，会影响反光的面积，强度。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public roughness: number = 1.0; 
            /**
             * @language zh_CN
             * 反射颜色的强度值，出射光照的出射率。
             * @default 1.0
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.albedo = 0.95;
            /**
            * @language zh_CN
            * 法线贴图的Y轴朝向
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.normalDir = -1.0;
            /**
            * @language zh_CN
            * uv 在贴图上的映射区域，值的范围限制在0.0~1.0之间。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.uvRectangle = new egret3d.Rectangle(0, 0, 1, 1);
            /**
            * @language zh_CN
            * ambientPower 值。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public ambientPower: number = 1.0; 
            /**
            * @language zh_CN
            * diffusePower。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public diffusePower: number = 1.0; 
            /**
            * @language zh_CN
            * normalPower 值。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public normalPower: number = 1.0; 
            /**
            * @language zh_CN
            * 材质数据需要变化。
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.materialDataNeedChange = true;
            /**
            * @language zh_CN
            * 纹理变化。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.textureChange = false;
            /**
            * @language zh_CN
            * 纹理状态需要更新。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.textureStateChage = true;
            /**
            * @language zh_CN
            * cullFrontOrBack。
            * @default Egret3DDrive.BACK
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cullFrontOrBack = egret3d.ContextConfig.BACK;
            //data
            /**
             * @language zh_CN
             */
            this.materialSourceData = new Float32Array(20); //20
            //public materialSourceData2: Float32Array = new Float32Array(21);//20
            /**
             * @language zh_CN
             */
            this.colorGradientsSource = new Float32Array(6); //y y rgba
        }
        /**
        * @language zh_CN
        * 克隆方法。
        * @returns {MaterialData}
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialData.prototype.clone = function () {
            var data = new MaterialData();
            //data.depthPassUsageData = this.depthPassUsageData;
            //data.normalPassUsageData = this.normalPassUsageData;
            //data.positionPassUsageData = this.positionPassUsageData;
            //data.postPassUsageData = this.positionPassUsageData;
            //data.lightPassUsageData = this.positionPassUsageData;
            //data.shadowPassUsageData = this.positionPassUsageData;
            //data.textureChange = true;
            //data.textureMethodTypes = this.textureMethodTypes;
            data.drawMode = this.drawMode;
            //data.context3D = this.context3D;
            data.diffuseTexture = this.diffuseTexture;
            //data.specularTex = this.specularTex;
            //data.lightMapTex = this.lightMapTex;
            //data.environmentMapTex = this.environmentMapTex;
            data.shadowMapTexture = this.shadowMapTexture;
            for (var i = 0; i < 4; ++i) {
                data.shadowColor[i] = this.shadowColor[i];
            }
            //data.splat_0Tex = this.splat_0Tex;
            //data.splat_1Tex = this.splat_1Tex;
            //data.splat_2Tex = this.splat_2Tex;
            //data.splat_3Tex = this.splat_3Tex;
            data.layer = this.layer;
            data.castShadow = this.castShadow;
            data.acceptShadow = this.acceptShadow;
            data.depthTest = this.depthTest;
            data.depthWrite = this.depthWrite;
            data.blendMode = this.blendMode;
            data.blend_src = this.blend_src;
            data.blend_dest = this.blend_dest;
            data.ambientColor = this.ambientColor;
            data.diffuseColor = this.diffuseColor;
            data.specularColor = this.specularColor;
            data.cutAlpha = this.cutAlpha;
            data.alpha = this.alpha;
            data.specularLevel = this.specularLevel;
            data.gloss = this.gloss;
            data.albedo = this.albedo;
            data.gamma = this.gamma;
            data.refraction = this.refraction;
            data.refractionintensity = this.refractionintensity;
            data.materialDataNeedChange = this.materialDataNeedChange;
            data.textureChange = true;
            data.cullFrontOrBack = this.cullFrontOrBack;
            data.colorTransform = this.colorTransform;
            //material state
            return data;
        };
        /**
        * @language zh_CN
        * 销毁。
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialData.prototype.dispose = function () {
            //if (this.depthPassUsageData)
            //    this.depthPassUsageData.dispose();
            //if (this.normalPassUsageData)
            //    this.normalPassUsageData.dispose();
            //if (this.normalPassUsageData)
            //    this.normalPassUsageData.dispose();
            //if (this.positionPassUsageData)
            //    this.positionPassUsageData.dispose();
            //if (this.postPassUsageData)
            //    this.postPassUsageData.dispose();
            //if (this.lightPassUsageData)
            //    this.lightPassUsageData.dispose();
            //if (this.shadowPassUsageData)
            //    this.shadowPassUsageData.dispose();
            //if (this.directLightList.length > 0) {
            //    this.directLightList.length = 0;
            //    this.directLightList = null;
            //}
            //if (this.sportLightList.length > 0) {
            //    this.sportLightList.length = 0;
            //    this.sportLightList = null;
            //}
            //if (this.pointLightList.length > 0) {
            //    this.pointLightList.length = 0;
            //    this.pointLightList = null;
            //}
        };
        return MaterialData;
    }(Object));
    egret3d.MaterialData = MaterialData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.MaterialPass
    * @classdesc
    * 材质渲染pass 根据Mesh数据、模型的材质还有灯光数据的不同。
    * 以不同的渲染方法，会组成相应的shader内容，然后渲染出不同的效果。
    * 阶段 shader 灵活动态的 特效组合
    * @see egret3d.Mesh
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MaterialPass = (function () {
        ///**
        //* @private
        //*/
        //private _helpMatrix: Matrix4_4 = new Matrix4_4(); 
        //private _helpVector: Vector3D = new Vector3D();
        /**
        * @private
        */
        function MaterialPass(data) {
            if (data === void 0) { data = null; }
            /**
           * @private
           */
            this._passChange = true;
            /**
           * @private
           */
            this._vs_shader_methods = {};
            /**
           * @private
           */
            this._fs_shader_methods = {};
            /**
            * @private
            */
            this.methodList = new Array();
            /**
            * @private
            */
            this.methodDatas = new Array();
            /**
            * @private
            */
            this.vsShaderNames = new Array();
            /**
            * @private
            */
            this.fsShaderNames = new Array();
            /**
              * @public
              * @language zh_CN
              * pass渲染是否开启使用
              * @param method 渲染方法
              * @version Egret 3.0
              * @platform Web,Native
              */
            this.enable = true;
            if (data) {
                this.materialData = data;
            }
        }
        Object.defineProperty(MaterialPass.prototype, "lightGroup", {
            /**
            * @private
            */
            get: function () {
                return this._lightGroup;
            },
            /**
            * @private
            */
            set: function (lightGroup) {
                if (this._lightGroup) {
                    this._lightGroup.removeEventListener(egret3d.LightGroup.EVENT_LIGHT_RESET, this.onLightReset, this);
                }
                this._lightGroup = lightGroup;
                if (this._lightGroup) {
                    this._lightGroup.addEventListener(egret3d.LightGroup.EVENT_LIGHT_RESET, this.onLightReset, this);
                }
            },
            enumerable: true,
            configurable: true
        });
        MaterialPass.prototype.onLightReset = function (e) {
            this._passChange = true;
        };
        Object.defineProperty(MaterialPass.prototype, "materialData", {
            /**
            * @private
            */
            set: function (materialData) {
                this._materialData = materialData;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 增加渲染方法
        * @param method 渲染方法
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialPass.prototype.addMethod = function (method) {
            var index = this.methodList.indexOf(method);
            if (index == -1) {
                this.methodList.push(method);
                method.materialData = this._materialData;
                this._passChange = true;
            }
        };
        /**
        * @language zh_CN
        * 移除渲染方法
        * @param method 渲染方法
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialPass.prototype.removeMethod = function (method) {
            var index = this.methodList.indexOf(method);
            if (index != -1) {
                this.methodList.splice(index, 1);
                this._passChange = true;
            }
        };
        /**
        * @language zh_CN
        * 使用类型拿到 MethodBase  getMethod(UVSpriteSheetMethod)
        * @param type 类型  比如:UVSpriteSheetMethod
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialPass.prototype.getMethod = function (type) {
            for (var i = 0; i < this.methodList.length; ++i) {
                if (this.methodList[i] instanceof type) {
                    return this.methodList[i];
                }
            }
            return null;
        };
        MaterialPass.prototype.addShadowMethod = function () {
            if (this._materialData.acceptShadow) {
                this._shadowMethod = new egret3d.ShadowMethod(this._materialData);
                this.addMethod(this._shadowMethod);
            }
        };
        MaterialPass.prototype.removShadowMethod = function () {
            if (this._shadowMethod) {
                this.removeMethod(this._shadowMethod);
                this._shadowMethod.dispose();
                this._shadowMethod = null;
            }
        };
        MaterialPass.prototype.materialDataChange = function () {
            this._materialData.materialDataNeedChange = true;
        };
        /**
        * @private
        */
        MaterialPass.prototype.passInvalid = function () {
            this._passChange = true;
        };
        /**
       * @language zh_CN
       * 重置纹理。
       * @version Egret 3.0
       * @platform Web,Native
       */
        MaterialPass.prototype.resetTexture = function (context3DProxy) {
            //--------texture----------------
            var sampler2D;
            for (var index in this._passUsage.sampler2DList) {
                sampler2D = this._passUsage.sampler2DList[index];
                if (this._materialData[sampler2D.varName]) {
                    sampler2D.texture = this._materialData[sampler2D.varName];
                }
            }
            var sampler3D;
            for (var index in this._passUsage.sampler3DList) {
                sampler3D = this._passUsage.sampler3DList[index];
                if (this._materialData[sampler3D.varName]) {
                    sampler3D.texture = this._materialData[sampler3D.varName];
                }
            }
            this._materialData.textureChange = false;
        };
        /**
        * @language zh_CN
        * @private
        * 指定shader 添加shader 片段。
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialPass.prototype.addMethodShaders = function (shaderBase, shaders) {
            for (var i = 0; i < shaders.length; i++) {
                shaderBase.addUseShaderName(shaders[i]);
            }
        };
        MaterialPass.prototype.addShaderPhase = function (passType, sourcePhase, targetPhase) {
            var names;
            var phase;
            var tn;
            for (phase in sourcePhase) {
                names = sourcePhase[phase];
                for (var i = 0; i < names.length; i++) {
                    targetPhase[phase] = targetPhase[phase] || [];
                    targetPhase[phase].push(names[i]);
                    tn = egret3d.ShaderPhaseType[phase];
                    var index = this._materialData.shaderPhaseTypes[passType].indexOf(egret3d.ShaderPhaseType[tn]);
                    if (index != -1) {
                        this._materialData.shaderPhaseTypes[passType].splice(index, 1);
                    }
                }
            }
        };
        MaterialPass.prototype.initOthreMethods = function () {
            var shaderPhase;
            var shaderList;
            for (var d = 0; d < this.methodList.length; d++) {
                var method = this.methodList[d];
                for (shaderPhase in method.vsShaderList) {
                    shaderList = method.vsShaderList[shaderPhase];
                    for (var i = 0; i < shaderList.length; i++) {
                        this._vs_shader_methods[shaderPhase] = this._vs_shader_methods[shaderPhase] || [];
                        this._vs_shader_methods[shaderPhase].push(shaderList[i]);
                    }
                }
                for (shaderPhase in method.fsShaderList) {
                    shaderList = method.fsShaderList[shaderPhase];
                    for (var i = 0; i < shaderList.length; i++) {
                        this._fs_shader_methods[shaderPhase] = this._fs_shader_methods[shaderPhase] || [];
                        this._fs_shader_methods[shaderPhase].push(shaderList[i]);
                    }
                }
            }
        };
        /**
        * @language zh_CN
        * @private
        * 初始化 UseMethod。
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialPass.prototype.initUseMethod = function (animation, geom) {
            this._passChange = false;
            var i = 0;
            this._passUsage = new egret3d.PassUsage();
            this._vs_shader_methods = {};
            this._fs_shader_methods = {};
            //pre Phase ---------------------------------------------------
            if (animation) {
                // to add accept animation shader
                if (animation.skeletonAnimationController) {
                    this._passUsage.maxBone = animation.skeletonAnimationController.jointNum * 2;
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("skeleton_vs");
                }
                else if (animation.particleAnimationController) {
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("particle_vs");
                    //to change importent
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.vertex_shaders, this._vs_shader_methods);
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.fragment_shaders, this._fs_shader_methods);
                }
            }
            if (this._materialData.acceptShadow) {
                // to add accept shadow maping shader+
                this._vs_shader_methods[egret3d.ShaderPhaseType.global_vertex] = this._vs_shader_methods[egret3d.ShaderPhaseType.global_vertex] || [];
                //this._vs_shader_methods[ShaderPhaseType.global_vertex].push("particle_vs");
                this._fs_shader_methods[egret3d.ShaderPhaseType.shadow_fragment] = this._fs_shader_methods[egret3d.ShaderPhaseType.shadow_fragment] || [];
            }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.diffuse_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment].push("diffuse_fragment");
            }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.normal_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.normal_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.normal_fragment].push("normalMap_fragment");
            }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.specular_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.specular_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.specular_fragment].push("specularMap_fragment");
            }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.matCap_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.matCap_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.matCap_fragment].push("matCap_TextureMult_fs");
            }
            if (this.lightGroup) {
                this._passUsage.maxDirectLight = this.lightGroup.directLightList.length;
                this._passUsage.maxSpotLight = this.lightGroup.spotLightList.length;
                this._passUsage.maxPointLight = this.lightGroup.pointLightList.length;
                this._vs_shader_methods[egret3d.ShaderPhaseType.local_vertex] = this._vs_shader_methods[egret3d.ShaderPhaseType.local_vertex] || [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.lighting_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.lighting_fragment].push("lightingBase_fs");
                if (this.lightGroup.directLightList.length) {
                    this._passUsage.directLightData = new Float32Array(egret3d.DirectLight.stride * this.lightGroup.directLightList.length);
                    this._vs_shader_methods[egret3d.ShaderPhaseType.local_vertex].push("varyingViewDir_vs");
                    this._fs_shader_methods[egret3d.ShaderPhaseType.lighting_fragment].push("directLight_fragment");
                }
                if (this.lightGroup.spotLightList.length) {
                    this._passUsage.spotLightData = new Float32Array(egret3d.SpotLight.stride * this.lightGroup.spotLightList.length);
                    this._fs_shader_methods[egret3d.ShaderPhaseType.lighting_fragment].push("spotLight_fragment");
                }
                if (this.lightGroup.pointLightList.length) {
                    this._passUsage.pointLightData = new Float32Array(egret3d.PointLight.stride * this.lightGroup.pointLightList.length);
                    this._fs_shader_methods[egret3d.ShaderPhaseType.lighting_fragment].push("pointLight_fragment");
                }
            }
            this.initOthreMethods();
            //pre Phase end ---------------------------------------------------
            this.phaseEnd(animation);
        };
        MaterialPass.prototype.phaseEnd = function (animation) {
            var shaderList;
            //---vs---shadering
            //utils Phase
            shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.utils_vertex];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.vertexShader, shaderList);
            //base Phase
            shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.base_vertex];
            if (shaderList && shaderList.length > 0) {
                this.addMethodShaders(this._passUsage.vertexShader, shaderList);
            }
            else {
                this.addMethodShaders(this._passUsage.vertexShader, ["base_vs"]);
                //start Phase
                shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex];
                if (shaderList && shaderList.length > 0)
                    this.addMethodShaders(this._passUsage.vertexShader, shaderList);
                else
                    this.addMethodShaders(this._passUsage.vertexShader, ["diffuse_vertex"]);
                //local
                shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.local_vertex];
                if (shaderList && shaderList.length > 0)
                    this.addMethodShaders(this._passUsage.vertexShader, shaderList);
                //global
                shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.global_vertex];
                if (shaderList && shaderList.length > 0)
                    this.addMethodShaders(this._passUsage.vertexShader, shaderList);
                //end
                shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.end_vertex];
                if (shaderList && shaderList.length > 0)
                    this.addMethodShaders(this._passUsage.vertexShader, shaderList);
                else
                    this.addMethodShaders(this._passUsage.vertexShader, ["end_vs"]);
                this.addMethodShaders(this._passUsage.vertexShader, ["out_vs"]);
            }
            //---vs---shadering-------------------------------------------------
            //---fs---shadering-------------------------------------------------
            //utils Phase
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.utils_fragment];
            if (shaderList && shaderList.length > 0)
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.base_fragment];
            if (shaderList && shaderList.length > 0) {
                this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            }
            else {
                this.addMethodShaders(this._passUsage.fragmentShader, ["base_fs"]);
                //start
                shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.start_fragment];
                if (shaderList && shaderList.length > 0)
                    this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
                //materialsource
                shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.materialsource_fragment];
                if (shaderList && shaderList.length > 0)
                    this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
                else
                    this.addMethodShaders(this._passUsage.fragmentShader, ["materialSource_fs"]);
                //diffuse
                shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment];
                if (shaderList && shaderList.length > 0)
                    this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
                else
                    this.addMethodShaders(this._passUsage.fragmentShader, ["diffuse_fragment"]);
                //normal
                shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.normal_fragment];
                if (shaderList && shaderList.length > 0)
                    this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
                //else
                //    this.addMethodShaders(this._passUsage.fragmentShader, ["normalMap_fragment"]);
                //else
                //    this.addMethodShaders(this._passUsage.fragmentShader, ["specularMap_fragment"]);
                //shadow
                shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.shadow_fragment];
                if (shaderList && shaderList.length > 0)
                    this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
                //specular
                shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.specular_fragment];
                if (shaderList && shaderList.length > 0)
                    this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
                //lighting
                shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.lighting_fragment];
                if (shaderList && shaderList.length > 0)
                    this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
                //matCap
                shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.matCap_fragment];
                if (shaderList && shaderList.length > 0)
                    this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
                //else 
                //    this.addMethodShaders(this._passUsage.fragmentShader, ["matCap_TextureAdd_fs"]);
                //end
                shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment];
                if (shaderList && shaderList.length > 0)
                    this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
                else {
                    this.addMethodShaders(this._passUsage.fragmentShader, ["end_fs"]);
                }
                //multi_end_fragment
                shaderList = this._fs_shader_methods[egret3d.ShaderPhaseType.multi_end_fragment];
                if (shaderList && shaderList.length > 0)
                    this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
                this.addMethodShaders(this._passUsage.fragmentShader, ["out_fs"]);
            }
            //---fs---shadering-------------------------------------------------
        };
        /**
        * @private
        */
        MaterialPass.prototype.upload = function (time, delay, context3DProxy, modeltransform, camera3D, animation, geometry, renderQuen) {
            //if (this._passChange && this._passUsage) {
            //    //delete this._passUsage; 
            //    //Context3DProxy.gl.deleteProgram(this._passUsage.program3D.program);
            //    this._passChange = false;
            //}
            this._passChange = false;
            this.initUseMethod(animation, geometry);
            this._passUsage.vertexShader.shader = this._passUsage.vertexShader.getShader(this._passUsage);
            this._passUsage.fragmentShader.shader = this._passUsage.fragmentShader.getShader(this._passUsage);
            //this._passUsage.program3D = context3DProxy.creatProgram(this._passUsage.vertexShader.shader, this._passUsage.fragmentShader.shader);
            this._passUsage.program3D = egret3d.ShaderPool.getProgram(this._passUsage.vertexShader.shader.id, this._passUsage.fragmentShader.shader.id);
            for (var property in this._passUsage) {
                if (property.indexOf("uniform") != -1) {
                    if (this._passUsage[property]) {
                        this._passUsage[property].uniformIndex = context3DProxy.getUniformLocation(this._passUsage.program3D, property);
                    }
                }
            }
            var sampler2D;
            for (var index in this._passUsage.sampler2DList) {
                sampler2D = this._passUsage.sampler2DList[index];
                sampler2D.uniformIndex = context3DProxy.getUniformLocation(this._passUsage.program3D, sampler2D.varName);
                sampler2D.texture = this._materialData[sampler2D.varName];
            }
            var sampler3D;
            for (var index in this._passUsage.sampler3DList) {
                sampler3D = this._passUsage.sampler3DList[index];
                sampler3D.uniformIndex = context3DProxy.getUniformLocation(this._passUsage.program3D, sampler3D.varName);
            }
            if (this.methodList) {
                for (var i = 0; i < this.methodList.length; i++) {
                    this.methodList[i].upload(time, delay, this._passUsage, null, context3DProxy, modeltransform, camera3D, renderQuen);
                }
            }
        };
        /**
        * @private
        */
        MaterialPass.prototype.draw = function (time, delay, context3DProxy, modeltransform, camera3D, subGeometry, render, renderQuen) {
            if (!this.enable)
                return;
            if (this._materialData.materialDataNeedChange) {
                //this._materialData.materialDataNeedChange = false;
                var tintValue = this._materialData.tintColor;
                var tintAlpha = tintValue >> 24 & 0xff;
                var tintRed = tintValue >> 16 & 0xff;
                var tintGreen = tintValue >> 8 & 0xff;
                var tintBlue = tintValue & 0xff;
                tintAlpha /= 0x80;
                tintRed /= 0x80;
                tintGreen /= 0x80;
                tintBlue /= 0x80;
                this._materialData.materialSourceData[0] = tintRed * (this._materialData.diffuseColor >> 16 & 0xff) / 255.0;
                this._materialData.materialSourceData[1] = tintGreen * (this._materialData.diffuseColor >> 8 & 0xff) / 255.0;
                this._materialData.materialSourceData[2] = tintBlue * (this._materialData.diffuseColor & 0xff) / 255.0;
                this._materialData.materialSourceData[3] = (this._materialData.ambientColor >> 16 & 0xff) / 255.0;
                this._materialData.materialSourceData[4] = (this._materialData.ambientColor >> 8 & 0xff) / 255.0;
                this._materialData.materialSourceData[5] = (this._materialData.ambientColor & 0xff) / 255.0;
                this._materialData.materialSourceData[6] = (this._materialData.specularColor >> 16 & 0xff) / 255.0;
                this._materialData.materialSourceData[7] = (this._materialData.specularColor >> 8 & 0xff) / 255.0;
                this._materialData.materialSourceData[8] = (this._materialData.specularColor & 0xff) / 255.0;
                this._materialData.materialSourceData[9] = tintAlpha * this._materialData.alpha;
                this._materialData.materialSourceData[10] = this._materialData.cutAlpha;
                this._materialData.materialSourceData[11] = this._materialData.gloss;
                this._materialData.materialSourceData[12] = this._materialData.specularLevel;
                //this._materialData.materialSourceData[13] = this._materialData.normalDir;
                this._materialData.materialSourceData[13] = this._materialData.uvRectangle.x;
                this._materialData.materialSourceData[14] = this._materialData.uvRectangle.y; //保留
                this._materialData.materialSourceData[15] = this._materialData.uvRectangle.width; //保留
                this._materialData.materialSourceData[16] = this._materialData.uvRectangle.height; //保留
                this._materialData.materialSourceData[17] = this._materialData.gamma; //保留refraction
                this._materialData.materialSourceData[18] = this._materialData.refraction; //保留
                this._materialData.materialSourceData[19] = this._materialData.refractionintensity; //保留
            }
            if (this._passChange) {
                this.upload(time, delay, context3DProxy, modeltransform, camera3D, render.animation, subGeometry.geometry, renderQuen);
            }
            context3DProxy.setProgram(this._passUsage.program3D);
            subGeometry.activeState(time, delay, this._passUsage, context3DProxy);
            if (this._materialData.depthTest) {
                context3DProxy.enableDepth();
                context3DProxy.depthFunc(egret3d.ContextConfig.LEQUAL);
            }
            else {
                context3DProxy.disableDepth();
                context3DProxy.depthFunc(egret3d.ContextConfig.LEQUAL);
            }
            if (this._materialData.acceptShadow) {
                if (renderQuen.renderDictionary[egret3d.PassType.shadowPass] && this._shadowMethod)
                    this._shadowMethod.shadowMapTexture = renderQuen.renderDictionary[egret3d.PassType.shadowPass].renderTexture;
            }
            //Context3DProxy.gl.clearColor(0.0,0.0,0.0,1.0);
            //Context3DProxy.gl.stencilOp(Context3DProxy.gl.BACK, Context3DProxy.gl.KEEP, Context3DProxy.gl.KEEP);
            context3DProxy.setCulling(this._materialData.cullFrontOrBack);
            if (this._materialData.bothside) {
                context3DProxy.disableCullFace();
            }
            else
                context3DProxy.enableCullFace();
            if (this._passID == egret3d.PassType.shadowPass) {
                //if (this._materialData.alphaBlending)
                //    Context3DProxy.gl.depthMask(false);
                context3DProxy.disableBlend();
                context3DProxy.setBlendFactors(egret3d.ContextConfig.ONE, egret3d.ContextConfig.ZERO);
            }
            else {
                if (!this._materialData.depthWrite) {
                    egret3d.Context3DProxy.gl.depthMask(false);
                }
                context3DProxy.enableBlend();
                context3DProxy.setBlendFactors(this._materialData.blend_src, this._materialData.blend_dest);
            }
            if (this._passUsage.uniform_materialSource) {
                context3DProxy.uniform1fv(this._passUsage.uniform_materialSource.uniformIndex, this._materialData.materialSourceData);
            }
            if (this._materialData.textureChange) {
                this.resetTexture(context3DProxy);
            }
            //texture 2D
            var sampler2D;
            var texture;
            for (var index in this._passUsage.sampler2DList) {
                sampler2D = this._passUsage.sampler2DList[index];
                sampler2D.texture = this._materialData[sampler2D.varName];
                if (!sampler2D.texture) {
                    continue;
                }
                texture = sampler2D.texture.parentTexture ? sampler2D.texture.parentTexture : sampler2D.texture;
                texture.upload(context3DProxy);
                context3DProxy.setTexture2DAt(sampler2D.activeTextureIndex, sampler2D.uniformIndex, sampler2D.index, texture.texture2D);
                if (texture.useMipmap)
                    texture.useMipmap = this._materialData.useMipmap;
                texture.repeat = this._materialData.repeat;
                texture.activeState(context3DProxy);
                this._materialData.textureStateChage = false;
            }
            var sampler3D;
            for (var index in this._passUsage.sampler3DList) {
                sampler3D = this._passUsage.sampler3DList[index];
                sampler3D.texture = this._materialData[sampler3D.varName];
                if (!sampler3D.texture) {
                    continue;
                }
                sampler3D.texture.upload(context3DProxy);
                context3DProxy.setCubeTextureAt(sampler3D.activeTextureIndex, sampler3D.uniformIndex, sampler3D.index, sampler3D.texture.texture3D);
            }
            var i = 0;
            if (this.lightGroup) {
                for (i = 0; i < this._passUsage.maxDirectLight; i++) {
                    this.lightGroup.directLightList[i].updateLightData(camera3D, i, this._passUsage.directLightData);
                }
                for (i = 0; i < this._passUsage.maxSpotLight; i++) {
                    this.lightGroup.spotLightList[i].updateLightData(camera3D, i, this._passUsage.spotLightData);
                }
                for (i = 0; i < this._passUsage.maxPointLight; i++) {
                    this.lightGroup.pointLightList[i].updateLightData(camera3D, i, this._passUsage.pointLightData);
                }
                if (this._passUsage.uniform_directLightSource)
                    context3DProxy.uniform1fv(this._passUsage.uniform_directLightSource.uniformIndex, this._passUsage.directLightData);
                if (this._passUsage.uniform_sportLightSource)
                    context3DProxy.uniform1fv(this._passUsage.uniform_sportLightSource.uniformIndex, this._passUsage.spotLightData);
                if (this._passUsage.uniform_pointLightSource)
                    context3DProxy.uniform1fv(this._passUsage.uniform_pointLightSource.uniformIndex, this._passUsage.pointLightData);
            }
            if (this._passUsage.uniform_ModelMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_ModelMatrix.uniformIndex, false, modeltransform.rawData);
            }
            if (this._passUsage.uniform_ViewMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_ViewMatrix.uniformIndex, false, camera3D.viewMatrix.rawData);
            }
            if (this._passUsage.uniform_ProjectionMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_ProjectionMatrix.uniformIndex, false, camera3D.projectMatrix.rawData);
            }
            if (this._passUsage.uniform_ViewProjectionMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_ViewProjectionMatrix.uniformIndex, false, camera3D.viewProjectionMatrix.rawData);
            }
            if (this._passUsage.uniform_orthProjectMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_orthProjectMatrix.uniformIndex, false, camera3D.orthProjectionMatrix.rawData);
            }
            if (render.animation) {
                render.animation.activeState(time, delay, this._passUsage, subGeometry, context3DProxy, modeltransform, camera3D);
            }
            if (this.methodList) {
                for (var i = 0; i < this.methodList.length; i++) {
                    this.methodList[i].activeState(time, delay, this._passUsage, null, context3DProxy, modeltransform, camera3D, renderQuen);
                }
            }
            if (this._passUsage.uniform_eyepos) {
                context3DProxy.uniform3f(this._passUsage.uniform_eyepos.uniformIndex, camera3D.x, camera3D.y, camera3D.z);
            }
            if (this._passUsage.uniform_cameraMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_cameraMatrix.uniformIndex, false, camera3D.modelMatrix.rawData);
            }
            if (this._passUsage["uniform_billboardMatrix"]) {
                var matrix;
                switch (render.billboard) {
                    case egret3d.BillboardType.STANDARD:
                        matrix = camera3D.billboardXYZ;
                        break;
                    case egret3d.BillboardType.X_AXIS:
                        matrix = camera3D.billboardX;
                        break;
                    case egret3d.BillboardType.Y_AXIS:
                        matrix = camera3D.billboardY;
                        break;
                    case egret3d.BillboardType.Z_AXIS:
                        matrix = camera3D.billboardZ;
                        break;
                    case egret3d.BillboardType.DISABLE:
                        matrix = egret3d.Matrix4_4.helpMatrix;
                        matrix.identity();
                        break;
                }
                context3DProxy.uniformMatrix4fv(this._passUsage["uniform_billboardMatrix"].uniformIndex, false, matrix.rawData);
            }
            if (this._passUsage["uniform_ObjectId"]) {
                var objectId = egret3d.Color.getColor(render.id, egret3d.ContextConfig.ColorFormat_RGBA8888, egret3d.Vector3D.HELP_0);
                context3DProxy.uniform3fv(this._passUsage["uniform_ObjectId"].uniformIndex, [objectId.x, objectId.y, objectId.z]);
            }
            context3DProxy.drawElement(this._materialData.drawMode, subGeometry.start * Uint16Array.BYTES_PER_ELEMENT, subGeometry.count);
            // gl.drawElements(gl.POINTS, 8, gl.UNSIGNED_INT, 0);
            if (!this._materialData.depthWrite) {
                egret3d.Context3DProxy.gl.depthMask(true);
            }
        };
        MaterialPass.prototype.deactiveState = function (passUsage, context3DProxy) {
            var sampler2D;
            for (var index in passUsage.sampler2DList) {
                sampler2D = this._passUsage.sampler2DList[index];
                if (!sampler2D.texture) {
                    continue;
                }
                context3DProxy.disableTexture2DAt(sampler2D.activeTextureIndex, sampler2D.uniformIndex, sampler2D.index);
            }
        };
        /**
        * @language zh_CN
        * 释放接口
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialPass.prototype.dispose = function () {
            if (this._passUsage) {
                this._passUsage.dispose();
            }
            this._passUsage = null;
        };
        return MaterialPass;
    }());
    egret3d.MaterialPass = MaterialPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ColorPass = (function (_super) {
        __extends(ColorPass, _super);
        function ColorPass(materialData) {
            _super.call(this, materialData);
            this._passID = egret3d.PassType.colorPass;
        }
        /**
       * @language zh_CN
       * @private
       * 初始化 UseMethod。
       * @version Egret 3.0
       * @platform Web,Native
       */
        ColorPass.prototype.initUseMethod = function (animation, geom) {
            var i = 0;
            this._passChange = false;
            this._passUsage = new egret3d.PassUsage();
            this._passUsage.vertexShader.shaderType = egret3d.Shader.vertex;
            this._passUsage.fragmentShader.shaderType = egret3d.Shader.fragment;
            //pre Phase ---------------------------------------------------
            if (animation) {
                // to add accept animation shader
                if (animation.skeletonAnimationController) {
                    this._passUsage.maxBone = animation.skeletonAnimationController.jointNum * 2;
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("skeleton_vs");
                }
                else if (animation.particleAnimationController) {
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("particle_vs");
                    //to change importent
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.vertex_shaders, this._vs_shader_methods);
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.fragment_shaders, this._fs_shader_methods);
                }
            }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.diffuse_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment].push("diffuse_fragment");
            }
            this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment] = this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment] || [];
            this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment].push("colorPassEnd_fs");
            this.phaseEnd(animation);
        };
        return ColorPass;
    }(egret3d.MaterialPass));
    egret3d.ColorPass = ColorPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var DiffusePass = (function (_super) {
        __extends(DiffusePass, _super);
        function DiffusePass(materialData) {
            _super.call(this, materialData);
            this._passID = egret3d.PassType.diffusePass;
        }
        /**
        * @language zh_CN
        * @private
        * 初始化 UseMethod。
        * @version Egret 3.0
        * @platform Web,Native
        */
        DiffusePass.prototype.initUseMethod = function (animation, geom) {
            _super.prototype.initUseMethod.call(this, animation, geom);
        };
        return DiffusePass;
    }(egret3d.MaterialPass));
    egret3d.DiffusePass = DiffusePass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var FakePBRPass = (function (_super) {
        __extends(FakePBRPass, _super);
        function FakePBRPass(materialData) {
            _super.call(this, materialData);
            this._passID = egret3d.PassType.diffusePass;
        }
        FakePBRPass.prototype.setTexture = function (name, texture) {
            this._materialData[name] = texture;
        };
        /**
        * @language zh_CN
        * @private
        * 初始化 UseMethod。
        * @version Egret 3.0
        * @platform Web,Native
        */
        //public initUseMethod(animation: IAnimation, geom: Geometry) {
        //    super.initUseMethod(animation, geom);
        //}
        FakePBRPass.prototype.initUseMethod = function (animation, geom) {
            this._passChange = false;
            var i = 0;
            this._passUsage = new egret3d.PassUsage();
            this._vs_shader_methods = {};
            this._fs_shader_methods = {};
            if (this.lightGroup) {
                this._passUsage.maxDirectLight = this.lightGroup.directLightList.length;
                this._passUsage.maxSpotLight = this.lightGroup.spotLightList.length;
                this._passUsage.maxPointLight = this.lightGroup.pointLightList.length;
                //this._vs_shader_methods[ShaderPhaseType.local_vertex] = this._vs_shader_methods[ShaderPhaseType.local_vertex] || [];
                //this._fs_shader_methods[ShaderPhaseType.lighting_fragment] = [];
                //this._fs_shader_methods[ShaderPhaseType.lighting_fragment].push("lightingBase_fs");
                if (this.lightGroup.directLightList.length) {
                    this._passUsage.directLightData = new Float32Array(egret3d.DirectLight.stride * this.lightGroup.directLightList.length);
                }
            }
            //pre Phase ---------------------------------------------------
            this.addMethodShaders(this._passUsage.vertexShader, ["FakePBR_vs"]);
            this.addMethodShaders(this._passUsage.fragmentShader, ["materialSource_fs"]);
            this.addMethodShaders(this._passUsage.fragmentShader, ["FakePBR_fs"]);
        };
        return FakePBRPass;
    }(egret3d.MaterialPass));
    egret3d.FakePBRPass = FakePBRPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ShadowPass = (function (_super) {
        __extends(ShadowPass, _super);
        function ShadowPass(materialData) {
            _super.call(this, materialData);
            this._passID = egret3d.PassType.shadowPass;
        }
        /**
        * @language zh_CN
        * @private
        * 初始化 UseMethod。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ShadowPass.prototype.initUseMethod = function (animation, geom) {
            this._passChange = false;
            var i = 0;
            this._passUsage = new egret3d.PassUsage();
            this._vs_shader_methods = {};
            this._fs_shader_methods = {};
            ////pre Phase ---------------------------------------------------
            //if (animation) {
            //    // to add accept animation shader
            //    if (animation.skeletonAnimationController) {
            //        this._passUsage.maxBone = animation.skeletonAnimationController.jointNum * 2;
            //        this._vs_shader_methods[ShaderPhaseType.start_vertex] = [];
            //        this._vs_shader_methods[ShaderPhaseType.start_vertex].push("skeletonShadowPass_vs");
            //    }
            //    else if (animation.particleAnimationController) {
            //        //this._vs_shader_methods[ShaderPhaseType.start_vertex] = [];
            //        //this._vs_shader_methods[ShaderPhaseType.start_vertex].push("particle_vs");
            //        ////to change importent
            //        //this.addShaderPhase(animation.particleAnimationController.particleAnimationState.vertex_shaders, this._vs_shader_methods);
            //        //this.addShaderPhase(animation.particleAnimationController.particleAnimationState.fragment_shaders, this._fs_shader_methods);
            //    }
            //}
            //else {
            //    this._vs_shader_methods[ShaderPhaseType.start_vertex] = [];
            //    this._vs_shader_methods[ShaderPhaseType.start_vertex].push("staticShadowPass_vs");
            //}
            if (animation) {
                if (animation.skeletonAnimationController) {
                    this._passUsage.maxBone = animation.skeletonAnimationController.jointNum * 2;
                    this.addMethodShaders(this._passUsage.vertexShader, ["shadowPass_skeleton_vs"]);
                }
                else if (animation.particleAnimationController) {
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("particle_vs");
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.vertex_shaders, this._vs_shader_methods);
                    this.addMethodShaders(this._passUsage.vertexShader, ["base_vs"]);
                    var shaderList;
                    //start Phase
                    shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex];
                    if (shaderList && shaderList.length > 0)
                        this.addMethodShaders(this._passUsage.vertexShader, shaderList);
                    //local
                    shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.local_vertex];
                    if (shaderList && shaderList.length > 0)
                        this.addMethodShaders(this._passUsage.vertexShader, shaderList);
                    //global
                    shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.global_vertex];
                    if (shaderList && shaderList.length > 0)
                        this.addMethodShaders(this._passUsage.vertexShader, shaderList);
                    //end
                    shaderList = this._vs_shader_methods[egret3d.ShaderPhaseType.end_vertex];
                    if (shaderList && shaderList.length > 0)
                        this.addMethodShaders(this._passUsage.vertexShader, shaderList);
                }
            }
            else {
                this.addMethodShaders(this._passUsage.vertexShader, ["shadowPass_vs"]);
            }
            this.addMethodShaders(this._passUsage.fragmentShader, ["shadowPass_fs"]);
            //if (this._materialData.shaderPhaseTypes[PassType.shadowPass].indexOf(ShaderPhaseType.diffuse_fragment) != -1) {
            //    this._fs_shader_methods[ShaderPhaseType.diffuse_fragment] = [];
            //    this._fs_shader_methods[ShaderPhaseType.diffuse_fragment].push("diffuseShadowPass_fs");
            //}
            //this.initOthreMethods();
            //pre Phase end ---------------------------------------------------
            //var shaderList: string[];
            ////---vs---shadering
            //this.addMethodShaders(this._passUsage.vertexShader, ["baseShadowPass_vs"]);
            ////start Phase
            //shaderList = this._vs_shader_methods[ShaderPhaseType.start_vertex];
            //if (shaderList && shaderList.length > 0)
            //    this.addMethodShaders(this._passUsage.vertexShader, shaderList);
            //this.addMethodShaders(this._passUsage.vertexShader, ["endShadowPass_vs"]);
            ////---vs---shadering-------------------------------------------------
            ////---fs---shadering
            //this.addMethodShaders(this._passUsage.fragmentShader, ["baseShadowPass_fs"]);
            ////diffuse
            //shaderList = this._fs_shader_methods[ShaderPhaseType.diffuse_fragment];
            //if (shaderList && shaderList.length > 0)
            //    this.addMethodShaders(this._passUsage.fragmentShader, shaderList);
            //this.addMethodShaders(this._passUsage.fragmentShader, ["endShadowPass_fs"]);
            ////---fs---shadering-------------------------------------------------
        };
        return ShadowPass;
    }(egret3d.MaterialPass));
    egret3d.ShadowPass = ShadowPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var NormalPass = (function (_super) {
        __extends(NormalPass, _super);
        function NormalPass(materialData) {
            _super.call(this, materialData);
            this._passID = egret3d.PassType.CubePass;
        }
        /**
        * @language zh_CN
        * @private
        * 初始化 UseMethod。
        * @version Egret 3.0
        * @platform Web,Native
        */
        NormalPass.prototype.initUseMethod = function (animation, geom) {
            //super.initUseMethod(animation, geom);
            var i = 0;
            this._passChange = false;
            this._passUsage = new egret3d.PassUsage();
            this._passUsage.vertexShader.shaderType = egret3d.Shader.vertex;
            this._passUsage.fragmentShader.shaderType = egret3d.Shader.fragment;
            //pre Phase ---------------------------------------------------
            if (animation) {
                // to add accept animation shader
                if (animation.skeletonAnimationController) {
                    this._passUsage.maxBone = animation.skeletonAnimationController.jointNum * 2;
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("skeleton_vs");
                }
                else if (animation.particleAnimationController) {
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("particle_vs");
                    //to change importent
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.vertex_shaders, this._vs_shader_methods);
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.fragment_shaders, this._fs_shader_methods);
                }
            }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.normal_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.normal_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.normal_fragment].push("normalMap_fragment");
            }
            this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment] = this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment] || [];
            this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment].push("normalPassEnd_fs");
            this.phaseEnd(animation);
        };
        return NormalPass;
    }(egret3d.MaterialPass));
    egret3d.NormalPass = NormalPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var PositionPass = (function (_super) {
        __extends(PositionPass, _super);
        function PositionPass(materialData) {
            _super.call(this, materialData);
            this._passID = egret3d.PassType.CubePass;
        }
        /**
        * @language zh_CN
        * @private
        * 初始化 UseMethod。
        * @version Egret 3.0
        * @platform Web,Native
        */
        PositionPass.prototype.initUseMethod = function (animation, geom) {
            var i = 0;
            this._passChange = false;
            this._passUsage = new egret3d.PassUsage();
            this._passUsage.vertexShader.shaderType = egret3d.Shader.vertex;
            this._passUsage.fragmentShader.shaderType = egret3d.Shader.fragment;
            //pre Phase ---------------------------------------------------
            if (animation) {
                // to add accept animation shader
                if (animation.skeletonAnimationController) {
                    this._passUsage.maxBone = animation.skeletonAnimationController.jointNum * 2;
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("skeleton_vs");
                }
                else if (animation.particleAnimationController) {
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("particle_vs");
                    //to change importent
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.vertex_shaders, this._vs_shader_methods);
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.fragment_shaders, this._fs_shader_methods);
                }
            }
            this._vs_shader_methods[egret3d.ShaderPhaseType.end_vertex] = this._vs_shader_methods[egret3d.ShaderPhaseType.end_vertex] || [];
            this._vs_shader_methods[egret3d.ShaderPhaseType.end_vertex].push("positionEndPass_vs");
            this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment] = this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment] || [];
            this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment].push("positionEndPass_fs");
            this.phaseEnd(animation);
        };
        return PositionPass;
    }(egret3d.MaterialPass));
    egret3d.PositionPass = PositionPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var GbufferPass = (function (_super) {
        __extends(GbufferPass, _super);
        function GbufferPass(materialData) {
            _super.call(this, materialData);
            this._passID = egret3d.PassType.CubePass;
        }
        /**
        * @language zh_CN
        * @private
        * 初始化 UseMethod。
        * @version Egret 3.0
        * @platform Web,Native
        */
        GbufferPass.prototype.initUseMethod = function (animation, geom) {
            this._passChange = false;
            var i = 0;
            this._passUsage = new egret3d.PassUsage();
            this._vs_shader_methods = {};
            this._fs_shader_methods = {};
            //pre Phase ---------------------------------------------------
            if (animation) {
                // to add accept animation shader
                if (animation.skeletonAnimationController) {
                    this._passUsage.maxBone = animation.skeletonAnimationController.jointNum * 2;
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("skeleton_vs");
                }
                else if (animation.particleAnimationController) {
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("particle_vs");
                    //to change importent
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.vertex_shaders, this._vs_shader_methods);
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.fragment_shaders, this._fs_shader_methods);
                }
            }
            if (this._materialData.acceptShadow) {
                // to add accept shadow maping shader+
                this._vs_shader_methods[egret3d.ShaderPhaseType.global_vertex] = this._vs_shader_methods[egret3d.ShaderPhaseType.global_vertex] || [];
                //this._vs_shader_methods[ShaderPhaseType.global_vertex].push("particle_vs");
                this._fs_shader_methods[egret3d.ShaderPhaseType.shadow_fragment] = this._fs_shader_methods[egret3d.ShaderPhaseType.shadow_fragment] || [];
            }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.diffuse_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.diffuse_fragment].push("diffuse_fragment");
            }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.normal_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.normal_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.normal_fragment].push("normalMap_fragment");
            }
            if (this._materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.specular_fragment) != -1) {
                this._fs_shader_methods[egret3d.ShaderPhaseType.specular_fragment] = [];
                this._fs_shader_methods[egret3d.ShaderPhaseType.specular_fragment].push("specularMap_fragment");
            }
            this._vs_shader_methods[egret3d.ShaderPhaseType.end_vertex] = this._vs_shader_methods[egret3d.ShaderPhaseType.end_vertex] || [];
            this._vs_shader_methods[egret3d.ShaderPhaseType.end_vertex].push("positionEndPass_vs");
            this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment] = this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment] || [];
            this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment].push("Gbuffer");
            this.initOthreMethods();
            //pre Phase end ---------------------------------------------------
            this.phaseEnd(animation);
        };
        return GbufferPass;
    }(egret3d.MaterialPass));
    egret3d.GbufferPass = GbufferPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.OutLinePass
    * @classdesc
    * 材质球描边特效
    * @version Egret 3.0
    * @platform Web,Native
    */
    var OutLinePass = (function (_super) {
        __extends(OutLinePass, _super);
        function OutLinePass() {
            _super.call(this, null);
            this.outline = new Float32Array(5);
            this._passID = egret3d.PassType.colorPass;
            this.outline[0] = 0.2;
            this.outline[1] = 1.0;
            this.outline[2] = 0.0;
            this.outline[3] = 0.0;
            this.outline[4] = 1.0;
        }
        Object.defineProperty(OutLinePass.prototype, "outLineColor", {
            /**
            * @language zh_CN
            * @public
            * @param  val 获取描边线框的现实颜色。
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return egret3d.Color.RGBAToColor(this.outline[1], this.outline[2], this.outline[3], this.outline[4]);
            },
            /**
            * @language zh_CN
            * @public
            * @param  val 设置描边线框的现实颜色。
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                var color = egret3d.Color.getColor(val);
                this.outline[1] = color.x;
                this.outline[2] = color.y;
                this.outline[3] = color.z;
                this.outline[4] = color.w;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OutLinePass.prototype, "outLineSize", {
            /**
            * @language zh_CN
            * @public
            * @param  size 获取描边线框的尺寸大小 从0开始的数值，可以无限大，一般在0~1之间会有意义。
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.outline[0];
            },
            /**
            * @language zh_CN
            * @public
            * @param  size 设置描边线框的尺寸大小 从0开始的数值，可以无限大，一般在0~1之间会有意义。
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (size) {
                this.outline[0] = size;
            },
            enumerable: true,
            configurable: true
        });
        /**
       * @language zh_CN
       * @private
       * 初始化 UseMethod。
       * @version Egret 3.0
       * @platform Web,Native
       */
        OutLinePass.prototype.initUseMethod = function (animation, geom) {
            var i = 0;
            this._passChange = false;
            this._passUsage = new egret3d.PassUsage();
            this._passUsage.vertexShader.shaderType = egret3d.Shader.vertex;
            this._passUsage.fragmentShader.shaderType = egret3d.Shader.fragment;
            //pre Phase ---------------------------------------------------
            if (animation) {
                // to add accept animation shader
                if (animation.skeletonAnimationController) {
                    this._passUsage.maxBone = animation.skeletonAnimationController.jointNum * 2;
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("skeleton_vs");
                }
                else if (animation.particleAnimationController) {
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex] = [];
                    this._vs_shader_methods[egret3d.ShaderPhaseType.start_vertex].push("particle_vs");
                    //to change importent
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.vertex_shaders, this._vs_shader_methods);
                    this.addShaderPhase(this._passID, animation.particleAnimationController.particleAnimationState.fragment_shaders, this._fs_shader_methods);
                }
            }
            this._vs_shader_methods[egret3d.ShaderPhaseType.global_vertex] = this._vs_shader_methods[egret3d.ShaderPhaseType.global_vertex] || [];
            this._vs_shader_methods[egret3d.ShaderPhaseType.global_vertex].push("outLine_vs");
            this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment] = this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment] || [];
            this._fs_shader_methods[egret3d.ShaderPhaseType.end_fragment].push("outLine_fs");
            this.phaseEnd(animation);
        };
        /**
        * @private
        */
        OutLinePass.prototype.upload = function (time, delay, context3DProxy, modeltransform, camera3D, animation, geometry, renderQuen) {
            _super.prototype.upload.call(this, time, delay, context3DProxy, modeltransform, camera3D, animation, geometry, renderQuen);
        };
        /**
        * @private
        */
        //public draw(time: number, delay: number, context3DProxy: Context3DProxy, modeltransform: Matrix4_4, camera3D: Camera3D, subGeometry: SubGeometry, render: IRender) {
        //    var depthTest: boolean = this._materialData.depthTest;
        //    var bothside: boolean = this._materialData.bothside;
        //    this._materialData.depthTest = false;
        //    this._materialData.bothside = true;
        //    super.draw(time, delay, context3DProxy, modeltransform, camera3D, subGeometry, render);
        //    this._materialData.depthTest = depthTest;
        //    this._materialData.bothside = bothside;
        //}
        /**
      * @private
      */
        OutLinePass.prototype.draw = function (time, delay, context3DProxy, modeltransform, camera3D, subGeometry, render, renderQuen) {
            if (!this.enable)
                return;
            if (this._passChange) {
                this.upload(time, delay, context3DProxy, modeltransform, camera3D, render.animation, subGeometry.geometry, renderQuen);
            }
            context3DProxy.setProgram(this._passUsage.program3D);
            subGeometry.activeState(time, delay, this._passUsage, context3DProxy);
            egret3d.Context3DProxy.gl.depthMask(false);
            if (this._passUsage.uniform_materialSource) {
                context3DProxy.uniform1fv(this._passUsage.uniform_materialSource.uniformIndex, this._materialData.materialSourceData);
            }
            if (this._passUsage.uniform_ModelMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_ModelMatrix.uniformIndex, false, modeltransform.rawData);
            }
            if (this._passUsage.uniform_ViewMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_ViewMatrix.uniformIndex, false, camera3D.viewMatrix.rawData);
            }
            if (this._passUsage.uniform_ProjectionMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_ProjectionMatrix.uniformIndex, false, camera3D.projectMatrix.rawData);
            }
            if (this._passUsage.uniform_ViewProjectionMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_ViewProjectionMatrix.uniformIndex, false, camera3D.viewProjectionMatrix.rawData);
            }
            if (this._passUsage.uniform_orthProjectMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_orthProjectMatrix.uniformIndex, false, camera3D.orthProjectionMatrix.rawData);
            }
            if (this._passUsage["uniform_ouline"]) {
                context3DProxy.uniform1fv(this._passUsage["uniform_ouline"].uniformIndex, this.outline);
            }
            if (render.animation) {
                render.animation.activeState(time, delay, this._passUsage, subGeometry, context3DProxy, modeltransform, camera3D);
            }
            if (this.methodList) {
                for (var i = 0; i < this.methodList.length; i++) {
                    this.methodList[i].activeState(time, delay, this._passUsage, null, context3DProxy, modeltransform, camera3D, renderQuen);
                }
            }
            if (this._passUsage.uniform_eyepos) {
                context3DProxy.uniform3f(this._passUsage.uniform_eyepos.uniformIndex, camera3D.x, camera3D.y, camera3D.z);
            }
            if (this._passUsage.uniform_cameraMatrix) {
                context3DProxy.uniformMatrix4fv(this._passUsage.uniform_cameraMatrix.uniformIndex, false, camera3D.modelMatrix.rawData);
            }
            context3DProxy.drawElement(this._materialData.drawMode, subGeometry.start, subGeometry.count);
            egret3d.Context3DProxy.gl.depthMask(true);
        };
        return OutLinePass;
    }(egret3d.MaterialPass));
    egret3d.OutLinePass = OutLinePass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var PickPass = (function (_super) {
        __extends(PickPass, _super);
        function PickPass(materialData) {
            _super.call(this, materialData);
            this._passID = egret3d.PassType.PickPass;
        }
        PickPass.prototype.initUseMethod = function (animation, geom) {
            this._passChange = false;
            var i = 0;
            this._passUsage = new egret3d.PassUsage();
            this._vs_shader_methods = {};
            this._fs_shader_methods = {};
            if (animation) {
                if (animation.skeletonAnimationController) {
                    this._passUsage.maxBone = animation.skeletonAnimationController.jointNum * 2;
                    this.addMethodShaders(this._passUsage.vertexShader, ["pickPass_skeleton_vs"]);
                }
            }
            else {
                this.addMethodShaders(this._passUsage.vertexShader, ["pickPass_vs"]);
            }
            this.addMethodShaders(this._passUsage.fragmentShader, ["pickPass_fs"]);
        };
        return PickPass;
    }(egret3d.MaterialPass));
    egret3d.PickPass = PickPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    (function (PassType) {
        PassType[PassType["diffusePass"] = 0] = "diffusePass";
        PassType[PassType["colorPass"] = 1] = "colorPass";
        PassType[PassType["normalPass"] = 2] = "normalPass";
        PassType[PassType["shadowPass"] = 3] = "shadowPass";
        PassType[PassType["lightPass"] = 4] = "lightPass";
        PassType[PassType["matCapPass"] = 5] = "matCapPass";
        PassType[PassType["depthPass_8"] = 6] = "depthPass_8";
        PassType[PassType["depthPass_32"] = 7] = "depthPass_32";
        PassType[PassType["CubePass"] = 8] = "CubePass";
        PassType[PassType["Gbuffer"] = 9] = "Gbuffer";
        PassType[PassType["PickPass"] = 10] = "PickPass";
        PassType[PassType["OutLinePass"] = 11] = "OutLinePass";
        PassType[PassType["position"] = 12] = "position";
    })(egret3d.PassType || (egret3d.PassType = {}));
    var PassType = egret3d.PassType;
    /**
    * @private
    */
    var PassUtil = (function () {
        function PassUtil() {
        }
        PassUtil.CreatPass = function (pass, materialData) {
            switch (pass) {
                case PassType.colorPass:
                    materialData.shaderPhaseTypes[PassType.colorPass] = [];
                    return [new egret3d.ColorPass(materialData)];
                case PassType.diffusePass:
                    materialData.shaderPhaseTypes[PassType.diffusePass] = [];
                    return [new egret3d.DiffusePass(materialData)];
                case PassType.shadowPass:
                    materialData.shaderPhaseTypes[PassType.shadowPass] = [];
                    return [new egret3d.ShadowPass(materialData)];
                case PassType.depthPass_8:
                    materialData.shaderPhaseTypes[PassType.depthPass_8] = [];
                    return [new egret3d.PositionPass(materialData)];
                case PassType.normalPass:
                    materialData.shaderPhaseTypes[PassType.normalPass] = [];
                    return [new egret3d.NormalPass(materialData)];
                case PassType.Gbuffer:
                    materialData.shaderPhaseTypes[PassType.Gbuffer] = [];
                    return [new egret3d.GbufferPass(materialData)];
                case PassType.PickPass:
                    materialData.shaderPhaseTypes[PassType.PickPass] = [];
                    return [new egret3d.PickPass(materialData)];
                case PassType.OutLinePass:
                    materialData.shaderPhaseTypes[PassType.OutLinePass] = [];
                    return [new egret3d.OutLinePass()];
            }
            return null;
        };
        PassUtil.PassAuto = [true, true, true, false, false, true, true, true, true, true, false, true, true];
        return PassUtil;
    }());
    egret3d.PassUtil = PassUtil;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.MaterialBase
    * @classdesc
    * 材质球共有的基础类型，封装了材质球共有的基础数据设置方法。</p>
    * 提供控制模型渲染的效果
    * 比如：
    * 默认贴图、法线贴图、高光贴图、
    * 裁剪模式、渲染方式等内容
    * 不同的渲染通道pass。</p>
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MaterialBase = (function () {
        /**
        * @language zh_CN
        * @class egret3d.MaterialBase
        * @classdesc
        * TerrainMaterial,TextureMaterial 的基类。</p>
        * 材质球共有的基础类型，封装了材质球共有的基础数据设置方法。</p>
        * 不同的渲染通道pass。</p>
        * @version Egret 3.0
        * @platform Web,Native
        */
        function MaterialBase(materialData) {
            if (materialData === void 0) { materialData = null; }
            /**
             * @language zh_CN
             * @private
             * @version Egret 3.0
             * @platform Web,Native
             */
            //public diffusePass: MaterialPass; 
            //public shadowPass: MaterialPass; 
            this.passes = {};
            if (materialData == null) {
                this.setData(new egret3d.MaterialData());
            }
            else
                this.setData(materialData);
        }
        /**
         * @language zh_CN
         * @private
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.setData = function (data) {
            this.materialData = data;
            this.initPass();
            this.blendMode = egret3d.BlendMode.NORMAL;
        };
        /**
         * @language zh_CN
         * @private
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.getData = function () {
            return this.materialData;
        };
        MaterialBase.prototype.initPass = function () {
            //this.passes[PassType.diffusePass] = new ColorPass(this.materialData);
            this.creatPass(egret3d.PassType.colorPass);
            //this.addPass(PassType.normalPass);
            //this.addPass(PassType.depthPass_8);
        };
        Object.defineProperty(MaterialBase.prototype, "lightGroup", {
            /**
             * @language zh_CN
             * 获取材质球接受的灯光组。
             * @returns LightGroup 灯光组
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._lightGroup;
            },
            /**
             * @language zh_CN
             * 设置材质 lightGroup 。
             * 设置材质球接受的灯光组。
             * @param lightGroup LightGroup
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (group) {
                this._lightGroup = group;
                if (this.passes[egret3d.PassType.diffusePass] && this.passes[egret3d.PassType.diffusePass].length > 0) {
                    for (var i = 0; i < this.passes[egret3d.PassType.diffusePass].length; i++) {
                        this.passes[egret3d.PassType.diffusePass][i].lightGroup = group;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "depth", {
            /**
            * @language zh_CN
            * 返回深度测试
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.depthTest;
            },
            /**
             * @language zh_CN
             * 设置材质 shadowMapTexture 。
             * 设置材质球的阴影贴图。
             * @param texture ITexture
             * @version Egret 3.0
             * @platform Web,Native
             */
            //public set shadowMapTexture(texture: ITexture) {
            //    if (texture) {
            //        this.materialData.shadowMapTexture = texture;
            //        this.materialData.textureChange = true;
            //        //if (this.materialData.shaderPhaseTypes.indexOf(ShaderPhaseType.shadow_fragment) == -1) {
            //        //    this.materialData.shaderPhaseTypes.push(ShaderPhaseType.shadow_fragment);
            //        //    this.diffusePass.passInvalid();
            //        //}
            //    }
            //}
            /**
            * @language zh_CN
            * 返回材质 shadowMapTexture。
            * 返回材质球的阴影贴图。
            * @returns ITexture 阴影贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public get shadowMapTexture(): ITexture {
            //    return this.materialData.shadowMapTexture;
            //}
            /**
             * @language zh_CN
             * 设置是否开启深度测试
             * @param bool 是否开启深度测试
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (bool) {
                this.materialData.depthTest = bool;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "depthWrite", {
            /**
            * @language zh_CN
            * 返回深度写入开关
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.depthWrite;
            },
            /**
            * @language zh_CN
            * 设置深度写入开关
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (v) {
                this.materialData.depthWrite = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "depthMode", {
            /**
            * @language zh_CN
            * 返回深度测试方式
            * @param texture ITexture
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.depthMode;
            },
            /**
             * @language zh_CN
             * 设置是否开启深度测试方式
             * @param v 模式
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (v) {
                this.materialData.depthMode = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "diffuseTexture", {
            /**
            * @language zh_CN
            * 返回材质 diffuseTexture。
            * 返回材质球的漫反射贴图。
            * @returns ITexture 漫反射贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.diffuseTexture;
            },
            /**
             * @language zh_CN
             * 设置材质 diffuseTexture 。
             * 设置材质球的漫反射贴图。
             * @param texture ITexture
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                if (texture) {
                    this.materialData.diffuseTexture = texture;
                    this.materialData.textureChange = true;
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass] && this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.diffuse_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].push(egret3d.ShaderPhaseType.diffuse_fragment);
                    }
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.shadowPass] && this.materialData.shaderPhaseTypes[egret3d.PassType.shadowPass].indexOf(egret3d.ShaderPhaseType.diffuse_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.shadowPass].push(egret3d.ShaderPhaseType.diffuse_fragment);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "diffuseTexture3D", {
            /**
            * @language zh_CN
            * 返回材质 diffuseTexture3D
            * @returns CubeTexture 漫反射贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData["diffuseTexture3D"];
            },
            /**
            * @language zh_CN
            * 设置材质 diffuseTexture3D
            * @param texture CubeTexutre
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                if (texture) {
                    this.materialData["diffuseTexture3D"] = texture;
                    this.materialData.textureChange = true;
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass] && this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.diffuse_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].push(egret3d.ShaderPhaseType.diffuse_fragment);
                    }
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.shadowPass] && this.materialData.shaderPhaseTypes[egret3d.PassType.shadowPass].indexOf(egret3d.ShaderPhaseType.diffuse_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.shadowPass].push(egret3d.ShaderPhaseType.diffuse_fragment);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "normalTexture", {
            /**
             * @language zh_CN
             * 得到材质球的凹凸法线贴图。
             * @returns ITexture
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.normalTexture;
            },
            /**
             * @language zh_CN
             * 设置材质 normalTexture 。
             * 设置材质球的凹凸法线贴图。
             * @param texture {TextureBase}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                if (texture) {
                    this.materialData.normalTexture = texture;
                    this.materialData.textureChange = true;
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass] && this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.normal_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].push(egret3d.ShaderPhaseType.normal_fragment);
                        this.passInvalid(egret3d.PassType.diffusePass);
                    }
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.matCapPass] && this.materialData.shaderPhaseTypes[egret3d.PassType.matCapPass].indexOf(egret3d.ShaderPhaseType.normal_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.matCapPass].push(egret3d.ShaderPhaseType.normal_fragment);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        MaterialBase.prototype.passInvalid = function (passType) {
            if (this.passes[passType] && this.passes[passType].length > 0) {
                for (var i = 0; i < this.passes[passType].length; i++) {
                    this.passes[passType][i].passInvalid();
                }
            }
        };
        Object.defineProperty(MaterialBase.prototype, "matcapTexture", {
            /**
            * @language zh_CN
            * 得到材质球特殊光效贴图。
            * @returns ITexture
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.normalTexture;
            },
            /**
              * @language zh_CN
              * 设置材质 matcapTexture 。
              * 设置材质球特殊光效算法。
              * @param texture {TextureBase}
              * @version Egret 3.0
              * @platform Web,Native
              */
            set: function (texture) {
                if (texture) {
                    this.materialData.matcapTexture = texture;
                    this.materialData.textureChange = true;
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass] && this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.matCap_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].push(egret3d.ShaderPhaseType.matCap_fragment);
                        this.passInvalid(egret3d.PassType.diffusePass);
                    }
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.matCapPass] && this.materialData.shaderPhaseTypes[egret3d.PassType.matCapPass].indexOf(egret3d.ShaderPhaseType.matCap_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.matCapPass].push(egret3d.ShaderPhaseType.matCap_fragment);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "specularTexture", {
            /**
             * @language zh_CN
             * 得到材质球的高光贴图。
             * @returns ITexture
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.specularTexture;
            },
            /**
             * @language zh_CN
             * 设置材质 specularTexture 。
             * 设置材质球的高光贴图。
             * @param texture {TextureBase}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                if (texture) {
                    this.materialData.specularTexture = texture;
                    this.materialData.textureChange = true;
                    if (this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass] && this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].indexOf(egret3d.ShaderPhaseType.specular_fragment) == -1) {
                        this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass].push(egret3d.ShaderPhaseType.specular_fragment);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "drawMode", {
            /**
            * @language zh_CN
            * 设置模型渲染模式。模型可以以顶点的方式渲染，线框渲染（会需要特定模型），三角形渲染
            * DrawMode.POINTS
            * DrawMode.LINES
            * DrawMode.TRIANGLES
            * @default DrawMode.TRIANGLES
            * @see egret3d.DrawMode
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.drawMode;
            },
            /**
            * @language zh_CN
            * 设置模型渲染模式。模型可以以顶点的方式渲染，线框渲染（会需要特定模型），三角形渲染
            * DrawMode.POINTS
            * rawMode.LINES
            * DrawMode.TRIANGLES
            * @default DrawMode.TRIANGLES
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (mode) {
                this.materialData.drawMode = mode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "cutAlpha", {
            /**
            * @language zh_CN
            * 获取模型渲染模式。模型渲染中，带透明贴图的 去除不渲染透明透明部分的阀值
            * 取值范围 0 - 1
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.cutAlpha;
            },
            /**
            * @language zh_CN
            * 设置模型渲染模式。模型渲染中，带透明贴图的 去除不渲染透明透明部分的阀值
            * 取值范围 0 - 1
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (v) {
                this.materialData.cutAlpha = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "diffuseColor", {
            /**
            * @language zh_CN
            * 获取材质 diffuseColor
            * @returns number 材质 diffuseColor
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.diffuseColor;
            },
            /**
            * @language zh_CN
            * 设置材质 diffuseColor。
            * 设置 16 进制的漫反射颜色
            * @param color {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this.materialData.materialDataNeedChange = true;
                this.materialData.diffuseColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "ambientColor", {
            /**
            * @language zh_CN
            * 获取材质 ambientColor
            * @returns number 材质 ambientColor
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.ambientColor;
            },
            /**
            * @language zh_CN
            * 设置材质 ambientColor。
            * 设置 16 进制的环境光颜色
            * @param color {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this.materialData.materialDataNeedChange = true;
                this.materialData.ambientColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "specularColor", {
            /**
            * @language zh_CN
            * 获取材质 specularColor
            * @returns number 材质 specularColor
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.specularColor;
            },
            /**
            * @language zh_CN
            * 设置材质 specularColor。
            * 设置 16 进制的镜面光反射颜色
            * @param color {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this.materialData.materialDataNeedChange = true;
                this.materialData.specularColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "tintColor", {
            /**
            * @language zh_CN
            * 获取材质 tintColor
            * @returns number 材质 tintColor
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.tintColor;
            },
            /**
            * @language zh_CN
            * 设置材质色相。
            * 设置 16 进制的色相颜色
            * @param color {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this.materialData.materialDataNeedChange = true;
                this.materialData.tintColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "alpha", {
            /**
             * @language zh_CN
             * 返回材质 alpha 值。
             * 返回 alpha 颜色
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.alpha;
            },
            /**
             * @language zh_CN
             * 设置材质 alpha 值。
             * 设置 材质球的透明度，如果透明度小于1会自动启用 alphablending
             * @param value {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                if (this.materialData.alpha != value) {
                    this.materialData.alpha = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "alphaBlending", {
            /**
             * @language zh_CN
             * 返回 alphaBlending 颜色
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.alphaBlending;
            },
            /**
           * @language zh_CN
           * 设置材质 的alphaBlending 值。
           * 设置 材质球的的alpha是否进行深度排序
           * @param value {Number}
           * @version Egret 3.0
           * @platform Web,Native
           */
            set: function (value) {
                if (this.materialData.alphaBlending != value) {
                    this.materialData.alphaBlending = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "specularLevel", {
            /**
             * @language zh_CN
             * 返回材质 specularLevel 值。
             * 返回材质 材质球的高光强度
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.specularLevel;
            },
            /**
             * @language zh_CN
             * 设置材质 specularLevel 值。
             * 设置材质球的材质球的高光强度
             * @param value {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                if (this.materialData.specularLevel != value) {
                    this.materialData.specularLevel = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "gloss", {
            /**
             * @language zh_CN
             * 返回材质球的镜面平滑程度值。
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.gloss;
            },
            /**
             * @language zh_CN
             * 设置材质 gloss 值。
             * 设置材质 镜面平滑程度值。
             * @param value {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                if (this.materialData.gloss != value) {
                    this.materialData.gloss = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "normalDir", {
            /**
    * @language zh_CN
    * 设置材质法线贴图的Y轴朝向
    * 美术的规范各不统一，轴向不一样，需要调整
    * @param value {Number}
    * @version Egret 3.0
    * @platform Web,Native
    */
            get: function () { return this.materialData.normalDir; },
            /**
            * @language zh_CN
            * 设置材质法线贴图的Y轴朝向
            * 美术的规范各不统一，轴向不一样，需要调整
            * @param value {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this.materialData.normalDir != value) {
                    this.materialData.normalDir = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "gamma", {
            /**
             * @language zh_CN
             * 返回材质的gamma值。
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.gamma;
            },
            /**
           * @language zh_CN
           * 矫正材质的gamma值。
           * 调整颜色的饱和对比度。
           * @param value {Number}
           * @version Egret 3.0
           * @platform Web,Native
           */
            set: function (value) {
                if (this.materialData.gamma != value) {
                    this.materialData.gamma = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "refraction", {
            get: function () {
                return this.materialData.refraction;
            },
            set: function (value) {
                if (this.materialData.refraction != value) {
                    this.materialData.refraction = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "refractionintensity", {
            get: function () {
                return this.materialData.refractionintensity;
            },
            set: function (value) {
                if (this.materialData.refractionintensity != value) {
                    this.materialData.refractionintensity = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "uvRectangle", {
            /**
            * @language zh_CN
            * 获取映射贴图UV坐标，区域，用uvRectangle 的方式映射
            * @returns rect Rectangle
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.uvRectangle;
            },
            /**
            * @language zh_CN
            * 映射贴图UV坐标，设置此材质要显示使用贴图的区域，用uvRectangle 的方式映射
            * @param rect Rectangle
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (rect) {
                this.materialData.uvRectangle.x = rect.x;
                this.materialData.uvRectangle.y = rect.y;
                this.materialData.uvRectangle.width = rect.width;
                this.materialData.uvRectangle.height = rect.height;
                this.materialData.materialDataNeedChange = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "diffusePass", {
            /**
             * @private
             * @language zh_CN
             * 设置材质 ambientPower 值。
             * 设置材质 环境光颜色的强度 值。
             * @param value {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.passes[egret3d.PassType.diffusePass][0];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         * 设置材质 ambientPower 值。
         * 设置材质 环境光颜色的强度 值。
         * @param value {Number}
         * @version Egret 3.0
         * @platform Web,Native
         */
        //public set ambientPower(value: number) {
        //    if (this.materialData.ambientPower != value) {
        //        this.materialData.ambientPower = value;
        //        this.materialData.materialDataNeedChange = true;
        //    }
        //}
        /**
         * @language zh_CN
         * 返回材质 ambientPower 值。
         * 返回材质 环境光颜色的强度 值。
         * @returns {Number}
         * @version Egret 3.0
         * @platform Web,Native
         */
        //public get ambientPower(): number {
        //    return this.materialData.ambientPower;
        //}
        /**
         * @language zh_CN
         * 设置材质 diffusePower 值。
         * 设置材质 漫反射颜色的强度 值。
         * @param value {Number}
         * @version Egret 3.0
         * @platform Web,Native
         */
        //public set diffusePower(value: number) {
        //    if (this.materialData.diffusePower != value) {
        //        this.materialData.diffusePower = value;
        //        this.materialData.materialDataNeedChange = true;
        //    }
        //}
        /**
         * @language zh_CN
         * 返回材质 diffusePower 值。
         * 返回材质 漫反射颜色的强度 值。
         * @returns {Number}
         * @version Egret 3.0
         * @platform Web,Native
         */
        //public get diffusePower(): number {
        //    return this.materialData.diffusePower;
        //}
        /**
         * @language zh_CN
         * 设置材质 normalPower 值。
         * 设置材质 法线的强度 值。
         * @param value {Number}
         * @version Egret 3.0
         * @platform Web,Native
         */
        //public set normalPower(value: number) {
        //    if (this.materialData.normalPower != value) {
        //        this.materialData.normalPower = value;
        //        this.materialData.materialDataNeedChange = true;
        //    }
        //}
        /**
         * @language zh_CN
         * 返回材质 normalPower 值。
         * 返回材质 法线的强度 值。
         * @returns {Number}
         * @version Egret 3.0
         * @platform Web,Native
         */
        //public get normalPower(): number {
        //    return this.materialData.normalPower;
        //}
        /** m
        * @language zh_CN
        * 引擎内部生成pass渲染通道
        * 返回材质 法线的强度 值。
        * @returns {Number}
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialBase.prototype.creatPass = function (pass) {
            this.passes[pass] = egret3d.PassUtil.CreatPass(pass, this.materialData);
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialBase.prototype.addDiffuseChilderPass = function (pass) {
            if (this.passes[egret3d.PassType.diffusePass]) {
                pass.materialData = this.materialData;
                this.passes[egret3d.PassType.diffusePass].push(pass);
            }
        };
        Object.defineProperty(MaterialBase.prototype, "castShadow", {
            /**
            * @language zh_CN
            * 使用阴影详细请看 ShadowCast
            * @see egret3d.ShadowCast
            * 返回材质 是否产生阴影 值。
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.castShadow;
            },
            /**
            * @language zh_CN
            * 使用阴影详细请看 ShadowCast
            * @see egret3d.ShadowCast
            * 设置材质 castShadow 值。
            * 设置材质是否接受阴影，设置了之后必须要给 shadowmaping 的方法。
            * @param value {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.materialData.castShadow = value;
                if (value) {
                    this.creatPass(egret3d.PassType.shadowPass);
                }
                else {
                    if (this.passes[egret3d.PassType.shadowPass]) {
                        this.disposePass(egret3d.PassType.shadowPass);
                        this.passes[egret3d.PassType.shadowPass] = null;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "castPick", {
            /**
            * @language zh_CN
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (value) {
                    egret3d.PickSystem.instance.enablePick = true;
                    this.creatPass(egret3d.PassType.PickPass);
                }
                else {
                    if (this.passes[egret3d.PassType.PickPass]) {
                        this.disposePass(egret3d.PassType.PickPass);
                        this.passes[egret3d.PassType.PickPass] = null;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "acceptShadow", {
            /**
            * @language zh_CN
            * 使用阴影详细请看 ShadowCast
            * @see egret3d.ShadowCast
            * 返回材质 acceptShadow 值。
            * 返回材质是否接受阴影，设置了之后必须要给 shadowmaping 的方法。
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.acceptShadow;
            },
            /**
            * @language zh_CN
            * 使用阴影详细请看 ShadowCast
            * @see egret3d.ShadowCast
            * 设置材质是否是否产生阴影，设置了之后必须要给 shadowmaping 的方法。
            * @param value {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this.materialData.acceptShadow == value) {
                    return;
                }
                this.materialData.acceptShadow = value;
                if (this.diffusePass)
                    this.diffusePass.addShadowMethod();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "shadowColor", {
            /**
            * @language zh_CN
            * 返回材质 阴影颜色
            * @returns number 阴影颜色
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                var color = 0;
                color |= this.materialData.shadowColor[0] * 255.0 << 16;
                color |= this.materialData.shadowColor[1] * 255.0 << 8;
                color |= this.materialData.shadowColor[2] * 255.0;
                return color;
            },
            /**
            * @language zh_CN
            * 设置 阴影颜色
            * @param color 0xffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this.materialData.shadowColor[0] = color >> 16 & 0xff / 255.0;
                this.materialData.shadowColor[1] = color >> 8 & 0xff / 255.0;
                this.materialData.shadowColor[2] = color & 0xff / 255.0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "shadowOffset", {
            /**
            * @language zh_CN
            * @private
            * 返回材质 阴影offset
            * @returns number 阴影offset
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.shadowColor[3];
            },
            /**
            * @language zh_CN
            * @private
            * 设置 阴影offset
            * @param offset
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (offset) {
                this.materialData.shadowColor[3] = offset;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "repeat", {
            /**
            * @language zh_CN
            * 返回材质 repeat 值。
            * 返回材质 是否进行纹理重复采样的方式开关。
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.repeat;
            },
            /**
             * @language zh_CN
             * 设置材质 repeat 值。
             * 设置材质 是否进行纹理重复采样的方式开关。
             * @param value {boolean}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (val) {
                this.materialData.repeat = val;
                this.materialData.textureStateChage = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "bothside", {
            /**
            * @language zh_CN
            * 返回材质 bothside 值。
            * 返回是否显示双面的开关。
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.bothside;
            },
            /**
            * @language zh_CN
            * 设置材质 bothside 值。
            * 设置材质是否显示双面的开关。
            * @param value {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                this.materialData.textureStateChage = true;
                this.materialData.bothside = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "cullMode", {
            /**
             * @language zh_CN
             * 返回 cull 模式。
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.cullFrontOrBack;
            },
            /**
            * @language zh_CN
            * 设置 cull 模式 正面渲染三角形或者背面渲染三角形。
            * @see egret3d.ContextConfig.BACK 裁剪反面进行正面渲染
            * @see egret3d.ContextConfig.FRONT 裁剪正面进行反面渲染
            * @param value {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.materialData.textureStateChage = true;
                this.materialData.cullFrontOrBack = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "blendMode", {
            /**
            * @language zh_CN
            * 设置材质 blendMode 值。
            * 设置材质球的 混合模式可以参照 blendmode 中的值
            * @see egret3d.BlendMode
            * @param value {BlendMode}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.materialData.textureStateChage = true;
                this.materialData.blendMode = value;
                switch (value) {
                    //his.materialData.blend_src = ContextConfig.SRC_ALPHA; 透明
                    //this.materialData.blend_dest = ContextConfig.SRC_COLOR;
                    case egret3d.BlendMode.NORMAL:
                        this.materialData.blend_src = egret3d.ContextConfig.ONE;
                        this.materialData.blend_dest = egret3d.ContextConfig.ONE_MINUS_SRC_ALPHA;
                        this.materialData.alphaBlending = false;
                        break;
                    case egret3d.BlendMode.LAYER:
                        this.materialData.blend_src = egret3d.ContextConfig.SRC_ALPHA;
                        this.materialData.blend_dest = egret3d.ContextConfig.ZERO;
                        this.materialData.alphaBlending = true;
                        break;
                    case egret3d.BlendMode.MULTIPLY:
                        this.materialData.blend_src = egret3d.ContextConfig.ZERO;
                        this.materialData.blend_dest = egret3d.ContextConfig.SRC_COLOR;
                        this.materialData.alphaBlending = true;
                        break;
                    case egret3d.BlendMode.ADD:
                        this.materialData.blend_src = egret3d.ContextConfig.SRC_ALPHA;
                        this.materialData.blend_dest = egret3d.ContextConfig.ONE;
                        this.materialData.alphaBlending = true;
                        break;
                    case egret3d.BlendMode.SOFT_ADD:
                        this.materialData.blend_src = egret3d.ContextConfig.SRC_COLOR;
                        this.materialData.blend_dest = egret3d.ContextConfig.ONE;
                        this.materialData.alphaBlending = true;
                        break;
                    case egret3d.BlendMode.ALPHA:
                        this.materialData.blend_src = egret3d.ContextConfig.ONE;
                        this.materialData.blend_dest = egret3d.ContextConfig.ONE_MINUS_SRC_ALPHA;
                        this.materialData.alphaBlending = true;
                        break;
                    case egret3d.BlendMode.SCREEN:
                        this.materialData.blend_src = egret3d.ContextConfig.ONE;
                        this.materialData.blend_dest = egret3d.ContextConfig.ONE_MINUS_SRC_COLOR;
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "pointSize", {
            /**
            * @language zh_CN
            * 获取点的大小
            * @returns number  点的大小
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.specularLevel;
            },
            /**
            * @language zh_CN
            * 设置点的大小
            * 只有 DrawMode.POINTS 渲染模式才能有作用
            * @param value  点的大小
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (value == this.materialData.specularLevel) {
                    return;
                }
                this.materialData.specularLevel = value;
                this.materialData.textureStateChage = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialBase.prototype.disposePass = function (passType) {
            for (var i = 0; i < this.passes[passType].length; i++) {
                this.passes[passType][i].dispose();
            }
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        //public renderDiffusePass(time: number, delay: number, matID: number , context3DProxy: Context3DProxy, modeltransform: Matrix4_4, camera3D: Camera3D, subGeometry: SubGeometry, animtion: IAnimation) {
        //    this.diffusePass.draw(time, delay, context3DProxy, modeltransform, camera3D, subGeometry, animtion);
        //}
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderXRayPass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderOutlinePass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderNormalPass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderDepthPass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderPositionPass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderUVPass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderScendUVPass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderVertexColorPass = function () {
        };
        /**
         * @language zh_CN
         * @private
         * @param value {BlendMode}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.renderLightingPass = function () {
        };
        /**
        * @private
        * @language zh_CN
        * 释放接口
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialBase.prototype.dispose = function () {
            for (var key in this.passes) {
                for (var i = 0; i < this.passes[key].length; ++i) {
                    this.passes[key][i].dispose();
                }
            }
        };
        return MaterialBase;
    }());
    egret3d.MaterialBase = MaterialBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ColorMaterial = (function (_super) {
        __extends(ColorMaterial, _super);
        function ColorMaterial(color) {
            if (color === void 0) { color = 0xcccccc; }
            _super.call(this);
            this.color = color;
            this.diffuseTexture = egret3d.CheckerboardTexture.texture;
            this.initMatPass();
        }
        ColorMaterial.prototype.initMatPass = function () {
            this.creatPass(egret3d.PassType.diffusePass);
            this.diffusePass.addMethod(new egret3d.ColorMethod());
        };
        Object.defineProperty(ColorMaterial.prototype, "color", {
            get: function () {
                return this.materialData.diffuseColor;
            },
            set: function (value) {
                this.materialData.diffuseColor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorMaterial.prototype, "alpha", {
            get: function () {
                return this.materialData.alpha;
            },
            set: function (value) {
                this.materialData.alpha = value;
            },
            enumerable: true,
            configurable: true
        });
        return ColorMaterial;
    }(egret3d.MaterialBase));
    egret3d.ColorMaterial = ColorMaterial;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.TextureMaterial
    * @classdesc
    * 纹理材质。
    * 标准的贴图材质球，可以设置三种贴图， diffuse ， normal ， speclar 贴图
    * 材质球中默认不设置纹理，显示的黑白棋盘格
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TextureMaterial = (function (_super) {
        __extends(TextureMaterial, _super);
        /**
        * @language zh_CN
        * 创建一个新的 TextureMaterial 对象。
        * @param texture 用来渲染的贴图，默认会给出一张棋盘格贴图
        * @param materialData 材质数据信息，可以不指定
        * @version Egret 3.0
        * @platform Web,Native
        */
        function TextureMaterial(texture, materialData) {
            if (texture === void 0) { texture = null; }
            if (materialData === void 0) { materialData = null; }
            _super.call(this, materialData);
            if (!texture) {
                this.diffuseTexture = egret3d.CheckerboardTexture.texture;
            }
            else {
                this.diffuseTexture = texture;
            }
            this.initMatPass();
        }
        TextureMaterial.prototype.initMatPass = function () {
            this.creatPass(egret3d.PassType.diffusePass);
        };
        /**
         * @language zh_CN
         * 克隆方法。
         * 将材质球克隆一份，公用shader着色器和贴图，不公用参数
         * @returns {TextureMaterial}
         * @version Egret 3.0
         * @platform Web,Native
         */
        TextureMaterial.prototype.clone = function () {
            var mat = new TextureMaterial(this.diffuseTexture, this.materialData.clone());
            return mat;
        };
        return TextureMaterial;
    }(egret3d.MaterialBase));
    egret3d.TextureMaterial = TextureMaterial;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.TextureMaterial
    * @classdesc
    * 纹理材质。
    * 标准的贴图材质球，可以设置三种贴图， diffuse ， normal ， speclar 贴图
    * 材质球中默认不设置纹理，显示的黑白棋盘格
    * @version Egret 3.0
    * @platform Web,Native
    */
    var FakePBRMaterial = (function (_super) {
        __extends(FakePBRMaterial, _super);
        /**
         * @language zh_CN
         * 创建一个新的 TextureMaterial 对象。
         * @param texture 用来渲染的贴图，默认会给出一张棋盘格贴图
         * @param materialData 材质数据信息，可以不指定
         * @version Egret 3.0
         * @platform Web,Native
         */
        function FakePBRMaterial(texture, materialData) {
            if (texture === void 0) { texture = null; }
            if (materialData === void 0) { materialData = null; }
            _super.call(this, materialData);
            if (!texture) {
                this.diffuseTexture = egret3d.CheckerboardTexture.texture;
            }
            else {
                this.diffuseTexture = texture;
            }
            this.initMatPass();
        }
        FakePBRMaterial.prototype.initMatPass = function () {
            //this.addPass(PassType.diffusePass);
            this._fakePBR = new egret3d.FakePBRPass(this.materialData);
            this.materialData.shaderPhaseTypes[egret3d.PassType.diffusePass] = [];
            this.passes[egret3d.PassType.diffusePass] = [this._fakePBR];
        };
        Object.defineProperty(FakePBRMaterial.prototype, "albedoTexture", {
            /**
            * @language zh_CN
            * 设置albedo贴图
            * @param tex 指定的贴图对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (tex) {
                this._fakePBR.setTexture("albedoTex", tex);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FakePBRMaterial.prototype, "normalTexture", {
            /**
            * @language zh_CN
            * 设置normal贴图
            * @param tex 指定的贴图对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (tex) {
                this._fakePBR.setTexture("normalTex", tex);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FakePBRMaterial.prototype, "glossTexture", {
            /**
            * @language zh_CN
            * 设置gloss贴图
            * @param tex 指定的贴图对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (tex) {
                this._fakePBR.setTexture("glossTex", tex);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FakePBRMaterial.prototype, "specularTexture", {
            /**
            * @language zh_CN
            * 设置specular贴图
            * @param tex 指定的贴图对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (tex) {
                this._fakePBR.setTexture("specularTex", tex);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FakePBRMaterial.prototype, "opacityTexture", {
            /**
            * @language zh_CN
            * 设置opacity贴图
            * @param tex 指定的贴图对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (tex) {
                this._fakePBR.setTexture("opacityTex ", tex);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FakePBRMaterial.prototype, "reflectionTexture", {
            /**
            * @language zh_CN
            * 设置reflection贴图
            * @param tex 指定的贴图对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (tex) {
                this._fakePBR.setTexture("reflectionMap", tex);
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 克隆方法。
        * 将材质球克隆一份，公用shader着色器和贴图，不公用参数
        * @returns {TextureMaterial}
        * @version Egret 3.0
        * @platform Web,Native
        */
        FakePBRMaterial.prototype.clone = function () {
            var mat = new egret3d.TextureMaterial(this.diffuseTexture, this.materialData.clone());
            return mat;
        };
        return FakePBRMaterial;
    }(egret3d.MaterialBase));
    egret3d.FakePBRMaterial = FakePBRMaterial;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.CubeTextureMaterial
    * @classdesc
    * cube纹理材质。
    * 6张无缝连接的贴图，使一个cube的6个面贴上不同的贴图。
    *
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CubeTextureMaterial = (function (_super) {
        __extends(CubeTextureMaterial, _super);
        /**
         * @language zh_CN
         * 创建一个新的 CubeTextureMaterial 对象。
         * @param texture {CubeTexture}
         * @param materialData {MaterialData}
         * @version Egret 3.0
         * @platform Web,Native
         */
        function CubeTextureMaterial(texture, materialData) {
            if (texture === void 0) { texture = null; }
            if (materialData === void 0) { materialData = null; }
            _super.call(this, materialData);
            this.initMatPass();
            if (!texture) {
                texture = egret3d.CubeTexture.createCubeTextureByImageTexture(egret3d.CheckerboardTexture.texture, egret3d.CheckerboardTexture.texture, egret3d.CheckerboardTexture.texture, egret3d.CheckerboardTexture.texture, egret3d.CheckerboardTexture.texture, egret3d.CheckerboardTexture.texture);
            }
            this.materialData["diffuseTexture3D"] = texture;
        }
        CubeTextureMaterial.prototype.initMatPass = function () {
            this.creatPass(egret3d.PassType.diffusePass);
            this.diffusePass.addMethod(new egret3d.CubeMethod());
        };
        /**
         * @language zh_CN
         * 克隆方法。
         * 将材质球克隆一份，公用shader着色器和贴图，不公用参数
         * @returns {TextureMaterial}
         * @version Egret 3.0
         * @platform Web,Native
         */
        CubeTextureMaterial.prototype.clone = function () {
            var mat = new CubeTextureMaterial(this.diffuseTexture, this.materialData.clone());
            return mat;
        };
        return CubeTextureMaterial;
    }(egret3d.MaterialBase));
    egret3d.CubeTextureMaterial = CubeTextureMaterial;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.RenderBase
    * @classdesc
    * 渲染器基类
    */
    var RenderBase = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function RenderBase() {
            /**
            * @language zh_CN
            * 渲染器名字
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.name = "default";
            /**
            * @language zh_CN
            * 是否启用当前渲染器，善用当前开关，可以优化渲染性能
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.enabled = true;
            /**
            * @language zh_CN
            * 渲染器使用的相机
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.viewPort = new egret3d.Rectangle();
        }
        Object.defineProperty(RenderBase.prototype, "pass", {
            /**
            * @public
            * @language zh_CN
            * 渲染器渲染的通道名
            * @classdesc
            */
            get: function () {
                return this._pass;
            },
            /**
            * @public
            * @language zh_CN
            * 渲染器渲染的通道名
            * @classdesc
            */
            set: function (value) {
                this._pass = value;
            },
            enumerable: true,
            configurable: true
        });
        RenderBase.prototype.setRenderToTexture = function (width, height, format) {
            if (format === void 0) { format = egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB; }
            if (this.renderTexture)
                this.renderTexture.dispose();
            this.renderTexture = new egret3d.RenderTexture(width, height, format);
        };
        /**
        * @language zh_CN
        * 每帧渲染
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @param context3D 设备上下文
        * @param collect 渲染对象收集器
        * @param camera 渲染时的相机
        */
        RenderBase.prototype.draw = function (time, delay, context3D, collect, backViewPort, renderQuen, posList) {
            if (posList === void 0) { posList = null; }
        };
        return RenderBase;
    }());
    egret3d.RenderBase = RenderBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.MultiRender
    * @classdesc
    * default render
    * 把所有需要渲染的对象，依次进行渲染
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MultiRender = (function (_super) {
        __extends(MultiRender, _super);
        /**
        * @language zh_CN
        * constructor
        */
        function MultiRender(pass) {
            if (pass === void 0) { pass = egret3d.PassType.diffusePass; }
            _super.call(this);
            this.pass = pass;
            //this.setRenderToTexture(1024, 1024, FrameBufferFormat.UNSIGNED_BYTE_RGB);
        }
        /**
        * @language zh_CN
        * 把所有需要渲染的对象，依次进行渲染
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @param context3D 设备上下文
        * @param collect 渲染对象收集器
        * @param camera 渲染时的相机
        */
        MultiRender.prototype.draw = function (time, delay, context3D, collect, backViewPort, renderQuen, posList) {
            if (posList === void 0) { posList = null; }
            if (this.renderTexture) {
                this.renderTexture.upload(context3D);
                this.renderTexture.useMipmap = false;
                context3D.setRenderToTexture(this.renderTexture.texture2D, true, true, 0);
                this.viewPort.setTo(0, 0, this.renderTexture.texture2D.width, this.renderTexture.texture2D.height);
            }
            else {
                this.viewPort.copyFrom(backViewPort);
            }
            for (var index = 0, len = collect.renderList.length; index < len; index++) {
                var renderItem = collect.renderList[index];
                renderItem.geometry.activeState(time, delay, egret3d.Egret3DCanvas.context3DProxy, this.camera);
                for (var i = 0; i < renderItem.geometry.subGeometrys.length; i++) {
                    var subGeometry = renderItem.geometry.subGeometrys[i];
                    var matID = subGeometry.matID;
                    var material = renderItem.multiMaterial[matID];
                    if (material == null) {
                        continue;
                    }
                    if (material.passes[this._pass] || egret3d.PassUtil.PassAuto[this._pass]) {
                        if (!material.passes[this._pass]) {
                            material.creatPass(this._pass);
                        }
                        for (var j = material.passes[this._pass].length - 1; j >= 0; j--) {
                            material.passes[this._pass][j].draw(time, delay, context3D, renderItem.modelMatrix, this.camera, subGeometry, renderItem, renderQuen);
                        }
                    }
                }
            }
            if (this.renderTexture) {
                this.viewPort.copyFrom(backViewPort);
                context3D.setRenderToBackBuffer();
                context3D.viewPort(this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height);
                context3D.setScissorRectangle(this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height);
            }
        };
        return MultiRender;
    }(egret3d.RenderBase));
    egret3d.MultiRender = MultiRender;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var RenderQuen = (function () {
        function RenderQuen() {
            this.renderDictionary = [];
            this.renderArray = [];
            var defaultRender = new egret3d.MultiRender(egret3d.PassType.diffusePass);
            this.setMainRender(defaultRender);
        }
        RenderQuen.prototype.setMainRender = function (render) {
            this.mainRender = render;
        };
        RenderQuen.prototype.addRender = function (render, index) {
            if (index === void 0) { index = -1; }
            var index = this.renderArray.indexOf(render);
            this.renderDictionary[render.name] = render;
            if (index == -1) {
                if (index == -1) {
                    this.renderArray.push(render);
                }
                else {
                    this.renderArray.splice(index, -1, render);
                }
            }
        };
        RenderQuen.prototype.removeRender = function (render) {
            var index = this.renderArray.indexOf(render);
            if (this.renderDictionary[render.name])
                delete this.renderDictionary[render.name];
            if (index != -1) {
                this.renderArray.splice(index, 1, render);
            }
        };
        RenderQuen.prototype.draw = function (time, delay, context3D, collect, backViewPort, posList) {
            if (posList === void 0) { posList = null; }
            var i;
            for (i = 0; i < this.renderArray.length; i++) {
                if (this.renderArray[i].enabled) {
                    this.renderArray[i].draw(time, delay, context3D, collect, backViewPort, this, posList);
                }
            }
            if (this.mainRender) {
                this.mainRender.draw(time, delay, context3D, collect, backViewPort, this, posList);
            }
        };
        return RenderQuen;
    }());
    egret3d.RenderQuen = RenderQuen;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var PostRender = (function (_super) {
        __extends(PostRender, _super);
        function PostRender(vs, fs) {
            _super.call(this);
            this.hud = new egret3d.HUD();
            this.needClean = false;
            this.hud.vsShader = vs;
            this.hud.fsShader = fs;
        }
        PostRender.prototype.setRenderToTexture = function (width, height, format) {
            if (format === void 0) { format = egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB; }
            this.renderTexture = new egret3d.RenderTexture(width, height, format);
        };
        PostRender.prototype.draw = function (time, delay, context3D, collect, backViewPort, posList) {
            var len = collect.renderList.length;
            if (this.renderTexture) {
                this.renderTexture.upload(context3D);
                context3D.setRenderToTexture(this.renderTexture.texture2D, this.needClean, true, 0);
            }
            //--------render container--------------
            this.hud.viewPort = this.camera.viewPort;
            this.hud.x = this.camera.viewPort.x;
            this.hud.y = this.camera.viewPort.y;
            this.hud.width = this.camera.viewPort.width;
            this.hud.height = this.camera.viewPort.height;
            this.hud.diffuseTexture = posList["final"];
            this.hud["colorTexture"] = posList["source"];
            this.hud.draw(context3D, this.camera);
            //--------------------------------------
            if (this.renderTexture)
                context3D.setRenderToBackBuffer();
            if (backViewPort) {
                context3D.viewPort(backViewPort.x, backViewPort.y, backViewPort.width, backViewPort.height);
                context3D.setScissorRectangle(backViewPort.x, backViewPort.y, backViewPort.width, backViewPort.height);
            }
        };
        return PostRender;
    }(egret3d.RenderBase));
    egret3d.PostRender = PostRender;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    (function (ValueType) {
        ValueType[ValueType["float"] = 0] = "float";
        ValueType[ValueType["vec2"] = 1] = "vec2";
        ValueType[ValueType["vec3"] = 2] = "vec3";
        ValueType[ValueType["vec4"] = 3] = "vec4";
    })(egret3d.ValueType || (egret3d.ValueType = {}));
    var ValueType = egret3d.ValueType;
    /**
    * @private
    */
    var ValueShape = (function () {
        function ValueShape() {
        }
        ValueShape.prototype.calculate = function (num, valueShape) {
            if (valueShape === void 0) { valueShape = null; }
            new Error("asd");
            return null;
        };
        ValueShape.prototype.dispose = function () {
        };
        return ValueShape;
    }());
    egret3d.ValueShape = ValueShape;
    /**
    * @private
    */
    var ConstValueShape = (function (_super) {
        __extends(ConstValueShape, _super);
        function ConstValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.float;
            this.value = 5;
        }
        ConstValueShape.prototype.calculate = function (num) {
            var values = [];
            for (var i = 0; i < num; i++) {
                values.push(this.value);
            }
            return values;
        };
        return ConstValueShape;
    }(ValueShape));
    egret3d.ConstValueShape = ConstValueShape;
    /**
    * @private
    */
    var ConstRandomValueShape = (function (_super) {
        __extends(ConstRandomValueShape, _super);
        function ConstRandomValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.float;
            this.min = 0;
            this.max = 100;
        }
        ConstRandomValueShape.prototype.calculate = function (num) {
            var values = [];
            for (var i = 0; i < num; i++) {
                values.push(this.min + Math.random() * (this.max - this.min));
            }
            return values;
        };
        return ConstRandomValueShape;
    }(ValueShape));
    egret3d.ConstRandomValueShape = ConstRandomValueShape;
    /**
    * @private
    */
    var Vec2ConstValueShape = (function (_super) {
        __extends(Vec2ConstValueShape, _super);
        function Vec2ConstValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec2;
            this.minX = 0;
            this.minY = 0;
        }
        Vec2ConstValueShape.prototype.calculate = function (num) {
            var values = [];
            for (var i = 0; i < num; i++) {
                var p = new egret3d.Point();
                p.x = this.minX;
                p.y = this.minY;
                values.push(p);
            }
            return values;
        };
        return Vec2ConstValueShape;
    }(ValueShape));
    egret3d.Vec2ConstValueShape = Vec2ConstValueShape;
    /**
    * @private
    */
    var Vec2ConstRandomValueShape = (function (_super) {
        __extends(Vec2ConstRandomValueShape, _super);
        function Vec2ConstRandomValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec2;
            this.minX = 0;
            this.minY = 0;
            this.maxX = 100;
            this.maxY = 100;
        }
        Vec2ConstRandomValueShape.prototype.calculate = function (num) {
            var values = [];
            for (var i = 0; i < num; i++) {
                var p = new egret3d.Point();
                p.x = this.minX + Math.random() * (this.maxX - this.minX);
                p.y = this.minY + Math.random() * (this.maxY - this.minY);
                values.push(p);
            }
            return values;
        };
        return Vec2ConstRandomValueShape;
    }(ValueShape));
    egret3d.Vec2ConstRandomValueShape = Vec2ConstRandomValueShape;
    /**
    * @private
    */
    var Vec3ConstValueShape = (function (_super) {
        __extends(Vec3ConstValueShape, _super);
        function Vec3ConstValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.minX = 0;
            this.minY = 0;
            this.minZ = 0;
        }
        Vec3ConstValueShape.prototype.calculate = function (num) {
            var values = [];
            for (var i = 0; i < num; i++) {
                var p = new egret3d.Vector3D();
                p.x = this.minX;
                p.y = this.minY;
                p.z = this.minZ;
                values.push(p);
            }
            return values;
        };
        return Vec3ConstValueShape;
    }(ValueShape));
    egret3d.Vec3ConstValueShape = Vec3ConstValueShape;
    /**
    * @private
    */
    var Vec3ConstRandomValueShape = (function (_super) {
        __extends(Vec3ConstRandomValueShape, _super);
        function Vec3ConstRandomValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.minX = -50;
            this.minY = -50;
            this.minZ = -50;
            this.maxX = 50;
            this.maxY = 50;
            this.maxZ = 50;
        }
        Vec3ConstRandomValueShape.prototype.calculate = function (num) {
            var values = [];
            for (var i = 0; i < num; i++) {
                var p = new egret3d.Vector3D();
                p.x = this.minX + Math.random() * (this.maxX - this.minX);
                p.y = this.minY + Math.random() * (this.maxY - this.minY);
                p.z = this.minZ + Math.random() * (this.maxZ - this.minZ);
                values.push(p);
            }
            return values;
        };
        return Vec3ConstRandomValueShape;
    }(ValueShape));
    egret3d.Vec3ConstRandomValueShape = Vec3ConstRandomValueShape;
    /**
    * @private
    */
    var CubeVector3DValueShape = (function (_super) {
        __extends(CubeVector3DValueShape, _super);
        function CubeVector3DValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.width = 100;
            this.height = 100;
            this.depth = 100;
        }
        /**
        * @language zh_CN
        * @param num
        * @param parameters [width, height, depth]
        * @returns Vector3D[]
        */
        CubeVector3DValueShape.prototype.calculate = function (num) {
            var values = [];
            var val;
            for (var i = 0; i < num; i++) {
                val = new egret3d.Vector3D();
                val.x = Math.random() * this.width - (this.width * 0.5);
                val.y = Math.random() * this.height - (this.height * 0.5);
                val.z = Math.random() * this.depth - (this.depth * 0.5);
                values.push(val);
            }
            return values;
        };
        return CubeVector3DValueShape;
    }(ValueShape));
    egret3d.CubeVector3DValueShape = CubeVector3DValueShape;
    /**
    * @private
    */
    var PlaneValueShape = (function (_super) {
        __extends(PlaneValueShape, _super);
        function PlaneValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.width = 100;
            this.height = 100;
        }
        PlaneValueShape.prototype.calculate = function (num) {
            var values = [];
            var pos;
            for (var i = 0; i < num; i++) {
                pos = new egret3d.Vector3D();
                pos.x = Math.random() * this.width - (this.width * 0.5);
                pos.y = 0;
                pos.z = Math.random() * this.height - (this.height * 0.5);
                values.push(pos);
            }
            return values;
        };
        return PlaneValueShape;
    }(ValueShape));
    egret3d.PlaneValueShape = PlaneValueShape;
    /**
    * @private
    * 圆锥体
    */
    var ConeValueShape = (function (_super) {
        __extends(ConeValueShape, _super);
        function ConeValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.radius = 20;
            this.angle = 20;
            this.length = 20;
            this.coneType = egret3d.ParticleConeShapeType.Volume;
        }
        ConeValueShape.prototype.dispose = function () {
            if (this.directions) {
                this.directions.length = 0;
            }
            this.origPoint = null;
            this.directions = null;
        };
        ConeValueShape.prototype.calculate = function (count) {
            if (this.angle > 90) {
                this.angle = 90;
            }
            if (this.radius <= 0) {
                this.radius = 0.01;
            }
            if (this.angle == 90) {
                this.origPoint = new egret3d.Vector3D();
            }
            else if (this.angle == 0) {
                this.origPoint = null;
            }
            else {
                this.origPoint = new egret3d.Vector3D();
                this.origPoint.z = -this.radius / Math.tan(this.angle * Math.PI / 180);
            }
            var values;
            this.directions = [];
            if (this.coneType == egret3d.ParticleConeShapeType.Volume) {
                if (this.angle == 90) {
                    values = this.calculateBase(count);
                }
                else {
                    values = this.calculateVolume(count);
                }
            }
            else if (this.coneType == egret3d.ParticleConeShapeType.VolumeShell) {
                if (this.angle == 90) {
                    values = this.calculateBaseShell(count);
                }
                else {
                    values = this.calculateVolumeShell(count);
                }
            }
            else if (this.coneType == egret3d.ParticleConeShapeType.Base) {
                values = this.calculateBase(count);
            }
            else if (this.coneType == egret3d.ParticleConeShapeType.BaseShell) {
                values = this.calculateBaseShell(count);
            }
            return values;
        };
        //在底部圆的内部随机一个位置
        ConeValueShape.prototype.calculateBase = function (count) {
            var pos;
            var dir;
            var values = [];
            var tempAngle;
            var targetRadius;
            for (var i = 0; i < count; i++) {
                tempAngle = Math.random() * Math.PI * 2;
                pos = new egret3d.Vector3D();
                pos.z = 0;
                targetRadius = Math.random() * this.radius;
                pos.x = Math.sin(tempAngle) * targetRadius;
                pos.y = Math.cos(tempAngle) * targetRadius;
                if (this.origPoint) {
                    dir = pos.subtract(this.origPoint);
                    dir.normalize();
                }
                else {
                    dir = new egret3d.Vector3D(0, 0, 1);
                }
                values.push(pos);
                this.directions.push(dir);
            }
            return values;
        };
        //在底部圆的周围随机一个位置
        ConeValueShape.prototype.calculateBaseShell = function (count) {
            var pos;
            var dir;
            var values = [];
            var tempAngle;
            var targetRadius;
            for (var i = 0; i < count; i++) {
                tempAngle = Math.random() * Math.PI * 2;
                pos = new egret3d.Vector3D();
                pos.z = 0;
                targetRadius = this.radius;
                pos.x = Math.sin(tempAngle) * targetRadius;
                pos.y = Math.cos(tempAngle) * targetRadius;
                if (this.origPoint) {
                    dir = pos.subtract(this.origPoint);
                    dir.normalize();
                }
                else {
                    dir = new egret3d.Vector3D(0, 0, 1);
                }
                values.push(pos);
                this.directions.push(dir);
            }
            return values;
        };
        //在圆锥体内随机一个位置
        ConeValueShape.prototype.calculateVolume = function (count) {
            var pos;
            var dir;
            var values = [];
            var tempAngle;
            var targetRadius;
            for (var i = 0; i < count; i++) {
                tempAngle = Math.random() * Math.PI * 2;
                pos = new egret3d.Vector3D();
                pos.z = this.length * Math.random();
                targetRadius = this.radius * Math.random();
                if (this.origPoint) {
                    targetRadius *= (pos.z - this.origPoint.z) / (-this.origPoint.z);
                }
                pos.x = Math.sin(tempAngle) * targetRadius;
                pos.y = Math.cos(tempAngle) * targetRadius;
                if (this.origPoint) {
                    dir = pos.subtract(this.origPoint);
                    dir.normalize();
                }
                else {
                    dir = new egret3d.Vector3D(0, 0, 1);
                }
                values.push(pos);
                this.directions.push(dir);
            }
            return values;
        };
        //在圆锥体圆筒壳随机一个位置
        ConeValueShape.prototype.calculateVolumeShell = function (count) {
            var pos;
            var dir;
            var values = [];
            var tempAngle;
            var targetRadius;
            for (var i = 0; i < count; i++) {
                tempAngle = Math.random() * Math.PI * 2;
                pos = new egret3d.Vector3D();
                pos.z = this.length * Math.random();
                targetRadius = this.radius;
                if (this.origPoint) {
                    targetRadius *= (pos.z - this.origPoint.z) / (-this.origPoint.z);
                }
                pos.x = Math.sin(tempAngle) * targetRadius;
                pos.y = Math.cos(tempAngle) * targetRadius;
                if (this.origPoint) {
                    dir = pos.subtract(this.origPoint);
                    dir.normalize();
                }
                else {
                    dir = new egret3d.Vector3D(0, 0, 1);
                }
                values.push(pos);
                this.directions.push(dir);
            }
            return values;
        };
        //在圆锥体的顶部随机一个位置
        ConeValueShape.prototype.randomPosAtTop = function () {
            var pos = ConeValueShape.randomPosTop;
            var values = [];
            var tempAngle;
            var targetRadius;
            tempAngle = Math.random() * Math.PI * 2;
            pos.z = this.length;
            if (this.origPoint) {
                targetRadius = this.radius * Math.random();
                targetRadius *= (pos.z - this.origPoint.z) / (-this.origPoint.z);
                pos.x = Math.sin(tempAngle) * targetRadius;
                pos.y = Math.cos(tempAngle) * targetRadius;
                pos.decrementBy(this.origPoint);
            }
            else {
                pos.x = pos.y = 0;
            }
        };
        /*
        * @private 获取一个随机方向
        */
        ConeValueShape.prototype.randomDirectionToTop = function (result) {
            this.randomPosAtTop();
            result.copyFrom(ConeValueShape.randomPosTop);
            result.normalize();
        };
        ConeValueShape.randomPosTop = new egret3d.Vector3D();
        return ConeValueShape;
    }(ValueShape));
    egret3d.ConeValueShape = ConeValueShape;
    /**
    * @private
    * 线性分布
    */
    var LineValueShape = (function (_super) {
        __extends(LineValueShape, _super);
        function LineValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.points = [new egret3d.Vector3D(), new egret3d.Vector3D(100, 0, 0), new egret3d.Vector3D(100, 200, 0)];
        }
        LineValueShape.prototype.calculate = function (num) {
            if (this.points.length == 1)
                return this.points;
            var values = [];
            var pos;
            var numLen = 0;
            var segment = 0;
            for (var i = 1; i < this.points.length; i++) {
                numLen += egret3d.Vector3D.distance(this.points[i - 1], this.points[i]);
            }
            segment = numLen / num;
            var ntmp = new egret3d.Vector3D();
            var sourceD = 0;
            var nD = 0;
            var len = 0;
            for (var i = 1; i < this.points.length; i++) {
                ntmp.x = this.points[i].x - this.points[i - 1].x;
                ntmp.y = this.points[i].y - this.points[i - 1].y;
                ntmp.z = this.points[i].z - this.points[i - 1].z;
                ntmp.normalize();
                ntmp.scaleBy(segment + len);
                sourceD = egret3d.Vector3D.distance(this.points[i - 1], this.points[i]);
                nD = egret3d.Vector3D.distance(ntmp, this.points[i]);
                if (nD > sourceD) {
                    len += nD;
                }
            }
            return values;
        };
        return LineValueShape;
    }(ValueShape));
    /**
    * @private
    * 球内分布
    */
    var BallValueShape = (function (_super) {
        __extends(BallValueShape, _super);
        function BallValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.r = 10;
            this.fromShell = false;
        }
        //parameters = [R]
        BallValueShape.prototype.calculate = function (num) {
            var values = [];
            values = this.getPoints1(num, this.r);
            return values;
        };
        BallValueShape.prototype.getPoints1 = function (num, r) {
            var values = [];
            var x;
            var y;
            var z;
            var pos;
            var radio = new egret3d.Vector3D(0, 0, 0);
            for (var i = 0; i < num; i++) {
                x = Math.random() * 2 * r - r;
                y = Math.random() * 2 * r - r;
                z = Math.random() * 2 * r - r;
                pos = new egret3d.Vector3D(x, y, z);
                //表面发射
                if (this.fromShell) {
                    pos.normalize(this.r);
                }
                if (egret3d.Vector3D.distance(radio, pos) > r) {
                    i--;
                }
                else {
                    values.push(pos);
                }
            }
            return values;
        };
        return BallValueShape;
    }(ValueShape));
    egret3d.BallValueShape = BallValueShape;
    /**
    * @private
    * 半球内分布
    */
    var HemiBallValueShape = (function (_super) {
        __extends(HemiBallValueShape, _super);
        function HemiBallValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.r = 10;
            this.fromShell = false;
        }
        //parameters = [R]
        HemiBallValueShape.prototype.calculate = function (num) {
            var values = [];
            values = this.getPoints(num, this.r);
            return values;
        };
        HemiBallValueShape.prototype.getPoints = function (num, r) {
            var values = [];
            var x;
            var y;
            var z;
            var pos;
            var radio = new egret3d.Vector3D(0, 0, 0);
            for (var i = 0; i < num; i++) {
                x = Math.random() * 2 * r - r;
                y = Math.random() * 2 * r - r;
                z = Math.abs(Math.random() * 2 * r - r);
                pos = new egret3d.Vector3D(x, y, z);
                //表面发射
                if (this.fromShell) {
                    pos.normalize(this.r);
                }
                if (egret3d.Vector3D.distance(radio, pos) > r) {
                    i--;
                }
                else {
                    values.push(pos);
                }
            }
            return values;
        };
        return HemiBallValueShape;
    }(ValueShape));
    egret3d.HemiBallValueShape = HemiBallValueShape;
    /**
    * @private
    * 平面圆
    */
    var CircleValueShape = (function (_super) {
        __extends(CircleValueShape, _super);
        function CircleValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
        }
        CircleValueShape.prototype.calculate = function (num) {
            var parameters = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                parameters[_i - 1] = arguments[_i];
            }
            var values;
            var tmpPar = parameters[0];
            var r = tmpPar[0];
            //var time: number = new Date().getTime();
            values = this.createRandomPoint1(num, r); //createRandomPoint1 比 createRandomPoint2 大部分情况下快了15% - 25%, 少数情况下略高于createRandomPoint2
            //console.log('createRandomPoint1 cost time: ', new Date().getTime() - time);
            //time = new Date().getTime();
            //this.createRandomPoint2(num, r);
            //console.log('createRandomPoint2 cost time: ', new Date().getTime() - time);
            return values;
        };
        //非稳定算法.但是因为没有三角函数和开平方的计算.反而在大部分情况下效率会更高
        CircleValueShape.prototype.createRandomPoint1 = function (num, r) {
            var values = [];
            var d = r * 2;
            for (var i = 0; i < num; i++) {
                var x = Math.random() * d - r;
                var z = Math.random() * d - r;
                if ((x * x + z * z) > (r * r)) {
                    i--;
                }
                else {
                    values.push(new egret3d.Vector3D(x, 0, z));
                }
            }
            return values;
        };
        CircleValueShape.prototype.createRandomPoint2 = function (num, r) {
            var values = [];
            var pos;
            var tempR;
            var theta;
            for (var i = 0; i < num; i++) {
                pos = new egret3d.Vector3D();
                tempR = Math.sqrt(Math.random()) * r;
                theta = Math.random() * 360;
                pos.x = tempR * Math.sin(theta);
                pos.z = tempR * Math.cos(theta);
                pos.y = 0;
                values.push(pos);
            }
            return values;
        };
        return CircleValueShape;
    }(ValueShape));
    /**
     * @private
     */
    var Mesh3DValueShape = (function (_super) {
        __extends(Mesh3DValueShape, _super);
        function Mesh3DValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
            this.normalList = [];
            this.type = egret3d.ParticleMeshShapeType.Edge;
            this.scale = 1;
        }
        /**
        * @language zh_CN
        * @param num
        * @param parameters [width, height, depth]
        * @returns Vector3D[]
        */
        Mesh3DValueShape.prototype.calculate = function (num) {
            var values = [];
            if (this.type == egret3d.ParticleMeshShapeType.Edge) {
                this.edgePosition(values, num);
            }
            else if (this.type == egret3d.ParticleMeshShapeType.Triangle) {
                this.trianglePosition(values, num);
            }
            else if (this.type == egret3d.ParticleMeshShapeType.Vertex) {
                this.vertexPosition(values, num);
            }
            if (this.scale != 1 && this.scale != 0) {
                var vec;
                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                    vec = values_1[_i];
                    vec.scaleBy(this.scale);
                }
            }
            return values;
        };
        Mesh3DValueShape.prototype.edgePosition = function (values, num) {
            var val;
            var normal;
            var triangleCount = this.geometry.faceCount;
            var vc1;
            var vc2;
            var random;
            var indexList = [];
            var xyz = [];
            for (var i = 0; i < num; i++) {
                val = new egret3d.Vector3D();
                values.push(val);
                indexList.length = 0;
                var index = 3 * Math.floor(triangleCount * Math.random()); //第n个三角形
                this.geometry.getVertexIndices(index, 3, indexList);
                //获取三角形的三个顶点
                xyz.length = 0;
                this.geometry.getVertexForIndex(indexList[0], egret3d.VertexFormat.VF_POSITION, xyz);
                Mesh3DValueShape.vct1.setTo(xyz[0], xyz[1], xyz[2]);
                xyz.length = 0;
                this.geometry.getVertexForIndex(indexList[1], egret3d.VertexFormat.VF_POSITION, xyz);
                Mesh3DValueShape.vct2.setTo(xyz[0], xyz[1], xyz[2]);
                xyz.length = 0;
                this.geometry.getVertexForIndex(indexList[2], egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL, xyz);
                Mesh3DValueShape.vct3.setTo(xyz[0], xyz[1], xyz[2]);
                normal = new egret3d.Vector3D();
                normal.setTo(xyz[3], xyz[4], xyz[5]);
                this.normalList.push(normal);
                //在三角形上获得一条边
                random = Math.random();
                if (random < 0.333) {
                    vc1 = Mesh3DValueShape.vct1;
                    vc2 = Mesh3DValueShape.vct2;
                }
                else if (random < 0.666) {
                    vc1 = Mesh3DValueShape.vct2;
                    vc2 = Mesh3DValueShape.vct3;
                }
                else {
                    vc1 = Mesh3DValueShape.vct3;
                    vc2 = Mesh3DValueShape.vct1;
                }
                //在这条直线上随机一个位置
                vc1.lerp(vc1, vc2, Math.random());
                val.copyFrom(vc1);
            }
        };
        Mesh3DValueShape.prototype.trianglePosition = function (values, num) {
            var val;
            var normal;
            var triangleCount = this.geometry.faceCount;
            var vc1 = new egret3d.Vector3D();
            var vc2 = new egret3d.Vector3D();
            var random;
            var xyz = [];
            var indexList = [];
            for (var i = 0; i < num; i++) {
                val = new egret3d.Vector3D();
                values.push(val);
                indexList.length = 0;
                var index = 3 * Math.floor(triangleCount * Math.random()); //第n个三角形
                this.geometry.getVertexIndices(index, 3, indexList);
                //获取三角形的三个顶点
                xyz.length = 0;
                this.geometry.getVertexForIndex(indexList[0], egret3d.VertexFormat.VF_POSITION, xyz);
                Mesh3DValueShape.vct1.setTo(xyz[0], xyz[1], xyz[2]);
                xyz.length = 0;
                this.geometry.getVertexForIndex(indexList[1], egret3d.VertexFormat.VF_POSITION, xyz);
                Mesh3DValueShape.vct2.setTo(xyz[0], xyz[1], xyz[2]);
                xyz.length = 0;
                this.geometry.getVertexForIndex(indexList[2], egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL, xyz);
                Mesh3DValueShape.vct3.setTo(xyz[0], xyz[1], xyz[2]);
                normal = new egret3d.Vector3D();
                normal.setTo(xyz[3], xyz[4], xyz[5]);
                this.normalList.push(normal);
                //在两条边上分别随机一个位置
                vc1.lerp(Mesh3DValueShape.vct1, Mesh3DValueShape.vct2, Math.random());
                vc2.lerp(Mesh3DValueShape.vct2, Mesh3DValueShape.vct3, Math.random());
                //连接两个随机位置的线段，之间随机一个位置
                val.lerp(vc1, vc2, Math.random());
            }
        };
        Mesh3DValueShape.prototype.vertexPosition = function (values, num) {
            var val;
            var normal;
            var triangleCount = this.geometry.faceCount;
            var random;
            var indexList = [];
            var xyz = [];
            for (var i = 0; i < num; i++) {
                val = new egret3d.Vector3D();
                values.push(val);
                var index = 3 * Math.floor(triangleCount * Math.random()); //第n个三角形
                indexList.length = 0;
                this.geometry.getVertexIndices(index, 3, indexList);
                //获取三角形的三个顶点
                xyz.length = 0;
                this.geometry.getVertexForIndex(indexList[0], egret3d.VertexFormat.VF_POSITION, xyz);
                Mesh3DValueShape.vct1.setTo(xyz[0], xyz[1], xyz[2]);
                xyz.length = 0;
                this.geometry.getVertexForIndex(indexList[1], egret3d.VertexFormat.VF_POSITION, xyz);
                Mesh3DValueShape.vct2.setTo(xyz[0], xyz[1], xyz[2]);
                xyz.length = 0;
                this.geometry.getVertexForIndex(indexList[2], egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_NORMAL, xyz);
                Mesh3DValueShape.vct3.setTo(xyz[0], xyz[1], xyz[2]);
                normal = new egret3d.Vector3D();
                normal.setTo(xyz[3], xyz[4], xyz[5]);
                this.normalList.push(normal);
                //在三角形上获得一个顶点
                random = Math.random();
                if (random < 0.333) {
                    val.copyFrom(Mesh3DValueShape.vct1);
                }
                else if (random < 0.666) {
                    val.copyFrom(Mesh3DValueShape.vct2);
                }
                else {
                    val.copyFrom(Mesh3DValueShape.vct3);
                }
            }
        };
        Mesh3DValueShape.prototype.calcNormal = function (pt0, pt1, pt2) {
            Mesh3DValueShape.crsVector1.setTo(pt1.x - pt0.x, pt1.y - pt0.y, pt1.z - pt0.z);
            Mesh3DValueShape.crsVector2.setTo(pt2.x - pt0.x, pt2.y - pt0.y, pt2.z - pt0.z);
            Mesh3DValueShape.crsVector1.normalize();
            Mesh3DValueShape.crsVector2.normalize();
            this.normal = Mesh3DValueShape.crsVector2.crossProduct(Mesh3DValueShape.crsVector1);
            this.normal.normalize();
            return this.normal;
        };
        Mesh3DValueShape.vct1 = new egret3d.Vector3D();
        Mesh3DValueShape.vct2 = new egret3d.Vector3D();
        Mesh3DValueShape.vct3 = new egret3d.Vector3D();
        Mesh3DValueShape.crsVector1 = new egret3d.Vector3D();
        Mesh3DValueShape.crsVector2 = new egret3d.Vector3D();
        return Mesh3DValueShape;
    }(ValueShape));
    egret3d.Mesh3DValueShape = Mesh3DValueShape;
    /**
    * @private
    * 贝塞尔曲线, 以Y为平面, parameters = [p0, p1, p2, p3]
    */
    var BezierCurveValueShape = (function (_super) {
        __extends(BezierCurveValueShape, _super);
        function BezierCurveValueShape() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
        }
        BezierCurveValueShape.prototype.calculate = function (num) {
            var parameters = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                parameters[_i - 1] = arguments[_i];
            }
            var values = [];
            //var tmpPar = parameters[0];
            var tmpPar = [];
            tmpPar.push(new egret3d.Vector3D(0, 0, 0));
            tmpPar.push(new egret3d.Vector3D(-200, 1000, 700));
            tmpPar.push(new egret3d.Vector3D(200, -50, 300));
            tmpPar.push(new egret3d.Vector3D(-300, -220, 500));
            var p0 = tmpPar[0];
            var p1 = tmpPar[1];
            var p2 = tmpPar[2];
            var p3 = tmpPar[3];
            var t;
            var yt;
            var x;
            var y;
            var z;
            for (var i = 0; i < num; i++) {
                t = Math.random();
                yt = 1 - t;
                x = p0.x * yt * yt * yt + 3 * p1.x * yt * yt * t + 3 * p2.x * yt * t * t + p3.x * t * t * t;
                y = p0.y * yt * yt * yt + 3 * p1.y * yt * yt * t + 3 * p2.y * yt * t * t + p3.y * t * t * t;
                z = p0.z * yt * yt * yt + 3 * p1.z * yt * yt * t + 3 * p2.z * yt * t * t + p3.z * t * t * t;
                values.push(new egret3d.Vector3D(x, y, z));
            }
            return values;
        };
        return BezierCurveValueShape;
    }(ValueShape));
    /**
   * @private
   * 外部指定的位置
   */
    var ValueShapeExternal = (function (_super) {
        __extends(ValueShapeExternal, _super);
        function ValueShapeExternal() {
            _super.apply(this, arguments);
            this.valueType = ValueType.vec3;
        }
        ValueShapeExternal.prototype.calculate = function (num) {
            var parameters = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                parameters[_i - 1] = arguments[_i];
            }
            var values = this.positionList.slice();
            return values;
        };
        return ValueShapeExternal;
    }(ValueShape));
    egret3d.ValueShapeExternal = ValueShapeExternal;
    /**
    * @private
    */
    var Value = (function () {
        function Value() {
            this.emitter = {};
            //this.emitter[ValueType.constValue] = new ConstValueShape();
            //this.emitter[ValueType.line] = new LineValueShape();
            //this.emitter[ValueType.plane] = new PlaneValueShape();
            //this.emitter[ValueType.cube3D] = new CubeVector3DValueShape();
            //this.emitter[ValueType.sphere] = new BallValueShape();
            //this.emitter[ValueType.sphere_plane] = new BallSurfaceValueShape();
            //this.emitter[ValueType.cylinder] = new CylinderValueShape();
        }
        Value.calculate = function (count, valueShape) {
            return valueShape.calculate(count, valueShape);
        };
        Value.getValues = function (count, valueType, parameters) {
        };
        Value._instance = new Value();
        return Value;
    }());
    egret3d.Value = Value;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ParticleEndNode = (function (_super) {
        __extends(ParticleEndNode, _super);
        function ParticleEndNode() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleEndNode";
            this.importShader(true, egret3d.ShaderPhaseType.end_vertex, "particle_end_vs");
            this.importShader(false, egret3d.ShaderPhaseType.end_fragment, "particle_end_fs");
            //##FilterEnd##
        }
        ParticleEndNode.prototype.build = function (geometry, count) {
        };
        return ParticleEndNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleEndNode = ParticleEndNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ParticleLifeGenerator = (function () {
        function ParticleLifeGenerator() {
            this._tiny = 0.001;
        }
        /**
        * 根据粒子的数据生成生命周期数据。
        * @private
        */
        ParticleLifeGenerator.prototype.generator = function (data) {
            //if (data.life.loop) {
            //    this._inputCount = data.property.particleCount;
            //} else {
            //    this._inputCount = 2000;
            //}
            this._inputCount = 2000;
            //reset
            this._data = data;
            this._node = data.life;
            this._burstsClone = data.emission.bursts;
            if (this._burstsClone) {
                this._burstsClone = this._burstsClone.slice();
            }
            this.planes = [];
            this.loopTime = this.circleTime = 0;
            if (this._data.emission.type == egret3d.ParticleValueType.Const) {
                this.generatorConst();
            }
            else {
                this.generatorBezier();
            }
            this.planes.sort(function (a, b) {
                return a.x - b.x;
            });
            var pt;
            var lastBornTime = 0;
            for (var _i = 0, _a = this.planes; _i < _a.length; _i++) {
                pt = _a[_i];
                this.circleTime = Math.max(this.circleTime, pt.x + pt.y);
                this.loopTime = Math.max(this.loopTime, pt.y);
                lastBornTime = pt.x;
            }
            if (lastBornTime > this.loopTime) {
                this.loopTime = lastBornTime; //不循环的粒子，这个数值没有意义。
            }
            if (this.loopTime < this._data.life.duration) {
                this.loopTime = this._data.life.duration;
            }
            this.circleTime += this._data.life.delay;
        };
        ParticleLifeGenerator.prototype.burstPlanes = function (now, next) {
            var burstItem;
            var time;
            var burstCount;
            var spliceItem;
            for (var b = 0, bCount = this._burstsClone.length; b < bCount; b++) {
                burstItem = this._burstsClone[b];
                time = burstItem.x;
                spliceItem = false;
                if (time >= now && time <= next) {
                    burstCount = Math.min(burstItem.y, this._data.property.particleCount);
                    for (var i = 0; i < burstCount; i++) {
                        this.tryCreatePlane(time);
                    }
                    spliceItem = true;
                }
                else if (time >= this._data.life.duration) {
                    spliceItem = true;
                }
                if (spliceItem) {
                    this._burstsClone.splice(b, 1);
                    b--;
                    bCount--;
                }
            }
        };
        ParticleLifeGenerator.prototype.generatorConst = function () {
            //补漏的代码，duration尽量和单个粒子的生命周期成整数倍，计算循环时间modTime的时候，会更加准确
            if (this._data.emission.type == egret3d.ParticleValueType.Const && this._data.life.type == egret3d.ParticleValueType.Const) {
                this._data.life.duration = Math.ceil(this._data.life.duration / this._data.life.max) * this._data.life.max;
            }
            //补漏结束
            var rate = this._data.emission.rate;
            if (rate == 0) {
                //不发射粒子
                while (this._burstsClone && this._burstsClone.length > 0 && this.planes.length < this._inputCount) {
                    this.burstPlanes(0, egret3d.MathUtil.MAX_VALUE);
                }
                return;
            }
            var createInterval = Math.max(1 / rate, this._tiny);
            var duration = this._data.life.duration;
            var now = 0;
            var next = createInterval;
            while (now <= this._data.life.duration && this.planes.length < this._inputCount) {
                this.tryCreatePlane(now);
                next = now + createInterval;
                //try burst
                if (this._burstsClone && this._burstsClone.length > 0) {
                    this.burstPlanes(now, next);
                }
                now = next;
            }
        };
        ParticleLifeGenerator.prototype.generatorBezier = function () {
            var frameInterval = 1 / 20;
            var duration = this._data.life.duration;
            var now = frameInterval;
            var next = now;
            var emitFloat = 0;
            var emitInt = 0;
            var emitPerTime = 0;
            while (now < duration && this.planes.length < this._inputCount) {
                emitFloat += this._data.emission.bezier.calc(now / duration) * frameInterval;
                emitInt = Math.floor(emitFloat);
                emitFloat -= emitInt;
                if (emitInt > 0) {
                    emitPerTime = frameInterval / emitInt;
                    while (emitInt > 0) {
                        next += emitPerTime;
                        this.tryCreatePlane(now);
                        //try burst
                        if (this._burstsClone && this._burstsClone.length > 0) {
                            this.burstPlanes(now, next);
                        }
                        now = next;
                        emitInt--;
                    }
                }
                else {
                    next = now + frameInterval;
                    //try burst
                    if (this._burstsClone && this._burstsClone.length > 0) {
                        this.burstPlanes(now, next);
                    }
                    now = next;
                }
            }
        };
        ParticleLifeGenerator.prototype.tryCreatePlane = function (now) {
            var liveCount = 0; //存活的数量
            var bornTime;
            var pt;
            var maxCount = this._data.property.particleCount;
            for (var i = 0, count = this.planes.length; i < count; i++) {
                pt = this.planes[i];
                bornTime = pt.x;
                if (pt.x + pt.y > now + 0.01) {
                    liveCount++;
                }
            }
            //当前存活数在范围之内
            if (liveCount < maxCount) {
                pt = new egret3d.Point(now, this.getLifeTime(now));
                this.planes.push(pt);
            }
        };
        ParticleLifeGenerator.prototype.getLifeTime = function (time) {
            var lifeType = this._data.life.type;
            var life = this._data.life;
            var value1;
            var value2;
            if (life.type == egret3d.ParticleValueType.Const) {
                value1 = value2 = life.max;
            }
            else if (life.type == egret3d.ParticleValueType.RandomConst) {
                value1 = life.max;
                value2 = life.min;
            }
            else if (life.type == egret3d.ParticleValueType.OneBezier) {
                value1 = value2 = life.bezier1.calc(time / life.duration);
            }
            else {
                value1 = life.bezier1.calc(time / life.duration);
                value2 = life.bezier2.calc(time / life.duration);
            }
            return Math.random() * (value1 - value2) + value2;
        };
        /**
        * 销毁
        * @private
        */
        ParticleLifeGenerator.prototype.dispose = function () {
            this._data = null;
            this._node = null;
            this._burstsClone = null;
            this.planes = null;
        };
        return ParticleLifeGenerator;
    }());
    egret3d.ParticleLifeGenerator = ParticleLifeGenerator;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var ParticleTime = (function (_super) {
        __extends(ParticleTime, _super);
        function ParticleTime() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleSpeedNode";
            var bezierShader = egret3d.Egret3DPolicy.useLowLoop ? "particle_bezier_low" : "particle_bezier";
            this.importShader(true, egret3d.ShaderPhaseType.utils_vertex, bezierShader);
            this.importShader(false, egret3d.ShaderPhaseType.utils_fragment, bezierShader);
            this.importShader(false, egret3d.ShaderPhaseType.diffuse_fragment, "particle_diffuse_fragment");
            this.attribute_time = new egret3d.GLSL.VarRegister();
            this.attribute_time.name = "attribute_time";
            this.attribute_time.size = 3;
            this.attributes.push(this.attribute_time);
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子生命周期数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleTime.prototype.initNode = function (data) {
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleTime.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            this._animationState = this.state;
            var generator = this._animationState.emitter.generator;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var pt;
            var planes = generator.planes;
            for (var i = 0; i < count; ++i) {
                pt = planes[i];
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_time.offsetIndex;
                    geometry.vertexArray[index + 0] = pt.x; //出生时间
                    geometry.vertexArray[index + 1] = pt.y; //单次生命周期时间
                    geometry.vertexArray[index + 2] = i; //下标
                }
            }
            //对于每个面片而言，取模的时间（周期）
            this._animationState.modTime = generator.loopTime;
            //最后一个面片消失的时间，即整个循环时间
            this._animationState.emitter.animation.loopTime = generator.circleTime;
            //##FilterEnd##
        };
        /**
        * @private
        * 构建结束后需要清理掉临时数据
        */
        ParticleTime.prototype.afterBuild = function () {
            //##FilterBegin## ##Particle##
            //##FilterEnd##
        };
        Object.defineProperty(ParticleTime.prototype, "offsetIndex", {
            /**
           * @language zh_CN
           * 获取时间节点在geometry的顶点数据中偏移量
           * @returns number
           * @version Egret 3.0
           * @platform Web,Native
           */
            get: function () {
                return this.attribute_time.offsetIndex;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        */
        ParticleTime.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._animationState = null;
        };
        return ParticleTime;
    }(egret3d.AnimationNode));
    egret3d.ParticleTime = ParticleTime;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticlePosition
    * @classdesc
    * 粒子位置效果节点，刚出生相对于(0,0,0)位置的偏移量
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticlePosition = (function (_super) {
        __extends(ParticlePosition, _super);
        function ParticlePosition() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticlePosition";
            this.attribute_offsetPosition = new egret3d.GLSL.VarRegister();
            this.attribute_offsetPosition.name = "attribute_offsetPosition";
            this.attribute_offsetPosition.size = 3;
            this.attributes.push(this.attribute_offsetPosition);
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子发射器形状数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticlePosition.prototype.initNode = function (data, arg) {
            //##FilterBegin## ##Particle##
            //根据粒子的属性，选择使用相机方式
            var renderMode = arg.renderMode;
            if (renderMode == egret3d.ParticleRenderModeType.StretchedBillboard) {
                this.importShader(true, egret3d.ShaderPhaseType.local_vertex, "particle_stretched_mode");
            }
            //初始化顶点数据
            var node = this._node = data;
            if (node.type == egret3d.ParticleDataShapeType.Point) {
                var pointShape = new egret3d.Vec3ConstValueShape();
                pointShape.minX = 0;
                pointShape.minY = 0;
                pointShape.minZ = 0;
                this._positions = pointShape;
            }
            else if (node.type == egret3d.ParticleDataShapeType.Cube) {
                var cubeShape = new egret3d.CubeVector3DValueShape();
                cubeShape.width = node.cubeW;
                cubeShape.height = node.cubeH;
                cubeShape.depth = node.cubeD;
                this._positions = cubeShape;
            }
            else if (node.type == egret3d.ParticleDataShapeType.Sphere) {
                var sphereShape = new egret3d.BallValueShape();
                sphereShape.r = node.sphereRadius;
                sphereShape.fromShell = node.emitFromShell;
                this._positions = sphereShape;
            }
            else if (node.type == egret3d.ParticleDataShapeType.HemiSphere) {
                var hemiShape = new egret3d.HemiBallValueShape();
                hemiShape.r = node.hemiSphereRadius;
                hemiShape.fromShell = node.emitFromShell;
                this._positions = hemiShape;
            }
            else if (node.type == egret3d.ParticleDataShapeType.Cone) {
                var coneShape = new egret3d.ConeValueShape();
                coneShape.angle = node.coneAngle;
                coneShape.length = node.coneLength;
                coneShape.radius = node.coneRadius;
                coneShape.coneType = node.coneType;
                this._positions = coneShape;
            }
            else if (node.type == egret3d.ParticleDataShapeType.Mesh) {
                var meshShape = new egret3d.Mesh3DValueShape();
                meshShape.geometry = node.geometry;
                meshShape.type = node.meshType;
                this._positions = meshShape;
            }
            else if (node.type == egret3d.ParticleDataShapeType.External) {
                var externalShape = new egret3d.ValueShapeExternal();
                externalShape.positionList = node.externalPositionList;
                this._positions = externalShape;
            }
            //##FilterEnd##
        };
        Object.defineProperty(ParticlePosition.prototype, "offsetIndex", {
            /**
            * @language zh_CN
            * 获取位置节点在geometry的顶点数据中偏移量
            * @returns number
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.attribute_offsetPosition.offsetIndex;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticlePosition.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            this._animationState = this.state;
            var positionArray = this._positions.calculate(count);
            var directionArray = this._animationState.directionArray = [];
            var meshNormalArray;
            if (this._node.type == egret3d.ParticleDataShapeType.Mesh) {
                meshNormalArray = this._positions.normalList;
            }
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var data = this._animationState.emitter.data;
            var recordPos = new egret3d.Vector3D(); //用于计算方向，缩放后的位置不能用于计算方向
            var coneShape = this._positions;
            for (var i = 0; i < count; ++i) {
                var pos = positionArray[i];
                recordPos.copyFrom(pos);
                //缩放______________________________________________________
                //pos.multiply(data.property.scale, pos);
                //粒子发射方向
                var dir = new egret3d.Vector3D();
                if (data.shape.randomDirection) {
                    if (this._node.type == egret3d.ParticleDataShapeType.Cone &&
                        (this._node.coneType == egret3d.ParticleConeShapeType.Base || this._node.coneType == egret3d.ParticleConeShapeType.BaseShell)) {
                        this._positions.randomDirectionToTop(dir);
                    }
                    else {
                        dir.setTo(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
                    }
                }
                else {
                    if (this._node.type == egret3d.ParticleDataShapeType.Point) {
                        dir.setTo(0, 0, 1, 1);
                    }
                    else if (this._node.type == egret3d.ParticleDataShapeType.Cube) {
                        dir.setTo(0, 0, 1, 1);
                    }
                    else if (this._node.type == egret3d.ParticleDataShapeType.Sphere) {
                        dir.copyFrom(recordPos);
                    }
                    else if (this._node.type == egret3d.ParticleDataShapeType.HemiSphere) {
                        dir.copyFrom(recordPos);
                    }
                    else if (this._node.type == egret3d.ParticleDataShapeType.Cone) {
                        dir = coneShape.directions[i];
                    }
                    else if (this._node.type == egret3d.ParticleDataShapeType.Mesh) {
                        dir.copyFrom(meshNormalArray[i]);
                    }
                    else if (this._node.type == egret3d.ParticleDataShapeType.External) {
                        dir.setTo(0, 0, 1, 1);
                    }
                }
                dir.normalize();
                directionArray.push(dir);
                //创建位置
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_offsetPosition.offsetIndex;
                    geometry.vertexArray[index + 0] = pos.x;
                    geometry.vertexArray[index + 1] = pos.y;
                    geometry.vertexArray[index + 2] = pos.z;
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        * 构建结束后需要清理掉临时数据
        */
        ParticlePosition.prototype.afterBuild = function () {
            //##FilterBegin## ##Particle##
            this._positions.dispose();
            this._positions = null;
            this._animationState.directionArray.length = 0;
            this._animationState.directionArray = null;
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticlePosition.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._positions = null;
            this._animationState = null;
            this._node = null;
        };
        return ParticlePosition;
    }(egret3d.AnimationNode));
    egret3d.ParticlePosition = ParticlePosition;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleRotation
    * @classdesc
    * 粒子旋转效果节点(初始角度，直接加成到了顶点位置上，不会在shader上反映出)
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleRotation = (function (_super) {
        __extends(ParticleRotation, _super);
        function ParticleRotation() {
            _super.call(this);
            this.name = "ParticleRotation";
            this.attribute_rotationBirth = new egret3d.GLSL.VarRegister();
            this.attribute_rotationBirth.name = "attribute_rotationBirth";
            this.attribute_rotationBirth.size = 1;
            this.attributes.push(this.attribute_rotationBirth);
        }
        /**
        * @language zh_CN
        * 填充粒子初始旋转数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotation.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            var node = this._node = data;
            this._rotations = new egret3d.ConstRandomValueShape();
            this._rotations.max = node.max;
            this._rotations.min = node.min;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotation.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            this._animationState = this.state;
            var renderMode = this._animationState.emitter.data.property.renderMode;
            if (renderMode == egret3d.ParticleRenderModeType.StretchedBillboard) {
                //忽略旋转
                return;
            }
            var rotationArray = this._rotations.calculate(count);
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var pos = new egret3d.Vector3D();
            var rot;
            var progress = 0;
            var duration = this._animationState.emitter.data.life.duration;
            var timeOffsetIndex = this._animationState.emitter.timeNode.offsetIndex;
            var particleIndex = 0;
            var timeIndex;
            var bornTime;
            for (var i = 0; i < count; ++i) {
                //
                if (this._node.type == egret3d.ParticleValueType.OneBezier || this._node.type == egret3d.ParticleValueType.TwoBezier) {
                    timeIndex = particleIndex * geometry.vertexAttLength + timeOffsetIndex;
                    bornTime = geometry.vertexArray[timeIndex + 0]; //出生时间
                    progress = bornTime / duration;
                    progress = progress - Math.floor(progress); //取小数部分
                    rot = this._node.bezier1.calc(progress);
                    if (this._node.type == egret3d.ParticleValueType.TwoBezier) {
                        var random = Math.random();
                        rot *= random;
                        rot += this._node.bezier2.calc(progress) * (1 - random);
                    }
                }
                else {
                    rot = rotationArray[i];
                }
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_rotationBirth.offsetIndex;
                    geometry.vertexArray[index + 0] = rot;
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        * 构建结束后需要清理掉临时数据
        */
        ParticleRotation.prototype.afterBuild = function () {
            //##FilterBegin## ##Particle##
            this._rotations.dispose();
            this._rotations = null;
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleRotation.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._animationState = null;
            this._node = null;
            this._rotations = null;
        };
        return ParticleRotation;
    }(egret3d.AnimationNode));
    egret3d.ParticleRotation = ParticleRotation;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleScale
    * @classdesc
    * 粒子初始化的尺寸大小
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleScale = (function (_super) {
        __extends(ParticleScale, _super);
        /*
        *@private
        */
        function ParticleScale() {
            _super.call(this);
            this.name = "ParticleScale";
        }
        /**
        * @language zh_CN
        * 填充粒子尺寸缩放数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleScale.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            var node = this._node = data;
            this._scaleValue = new egret3d.ConstRandomValueShape();
            this._scaleValue.max = node.max;
            this._scaleValue.min = node.min;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleScale.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            this._animationState = this.state;
            var scaleArray = this._scaleValue.calculate(count);
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var progress = 0;
            var duration = this._animationState.emitter.data.life.duration;
            var timeOffsetIndex = this._animationState.emitter.timeNode.offsetIndex;
            var particleIndex = 0;
            var timeIndex;
            var bornTime;
            var scale = 0;
            for (var i = 0; i < count; ++i) {
                //
                if (this._node.type == egret3d.ParticleValueType.OneBezier || this._node.type == egret3d.ParticleValueType.TwoBezier) {
                    timeIndex = particleIndex * geometry.vertexAttLength + timeOffsetIndex;
                    bornTime = geometry.vertexArray[timeIndex + 0]; //出生时间
                    progress = bornTime / duration;
                    progress = progress - Math.floor(progress); //取小数部分
                    scale = this._node.bezier1.calc(progress);
                    if (this._node.type == egret3d.ParticleValueType.TwoBezier) {
                        var random = Math.random();
                        scale *= random;
                        scale += this._node.bezier2.calc(progress) * (1 - random);
                    }
                    scaleArray[i] = scale;
                }
                else {
                    scale = scaleArray[i];
                }
            }
            this._animationState.scaleBirthArray = scaleArray;
            //##FilterEnd##
        };
        /**
        * @private
        * 构建结束后需要清理掉临时数据
        */
        ParticleScale.prototype.afterBuild = function () {
            //##FilterBegin## ##Particle##
            this._scaleValue.dispose();
            this._scaleValue = null;
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleScale.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._animationState = null;
            this._node = null;
            this._scaleValue = null;
        };
        return ParticleScale;
    }(egret3d.AnimationNode));
    egret3d.ParticleScale = ParticleScale;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleStartColor
    * @classdesc
    * 粒子起始颜色，用顶点色实现
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleStartColor = (function (_super) {
        __extends(ParticleStartColor, _super);
        function ParticleStartColor() {
            _super.call(this);
            this.bornTime = 0;
            this.life = 0;
            this.id = 0;
            this.timeIndex = 0;
            this.name = "ParticleStartColor";
        }
        /**
        * @language zh_CN
        * 填充粒子发射器起始颜色
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleStartColor.prototype.initNode = function (data) {
            this._node = data;
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleStartColor.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            this._animationState = this.state;
            var colorOffsetIndex = 6; //position, normal
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var timeOffsetIndex = this._animationState.emitter.timeNode.offsetIndex;
            var particleIndex = 0;
            var clr1 = new egret3d.Color();
            var clr2 = new egret3d.Color();
            var progress = 0;
            var duration = this._animationState.emitter.data.life.duration;
            var scaleValue = 1 / 0xff;
            for (var i = 0; i < count; ++i) {
                particleIndex = i * vertices;
                this.timeIndex = particleIndex * geometry.vertexAttLength + timeOffsetIndex;
                this.bornTime = geometry.vertexArray[this.timeIndex + 0]; //出生时间
                //this.life = geometry.verticesData[this.timeIndex + 1];              //单次生命周期时间
                //this.id = geometry.verticesData[this.timeIndex + 2];              //下标(i)
                progress = this.bornTime / duration;
                progress = progress - Math.floor(progress); //取小数部分
                this.lerpBirthColor(clr1, clr2, progress);
                clr1.scaleBy(scaleValue);
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + colorOffsetIndex;
                    geometry.vertexArray[index + 0] = clr1.r;
                    geometry.vertexArray[index + 1] = clr1.g;
                    geometry.vertexArray[index + 2] = clr1.b;
                    geometry.vertexArray[index + 3] = clr1.a;
                }
            }
            //##FilterEnd##
        };
        //##FilterBegin## ##Particle##
        /**
        * @private
        * 根据每种出生颜色数据，相应获得一个颜色
        */
        ParticleStartColor.prototype.lerpBirthColor = function (c1, c2, t) {
            if (this._node.colorType == egret3d.ParticleBirthColorType.Const) {
                c1.copyFrom(this._node.colorConst1);
            }
            else if (this._node.colorType == egret3d.ParticleBirthColorType.RandomConst) {
                c1.randomColor(this._node.colorConst1, this._node.colorConst2, true);
            }
            else if (this._node.colorType == egret3d.ParticleBirthColorType.OneGradients) {
                this._node.colorGradients1.lerpColor(t, c1);
            }
            else if (this._node.colorType == egret3d.ParticleBirthColorType.TwoGradients) {
                this._node.colorGradients1.lerpColor(t, c1);
                this._node.colorGradients2.lerpColor(t, c2);
                c1.lerp(c1, c2, 0.5);
            }
        };
        //##FilterEnd##
        /**
        * @private
        */
        ParticleStartColor.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._node = null;
        };
        return ParticleStartColor;
    }(egret3d.AnimationNode));
    egret3d.ParticleStartColor = ParticleStartColor;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleFollowNode
    * @classdesc
    * 粒子跟随效果节点
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleFollowNode = (function (_super) {
        __extends(ParticleFollowNode, _super);
        //##FilterEnd##
        function ParticleFollowNode() {
            _super.call(this);
            this._count = 0;
            this._followRotation = false;
            this._followScale = false;
            this.bornTime = 0;
            this.life = 0;
            this.id = 0;
            this.timeIndex = 0;
            /**
            * @language zh_CN
            * 顶点数据是否需要重新upload
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._verticesDataDirty = false;
            //##FilterBegin## ##Particle##
            this.name = "ParticleFollowNode";
            this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_follow_vs");
            this.attribute_followPosition = new egret3d.GLSL.VarRegister();
            this.attribute_followPosition.name = "attribute_followPosition";
            this.attribute_followPosition.size = 3;
            this.attributes.push(this.attribute_followPosition);
            this.attribute_followRotation = new egret3d.GLSL.VarRegister();
            this.attribute_followRotation.name = "attribute_followRotation";
            this.attribute_followRotation.size = 4;
            this.attributes.push(this.attribute_followRotation);
            this.attribute_followScale = new egret3d.GLSL.VarRegister();
            this.attribute_followScale.name = "attribute_followScale";
            this.attribute_followScale.size = 3;
            this.attributes.push(this.attribute_followScale);
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子跟随属性
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleFollowNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            var node = data;
            this._followScale = node.followScale;
            this._followRotation = node.followRotation;
            //##FilterEnd##
        };
        /**
        * @private
        * 强制更新了时间之后，follow数据需要更新
        */
        ParticleFollowNode.prototype.onAnimTimeChange = function () {
            _super.prototype.onAnimTimeChange.call(this);
            this.resetCircleData();
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleFollowNode.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            this._count = count;
            this._animationState = this.state;
            //先重置成-1，然后每帧检测每个粒子的上一帧的所属出身次数和下一帧的出身次数，判定是否要刷新他的初始位置
            this._lifeCircles = [];
            this.resetCircleData();
            //##FilterEnd##
        };
        ParticleFollowNode.prototype.resetCircleData = function () {
            for (var i = 0; i < this._count; i++) {
                this._lifeCircles[i] = -1;
            }
        };
        /**
        * @language zh_CN
        * @param animTime 动画当前时间（单位为ms）
        * @param delay  这一帧的时间跨度
        * @param geometry 几何对象
        * 顶点数据是否需要重新upload
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleFollowNode.prototype.update = function (animTime, delay, geometry) {
            //##FilterBegin## ##Particle##
            //保留原来的geometryDirty为true的属性
            this._verticesDataDirty = this._verticesDataDirty;
            //非循环的粒子生命周期达上限
            var particleData = this._animationState.emitter.data;
            var loop = particleData.life.loop;
            var maxLife = this._animationState.modTime + particleData.life.duration + particleData.life.delay;
            if (!loop && (animTime * 0.001 >= maxLife)) {
                return;
            }
            //animTime += delay;
            var index = 0;
            var vertices = geometry.vertexCount / this._count;
            var particleIndex = 0;
            var changed = false;
            var timeOffsetIndex = this._animationState.emitter.timeNode.offsetIndex;
            var particleTime = animTime * 0.001 - particleData.life.delay;
            var verticesData = geometry.sharedVertexBuffer ? geometry.sharedVertexBuffer.arrayBuffer : geometry.vertexArray;
            //没有跟随对象，使用自己
            var followTarget = this._animationState.followTarget || this._animationState.emitter;
            for (var i = 0; i < this._count; ++i) {
                particleIndex = i * vertices;
                this.timeIndex = particleIndex * geometry.vertexAttLength + timeOffsetIndex;
                this.bornTime = verticesData[this.timeIndex + 0]; //出生时间
                this.life = verticesData[this.timeIndex + 1]; //单次生命周期时间
                //this.id = verticesData[this.timeIndex + 2];                //下标(i)
                var curCircleIndex = -1;
                if (particleTime >= this.bornTime) {
                    //粒子超时了，并且不需要继续循环
                    if (particleTime > (this.bornTime + this.life) && !loop)
                        continue;
                    curCircleIndex = Math.floor((particleTime - this.bornTime) / this._animationState.modTime);
                    //
                    if (((particleTime - this.bornTime) % this._animationState.modTime) > this.life) {
                        continue;
                    }
                    if (curCircleIndex != this._lifeCircles[i]) {
                        this._lifeCircles[i] = curCircleIndex;
                        changed = true;
                        for (var j = 0; j < vertices; ++j) {
                            //position
                            index = particleIndex + j;
                            index = index * geometry.vertexAttLength + this.attribute_followPosition.offsetIndex;
                            if (true) {
                                verticesData[index + 0] = followTarget.globalPosition.x;
                                verticesData[index + 1] = followTarget.globalPosition.y;
                                verticesData[index + 2] = followTarget.globalPosition.z;
                            }
                            //rotation
                            index = particleIndex + j;
                            index = index * geometry.vertexAttLength + this.attribute_followRotation.offsetIndex;
                            if (this._followRotation) {
                                verticesData[index + 0] = followTarget.globalOrientation.x;
                                verticesData[index + 1] = followTarget.globalOrientation.y;
                                verticesData[index + 2] = followTarget.globalOrientation.z;
                                verticesData[index + 3] = followTarget.globalOrientation.w;
                            }
                            else {
                                verticesData[index + 0] = 0;
                                verticesData[index + 1] = 0;
                                verticesData[index + 2] = 0;
                                verticesData[index + 3] = 0;
                            }
                            //scale
                            index = particleIndex + j;
                            index = index * geometry.vertexAttLength + this.attribute_followScale.offsetIndex;
                            if (this._followScale) {
                                verticesData[index + 0] = followTarget.globalScaleX;
                                verticesData[index + 1] = followTarget.globalScaleY;
                                verticesData[index + 2] = followTarget.globalScaleZ;
                            }
                            else {
                                verticesData[index + 0] = 0;
                                verticesData[index + 1] = 0;
                                verticesData[index + 2] = 0;
                            }
                        }
                    }
                }
            }
            this._verticesDataDirty = changed;
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleFollowNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            //##FilterBegin## ##Particle##
            if (this._verticesDataDirty) {
                geometry.geometry.upload(context3DProxy);
                this._verticesDataDirty = false;
            }
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleFollowNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._animationState = null;
            this._lifeCircles = null;
        };
        return ParticleFollowNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleFollowNode = ParticleFollowNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleVelocityNode
    * @classdesc
    * 粒子速度节点(根据粒子的出生相对位置，以及是否随机方向获得一个三维向量)
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityNode = (function (_super) {
        __extends(ParticleVelocityNode, _super);
        //##FilterEnd##
        function ParticleVelocityNode() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleVelocityNode";
            this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocity");
            this.attribute_velocity = new egret3d.GLSL.VarRegister();
            this.attribute_velocity.name = "attribute_velocity";
            this.attribute_velocity.size = 3;
            this.attributes.push(this.attribute_velocity);
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            var node = this._node = data;
            if (node.type == egret3d.ParticleValueType.Const || node.type == egret3d.ParticleValueType.RandomConst) {
                this._constValue = new egret3d.ConstRandomValueShape();
                this._constValue.max = node.max;
                this._constValue.min = node.min;
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityNode.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            this._animationState = this.state;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var constList;
            if (this._constValue)
                constList = this._constValue.calculate(count);
            var directionVector = this._animationState.directionArray;
            var direction = new egret3d.Vector3D();
            //
            var progress = 0;
            var duration = this._animationState.emitter.data.life.duration;
            var timeOffsetIndex = this._animationState.emitter.timeNode.offsetIndex;
            var particleIndex = 0;
            var timeIndex;
            var bornTime;
            var speed;
            for (var i = 0; i < count; ++i) {
                particleIndex = i * vertices;
                //
                if (this._node.type == egret3d.ParticleValueType.OneBezier || this._node.type == egret3d.ParticleValueType.TwoBezier) {
                    timeIndex = particleIndex * geometry.vertexAttLength + timeOffsetIndex;
                    bornTime = geometry.vertexArray[timeIndex + 0]; //出生时间
                    progress = bornTime / duration;
                    progress = progress - Math.floor(progress); //取小数部分
                    speed = this._node.bezier1.calc(progress);
                    if (this._node.type == egret3d.ParticleValueType.TwoBezier) {
                        var random = Math.random();
                        speed *= random;
                        speed += this._node.bezier2.calc(progress) * (1 - random);
                    }
                }
                else {
                    speed = constList[i];
                }
                direction.copyFrom(directionVector[i]);
                direction.scaleBy(speed);
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_velocity.offsetIndex;
                    geometry.vertexArray[index + 0] = direction.x;
                    geometry.vertexArray[index + 1] = direction.y;
                    geometry.vertexArray[index + 2] = direction.z;
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        * 构建结束后需要清理掉临时数据
        */
        ParticleVelocityNode.prototype.afterBuild = function () {
            //##FilterBegin## ##Particle##
            this._constValue && this._constValue.dispose();
            this._constValue = null;
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleVelocityNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._constValue = null;
            this._animationState = null;
            this._node = null;
        };
        return ParticleVelocityNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityNode = ParticleVelocityNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleColorGlobalNode
    * @classdesc
    * 颜色渐变
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleColorGlobalNode = (function (_super) {
        __extends(ParticleColorGlobalNode, _super);
        function ParticleColorGlobalNode() {
            _super.call(this);
            this._colorSegment = new Float32Array(ParticleColorGlobalNode.MaxColor * 2);
            //##FilterBegin## ##Particle##
            this.name = "ParticleColorGlobalNode";
            this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_color_vs");
            var fsShader = egret3d.Egret3DPolicy.useLowLoop ? "particle_color_fs_low" : "particle_color_fs";
            this.importShader(false, egret3d.ShaderPhaseType.end_fragment, fsShader);
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子颜色变化数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleColorGlobalNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            var node = data;
            var count = ParticleColorGlobalNode.MaxColor;
            var gradients = node.data;
            gradients.colors.length = gradients.times.length = count;
            var color;
            for (var i = 0; i < count; i++) {
                color = gradients.colors[i];
                if (color) {
                    //这里采用了压缩方法：rgb三个数值压缩到一个float，a和time压缩放到第二个float
                    //然后在gpu中还原
                    this._colorSegment[i] = this.getGpuColor(color.r, color.g, color.b);
                    this._colorSegment[i + count] = this.getTimeAndAlpha(gradients.times[i], color.a);
                }
                else {
                    this._colorSegment[i] = 0;
                    this._colorSegment[i + count] = 0;
                }
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleColorGlobalNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        */
        ParticleColorGlobalNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            //##FilterBegin## ##Particle##
            if (usage["uniform_colorTransform"]) {
                context3DProxy.uniform1fv(usage["uniform_colorTransform"].uniformIndex, this._colorSegment);
            }
            //##FilterEnd##
        };
        /**
        * 压缩一个颜色值到一个float中
        */
        ParticleColorGlobalNode.prototype.getGpuColor = function (r, g, b) {
            var value;
            //##FilterBegin## ##Particle##
            r = this.normalizeChannel(r);
            g = this.normalizeChannel(g);
            b = this.normalizeChannel(b);
            value = r * 0x100 + g + b / 0x100;
            //##FilterEnd##
            return value;
        };
        /**
        * @private
        * 将一个颜色通道规范到0-255之间
        */
        ParticleColorGlobalNode.prototype.normalizeChannel = function (value) {
            //##FilterBegin## ##Particle##
            if (value > 0xff)
                value = 0xff;
            else if (value < 0)
                value = 0;
            value = Math.floor(value);
            //##FilterEnd##
            return value;
        };
        /**
        * @private
        * 将时间规范到0和0.9999之间
        */
        ParticleColorGlobalNode.prototype.normalizeTime = function (value) {
            //##FilterBegin## ##Particle##
            //注：value是一个0-1之间的数，而非真实的秒时间
            //所以超过1将为无效会被设定成为一个接近1的数
            if (value >= 1)
                value = 0.9999;
            else if (value < 0)
                value = 0;
            //##FilterEnd##
            return value;
        };
        /**
        * @private
        * 合并alpha和time到一个float中
        */
        ParticleColorGlobalNode.prototype.getTimeAndAlpha = function (time, a) {
            //##FilterBegin## ##Particle##
            a = this.normalizeChannel(a);
            time = this.normalizeTime(time);
            //##FilterEnd##
            return a + time;
        };
        /**
        * @private
        */
        ParticleColorGlobalNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._colorSegment = null;
        };
        /**
        * @private
        * 最大支持的颜色变化数量
        */
        ParticleColorGlobalNode.MaxColor = 20;
        return ParticleColorGlobalNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleColorGlobalNode = ParticleColorGlobalNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleSizeGlobalNode
    * @classdesc
    * 粒子缩放变化
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleSizeGlobalNode = (function (_super) {
        __extends(ParticleSizeGlobalNode, _super);
        function ParticleSizeGlobalNode() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleSizeGlobalNode";
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子初始缩放数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleSizeGlobalNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            this._node = data;
            //由于初始缩放也要在这里输入，所以为必备的一个元素
            this.attribute_scaleSizeConst = new egret3d.GLSL.VarRegister();
            this.attribute_scaleSizeConst.name = "attribute_scaleSizeConst";
            this.attribute_scaleSizeConst.size = 1;
            this.attributes.push(this.attribute_scaleSizeConst);
            this.importShader(true, egret3d.ShaderPhaseType.local_vertex, "particle_scaleSizeConst");
            if (this._node) {
                this._sizeScale = new egret3d.ConstRandomValueShape();
                this._sizeScale.max = this._node.max;
                this._sizeScale.min = this._node.min;
                if (this._node.type == egret3d.ParticleValueType.OneBezier) {
                    this._floatCompressData1 = this._node.bezier1.sampler();
                    this.importShader(true, egret3d.ShaderPhaseType.local_vertex, "particle_scaleSizeBezier1");
                }
                else if (this._node.type == egret3d.ParticleValueType.TwoBezier) {
                    this.importShader(true, egret3d.ShaderPhaseType.local_vertex, "particle_scaleSizeBezier2");
                    this._floatCompressData2 = this._node.bezier1.sampler();
                    this._floatCompressData2 = this._node.bezier2.sampler();
                    this.attribute_bezierRandomSeed = new egret3d.GLSL.VarRegister();
                    this.attribute_bezierRandomSeed.name = "attribute_bezierRandomSeed";
                    this.attribute_bezierRandomSeed.size = 1;
                    this.attributes.push(this.attribute_bezierRandomSeed);
                }
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleSizeGlobalNode.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            var pState = this.state;
            this._scaleResult = pState.scaleBirthArray;
            //
            var index = 0;
            var vertices = geometry.vertexCount / count;
            if (this._node) {
                if (this._node.type == egret3d.ParticleValueType.TwoBezier) {
                    for (var i = 0; i < count; ++i) {
                        var random = Math.random();
                        for (var j = 0; j < vertices; ++j) {
                            index = i * vertices + j;
                            index = index * geometry.vertexAttLength + this.attribute_bezierRandomSeed.offsetIndex;
                            geometry.vertexArray[index + 0] = random;
                        }
                    }
                }
                if (this._node.type == egret3d.ParticleValueType.Const || this._node.type == egret3d.ParticleValueType.RandomConst) {
                    var data = this._sizeScale.calculate(count);
                    for (var i = 0; i < count; i++) {
                        this._scaleResult[i] *= data[i];
                    }
                }
            }
            for (var i = 0; i < count; ++i) {
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_scaleSizeConst.offsetIndex;
                    geometry.vertexArray[index + 0] = this._scaleResult[i];
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleSizeGlobalNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            //##FilterBegin## ##Particle##
            if (this._floatCompressData1) {
                context3DProxy.uniform1fv(usage["uniform_scaleSizeBezier1"].uniformIndex, this._floatCompressData1);
            }
            if (this._floatCompressData2) {
                context3DProxy.uniform1fv(usage["uniform_scaleSizeBezier2"].uniformIndex, this._floatCompressData2);
            }
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleSizeGlobalNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._floatCompressData1 = null;
            this._floatCompressData2 = null;
            this._node = null;
        };
        return ParticleSizeGlobalNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleSizeGlobalNode = ParticleSizeGlobalNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleVelocityOverConstNode
    * @classdesc
    * 粒子速度节点叠加(常量的影响方式)
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityOverConstNode = (function (_super) {
        __extends(ParticleVelocityOverConstNode, _super);
        function ParticleVelocityOverConstNode() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleVelocityOverConstNode";
            this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityOverConst");
            this.attribute_velocityOver = new egret3d.GLSL.VarRegister();
            this.attribute_velocityOver.name = "attribute_velocityOverConst";
            this.attribute_velocityOver.size = 3;
            this.attributes.push(this.attribute_velocityOver);
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityOverConstNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            var node = data;
            this._overValue = new egret3d.Vec3ConstRandomValueShape();
            this._overValue.maxX = node.velocityOver.max.x;
            this._overValue.maxY = node.velocityOver.max.y;
            this._overValue.maxZ = node.velocityOver.max.z;
            this._overValue.minX = node.velocityOver.min.x;
            this._overValue.minY = node.velocityOver.min.y;
            this._overValue.minZ = node.velocityOver.min.z;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityOverConstNode.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            this._animationState = this.state;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var data = this._overValue.calculate(count);
            for (var i = 0; i < count; ++i) {
                var over = data[i];
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_velocityOver.offsetIndex;
                    geometry.vertexArray[index + 0] = over.x;
                    geometry.vertexArray[index + 1] = over.y;
                    geometry.vertexArray[index + 2] = over.z;
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        * 构建结束后需要清理掉临时数据
        */
        ParticleVelocityOverConstNode.prototype.afterBuild = function () {
            //##FilterBegin## ##Particle##
            this._overValue.dispose();
            this._overValue = null;
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleVelocityOverConstNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._overValue = null;
            this._animationState = null;
        };
        return ParticleVelocityOverConstNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityOverConstNode = ParticleVelocityOverConstNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleVelocityOverOneBezierNode
    * @classdesc
    * 粒子速度叠加节点,贝塞尔曲线获得
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityOverOneBezierNode = (function (_super) {
        __extends(ParticleVelocityOverOneBezierNode, _super);
        function ParticleVelocityOverOneBezierNode() {
            _super.call(this);
            this.name = "ParticleVelocityOverOneBezierNode";
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityOverOneBezierNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            this._node = data;
            this._floatCompressDataX = this._node.velocityOver.xBezier1.trySampler();
            this._floatCompressDataY = this._node.velocityOver.yBezier1.trySampler();
            this._floatCompressDataZ = this._node.velocityOver.zBezier1.trySampler();
            this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityOverOneBezier");
            if (this._floatCompressDataX) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityOverOneBezierX");
            }
            if (this._floatCompressDataY) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityOverOneBezierY");
            }
            if (this._floatCompressDataZ) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityOverOneBezierZ");
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityOverOneBezierNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        */
        ParticleVelocityOverOneBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            //##FilterBegin## ##Particle##
            if (this._floatCompressDataX) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverX"].uniformIndex, this._floatCompressDataX);
            }
            if (this._floatCompressDataY) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverY"].uniformIndex, this._floatCompressDataY);
            }
            if (this._floatCompressDataZ) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverZ"].uniformIndex, this._floatCompressDataZ);
            }
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleVelocityOverOneBezierNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._floatCompressDataX = this._floatCompressDataY = this._floatCompressDataZ = null;
            this._node = null;
        };
        return ParticleVelocityOverOneBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityOverOneBezierNode = ParticleVelocityOverOneBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleVelocityOverTwoBezierNode
    * @classdesc
    * 粒子速度叠加节点,双贝塞尔曲线获得
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityOverTwoBezierNode = (function (_super) {
        __extends(ParticleVelocityOverTwoBezierNode, _super);
        function ParticleVelocityOverTwoBezierNode() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleVelocityOverTwoBezierNode";
            this.attribute_randomSeed = new egret3d.GLSL.VarRegister();
            this.attribute_randomSeed.name = "attribute_velocityOverRandomSeed";
            this.attribute_randomSeed.size = 1;
            this.attributes.push(this.attribute_randomSeed);
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityOverTwoBezierNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            this._node = data;
            this._floatCompressDataX1 = this._node.velocityOver.xBezier1.trySampler();
            this._floatCompressDataY1 = this._node.velocityOver.yBezier1.trySampler();
            this._floatCompressDataZ1 = this._node.velocityOver.zBezier1.trySampler();
            this._floatCompressDataX2 = this._node.velocityOver.xBezier2.trySampler();
            this._floatCompressDataY2 = this._node.velocityOver.yBezier2.trySampler();
            this._floatCompressDataZ2 = this._node.velocityOver.zBezier2.trySampler();
            this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityOverTwoBezier");
            if (this._floatCompressDataX1) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityOverTwoBezierX1");
            }
            if (this._floatCompressDataX2) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityOverTwoBezierX2");
            }
            if (this._floatCompressDataY1) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityOverTwoBezierY1");
            }
            if (this._floatCompressDataY2) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityOverTwoBezierY2");
            }
            if (this._floatCompressDataZ1) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityOverTwoBezierZ1");
            }
            if (this._floatCompressDataZ2) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityOverTwoBezierZ2");
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityOverTwoBezierNode.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            this._animationState = this.state;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            for (var i = 0; i < count; ++i) {
                var random = Math.random();
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_randomSeed.offsetIndex;
                    geometry.vertexArray[index + 0] = random;
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleVelocityOverTwoBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            //##FilterBegin## ##Particle##
            if (this._floatCompressDataX1) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverX1"].uniformIndex, this._floatCompressDataX1);
            }
            if (this._floatCompressDataX2) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverX2"].uniformIndex, this._floatCompressDataX2);
            }
            if (this._floatCompressDataY1) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverY1"].uniformIndex, this._floatCompressDataY1);
            }
            if (this._floatCompressDataY2) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverY2"].uniformIndex, this._floatCompressDataY2);
            }
            if (this._floatCompressDataZ1) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverZ1"].uniformIndex, this._floatCompressDataZ1);
            }
            if (this._floatCompressDataZ2) {
                context3DProxy.uniform1fv(usage["uniform_velocityOverZ2"].uniformIndex, this._floatCompressDataZ2);
            }
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleVelocityOverTwoBezierNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._floatCompressDataX1 = this._floatCompressDataY1 = this._floatCompressDataZ1 = null;
            this._floatCompressDataX2 = this._floatCompressDataY2 = this._floatCompressDataZ2 = null;
            this._node = null;
            this._animationState = null;
        };
        return ParticleVelocityOverTwoBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityOverTwoBezierNode = ParticleVelocityOverTwoBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleVelocityForceConstNode(常量部分)
    * @classdesc
    * 粒子加速度效果节点
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityForceConstNode = (function (_super) {
        __extends(ParticleVelocityForceConstNode, _super);
        function ParticleVelocityForceConstNode() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleVelocityForceConstNode";
            this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityForceConst");
            this.attribute_accelerationSpeed = new egret3d.GLSL.VarRegister();
            this.attribute_accelerationSpeed.name = "attribute_velocityForceConst";
            this.attribute_accelerationSpeed.size = 3;
            this.attributes.push(this.attribute_accelerationSpeed);
            //##FilterEnd##
        }
        /**
       * @language zh_CN
       * 填充粒子加速度数据
       * @param data ParticleDataNode 粒子数据来源
       * @version Egret 3.0
       * @platform Web,Native
       */
        ParticleVelocityForceConstNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            this._node = data;
            var node = this._node.velocityForce;
            this._forceValue = new egret3d.Vec3ConstRandomValueShape();
            this._forceValue.maxX = node.max.x;
            this._forceValue.maxY = node.max.y;
            this._forceValue.maxZ = node.max.z;
            this._forceValue.minX = node.min.x;
            this._forceValue.minY = node.min.y;
            this._forceValue.minZ = node.min.z;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityForceConstNode.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var data = this._forceValue.calculate(count);
            for (var i = 0; i < count; ++i) {
                var accSpeed = data[i];
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_accelerationSpeed.offsetIndex;
                    geometry.vertexArray[index + 0] = accSpeed.x;
                    geometry.vertexArray[index + 1] = accSpeed.y;
                    geometry.vertexArray[index + 2] = accSpeed.z;
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        * 构建结束后需要清理掉临时数据
        */
        ParticleVelocityForceConstNode.prototype.afterBuild = function () {
            //##FilterBegin## ##Particle##
            this._forceValue.dispose();
            this._forceValue = null;
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleVelocityForceConstNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._forceValue = null;
            this._node = null;
        };
        return ParticleVelocityForceConstNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityForceConstNode = ParticleVelocityForceConstNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleVelocityForceOneBezierNode
    * @classdesc
    * 粒子加速度叠加节点,贝塞尔曲线获得
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityForceOneBezierNode = (function (_super) {
        __extends(ParticleVelocityForceOneBezierNode, _super);
        function ParticleVelocityForceOneBezierNode() {
            _super.call(this);
            this.name = "ParticleVelocityForceOneBezierNode";
        }
        /**
        * @language zh_CN
        * 填充粒子加速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityForceOneBezierNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            this._node = data;
            this._floatCompressDataX = this._node.velocityForce.xBezier1.trySampler();
            this._floatCompressDataY = this._node.velocityForce.yBezier1.trySampler();
            this._floatCompressDataZ = this._node.velocityForce.zBezier1.trySampler();
            this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityForceOneBezier");
            if (this._floatCompressDataX) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityForceOneBezierX");
            }
            if (this._floatCompressDataY) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityForceOneBezierY");
            }
            if (this._floatCompressDataZ) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityForceOneBezierZ");
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityForceOneBezierNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        */
        ParticleVelocityForceOneBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            //##FilterBegin## ##Particle##
            if (this._floatCompressDataX) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceX"].uniformIndex, this._floatCompressDataX);
            }
            if (this._floatCompressDataY) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceY"].uniformIndex, this._floatCompressDataY);
            }
            if (this._floatCompressDataZ) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceZ"].uniformIndex, this._floatCompressDataZ);
            }
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleVelocityForceOneBezierNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._floatCompressDataX = this._floatCompressDataY = this._floatCompressDataZ = null;
            this._node = null;
        };
        return ParticleVelocityForceOneBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityForceOneBezierNode = ParticleVelocityForceOneBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleVelocityForceTwoBezierNode
    * @classdesc
    * 粒子加速度叠加节点,双贝塞尔曲线获得
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityForceTwoBezierNode = (function (_super) {
        __extends(ParticleVelocityForceTwoBezierNode, _super);
        function ParticleVelocityForceTwoBezierNode() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleVelocityForceTwoBezierNode";
            this.attribute_randomSeed = new egret3d.GLSL.VarRegister();
            this.attribute_randomSeed.name = "attribute_velocityForceRandomSeed";
            this.attribute_randomSeed.size = 1;
            this.attributes.push(this.attribute_randomSeed);
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子加速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityForceTwoBezierNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            this._node = data;
            this._floatCompressDataX1 = this._node.velocityForce.xBezier1.trySampler();
            this._floatCompressDataY1 = this._node.velocityForce.yBezier1.trySampler();
            this._floatCompressDataZ1 = this._node.velocityForce.zBezier1.trySampler();
            this._floatCompressDataX2 = this._node.velocityForce.xBezier2.trySampler();
            this._floatCompressDataY2 = this._node.velocityForce.yBezier2.trySampler();
            this._floatCompressDataZ2 = this._node.velocityForce.zBezier2.trySampler();
            this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityForceTwoBezier");
            if (this._floatCompressDataX1) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityForceTwoBezierX1");
            }
            if (this._floatCompressDataX2) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityForceTwoBezierX2");
            }
            if (this._floatCompressDataY1) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityForceTwoBezierY1");
            }
            if (this._floatCompressDataY2) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityForceTwoBezierY2");
            }
            if (this._floatCompressDataZ1) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityForceTwoBezierZ1");
            }
            if (this._floatCompressDataZ2) {
                this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityForceTwoBezierZ2");
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityForceTwoBezierNode.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            this._animationState = this.state;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            for (var i = 0; i < count; ++i) {
                var random = Math.random();
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_randomSeed.offsetIndex;
                    geometry.vertexArray[index + 0] = random;
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleVelocityForceTwoBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            //##FilterBegin## ##Particle##
            if (this._floatCompressDataX1) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceX1"].uniformIndex, this._floatCompressDataX1);
            }
            if (this._floatCompressDataX2) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceX2"].uniformIndex, this._floatCompressDataX2);
            }
            if (this._floatCompressDataY1) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceY1"].uniformIndex, this._floatCompressDataY1);
            }
            if (this._floatCompressDataY2) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceY2"].uniformIndex, this._floatCompressDataY2);
            }
            if (this._floatCompressDataZ1) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceZ1"].uniformIndex, this._floatCompressDataZ1);
            }
            if (this._floatCompressDataZ2) {
                context3DProxy.uniform1fv(usage["uniform_velocityForceZ2"].uniformIndex, this._floatCompressDataZ2);
            }
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleVelocityForceTwoBezierNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._floatCompressDataX1 = this._floatCompressDataY1 = this._floatCompressDataZ1 = null;
            this._floatCompressDataX2 = this._floatCompressDataY2 = this._floatCompressDataZ2 = null;
            this._node = null;
            this._animationState = null;
        };
        return ParticleVelocityForceTwoBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityForceTwoBezierNode = ParticleVelocityForceTwoBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleVelocityLimitConstNode
    * @classdesc
    * 粒子速度节点限制(常量的影响方式)
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityLimitConstNode = (function (_super) {
        __extends(ParticleVelocityLimitConstNode, _super);
        function ParticleVelocityLimitConstNode() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleVelocityLimitConstNode";
            this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityLimitConst");
            this.attribute_velocityLimit = new egret3d.GLSL.VarRegister();
            this.attribute_velocityLimit.name = "attribute_velocityLimit";
            this.attribute_velocityLimit.size = 1;
            this.attributes.push(this.attribute_velocityLimit);
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityLimitConstNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            var node = data;
            this._limitValue = new egret3d.ConstRandomValueShape();
            this._limitValue.max = node.velocityLimit.max;
            this._limitValue.min = node.velocityLimit.min;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityLimitConstNode.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            this._animationState = this.state;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            var data = this._limitValue.calculate(count);
            for (var i = 0; i < count; ++i) {
                var limit = data[i];
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_velocityLimit.offsetIndex;
                    geometry.vertexArray[index + 0] = limit;
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        * 构建结束后需要清理掉临时数据
        */
        ParticleVelocityLimitConstNode.prototype.afterBuild = function () {
            //##FilterBegin## ##Particle##
            this._limitValue.dispose();
            this._limitValue = null;
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleVelocityLimitConstNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._animationState = null;
            this._limitValue = null;
        };
        return ParticleVelocityLimitConstNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityLimitConstNode = ParticleVelocityLimitConstNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleVelocityLimitOneBezierNode
    * @classdesc
    * 粒子速度限制,贝塞尔曲线获得
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityLimitOneBezierNode = (function (_super) {
        __extends(ParticleVelocityLimitOneBezierNode, _super);
        function ParticleVelocityLimitOneBezierNode() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleVelocityLimitOneBezierNode";
            this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityLimitOneBezier");
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityLimitOneBezierNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            this._node = data;
            this._floatCompressData = this._node.velocityLimit.bezier1.sampler();
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityLimitOneBezierNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        */
        ParticleVelocityLimitOneBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            //##FilterBegin## ##Particle##
            context3DProxy.uniform1fv(usage["uniform_velocityLimit"].uniformIndex, this._floatCompressData);
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleVelocityLimitOneBezierNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._floatCompressData = null;
            this._node = null;
        };
        return ParticleVelocityLimitOneBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityLimitOneBezierNode = ParticleVelocityLimitOneBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleVelocityLimitTwoBezierNode
    * @classdesc
    * 粒子速度限制,贝塞尔曲线获得
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVelocityLimitTwoBezierNode = (function (_super) {
        __extends(ParticleVelocityLimitTwoBezierNode, _super);
        //##FilterEnd##
        function ParticleVelocityLimitTwoBezierNode() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleVelocityLimitTwoBezierNode";
            this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_velocityLimitTwoBezier");
            this.attribute_randomSeed = new egret3d.GLSL.VarRegister();
            this.attribute_randomSeed.name = "attribute_velocityLimitRandomSeed";
            this.attribute_randomSeed.size = 1;
            this.attributes.push(this.attribute_randomSeed);
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityLimitTwoBezierNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            this._node = data;
            this._floatCompressData = this._node.velocityLimit.bezier1.sampler();
            this._floatCompressData2 = this._node.velocityLimit.bezier2.sampler();
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleVelocityLimitTwoBezierNode.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            this._animationState = this.state;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            for (var i = 0; i < count; ++i) {
                var random = Math.random();
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_randomSeed.offsetIndex;
                    geometry.vertexArray[index + 0] = random;
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleVelocityLimitTwoBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            //##FilterBegin## ##Particle##
            context3DProxy.uniform1fv(usage["uniform_velocityLimit"].uniformIndex, this._floatCompressData);
            context3DProxy.uniform1fv(usage["uniform_velocityLimit2"].uniformIndex, this._floatCompressData2);
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleVelocityLimitTwoBezierNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._floatCompressData = null;
            this._floatCompressData2 = null;
            this._animationState = null;
            this._node = null;
        };
        return ParticleVelocityLimitTwoBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleVelocityLimitTwoBezierNode = ParticleVelocityLimitTwoBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleRotationConstNode
    * @classdesc
    * 粒子的旋转角速度，当前实现为Z轴的速度（todo：模型粒子或许需要同时有x/y/z三个方向的角速度）    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleRotationConstNode = (function (_super) {
        __extends(ParticleRotationConstNode, _super);
        function ParticleRotationConstNode() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleRotationConstNode";
            this.importShader(true, egret3d.ShaderPhaseType.local_vertex, "particle_rotationConst");
            this.attribute_Rotation = new egret3d.GLSL.VarRegister();
            this.attribute_Rotation.name = "attribute_rotationZ";
            this.attribute_Rotation.size = 1;
            this.attributes.push(this.attribute_Rotation);
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子过程旋转数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotationConstNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            var node = data;
            this._rotation = new egret3d.ConstRandomValueShape();
            this._rotation.max = node.max.z;
            this._rotation.min = node.min.z;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotationConstNode.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            var index = 0;
            var vertices = geometry.vertexCount / count;
            var data = this._rotation.calculate(count);
            for (var i = 0; i < count; ++i) {
                var rot = data[i];
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_Rotation.offsetIndex;
                    geometry.vertexArray[index + 0] = rot;
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        * 构建结束后需要清理掉临时数据
        */
        ParticleRotationConstNode.prototype.afterBuild = function () {
            //##FilterBegin## ##Particle##
            this._rotation.dispose();
            this._rotation = null;
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleRotationConstNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._rotation = null;
        };
        return ParticleRotationConstNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleRotationConstNode = ParticleRotationConstNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleRotationTwoBezierNode
    * @classdesc
    * 粒子的旋转角速度，当前实现为XYZ轴的速度
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleRotationXYZConstNode = (function (_super) {
        __extends(ParticleRotationXYZConstNode, _super);
        function ParticleRotationXYZConstNode() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleRotationXYZConstNode";
            this.importShader(true, egret3d.ShaderPhaseType.local_vertex, "particle_rotationXYZConst");
            this.attribute_rotBirthXYZ = new egret3d.GLSL.VarRegister();
            this.attribute_rotBirthXYZ.name = "attribute_rotBirthXYZ";
            this.attribute_rotBirthXYZ.size = 3;
            this.attributes.push(this.attribute_rotBirthXYZ);
            this.attribute_rotSpeedXYZ = new egret3d.GLSL.VarRegister();
            this.attribute_rotSpeedXYZ.name = "attribute_rotSpeedXYZ";
            this.attribute_rotSpeedXYZ.size = 3;
            this.attributes.push(this.attribute_rotSpeedXYZ);
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子过程旋转数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotationXYZConstNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            var node = data;
            this._rotationSpeed = new egret3d.Vec3ConstRandomValueShape();
            this._rotationSpeed.maxX = node.max.x;
            this._rotationSpeed.maxY = node.max.y;
            this._rotationSpeed.maxZ = node.max.z;
            this._rotationSpeed.minX = node.min.x;
            this._rotationSpeed.minY = node.min.y;
            this._rotationSpeed.minZ = node.min.z;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotationXYZConstNode.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            var index = 0;
            var vertices = geometry.vertexCount / count;
            var data = this._rotationSpeed.calculate(count);
            var birthRotX;
            var birthRotY;
            var birthRotZ;
            for (var i = 0; i < count; ++i) {
                var rot = data[i];
                birthRotX = Math.random() * 360 - 180;
                birthRotY = Math.random() * 360 - 180;
                birthRotZ = Math.random() * 360 - 180;
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_rotSpeedXYZ.offsetIndex;
                    geometry.vertexArray[index + 0] = rot.x;
                    geometry.vertexArray[index + 1] = rot.y;
                    geometry.vertexArray[index + 2] = rot.z;
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_rotBirthXYZ.offsetIndex;
                    geometry.vertexArray[index + 0] = birthRotX;
                    geometry.vertexArray[index + 1] = birthRotY;
                    geometry.vertexArray[index + 2] = birthRotZ;
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        * 构建结束后需要清理掉临时数据
        */
        ParticleRotationXYZConstNode.prototype.afterBuild = function () {
            //##FilterBegin## ##Particle##
            this._rotationSpeed.dispose();
            this._rotationSpeed = null;
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleRotationXYZConstNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._rotationSpeed = null;
        };
        return ParticleRotationXYZConstNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleRotationXYZConstNode = ParticleRotationXYZConstNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleRotationOneBezierNode
    * @classdesc
    * 粒子z轴旋转角速度（bezier曲线）
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleRotationOneBezierNode = (function (_super) {
        __extends(ParticleRotationOneBezierNode, _super);
        function ParticleRotationOneBezierNode() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleRotationOneBezierNode";
            this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_rotationOneBezier");
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子旋转角速度
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotationOneBezierNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            this._node = data;
            this._floatCompressData = this._node.bezier1.sampler();
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotationOneBezierNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        */
        ParticleRotationOneBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            //##FilterBegin## ##Particle##
            context3DProxy.uniform1fv(usage["uniform_rotationBezier"].uniformIndex, this._floatCompressData);
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleRotationOneBezierNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._floatCompressData = null;
            this._node = null;
        };
        return ParticleRotationOneBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleRotationOneBezierNode = ParticleRotationOneBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleRotationTwoBezierNode
    * @classdesc
    * 粒子z轴旋转角速度（双bezier曲线）
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleRotationTwoBezierNode = (function (_super) {
        __extends(ParticleRotationTwoBezierNode, _super);
        function ParticleRotationTwoBezierNode() {
            _super.call(this);
            //##FilterBegin## ##Particle##
            this.name = "ParticleRotationTwoBezierNode";
            this.attribute_randomSeed = new egret3d.GLSL.VarRegister();
            this.attribute_randomSeed.name = "attribute_rotationRandomSeed";
            this.attribute_randomSeed.size = 1;
            this.attributes.push(this.attribute_randomSeed);
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充粒子移动速度数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotationTwoBezierNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            this._node = data;
            this._floatCompressData = this._node.bezier1.sampler();
            this._floatCompressData2 = this._node.bezier2.sampler();
            this.importShader(true, egret3d.ShaderPhaseType.global_vertex, "particle_rotationTwoBezier");
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRotationTwoBezierNode.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            this._animationState = this.state;
            var vertices = geometry.vertexCount / count;
            var index = 0;
            for (var i = 0; i < count; ++i) {
                var random = Math.random();
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_randomSeed.offsetIndex;
                    geometry.vertexArray[index + 0] = random;
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleRotationTwoBezierNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            //##FilterBegin## ##Particle##
            context3DProxy.uniform1fv(usage["uniform_rotationBezier"].uniformIndex, this._floatCompressData);
            context3DProxy.uniform1fv(usage["uniform_rotationBezier2"].uniformIndex, this._floatCompressData2);
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleRotationTwoBezierNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._floatCompressData = null;
            this._floatCompressData2 = null;
            this._animationState = null;
            this._node = null;
        };
        return ParticleRotationTwoBezierNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleRotationTwoBezierNode = ParticleRotationTwoBezierNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleTextureSheetNode
    * @classdesc
    * uv序列帧
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleTextureSheetNode = (function (_super) {
        __extends(ParticleTextureSheetNode, _super);
        function ParticleTextureSheetNode() {
            _super.call(this);
            this._sheetFloatData = new Float32Array(5);
            //##FilterBegin## ##Particle##
            this.name = "ParticleTextureSheetNode";
            //
            this.attribute_textureSheetData = new egret3d.GLSL.VarRegister();
            this.attribute_textureSheetData.name = "attribute_textureSheetData";
            this.attribute_textureSheetData.size = 3;
            this.attributes.push(this.attribute_textureSheetData);
            this.importShader(true, egret3d.ShaderPhaseType.local_vertex, "particle_textureSheet_vs");
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充UV滚动
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleTextureSheetNode.prototype.initNode = function (data, args) {
            //##FilterBegin## ##Particle##
            this._sheetData = args;
            this._sheetFloatData[0] = this._sheetData.tileX;
            this._sheetFloatData[1] = this._sheetData.tileY;
            this._sheetFloatData[2] = this._sheetData.circles;
            if (this._sheetData.whole) {
                this._sheetFloatData[3] = 0;
                this._sheetFloatData[4] = this._sheetData.tileX * this._sheetData.tileY - 1;
            }
            else {
                this._sheetFloatData[3] = 0;
                this._sheetFloatData[4] = this._sheetData.tileY - 1;
            }
            if (this._sheetData.frameType == egret3d.ParticleValueType.Const || this._sheetData.frameType == egret3d.ParticleValueType.RandomConst) {
                this.importShader(false, egret3d.ShaderPhaseType.start_fragment, "particle_textureSheetConst");
            }
            else if (this._sheetData.frameType == egret3d.ParticleValueType.OneBezier) {
                this.importShader(false, egret3d.ShaderPhaseType.start_fragment, "particle_textureSheetOneBezier");
                this._floatCompressData1 = this._sheetData.bezier1.sampler();
            }
            else if (this._sheetData.frameType == egret3d.ParticleValueType.TwoBezier) {
                this.importShader(false, egret3d.ShaderPhaseType.start_fragment, "particle_textureSheetTwoBezier");
                this._floatCompressData1 = this._sheetData.bezier1.sampler();
                this._floatCompressData2 = this._sheetData.bezier2.sampler();
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleTextureSheetNode.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            var frameStart = 0;
            var frameConst = 0;
            var randomSeed = 0;
            //将frameStart放入到顶点数据中
            var index = 0;
            var vertices = geometry.vertexCount / count;
            for (var i = 0; i < count; ++i) {
                //frameStart
                if (this._sheetData.whole) {
                    frameStart = 0;
                }
                else {
                    if (this._sheetData.randomRow) {
                        frameStart = Math.floor(this._sheetData.tileY * Math.random()) * this._sheetData.tileX;
                    }
                    else {
                        frameStart = this._sheetData.row * this._sheetData.tileX;
                    }
                }
                //frame const
                if (this._sheetData.frameType == egret3d.ParticleValueType.Const || this._sheetData.frameType == egret3d.ParticleValueType.RandomConst) {
                    frameConst = (this._sheetData.max - this._sheetData.min) * Math.random() + this._sheetData.min;
                    frameConst = Math.floor(frameConst);
                }
                else {
                    frameConst = 0;
                }
                //
                if (this._sheetData.frameType == egret3d.ParticleValueType.TwoBezier) {
                    randomSeed = Math.random();
                }
                else {
                    randomSeed = 1;
                }
                for (var j = 0; j < vertices; ++j) {
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_textureSheetData.offsetIndex;
                    geometry.vertexArray[index + 0] = frameStart + 0.001; //修复抖动的问题
                    geometry.vertexArray[index + 1] = frameConst;
                    geometry.vertexArray[index + 2] = randomSeed;
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleTextureSheetNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            //##FilterBegin## ##Particle##
            context3DProxy.uniform1fv(usage["uniform_textureSheet"].uniformIndex, this._sheetFloatData);
            if (this._sheetData.frameType == egret3d.ParticleValueType.OneBezier) {
                context3DProxy.uniform1fv(usage["uniform_frameBezier"].uniformIndex, this._floatCompressData1);
            }
            else if (this._sheetData.frameType == egret3d.ParticleValueType.TwoBezier) {
                context3DProxy.uniform1fv(usage["uniform_frameBezier1"].uniformIndex, this._floatCompressData1);
                context3DProxy.uniform1fv(usage["uniform_frameBezier2"].uniformIndex, this._floatCompressData2);
            }
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleTextureSheetNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._animationState = null;
            this._floatCompressData1 = this._floatCompressData2 = null;
            this._sheetData = null;
            this._sheetFloatData = null;
        };
        return ParticleTextureSheetNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleTextureSheetNode = ParticleTextureSheetNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleUVRollNode
    * @classdesc
    * uv滚动
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleUVRollNode = (function (_super) {
        __extends(ParticleUVRollNode, _super);
        function ParticleUVRollNode() {
            _super.call(this);
            this._uvRollData = new Float32Array(2);
            //##FilterBegin## ##Particle##
            this.name = "ParticleUVRollNode";
            //需要在之前进行设置UV
            this.importShader(false, egret3d.ShaderPhaseType.start_fragment, "particle_uv_roll_fs");
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 填充UV滚动
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleUVRollNode.prototype.initNode = function (data, args) {
            //##FilterBegin## ##Particle##
            this._methodData = args;
            this._uvRollData[0] = this._methodData.uSpeed;
            this._uvRollData[1] = this._methodData.vSpeed;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleUVRollNode.prototype.build = function (geometry, count) {
        };
        /**
        * @private
        */
        ParticleUVRollNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            //##FilterBegin## ##Particle##
            context3DProxy.uniform1fv(usage["uniform_particleUVRoll"].uniformIndex, this._uvRollData);
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleUVRollNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._animationState = null;
            this._methodData = null;
            this._uvRollData = null;
        };
        return ParticleUVRollNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleUVRollNode = ParticleUVRollNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleSubEmitterNode
    * @classdesc
    * 粒子子发射器
    * @see egret3d.AnimationNode
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleSubEmitterNode = (function (_super) {
        __extends(ParticleSubEmitterNode, _super);
        function ParticleSubEmitterNode() {
            _super.call(this);
            this._empty = true;
            this.bornTime = 0;
            this.life = 0;
            this.id = 0;
            this.timeIndex = 0;
            this.count = 0;
            this.position = new egret3d.Vector3D();
            this._added = false;
            this._orientation = new egret3d.Quaternion();
            this._birthPhase = new ParticleSubEmitterNodePhase(egret3d.ParticleDataSubEmitterPhase.BIRTH);
            this._collisionPhase = new ParticleSubEmitterNodePhase(egret3d.ParticleDataSubEmitterPhase.COLLISION);
            this._deathPhase = new ParticleSubEmitterNodePhase(egret3d.ParticleDataSubEmitterPhase.DEATH);
            this.name = "ParticleSubEmitterNode";
        }
        /**
        * @language zh_CN
        * 填充粒子属性
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleSubEmitterNode.prototype.initNode = function (data, parent) {
            if (parent === void 0) { parent = null; }
            this._parent = parent;
        };
        /**
        * @language zh_CN
        * 导入新的子粒子发射
        * @param subEmitter ParticleEmitter 子发射器
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleSubEmitterNode.prototype.importSubEmitter = function (phase, subEmitter) {
            var nodePhase;
            if (phase == egret3d.ParticleDataSubEmitterPhase.BIRTH) {
                nodePhase = this._birthPhase;
            }
            else if (phase == egret3d.ParticleDataSubEmitterPhase.COLLISION) {
                nodePhase = this._collisionPhase;
            }
            else if (phase == egret3d.ParticleDataSubEmitterPhase.DEATH) {
                nodePhase = this._deathPhase;
            }
            if (nodePhase) {
                this._empty = false;
                nodePhase.importSubEmitter(subEmitter);
            }
        };
        /**
        * @language zh_CN
        * 获取子粒子
        * @param phase 某个阶段的子粒子
        * @returns ParticleEmitter列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleSubEmitterNode.prototype.getSubEmitters = function (phase) {
            if (phase == egret3d.ParticleDataSubEmitterPhase.BIRTH) {
                return this._birthPhase.playing.getKeys();
            }
            else if (phase == egret3d.ParticleDataSubEmitterPhase.COLLISION) {
                return this._collisionPhase.playing.getKeys();
            }
            else if (phase == egret3d.ParticleDataSubEmitterPhase.DEATH) {
                return this._deathPhase.playing.getKeys();
            }
            return null;
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleSubEmitterNode.prototype.build = function (geometry, count) {
            this.count = count;
            this._animationState = this.state;
            //先重置成-1，然后每帧检测每个粒子的上一帧的所属出身次数和下一帧的出身次数，判定是否要刷新他的初始位置
            this._lifeCircles = [];
            this.resetCircleData();
        };
        ParticleSubEmitterNode.prototype.resetCircleData = function () {
            for (var i = 0; i < this.count; i++) {
                this._lifeCircles[i] = -1;
            }
        };
        /**
        * @language zh_CN
        * @param animTime 动画当前时间（单位为ms）
        * @param delay  这一帧的时间跨度
        * @param geometry 几何对象
        * 判定是否需要发射子粒子
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleSubEmitterNode.prototype.update = function (animTime, delay, geometry) {
            if (this._empty)
                return;
            //回收已经可以结束的子特效
            this.recycleParticle();
            //卡顿了就不发射子粒子了
            this.ignoreEmit = delay > 25;
            //非循环的粒子生命周期达上限
            var particleData = this._animationState.emitter.data;
            var loop = particleData.life.loop;
            var maxLife = this._animationState.modTime + particleData.life.duration + particleData.life.delay;
            if (!loop && (animTime * 0.001 >= maxLife)) {
                return;
            }
            //animTime += delay;
            var index = 0;
            var vertices = geometry.vertexCount / this.count;
            var particleIndex = 0;
            var positionOffsetIndex = this._animationState.emitter.positionNode.offsetIndex;
            var timeOffsetIndex = this._animationState.emitter.timeNode.offsetIndex;
            var particleTime = animTime * 0.001 - particleData.life.delay;
            var verticesData = geometry.sharedVertexBuffer ? geometry.sharedVertexBuffer.arrayBuffer : geometry.vertexArray;
            //没有跟随对象，使用自己
            var followTarget = this._animationState.followTarget || this._animationState.emitter;
            for (var i = 0; i < this.count; ++i) {
                particleIndex = i * vertices;
                this.timeIndex = particleIndex * geometry.vertexAttLength + timeOffsetIndex;
                this.bornTime = verticesData[this.timeIndex + 0]; //出生时间
                this.life = verticesData[this.timeIndex + 1]; //单次生命周期时间
                //this.id = array32[this.timeIndex + 2];                //下标(i)
                var curCircleIndex = -1;
                if (particleTime >= this.bornTime) {
                    //粒子超时了，并且不需要继续循环
                    if (particleTime > (this.bornTime + this.life) && !loop)
                        continue;
                    curCircleIndex = Math.floor((particleTime - this.bornTime) / this._animationState.modTime);
                    if (curCircleIndex != this._lifeCircles[i]) {
                        //不发射
                        this._lifeCircles[i] = curCircleIndex;
                        if (this.ignoreEmit) {
                            continue;
                        }
                        index = particleIndex * geometry.vertexAttLength + positionOffsetIndex;
                        //position
                        this.position.x = verticesData[index + 0];
                        this.position.y = verticesData[index + 1];
                        this.position.z = verticesData[index + 2];
                        this.emitParticleAtPhase(this._birthPhase, this.position);
                    }
                }
            }
        };
        ParticleSubEmitterNode.prototype.emitParticleAtPhase = function (phase, pos) {
            var bakEmitter;
            var bakEmitters = phase.playing.getKeys();
            var playingArr;
            var recycleArr;
            var newParticle;
            this._orientation.copyFrom(this._parent.orientation);
            this._orientation.w *= -1;
            for (var i = 0, count = bakEmitters.length; i < count; i++) {
                bakEmitter = bakEmitters[i];
                recycleArr = phase.recycle.getValueByKey(bakEmitter);
                playingArr = phase.playing.getValueByKey(bakEmitter);
                newParticle = recycleArr.shift();
                if (newParticle == null) {
                    newParticle = new egret3d.ParticleEmitter(bakEmitter.data, bakEmitter.material);
                }
                playingArr.push(newParticle);
                newParticle.play(1.0, true, bakEmitter.data.property.prewarm);
                newParticle.position = pos;
                newParticle.orientation = this._orientation;
                this._parent.addChild(newParticle);
            }
        };
        ParticleSubEmitterNode.prototype.recycleParticle = function () {
            this.recycleParticleAtPhase(this._birthPhase);
            this.recycleParticleAtPhase(this._collisionPhase);
            this.recycleParticleAtPhase(this._deathPhase);
        };
        ParticleSubEmitterNode.prototype.recycleParticleAtPhase = function (phaseNode) {
            var bakEmiter;
            var playingArr;
            var recycleArr;
            var tempParticle;
            var j;
            var jCount;
            var bakEmitters = phaseNode.playing.getKeys();
            for (var i = 0, count = bakEmitters.length; i < count; i++) {
                bakEmiter = bakEmitters[i];
                playingArr = phaseNode.playing.getValueByKey(bakEmiter);
                recycleArr = phaseNode.recycle.getValueByKey(bakEmiter);
                for (j = playingArr.length - 1; j >= 0; j--) {
                    tempParticle = playingArr[j];
                    if (tempParticle.loopProgress > 1) {
                        playingArr.splice(j, 1);
                        tempParticle.stop();
                        this._parent.removeChild(tempParticle);
                        recycleArr.push(tempParticle);
                    }
                }
            }
        };
        /**
        * @private
        */
        ParticleSubEmitterNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
        };
        /**
        * @private
        */
        ParticleSubEmitterNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._animationState = null;
            this._birthPhase && this._birthPhase.dispose();
            this._birthPhase = null;
            this._collisionPhase && this._collisionPhase.dispose();
            this._collisionPhase = null;
            this._deathPhase && this._deathPhase.dispose();
            this._deathPhase = null;
            this._lifeCircles = null;
            this._orientation = null;
            this._parent = null;
        };
        return ParticleSubEmitterNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleSubEmitterNode = ParticleSubEmitterNode;
    /**
    * @language zh_CN
    * @private
    * @class egret3d.ParticleSubEmitterNodePhase
    * @classdesc
    * 用于子粒子的回收
    * @see egret3d.DoubleArray
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleSubEmitterNodePhase = (function () {
        function ParticleSubEmitterNodePhase(phase) {
            this.playing = new egret3d.DoubleArray();
            this.recycle = new egret3d.DoubleArray();
            this._phase = phase;
        }
        /**
        * @private
        */
        ParticleSubEmitterNodePhase.prototype.importSubEmitter = function (subEmitter) {
            if (this.playing.getKeys().indexOf(subEmitter) >= 0)
                return;
            this.playing.put(subEmitter, []);
            this.recycle.put(subEmitter, []);
        };
        /**
        * @private
        */
        ParticleSubEmitterNodePhase.prototype.dispose = function () {
            var emitter;
            for (var _i = 0, _a = this.playing.getValues(); _i < _a.length; _i++) {
                emitter = _a[_i];
                emitter.dispose();
            }
            for (var _b = 0, _c = this.recycle.getValues(); _b < _c.length; _b++) {
                emitter = _c[_b];
                emitter.dispose();
            }
            this.playing.clear();
            this.recycle.clear();
            this.playing = this.recycle = null;
        };
        return ParticleSubEmitterNodePhase;
    }());
    egret3d.ParticleSubEmitterNodePhase = ParticleSubEmitterNodePhase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * 追踪某个固定位置
    */
    var ParticleTrackPositionNode = (function (_super) {
        __extends(ParticleTrackPositionNode, _super);
        function ParticleTrackPositionNode() {
            _super.call(this);
            this._verticesDataDirty = true;
            //##FilterBegin## ##Particle##
            this.name = "ParticleTrackPositionNode";
            this.importShader(true, egret3d.ShaderPhaseType.local_vertex, "particle_trackPosition");
            this.attribute_trackPosition = new egret3d.GLSL.VarRegister();
            this.attribute_trackPosition.name = "attribute_trackPosition";
            this.attribute_trackPosition.size = 3;
            this.attributes.push(this.attribute_trackPosition);
            //##FilterEnd##
        }
        Object.defineProperty(ParticleTrackPositionNode.prototype, "endCoords", {
            get: function () {
                return this._toCoords;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 将粒子的出生位置设置为原结束为止，然后重新设置结束位置
        * @param fromCoords 粒子出生位置列表
        * @param endCoords 粒子目标位置列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleTrackPositionNode.prototype.trackPosition = function (fromCoords, endCoords) {
            //##FilterBegin## ##Particle##
            if (fromCoords.length != this._count || endCoords.length != this._count) {
                throw new Error("count don't match!");
            }
            var index;
            var positionIndex = this._animationState.emitter.positionNode.offsetIndex;
            var geometry = this._animationState.emitter.geometry;
            var vertices = geometry.vertexCount / this._count;
            for (var i = 0; i < this._count; ++i) {
                var fromPos = fromCoords[i];
                var toPos = endCoords[i];
                //创建位置
                for (var j = 0; j < vertices; ++j) {
                    //from
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + positionIndex;
                    geometry.vertexArray[index + 0] = fromPos.x;
                    geometry.vertexArray[index + 1] = fromPos.y;
                    geometry.vertexArray[index + 2] = fromPos.z;
                    //end
                    index = i * vertices + j;
                    index = index * geometry.vertexAttLength + this.attribute_trackPosition.offsetIndex;
                    geometry.vertexArray[index + 0] = toPos.x;
                    geometry.vertexArray[index + 1] = toPos.y;
                    geometry.vertexArray[index + 2] = toPos.z;
                }
            }
            this._toCoords = endCoords;
            this._verticesDataDirty = true;
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleTrackPositionNode.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy) {
            //##FilterBegin## ##Particle##
            if (this._verticesDataDirty) {
                geometry.geometry.upload(context3DProxy);
                this._verticesDataDirty = false;
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充粒子过程旋转数据
        * @param data ParticleDataNode 粒子数据来源
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleTrackPositionNode.prototype.initNode = function (data) {
            //##FilterBegin## ##Particle##
            //var node: ParticleDataRotationSpeed = <ParticleDataRotationSpeed>data;
            this._trackPosition = new egret3d.CubeVector3DValueShape();
            this._trackPosition.depth = 200;
            this._trackPosition.width = 300;
            this._trackPosition.height = 100;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 填充顶点数据
        * @param geometry 网格数据
        * @param count 粒子数量
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleTrackPositionNode.prototype.build = function (geometry, count) {
            //##FilterBegin## ##Particle##
            this._animationState = this.state;
            this._count = count;
            //##FilterEnd##
        };
        /**
        * @private
        * 构建结束后需要清理掉临时数据
        */
        ParticleTrackPositionNode.prototype.afterBuild = function () {
            //##FilterBegin## ##Particle##
            this._trackPosition.dispose();
            this._trackPosition = null;
            //##FilterEnd##
        };
        /**
        * @private
        */
        ParticleTrackPositionNode.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._trackPosition = null;
        };
        return ParticleTrackPositionNode;
    }(egret3d.AnimationNode));
    egret3d.ParticleTrackPositionNode = ParticleTrackPositionNode;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.ParticleAnimationState
     * @classdesc
     * 粒子动画状态机，继承自IAnimationState。ParticleEmitter会自动创建该对象，不建议使用者在外部自行创建该对象。
     * 该类主要用于维护粒子的顶点数据/shader拼装/辅助初始化Geometry对象；负责在每次update时更新每个节点，和绘制前的基础数据上传工作。
     * @see egret3d.IAnimationState
     * @see egret3d.AnimationNode
     * @see egret3d.Geometry
     * @see egret3d.ParticleData
     * @see egret3d.ParticleAnimation
     * @version Egret 3.0
     * @platform Web,Native
     */
    var ParticleAnimationState = (function () {
        /**
        * @language zh_CN
        * 构造函数，随着ParticleEmitter的初始化，会创建该ParticleAnimationState对象
        * @param name 粒子动画状态名
        * @param emitter 当前粒子动画主体部分
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ParticleAnimationState(name, emitter) {
            /**
            * @language zh_CN
            * 新增顶点个数总量
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.numberOfVertices = 0;
            /**
            * @language zh_CN
            * 新增顶点的长度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.vertexSizeInBytes = 0;
            /**
            * @language zh_CN
            * 动画状态机顶点着色器文件名列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.vertex_shaders = {};
            /**
            * @language zh_CN
            * 动画状态机片段着色器文件名列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.fragment_shaders = {};
            /**
            * @language zh_CN
            * 对于每个面片而言周期时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.modTime = 0;
            /**
            * @language zh_CN
            * 是否反转 1.0是反转 0.0是不反转
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.reverse = 1.0; //0.0/1.0
            /**
            * @language zh_CN
            * 跟随的目标，在被使用的情况下，新出生的粒子会使用这个对象的旋转和位置信息。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.followTarget = null;
            this._particleProperty = new Float32Array(27);
            this._emitter = emitter;
            this.name = name;
            this.animNodes = [];
            this.keyFrames = [];
        }
        Object.defineProperty(ParticleAnimationState.prototype, "emitter", {
            /**
           * @language zh_CN
           * 获取发射器
           * @returns ParticleEmitter
           * @version Egret 3.0
           * @platform Web,Native
           */
            get: function () {
                return this._emitter;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 添加动画功能节点
        * 添加继承 animNodeBase 功能节点 例如粒子的 加速度功能节点，匀速功能节点
        * @param node 节点对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimationState.prototype.addNode = function (node) {
            node.state = this;
            this.animNodes.push(node);
        };
        /**
        * @language zh_CN
        * 移除动画功能节点
        * 删除指定的动画功能节点，但是不能动态删除，需要进行 功能重置
        * @param node 节点对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimationState.prototype.removeNode = function (node) {
            var index = this.animNodes.indexOf(node);
            if (index != -1)
                this.animNodes.splice(index, 1);
        };
        /**
        * @private
        * 强制更新了时间之后，follow数据需要更新
        */
        ParticleAnimationState.prototype.onAnimTimeChange = function () {
            var node;
            for (var i = 0, count = this.animNodes.length; i < count; i++) {
                this.animNodes[i].onAnimTimeChange();
            }
        };
        /**
       * @language zh_CN
       * 清空分配好的动画节点
       * @version Egret 3.0
       * @platform Web,Native
       */
        ParticleAnimationState.prototype.clean = function () {
            this.animNodes.length = 0;
        };
        ParticleAnimationState.prototype.addShaderPhase = function (sourcePhase, targetPhase) {
            //##FilterBegin## ##Particle##
            var names;
            var phase;
            for (phase in sourcePhase) {
                names = sourcePhase[phase];
                for (var i = 0; i < names.length; i++) {
                    targetPhase[phase] = targetPhase[phase] || [];
                    targetPhase[phase].push(names[i]);
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        * @language zh_CN
        * 计算节点
        */
        ParticleAnimationState.prototype.calculate = function (geometry) {
            //##FilterBegin## ##Particle##
            for (var i = 0; i < this.animNodes.length; i++) {
                this.addShaderPhase(this.animNodes[i].vertex_ShaderName, this.vertex_shaders);
                this.addShaderPhase(this.animNodes[i].fragment_ShaderName, this.fragment_shaders);
                var offsetIndex = geometry.vertexAttLength;
                for (var j = 0; j < this.animNodes[i].attributes.length; ++j) {
                    if (this.animNodes[i].attributes[j].size > 0) {
                        this.animNodes[i].attributes[j].offsetIndex = offsetIndex;
                        geometry.vertexAttLength += this.animNodes[i].attributes[j].size;
                        geometry.vertexSizeInBytes += this.animNodes[i].attributes[j].size * 4;
                        geometry.subGeometrys[0].preAttList.push(this.animNodes[i].attributes[j]);
                    }
                    offsetIndex = geometry.vertexAttLength;
                }
            }
            //##FilterEnd##
        };
        /**
        * @private
        * @language zh_CN
        */
        ParticleAnimationState.prototype.fill = function (geometry, maxParticle) {
            //##FilterBegin## ##Particle##
            for (var i = 0; i < this.animNodes.length; i++) {
                this.animNodes[i].build(geometry, maxParticle);
            }
            for (var i = 0; i < this.animNodes.length; i++) {
                this.animNodes[i].afterBuild();
            }
            //##FilterEnd##
        };
        /**
        * @private
        * @language zh_CN
        */
        ParticleAnimationState.prototype.update = function (animTime, delay, geometry) {
            //##FilterBegin## ##Particle##
            for (var i = 0; i < this.animNodes.length; i++) {
                this.animNodes[i].update(animTime, delay, geometry);
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * @private
        */
        ParticleAnimationState.prototype.activeState = function (time, animTime, delay, animDelay, usage, geometry, context3DProxy, camera3D) {
            //##FilterBegin## ##Particle##
            var scaleData;
            var rotateData;
            var positionData;
            var data = this._emitter.data;
            if (data.followTarget && this._emitter.followTarget) {
                scaleData = this._emitter.followTarget.globalScale;
                rotateData = this._emitter.followTarget.globalOrientation;
                positionData = this._emitter.followTarget.globalPosition;
            }
            else {
                scaleData = this._emitter.globalScale;
                rotateData = this._emitter.globalOrientation;
                positionData = this._emitter.globalPosition;
            }
            var multiAlpha = this._emitter.material.materialData.blendMode == egret3d.BlendMode.ALPHA;
            //
            this._particleProperty[0] = animTime * 0.001;
            this._particleProperty[1] = data.life.loop ? 1 : 0;
            this._particleProperty[2] = data.followTarget ? 1 : 0;
            this._particleProperty[3] = scaleData.x;
            this._particleProperty[4] = scaleData.y;
            this._particleProperty[5] = scaleData.z;
            this._particleProperty[6] = rotateData.x;
            this._particleProperty[7] = rotateData.y;
            this._particleProperty[8] = rotateData.z;
            this._particleProperty[9] = rotateData.w;
            this._particleProperty[10] = positionData.x;
            this._particleProperty[11] = positionData.y;
            this._particleProperty[12] = positionData.z;
            this._particleProperty[13] = this.modTime;
            this._particleProperty[14] = data.life.delay;
            this._particleProperty[15] = data.life.duration;
            this._particleProperty[16] = data.property.gravity;
            this._particleProperty[17] = (data.moveSpeed.velocityOver && data.moveSpeed.velocityOver.worldSpace) ? 1 : 0;
            this._particleProperty[18] = (data.moveSpeed.velocityForce && data.moveSpeed.velocityForce.worldSpace) ? 1 : 0;
            this._particleProperty[19] = data.moveSpeed.velocityLimit ? data.moveSpeed.velocityLimit.dampen : 0;
            this._particleProperty[20] = data.property.cameraScale;
            this._particleProperty[21] = data.property.speedScale;
            this._particleProperty[22] = data.property.lengthScale;
            this._particleProperty[23] = data.property.renderMode;
            this._particleProperty[24] = data.property.stayAtEnd ? 1 : 0;
            this._particleProperty[25] = multiAlpha ? 1 : 0;
            this._particleProperty[26] = data.shape.type;
            context3DProxy.uniform1fv(usage["uniform_particleState"].uniformIndex, this._particleProperty);
            for (var i = 0; i < this.animNodes.length; i++) {
                this.animNodes[i].activeState(time, animTime, delay, animDelay, usage, geometry, context3DProxy);
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 释放所有数据，销毁该对象的内部属性
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimationState.prototype.dispose = function () {
            var node;
            for (var _i = 0, _a = this.animNodes; _i < _a.length; _i++) {
                node = _a[_i];
                node.dispose();
            }
            this.animNodes.length = 0;
            this.animNodes = null;
            this.keyFrames.length = 0;
            this.keyFrames = null;
        };
        return ParticleAnimationState;
    }());
    egret3d.ParticleAnimationState = ParticleAnimationState;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @classdesc
    * 粒子动画的实现IAnimation的部分，ParticleEmitter会自动创建该对象，不建议使用者在外部自行创建该对象。
    * 主要用于控制粒子的播放/暂停/更改播放速度/粒子的帧刷新，控制当前粒子所有节点的数据更新等。
    * @see egret3d.IAnimation
    * @see egret3d.EventDispatcher
    * @see egret3d.ParticleData
    * @see egret3d.ParticleAnimationState
    * @class egret3d.ParticleAnimation
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleAnimation = (function (_super) {
        __extends(ParticleAnimation, _super);
        /**
        * @language zh_CN
        * 构造函数，创建一个ParticleAnimation对象
        * @param emitter 该动画对应粒子发射器对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ParticleAnimation(emitter) {
            _super.call(this);
            /**
            * @language zh_CN
            * 总时间，加成过特效播放速度后的时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.animTime = 0;
            this._event3D = new egret3d.AnimationEvent3D();
            this._lastAnimTime = 0;
            /**
            * @language zh_CN
            * 帧间隔时间
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.delay = 0;
            /**
            * @language zh_CN
            * 一个完整的动画播放时间周期
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.loopTime = 0;
            /**
            * @language zh_CN
            * 播放速度，注意0的情况（x/0=?）
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.speed = 1;
            /**
            * @language zh_CN
            * 是否在播放
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._play = false;
            this.animStates = [];
            this.particleAnimationState = new egret3d.ParticleAnimationState("particle", emitter);
            this.addAnimState(this.particleAnimationState);
        }
        /**
        * @private
        * @language zh_CN
        * 更新调度
        * @param time 总时间
        * @param delay 帧间隔时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimation.prototype.update = function (time, delay, geometry) {
            if (ParticleAnimation.Reset) {
                this.animTime = 0;
            }
            if (this._play && this.speed != 0) {
                this.animTime += delay * this.speed;
                this.particleAnimationState.update(this.animTime, delay, geometry);
                if (this.isLoop == false) {
                    var endTime = this.loopTime * 1000;
                    if (this._lastAnimTime <= endTime && this.animTime > endTime) {
                        this._event3D.eventType = egret3d.AnimationEvent3D.COMPLETE;
                        this._event3D.target = this;
                        this.dispatchEvent(this._event3D);
                    }
                }
                this._lastAnimTime = this.animTime;
            }
        };
        /**
       * @private
       * @language zh_CN
       * 将粒子信息更新给GPU
       * @param time 当前时间
       * @param delay 当前帧时间
       * @param usage PassUsage
       * @param geometry 子几何信息
       * @param context3DProxy 上下文信息
       * @param modeltransform 模型矩阵
       * @param camera3D 相机
       * @version Egret 3.0
       * @platform Web,Native
       */
        ParticleAnimation.prototype.activeState = function (time, delay, usage, geometry, context3DProxy, modeltransform, camera3D) {
            if (this.particleAnimationState) {
                this.particleAnimationState.activeState(time, this.animTime, delay, delay, usage, geometry, context3DProxy, camera3D);
            }
        };
        /**
        * @language zh_CN
        * 播放该粒子动画，你可以使用stop函数暂停该粒子的播放
        * @param animName 动画名称
        * @param speed 播放速度（默认为1）
        * @param reset 是否从头播放
        * @param prewarm 是否预热
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimation.prototype.play = function (animName, speed, reset, prewarm) {
            if (speed === void 0) { speed = 1; }
            if (reset === void 0) { reset = true; }
            if (prewarm === void 0) { prewarm = true; }
            this._play = true;
            if (reset) {
                this.animTime = 0;
            }
            if (prewarm) {
                this.animTime = this.particleAnimationState.modTime;
            }
            if (prewarm || reset) {
                this.particleAnimationState.onAnimTimeChange();
            }
            this.speed = speed;
        };
        /**
        * @language zh_CN
        * 暂停播放该粒子，你可以在之后使用play函数继续播放该动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimation.prototype.stop = function () {
            this._play = false;
        };
        /**
        * @language zh_CN
        * 获取当前粒子是否正在播放
        * @returns 是否播放中
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimation.prototype.isPlay = function () {
            return this._play;
        };
        /**
        * @language zh_CN
        * 添加动画状态
        * @param animState IAnimationState给改动画添加一个控制器，应该为ParticleAnimationState的实例。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimation.prototype.addAnimState = function (animState) {
            var has = this.animStates.indexOf(animState);
            if (has == -1)
                this.animStates.push(animState);
        };
        /**
        * @language zh_CN
        * 移除一个动画状态机
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleAnimation.prototype.removeAnimState = function (animState) {
            var has = this.animStates.indexOf(animState);
            if (has != -1)
                this.animStates.splice(has, 1);
        };
        /**
        * @private
        * @language zh_CN
        * 获取动画列表
        * @returns 动画名称列表
        */
        ParticleAnimation.prototype.getAnimList = function () {
            return [];
        };
        /**
        * @private
        * @language zh_CN
        * 获取动画节点
        * @returns 动画节点数组
        */
        ParticleAnimation.prototype.getAnimNode = function () {
            return [];
        };
        /**
        * @private
        * @language zh_CN
        * 克隆新的ParticleAnimation对象;
        * @returns 新的ParticleAnimation对象
        */
        ParticleAnimation.prototype.clone = function () {
            return null;
        };
        return ParticleAnimation;
    }(egret3d.EventDispatcher));
    egret3d.ParticleAnimation = ParticleAnimation;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @private
    * 粒子数据节点类型，加载自粒子数据配置文件后，创建生成
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleDataNodeType) {
        //以下类型必须有
        ParticleDataNodeType[ParticleDataNodeType["Property"] = 0] = "Property";
        ParticleDataNodeType[ParticleDataNodeType["Emission"] = 1] = "Emission";
        ParticleDataNodeType[ParticleDataNodeType["Life"] = 2] = "Life";
        ParticleDataNodeType[ParticleDataNodeType["Shape"] = 3] = "Shape";
        ParticleDataNodeType[ParticleDataNodeType["RotationBirth"] = 4] = "RotationBirth";
        ParticleDataNodeType[ParticleDataNodeType["ScaleBirth"] = 5] = "ScaleBirth";
        ParticleDataNodeType[ParticleDataNodeType["Geometry"] = 6] = "Geometry";
        ParticleDataNodeType[ParticleDataNodeType["MoveSpeed"] = 7] = "MoveSpeed";
        //其他挂接节点
        ParticleDataNodeType[ParticleDataNodeType["FollowTarget"] = 8] = "FollowTarget";
        ParticleDataNodeType[ParticleDataNodeType["ScaleSize"] = 9] = "ScaleSize";
        ParticleDataNodeType[ParticleDataNodeType["RotationSpeed"] = 10] = "RotationSpeed";
        ParticleDataNodeType[ParticleDataNodeType["ColorOffset"] = 11] = "ColorOffset";
        ParticleDataNodeType[ParticleDataNodeType["TextureSheet"] = 12] = "TextureSheet";
    })(egret3d.ParticleDataNodeType || (egret3d.ParticleDataNodeType = {}));
    var ParticleDataNodeType = egret3d.ParticleDataNodeType;
    /**
    * @language zh_CN
    * 子发射器阶段，枚举出子粒子会在哪个阶段触发创建规则
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleDataSubEmitterPhase) {
        /**
        * @language zh_CN
        * 出生阶段，子粒子会在母粒子的某个单元出生的同时创建，并绑定该粒子单元的位置和旋转信息
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleDataSubEmitterPhase[ParticleDataSubEmitterPhase["BIRTH"] = 0] = "BIRTH";
        /**
        * @language zh_CN
        * 碰撞阶段，子粒子会在母粒子的某个单元触发碰撞的同时创建，并绑定该粒子单元的位置和旋转信息（待实现）
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleDataSubEmitterPhase[ParticleDataSubEmitterPhase["COLLISION"] = 1] = "COLLISION";
        /**
        * @language zh_CN
        * 死亡阶段，子粒子会在母粒子的某个单元消失的同时创建，并绑定该粒子单元的位置和旋转信息（待实现）
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleDataSubEmitterPhase[ParticleDataSubEmitterPhase["DEATH"] = 2] = "DEATH";
    })(egret3d.ParticleDataSubEmitterPhase || (egret3d.ParticleDataSubEmitterPhase = {}));
    var ParticleDataSubEmitterPhase = egret3d.ParticleDataSubEmitterPhase;
    /**
    * @language zh_CN
    * 粒子数据中，大部分的节点数据都需要指定类型。可以有单常量/限定范围取值常量/单贝塞尔曲线/双贝塞尔曲线，一共四种。
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleValueType) {
        /**
        * @language zh_CN
        * 常量形式，粒子单元的属性都使用固定的某个数值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleValueType[ParticleValueType["Const"] = 0] = "Const";
        /**
        * @language zh_CN
        * 两个常量之间随机，粒子单元的属性在指定的两个值之间随机取值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleValueType[ParticleValueType["RandomConst"] = 1] = "RandomConst";
        /**
        * @language zh_CN
        * 单贝塞尔曲线，粒子单元的属性在按照一个贝塞尔曲线描述的规律下进行取值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleValueType[ParticleValueType["OneBezier"] = 2] = "OneBezier";
        /**
        * @language zh_CN
        * 双贝塞尔曲线，粒子单元的属性在贝塞尔曲线a和贝塞尔曲线b之间取完值va和vb之后，于va和vb之间随机取值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleValueType[ParticleValueType["TwoBezier"] = 3] = "TwoBezier";
    })(egret3d.ParticleValueType || (egret3d.ParticleValueType = {}));
    var ParticleValueType = egret3d.ParticleValueType;
    /**
    * @language zh_CN
    * 枚举出粒子的面向相机模式，粒子的每个单元渲染时候用到的相机对准方式。
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleRenderModeType) {
        /**
        * @language zh_CN
        * 公告板形式：粒子的单元会始终面向相机。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRenderModeType[ParticleRenderModeType["Billboard"] = 0] = "Billboard";
        /**
        * @language zh_CN
        * 指向运动方向的公告板：粒子单元在面向相机的同时，根据自身的运动方向旋转Z轴，使其Z轴旋转指向运动方向。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRenderModeType[ParticleRenderModeType["StretchedBillboard"] = 1] = "StretchedBillboard";
        /**
        * @language zh_CN
        * 横向公告板：粒子单元会在X轴方向翻转至水平之后，保持Y方向始终面向相机。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRenderModeType[ParticleRenderModeType["HorizontalBillboard"] = 2] = "HorizontalBillboard";
        /**
        * @language zh_CN
        * 纵向公告板：粒子单元会在X轴方向翻转至竖直之后，保持Y方向始终面向相机。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRenderModeType[ParticleRenderModeType["VerticalBillboard"] = 3] = "VerticalBillboard";
        /**
        * @language zh_CN
        * 模型形式，不接受相机的朝向做任何transform的变换，保持自身的modelMatrix变换。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleRenderModeType[ParticleRenderModeType["Mesh"] = 4] = "Mesh";
    })(egret3d.ParticleRenderModeType || (egret3d.ParticleRenderModeType = {}));
    var ParticleRenderModeType = egret3d.ParticleRenderModeType;
    /**
    * @language zh_CN
    * 枚举出粒子单元，其出生时候的初始颜色数据源的类型。
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleBirthColorType) {
        /**
        * @language zh_CN
        * 常量形式，所有的粒子单元都使用固定的某个数值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleBirthColorType[ParticleBirthColorType["Const"] = 0] = "Const";
        /**
        * @language zh_CN
        * 两个颜色之间随机：粒子单元的某个属性值在指定的两个颜色之间随机采样，作为一个常量使用。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleBirthColorType[ParticleBirthColorType["RandomConst"] = 1] = "RandomConst";
        /**
        * @language zh_CN
        * 单渐变色，使用一个渐变颜色带控制颜色的变化。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleBirthColorType[ParticleBirthColorType["OneGradients"] = 2] = "OneGradients";
        /**
        * @language zh_CN
        * 双渐变色，使用两个渐变颜色带，分别去除颜色a和颜色b之后，计算一个a到b之间的随机插值作为最终数据。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleBirthColorType[ParticleBirthColorType["TwoGradients"] = 3] = "TwoGradients";
    })(egret3d.ParticleBirthColorType || (egret3d.ParticleBirthColorType = {}));
    var ParticleBirthColorType = egret3d.ParticleBirthColorType;
    /**
    * @language zh_CN
    * 发射器形状，控制粒子单元的出生位置区域。通过这个出生位置，可以相应计算出之后的运动方向。
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleDataShapeType) {
        /**
        * @language zh_CN
        * 点状发射器，所有的粒子单元都从一个固定的点作为出生位置。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleDataShapeType[ParticleDataShapeType["Point"] = 0] = "Point";
        /**
        * @language zh_CN
        * 立方体状发射器，粒子单元会在这个立方体的表面或者体内随机一个位置出生。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleDataShapeType[ParticleDataShapeType["Cube"] = 1] = "Cube";
        /**
        * @language zh_CN
        * 球形发射器，粒子单元会在这个球体的表面或者体内随机一个位置出生。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleDataShapeType[ParticleDataShapeType["Sphere"] = 2] = "Sphere";
        /**
        * @language zh_CN
        * 半球形发射器，粒子单元会在这个半球体的表面或者体内随机一个位置出生。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleDataShapeType[ParticleDataShapeType["HemiSphere"] = 3] = "HemiSphere";
        /**
        * @language zh_CN
        * 筒状发射器，粒子单元会在这个筒状集合体的表面或者体内随机一个位置出生。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleDataShapeType[ParticleDataShapeType["Cone"] = 4] = "Cone";
        /**
        * @language zh_CN
        * 从外部模型获得发射范围，粒子单元会以这个模型为基准，从它的三角面随机一个点，或者随机边上面获取一个随机点，或者随机一个顶点的作为位置出生。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleDataShapeType[ParticleDataShapeType["Mesh"] = 5] = "Mesh";
        /**
        * @language zh_CN
        * 外部传入的位置作为粒子发射的范围，粒子单元会从传入的点的列表中，随机取一个位置作为位置出生。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleDataShapeType[ParticleDataShapeType["External"] = 6] = "External";
    })(egret3d.ParticleDataShapeType || (egret3d.ParticleDataShapeType = {}));
    var ParticleDataShapeType = egret3d.ParticleDataShapeType;
    /**
    * @language zh_CN
    * 外置模型发射器类型，当发射器类型为ParticleDataShapeType.Mesh类型时，需要指定具体使用哪种规则采样出生位置。
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleMeshShapeType) {
        /**
        * @language zh_CN
        * 顶点发射，粒子单元从几何体的顶点上随机一个位置出生。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleMeshShapeType[ParticleMeshShapeType["Vertex"] = 0] = "Vertex";
        /**
        * @language zh_CN
        * 从三角面上获得发射位置，粒子单元从几何体的三角面内随机一个位置出生。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleMeshShapeType[ParticleMeshShapeType["Triangle"] = 1] = "Triangle";
        /**
        * @language zh_CN
        * 从三角形的边上获得发射位置，粒子单元从几何体的一条随机边上，随机一个点作为位置出生。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleMeshShapeType[ParticleMeshShapeType["Edge"] = 2] = "Edge";
    })(egret3d.ParticleMeshShapeType || (egret3d.ParticleMeshShapeType = {}));
    var ParticleMeshShapeType = egret3d.ParticleMeshShapeType;
    /**
    * @language zh_CN
    * 发射器类型为圆筒发射器类型：ParticleDataShapeType.Cone，此时对应的在圆筒内具体部位
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (ParticleConeShapeType) {
        /**
        * @language zh_CN
        * 底部发射，指定为圆筒发射器的底部圆。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleConeShapeType[ParticleConeShapeType["Base"] = 0] = "Base";
        /**
        * @language zh_CN
        * 底部边缘发射，指定为圆筒发射器的底部圆的边缘。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleConeShapeType[ParticleConeShapeType["BaseShell"] = 1] = "BaseShell";
        /**
        * @language zh_CN
        * 体内发射，指定为圆筒发射器的体内。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleConeShapeType[ParticleConeShapeType["Volume"] = 2] = "Volume";
        /**
        * @language zh_CN
        * 体内的边缘发射，指定为圆筒发射器的圆筒的边缘曲面。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleConeShapeType[ParticleConeShapeType["VolumeShell"] = 3] = "VolumeShell";
    })(egret3d.ParticleConeShapeType || (egret3d.ParticleConeShapeType = {}));
    var ParticleConeShapeType = egret3d.ParticleConeShapeType;
    /**
    * @language zh_CN
    * @class egret3d.ParticleData
    * @classdesc
    * 创建一个粒子，所用到的数据对象，通过UnitLoader加载粒子的配置表，解析之后会自动生成该对象。
    * 或者您可以自己主动创建一个该对象，描述粒子如何生成/变化/消失。
    * @see egret3d.ParticeEmitter
    * @see egret3d.IAnimation
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleData = (function () {
        /**
        * @language zh_CN
        * 构造函数，该数据一般由粒子的loader加载完文件后创建；您也可以自己手动编码生成，然后使用
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ParticleData() {
            /**
            * @language zh_CN
            * 粒子的基础属性部分数据，如颜色/最大数量限制/是否自启动等。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.property = new ParticleDataProperty();
            /**
            * @language zh_CN
            * 发射速率相关数据，指定了粒子单元出现的规则，例如1秒内发射的个数和在某个时间点爆发的个数等。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.emission = new ParticleDataEmission();
            /**
            * @language zh_CN
            * 生命周期相关数据，指定了粒子单元的出生时间和存活时间的分布规则。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.life = new ParticleDataLife();
            /**
            * @language zh_CN
            * 发射器相关数据，指定了粒子单元如何获得初始位置和运动方向信息。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.shape = new ParticleDataShape();
            /**
            * @language zh_CN
            * 出生时候的旋转角度数据，指定粒子单元的初始缩放数据，后期会按照一定的规则迭代修改
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.rotationBirth = new ParticleDataRotationBirth();
            /**
            * @language zh_CN
            * 出生时候的缩放数据，指定粒子单元的初始缩放数据，后期会按照一定的规则迭代修改
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.scaleBirth = new ParticleDataScaleBirth();
            /**
            * @language zh_CN
            * 所采用的模型数据，如果粒子的单元为面片，该数据指定了面片的宽度和高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.geometry = new ParticleDataGeometry();
            /**
            * @language zh_CN
            * 运动数据，描述了粒子单元在存活期间内的运动规则。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.moveSpeed = new ParticleDataMoveSpeed();
        }
        /**
        * @language zh_CN
        * 数据内部进行合法矫正（例如你的粒子的delay为负数，该函数会主动修改delay为0）
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleData.prototype.validate = function () {
            this.property.validate();
            this.emission.validate();
            this.life.validate();
            this.shape.validate();
            this.rotationBirth.validate();
            this.scaleBirth.validate();
            this.geometry.validate();
            this.moveSpeed.validate();
            if (this.scaleSize) {
                this.scaleSize.validate();
            }
            if (this.rotationSpeed) {
                this.rotationSpeed.validate();
            }
            if (this.colorOffset) {
                this.colorOffset.validate();
            }
            if (this.followTarget) {
                this.followTarget.validate();
            }
            if (this.textureSheet) {
                this.textureSheet.validate();
            }
        };
        return ParticleData;
    }());
    egret3d.ParticleData = ParticleData;
    /**
    * @language zh_CN
    * @class egret3d.ParticleDataNode
    * @classdesc
    * 粒子节点的基类，描述粒子属性的节点都继承于此类。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataNode = (function () {
        /**
        * @language zh_CN
        * 构造函数，创建一个粒子节点
        * @param node 节点的类型。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ParticleDataNode(node) {
            this._nodeType = node;
        }
        Object.defineProperty(ParticleDataNode.prototype, "nodeType", {
            /*
            *@private
            */
            get: function () {
                return this._nodeType;
            },
            enumerable: true,
            configurable: true
        });
        return ParticleDataNode;
    }());
    egret3d.ParticleDataNode = ParticleDataNode;
    /**
    * @language zh_CN
    * @class egret3d.ParticleDataProperty
    * @classdesc
    * 粒子的基础属性，粒子的必备属性
    * @see egret3d.ColorGradients
    * @see egret3d.ParticleRenderModeType
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataProperty = (function (_super) {
        __extends(ParticleDataProperty, _super);
        /**
       * @language zh_CN
       * 构造函数，创建一个ParticleDataProperty
       * @version Egret 3.0
       * @platform Web,Native
       */
        function ParticleDataProperty() {
            _super.call(this, ParticleDataNodeType.Property);
            /**
            * @language zh_CN
            * 粒子数量，用于限制同一个时间内允许共存的最大粒子单元数量。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.particleCount = 10;
            /**
            * @language zh_CN
            * 包围盒数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.bounds = new egret3d.Vector3D(10, 10, 10);
            /**
            * @language zh_CN
            * 初始颜色属性，有常量/随机常量/单贝塞尔曲线/双贝塞尔曲线四种选择
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.colorType = ParticleBirthColorType.Const;
            /**
            * @language zh_CN
            * 常量颜色（一），初始颜色为单常量的情况下，使用该数据作为最终数据；<p/>
            * 如果初始颜色类型为随机常量，用colorConst1和colorConst2作为样本，随机插值作为最终数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.colorConst1 = new egret3d.Color(255, 255, 255, 255);
            /**
            * @language zh_CN
            * 常量颜色（二），如果初始颜色类型为随机常量，用colorConst1和colorConst2作为样本，随机插值作为最终数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.colorConst2 = new egret3d.Color(255, 255, 255, 255);
            /**
            * @language zh_CN
            * 重力，粒子单元受重力的影响自由落体运动。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.gravity = 0;
            /**
            * @language zh_CN
            * 是否预热，预热的粒子，在刚开始播放的时候，系统自动分配一个逝去时间，让该粒子看上去已经播放过一阵子，跳过启动播放的开头部分
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.prewarm = false;
            /**
            * @language zh_CN
            * 是否自启动，粒子一旦放入到场景节点中，自动播放该粒子特效
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.playOnAwake = true;
            /**
            * @language zh_CN
            * 旋转信息，粒子模型的旋转数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.rotation = new egret3d.Vector3D(0, 0, 0, 1);
            /**
            * @language zh_CN
            * 缩放信息，粒子模型的缩放数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.scale = new egret3d.Vector3D(1, 1, 1, 1);
            /**
            * @language zh_CN
            * 位置信息，粒子模型的位置数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.position = new egret3d.Vector3D(0, 0, 0, 1);
            /**
            * @language zh_CN
            * 渲染排序参数，修改这个属性会导致粒子渲染的先后顺序，数据越大，越优先渲染
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.sortingFudge = 0;
            /**
            * @language zh_CN
            * 粒子的每个单元渲染时候用到的相机对准方式，默认为公告板模式，请参照ParticleRenderModeType的其他枚举类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.renderMode = ParticleRenderModeType.Billboard;
            /**
            * @private
            * @language zh_CN
            * cameraScale
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cameraScale = 0.0;
            /**
           * @language zh_CN
           * 运动加成缩放，速度越大，当前拉长的系数会越大
           * @version Egret 3.0
           * @platform Web,Native
           */
            this.speedScale = 0.0;
            /**
            * @language zh_CN
            * 长度缩放，数值越大，粒子被拉长的尺度越大
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lengthScale = 1.0;
        }
        /*
        * @private
        */
        ParticleDataProperty.prototype.validate = function () {
            if (this.bounds == null) {
                this.bounds = new egret3d.Vector3D(10, 10, 10);
            }
            if (this.bounds.x < 0) {
                this.bounds.x = 1;
            }
            if (this.bounds.y < 0) {
                this.bounds.y = 1;
            }
            if (this.bounds.z < 0) {
                this.bounds.z = 1;
            }
            if (this.particleCount < 0) {
                this.particleCount = 10;
            }
            if (this.colorConst1 == null) {
                this.colorConst1 = new egret3d.Color(255, 255, 255, 255);
            }
            if (this.colorConst2 == null) {
                this.colorConst2 = new egret3d.Color(255, 255, 255, 255);
            }
            if (this.colorType == ParticleBirthColorType.OneGradients || this.colorType == ParticleBirthColorType.TwoGradients) {
                if (this.colorGradients1 == null) {
                    this.colorGradients1 = new egret3d.ColorGradients();
                }
            }
            if (this.colorType == ParticleBirthColorType.TwoGradients) {
                if (this.colorGradients2 == null) {
                    this.colorGradients2 = new egret3d.ColorGradients();
                }
            }
            if (this.rotation == null) {
                this.rotation = new egret3d.Vector3D(0, 0, 0, 1);
            }
            if (this.scale == null) {
                this.scale = new egret3d.Vector3D(1, 1, 1, 1);
            }
            if (this.position == null) {
                this.rotation = new egret3d.Vector3D(0, 0, 0, 1);
            }
        };
        return ParticleDataProperty;
    }(ParticleDataNode));
    egret3d.ParticleDataProperty = ParticleDataProperty;
    /**
    * @language zh_CN
    * @class egret3d.ParticleDataEmission
    * @classdesc
    * 发射速率相关数据，指定了粒子单元出现的规则，例如1秒内发射的个数和在某个时间点爆发的个数等。
    * @see egret3d.ParticleValueType
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataEmission = (function (_super) {
        __extends(ParticleDataEmission, _super);
        /**
       * @language zh_CN
       * 构造函数，创建一个ParticleDataEmission对象
       * @version Egret 3.0
       * @platform Web,Native
       */
        function ParticleDataEmission() {
            _super.call(this, ParticleDataNodeType.Emission);
            /**
            * @language zh_CN
            * 指定粒子单元按照每秒发射的出来的速度，如果是0，则不会发射粒子
            * 两外，bursts里面也可以设定发射粒子请参照egret3d.ParticleDataEmission.bursts;
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.rate = 10;
            /**
            * @language zh_CN
            * 指定数据类型，可以有单常量/限定范围取值常量/单贝塞尔曲线/双贝塞尔曲线，四种类型。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.type = ParticleValueType.Const;
            /**
            * @language zh_CN
            * 发射速率指定为单贝塞尔曲线时候，用到的贝塞尔曲线数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.bezier = new egret3d.BezierData();
        }
        /*
        * @private
        */
        ParticleDataEmission.prototype.validate = function () {
            if (this.rate < 0) {
                this.rate = 0.00001;
            }
            if (this.type == ParticleValueType.OneBezier) {
                if (this.bezier == null) {
                    this.bezier = new egret3d.BezierData();
                }
                this.bezier.validate();
            }
        };
        return ParticleDataEmission;
    }(ParticleDataNode));
    egret3d.ParticleDataEmission = ParticleDataEmission;
    /**
    * @language zh_CN
    * @class egret3d.ParticleDataLife
    * @classdesc
    * 粒子生命周期数据，指定粒子单元出生后的存活时间，以及每个粒子单元存活时间各自不同的规则
    * @see egret3d.ParticleValueType
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataLife = (function (_super) {
        __extends(ParticleDataLife, _super);
        /**
       * @language zh_CN
       * 构造函数，创建一个ParticleDataLife
       * @version Egret 3.0
       * @platform Web,Native
       */
        function ParticleDataLife() {
            _super.call(this, ParticleDataNodeType.Life);
            /**
            * @language zh_CN
            * 指定数据类型，可以有单常量/限定范围取值常量/单贝塞尔曲线/双贝塞尔曲线，四种类型。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.type = ParticleValueType.Const;
            /**
            * @language zh_CN
            * 类型为随机常量时，指定的最大值；如果类型为常量时，max和min相等
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.max = 0;
            /**
            * @language zh_CN
            * 类型为随机常量时，指定的最小值；如果类型为常量时，max和min相等
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.min = 0;
            /**
            * @language zh_CN
            * 发射器存活时间，如果是loop粒子，该参数不一定生效
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.duration = 5;
            /**
            * @language zh_CN
            * 粒子发射前的等待时间，在0-delay时间内，不会有粒子单元出生
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.delay = 0;
            /**
            * @language zh_CN
            * 是否循环，循环的粒子会在播放了一段时间之后，自动重复播放
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.loop = true;
        }
        /*
        * @private
        */
        ParticleDataLife.prototype.validate = function () {
            if (this.max <= 0) {
                this.max = 0.000001;
            }
            if (this.min <= 0) {
                this.min = 0.000001;
            }
            //life
            if (this.type == ParticleValueType.Const) {
                this.min = this.max;
            }
            if (this.type == ParticleValueType.RandomConst) {
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
            //delay
            if (this.delay < 0) {
                this.delay = 0;
            }
            //duration
            if (this.duration < 0) {
                this.duration = 5;
            }
        };
        return ParticleDataLife;
    }(ParticleDataNode));
    egret3d.ParticleDataLife = ParticleDataLife;
    /**
    * @language zh_CN
    * @class egret3d.ParticleDataShape
    * @classdesc
    * 粒子发射器形状，指定粒子的每个单元出生的范围。
    * 一旦确定了某粒子单元的出生点之后，根据各自不同的发射器形状，便能够获取到他的默认运动方向。
    * @see egret3d.ParticleDataShapeType
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataShape = (function (_super) {
        __extends(ParticleDataShape, _super);
        /**
        * @language zh_CN
        * 构造函数，创建一个ParticleDataShape实例
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ParticleDataShape() {
            _super.call(this, ParticleDataNodeType.Shape);
            /**
            * @language zh_CN
            * 粒子发射器形状类型，请参照egret3d.ParticleDataShapeType
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.type = ParticleDataShapeType.Point;
            /**
            * @language zh_CN
            * 是否随机方向发射，制定为随机发射方向的粒子，会自动获取一个在xyz三轴随机取值方向作为默认运动方向。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.randomDirection = false;
            /**
            * @language zh_CN
            * 粒子单元是否仅仅在发射器的壳位置发射
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.emitFromShell = false;
            /**
            * @language zh_CN
            * 指定为ParticleDataShapeType.Cube类型时，正方体发射器的宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cubeW = 0;
            /**
            * @language zh_CN
            * 指定为ParticleDataShapeType.Cube类型时，正方体发射器的高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cubeH = 0;
            /**
            * @language zh_CN
            * 指定为ParticleDataShapeType.Cube类型时，正方体发射器的深度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cubeD = 0;
            /**
            * @language zh_CN
            * 指定为ParticleDataShapeType.Sphere类型时，球型发射器的半径
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.sphereRadius = 10;
            /**
            * @language zh_CN
            * 指定为ParticleDataShapeType.HemiSphere类型时，半球型发射器的半径
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.hemiSphereRadius = 10;
            /**
            * @language zh_CN
            * 指定为ParticleDataShapeType.Cone类型时，具体指定粒子出生的区域，详细请参考egret3d.ParticleConeShapeType
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.coneType = ParticleConeShapeType.Volume;
            /**
            * @language zh_CN
            * 指定为ParticleDataShapeType.Cone类型时，圆筒的长度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.coneLength = 10;
            /**
            * @language zh_CN
            * 指定为ParticleDataShapeType.Cone类型时，圆筒的底部半径
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.coneRadius = 10;
            /**
            * @language zh_CN
            * 指定为ParticleDataShapeType.Cone类型时，圆筒的角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.coneAngle = 30;
            /**
            * @language zh_CN
            * 指定为ParticleDataShapeType.Mesh类型时，mesh类型发射器的子类型，具体请参照egret3d.ParticleMeshShapeType
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.meshType = ParticleMeshShapeType.Vertex;
        }
        /*
        * @private
        */
        ParticleDataShape.prototype.validate = function () {
            if (this.type == ParticleDataShapeType.Cube) {
                if (this.cubeW < 0) {
                    this.cubeW = 0;
                }
                if (this.cubeH < 0) {
                    this.cubeH = 0;
                }
                if (this.cubeD < 0) {
                    this.cubeD = 0;
                }
            }
            else if (this.type == ParticleDataShapeType.Sphere) {
                if (this.sphereRadius < 0) {
                    this.sphereRadius = 10;
                }
            }
        };
        return ParticleDataShape;
    }(ParticleDataNode));
    egret3d.ParticleDataShape = ParticleDataShape;
    /**
    * @language zh_CN
    * @class egret3d.ParticleDataRotationBirth
    * @classdesc
    * 出生时候的旋转角度数据，指定粒子单元的初始缩放数据，后期会按照一定的规则迭代修改
    * @see egret3d.ParticleValueType
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataRotationBirth = (function (_super) {
        __extends(ParticleDataRotationBirth, _super);
        /**
       * @language zh_CN
       * 构造函数，创建一个ParticleDataRotationBirth对象
       * @version Egret 3.0
       * @platform Web,Native
       */
        function ParticleDataRotationBirth() {
            _super.call(this, ParticleDataNodeType.RotationBirth);
            /**
            * @language zh_CN
            * 指定数据类型，可以有单常量/限定范围取值常量/单贝塞尔曲线/双贝塞尔曲线，四种类型。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.type = ParticleValueType.Const;
            /**
            * @language zh_CN
            * 类型为随机常量时，指定的最大值；如果类型为常量时，max和min相等
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.max = 0;
            /**
            * @language zh_CN
            * 类型为随机常量时，指定的最小值；如果类型为常量时，max和min相等
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.min = 0;
        }
        /*
        * @private
        */
        ParticleDataRotationBirth.prototype.validate = function () {
            if (this.type == ParticleValueType.Const) {
                this.min = this.max;
            }
            if (this.type == ParticleValueType.RandomConst) {
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
        };
        return ParticleDataRotationBirth;
    }(ParticleDataNode));
    egret3d.ParticleDataRotationBirth = ParticleDataRotationBirth;
    /**
    * @language zh_CN
    * @class egret3d.ParticleDataScaleBirth
    * @classdesc
    * 粒子初始缩放值，指定粒子单元出生时候的默认缩放值，以及在每个粒子之间默认缩放值的变化规律
    * @see egret3d.ParticleValueType
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataScaleBirth = (function (_super) {
        __extends(ParticleDataScaleBirth, _super);
        /**
       * @language zh_CN
       * 构造函数，创建一个ParticleDataScaleBirth对象
       * @version Egret 3.0
       * @platform Web,Native
       */
        function ParticleDataScaleBirth() {
            _super.call(this, ParticleDataNodeType.ScaleBirth);
            /**
            * @language zh_CN
            * 指定数据类型，可以有单常量/限定范围取值常量/单贝塞尔曲线/双贝塞尔曲线，四种类型。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.type = ParticleValueType.Const;
            /**
            * @language zh_CN
            * 类型为随机常量时，指定的最大值；如果类型为常量时，max和min相等
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.max = 1;
            /**
            * @language zh_CN
            * 类型为随机常量时，指定的最小值；如果类型为常量时，max和min相等
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.min = 1;
        }
        /*
        * @private
        */
        ParticleDataScaleBirth.prototype.validate = function () {
            if (this.type == ParticleValueType.Const) {
                this.min = this.max;
            }
            if (this.type == ParticleValueType.RandomConst) {
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
        };
        return ParticleDataScaleBirth;
    }(ParticleDataNode));
    egret3d.ParticleDataScaleBirth = ParticleDataScaleBirth;
    /**
    * @language zh_CN
    * @class egret3d.ParticleDataGeometry
    * @classdesc
    * 粒子模型，指定粒子单元出生时候的宽度和高度，如果粒子单元的模型为外部模型，该值不生效
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataGeometry = (function (_super) {
        __extends(ParticleDataGeometry, _super);
        /**
       * @language zh_CN
       * 构造函数，创建一个ParticleDataGeometry对象
       * @version Egret 3.0
       * @platform Web,Native
       */
        function ParticleDataGeometry() {
            _super.call(this, ParticleDataNodeType.Geometry);
            /**
            * @language zh_CN
            * 指定面片的宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.planeW = 10;
            /**
            * @language zh_CN
            * 指定面片的高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.planeH = 10;
        }
        /*
        * @private
        */
        ParticleDataGeometry.prototype.validate = function () {
            if (this.planeW < 0) {
                this.planeW = 10;
            }
            if (this.planeH < 0) {
                this.planeH = 10;
            }
        };
        return ParticleDataGeometry;
    }(ParticleDataNode));
    egret3d.ParticleDataGeometry = ParticleDataGeometry;
    /**
    * @language zh_CN
    * @class egret3d.ParticleDataMoveSpeed
    * @classdesc
    * 粒子移动速度，指定粒子单元在存活期内的移动速度变化规律，粒子的运动会叠加有：
    * 1，默认朝向下的默认速度
    * 2，重力
    * 3，速度叠加
    * 4，速度限制
    * 5，外部推力
    * @see egret3d.ParticleValueType
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataMoveSpeed = (function (_super) {
        __extends(ParticleDataMoveSpeed, _super);
        /**
       * @language zh_CN
       * 构造函数，创建一个ParticleDataMoveSpeed对象
       * @version Egret 3.0
       * @platform Web,Native
       */
        function ParticleDataMoveSpeed() {
            _super.call(this, ParticleDataNodeType.MoveSpeed);
            /**
            * @language zh_CN
            * 指定数据类型，可以有单常量/限定范围取值常量/单贝塞尔曲线/双贝塞尔曲线，四种类型。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.type = ParticleValueType.Const;
            /**
            * @language zh_CN
            * 类型为随机常量时，指定的最大值；如果类型为常量时，max和min相等
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.max = 0;
            /**
            * @language zh_CN
            * 类型为随机常量时，指定的最小值；如果类型为常量时，max和min相等
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.min = 0;
        }
        /*
        * @private
        */
        ParticleDataMoveSpeed.prototype.validate = function () {
            if (this.velocityOver) {
                this.velocityOver.validate();
            }
            if (this.velocityLimit) {
                this.velocityLimit.validate();
            }
            if (this.velocityForce) {
                this.velocityForce.validate();
            }
            if (this.type == ParticleValueType.Const) {
                this.min = this.max;
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
        };
        return ParticleDataMoveSpeed;
    }(ParticleDataNode));
    egret3d.ParticleDataMoveSpeed = ParticleDataMoveSpeed;
    /**
    * @language zh_CN
    * @class egret3d.VelocityLimitLifeTimeData
    * @classdesc
    * 粒子限速数据，粒子在存活时间内，运动的时候设定一个速度范围
    * @see egret3d.ParticleValueType
    * @version Egret 3.0
    * @platform Web,Native
    */
    var VelocityLimitLifeTimeData = (function () {
        /**
        * @language zh_CN
        * 构造函数，创建一个VelocityLimitLifeTimeData对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function VelocityLimitLifeTimeData() {
            /**
            * @language zh_CN
            * 指定数据类型，可以有单常量/限定范围取值常量/单贝塞尔曲线/双贝塞尔曲线，四种类型。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.type = ParticleValueType.Const;
            /**
            * @language zh_CN
            * 类型为随机常量时，指定的最大值；如果类型为常量时，max和min相等
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.max = 0;
            /**
            * @language zh_CN
            * 类型为随机常量时，指定的最小值；如果类型为常量时，max和min相等
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.min = 0;
            /**
            * @language zh_CN
            * 限速抑制值，该值越大，受限制的影响越明显
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.dampen = 0;
            /**
            * @language zh_CN
            * 类型为单贝塞尔曲线或者双贝塞尔曲线时，用到的贝塞尔曲线一
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.bezier1 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 类型为双贝塞尔曲线时，用到的贝塞尔曲线二
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.bezier2 = new egret3d.BezierData();
        }
        /*
        * @private
        */
        VelocityLimitLifeTimeData.prototype.validate = function () {
            if (this.max < 0) {
                this.max = 0;
            }
            if (this.min < 0) {
                this.min = 0;
            }
            this.dampen = this.dampen || 0;
            if (this.type == ParticleValueType.Const) {
                this.min = this.max;
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
        };
        return VelocityLimitLifeTimeData;
    }());
    egret3d.VelocityLimitLifeTimeData = VelocityLimitLifeTimeData;
    /**
    * @language zh_CN
    * @class egret3d.VelocityOverLifeTimeData
    * @classdesc
    * 粒子速度叠加，指定粒子单元的运动受到一个叠加速度影响，该叠加速度可以是世界坐标系方向或者本地坐标系两种类型。
    * @see egret3d.ParticleValueType
    * @version Egret 3.0
    * @platform Web,Native
    */
    var VelocityOverLifeTimeData = (function () {
        function VelocityOverLifeTimeData() {
            /**
            * @language zh_CN
            * 指定数据类型，可以有单常量/限定范围取值常量/单贝塞尔曲线/双贝塞尔曲线，四种类型。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.type = ParticleValueType.Const;
            /**
            * @language zh_CN
            * 速度叠加范围上限，xyz分别为坐标系的3个朝向，w无效
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.max = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 速度叠加范围下限，xyz分别为坐标系的3个朝向，w无效
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.min = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 指定叠加速度是世界坐标系方向或者本地坐标系：true为世界坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.worldSpace = false;
            /**
            * @language zh_CN
            * 当数据类型为单贝塞尔曲线或者双贝塞尔曲线时，x轴用到的贝塞尔曲线一
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.xBezier1 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 当数据类型为单贝塞尔曲线或者双贝塞尔曲线时，y轴用到的贝塞尔曲线一
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.yBezier1 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 当数据类型为单贝塞尔曲线或者双贝塞尔曲线时，z轴用到的贝塞尔曲线一
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.zBezier1 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 当数据类型为双贝塞尔曲线时，x轴用到的贝塞尔曲线二
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.xBezier2 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 当数据类型为双贝塞尔曲线时，y轴用到的贝塞尔曲线二
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.yBezier2 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 当数据类型为双贝塞尔曲线时，z轴用到的贝塞尔曲线二
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.zBezier2 = new egret3d.BezierData();
        }
        /*
        * @private
        */
        VelocityOverLifeTimeData.prototype.validate = function () {
            if (this.max == null) {
                this.max = new egret3d.Vector3D();
            }
            if (this.min == null) {
                this.min = this.max.clone();
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.xBezier1 == null) {
                    this.xBezier1 = new egret3d.BezierData();
                }
                if (this.yBezier1 == null) {
                    this.yBezier1 = new egret3d.BezierData();
                }
                if (this.zBezier1 == null) {
                    this.zBezier1 = new egret3d.BezierData();
                }
                this.xBezier1.validate();
                this.yBezier1.validate();
                this.zBezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.xBezier2 == null) {
                    this.xBezier2 = new egret3d.BezierData();
                }
                if (this.yBezier2 == null) {
                    this.yBezier2 = new egret3d.BezierData();
                }
                if (this.zBezier2 == null) {
                    this.zBezier2 = new egret3d.BezierData();
                }
                this.xBezier2.validate();
                this.yBezier2.validate();
                this.zBezier2.validate();
            }
        };
        return VelocityOverLifeTimeData;
    }());
    egret3d.VelocityOverLifeTimeData = VelocityOverLifeTimeData;
    /**
    * @language zh_CN
    * @class egret3d.VelocityForceLifeTimeData
    * @classdesc
    * 给予粒子一个作用力，指定粒子单元的运动受到一个外部力影响，该力的作用会持续影响粒子的运动，可以是世界坐标系方向或者本地坐标系两种类型。
    * @see egret3d.ParticleValueType
    * @version Egret 3.0
    * @platform Web,Native
    */
    var VelocityForceLifeTimeData = (function () {
        function VelocityForceLifeTimeData() {
            /**
            * @language zh_CN
            * 指定数据类型，可以有单常量/限定范围取值常量/单贝塞尔曲线/双贝塞尔曲线，四种类型。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.type = ParticleValueType.Const;
            /**
            * @language zh_CN
            * 受力范围上限，xyz分别为坐标系的3个朝向，w无效
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.max = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 受力范围下限，xyz分别为坐标系的3个朝向，w无效
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.min = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 指定外部力是世界坐标系方向或者本地坐标系：true为世界坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.worldSpace = false;
            /**
            * @language zh_CN
            * 当数据类型为单贝塞尔曲线或者双贝塞尔曲线时，x轴用到的贝塞尔曲线一
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.xBezier1 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 当数据类型为单贝塞尔曲线或者双贝塞尔曲线时，y轴用到的贝塞尔曲线一
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.yBezier1 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 当数据类型为单贝塞尔曲线或者双贝塞尔曲线时，z轴用到的贝塞尔曲线一
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.zBezier1 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 当数据类型为双贝塞尔曲线时，x轴用到的贝塞尔曲线二
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.xBezier2 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 当数据类型为双贝塞尔曲线时，y轴用到的贝塞尔曲线二
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.yBezier2 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 当数据类型为双贝塞尔曲线时，z轴用到的贝塞尔曲线二
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.zBezier2 = new egret3d.BezierData();
        }
        /*
        * @private
        */
        VelocityForceLifeTimeData.prototype.validate = function () {
            if (this.max == null) {
                this.max = new egret3d.Vector3D();
            }
            if (this.min == null) {
                this.min = this.max.clone();
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.xBezier1 == null) {
                    this.xBezier1 = new egret3d.BezierData();
                }
                if (this.yBezier1 == null) {
                    this.yBezier1 = new egret3d.BezierData();
                }
                if (this.zBezier1 == null) {
                    this.zBezier1 = new egret3d.BezierData();
                }
                this.xBezier1.validate();
                this.yBezier1.validate();
                this.zBezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.xBezier2 == null) {
                    this.xBezier2 = new egret3d.BezierData();
                }
                if (this.yBezier2 == null) {
                    this.yBezier2 = new egret3d.BezierData();
                }
                if (this.zBezier2 == null) {
                    this.zBezier2 = new egret3d.BezierData();
                }
                this.xBezier2.validate();
                this.yBezier2.validate();
                this.zBezier2.validate();
            }
        };
        return VelocityForceLifeTimeData;
    }());
    egret3d.VelocityForceLifeTimeData = VelocityForceLifeTimeData;
    /**
    * @language zh_CN
    * @class egret3d.ParticleDataScaleSize
    * @classdesc
    * 粒子缩放贝塞尔曲线，指定粒子单元的在存活期内，其宽度和高度按照这个贝塞尔曲线的指定的规则变化
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataScaleSize = (function (_super) {
        __extends(ParticleDataScaleSize, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ParticleDataScaleSize() {
            _super.call(this, ParticleDataNodeType.ScaleSize);
            /**
            * @language zh_CN
            * 指定数据类型，可以有单常量/限定范围取值常量/单贝塞尔曲线/双贝塞尔曲线，四种类型。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.type = ParticleValueType.Const;
            /**
            * @language zh_CN
            * 类型为随机常量时，指定的最大值；如果类型为常量时，max和min相等
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.max = 1;
            /**
            * @language zh_CN
            * 类型为随机常量时，指定的最小值；如果类型为常量时，max和min相等
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.min = 1;
            /**
            * @language zh_CN
            * 类型为单贝塞尔曲线或者双贝塞尔曲线时，用到的贝塞尔曲线一
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.bezier1 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 类型为双贝塞尔曲线时，用到的贝塞尔曲线二
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.bezier2 = new egret3d.BezierData();
        }
        /*
        * @private
        */
        ParticleDataScaleSize.prototype.validate = function () {
            if (this.max <= 0) {
                this.max = 0.000001;
            }
            if (this.min <= 0) {
                this.min = 0.000001;
            }
            //type
            if (this.type == ParticleValueType.Const) {
                this.min = this.max;
            }
            if (this.type == ParticleValueType.RandomConst) {
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
        };
        return ParticleDataScaleSize;
    }(ParticleDataNode));
    egret3d.ParticleDataScaleSize = ParticleDataScaleSize;
    /**
    * @language zh_CN
    * @class egret3d.ParticleDataRotationSpeed
    * @classdesc
    * 粒子角速度，指定粒子单元的在存活期内，按照一定的规则持续旋转
    * @see egret3d.ParticleValueType
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataRotationSpeed = (function (_super) {
        __extends(ParticleDataRotationSpeed, _super);
        /**
        * @language zh_CN
        * 构造函数，创建一个ParticleDataRotationSpeed
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ParticleDataRotationSpeed() {
            _super.call(this, ParticleDataNodeType.RotationSpeed);
            /**
            * @language zh_CN
            * 角速度上限，xyz分别为坐标系的3个朝向，w无效
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.max = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 角速度下限，xyz分别为坐标系的3个朝向，w无效
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.min = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 指定数据类型，可以有单常量/限定范围取值常量/单贝塞尔曲线/双贝塞尔曲线，四种类型。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.type = ParticleValueType.Const;
            /**
            * @language zh_CN
            * 类型为单贝塞尔曲线或者双贝塞尔曲线时，用到的贝塞尔曲线一
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.bezier1 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 类型为双贝塞尔曲线时，用到的贝塞尔曲线二
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.bezier2 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 是否三轴同时旋转，通常条件下，粒子只有在围绕Z轴做旋转运动
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.rot3Axis = false;
        }
        /*
        * @private
        */
        ParticleDataRotationSpeed.prototype.validate = function () {
            if (this.max == null) {
                this.max = new egret3d.Vector3D();
            }
            if (this.min == null) {
                this.min = this.max.clone();
            }
            if (this.type == ParticleValueType.OneBezier || this.type == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            if (this.type == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
        };
        return ParticleDataRotationSpeed;
    }(ParticleDataNode));
    egret3d.ParticleDataRotationSpeed = ParticleDataRotationSpeed;
    /**
    * @language zh_CN
    * @class egret3d.ParticleDataColorOffset
    * @classdesc
    * 粒子颜色变化渐变数据，指定粒子单元的在存活期内，其颜色变化规则所采用的渐变数据源
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataColorOffset = (function (_super) {
        __extends(ParticleDataColorOffset, _super);
        /**
       * @language zh_CN
       * 构造函数
       * @version Egret 3.0
       * @platform Web,Native
       */
        function ParticleDataColorOffset() {
            _super.call(this, ParticleDataNodeType.ColorOffset);
            /**
            * @language zh_CN
            * 颜色渐变数据，数据格式为0-1时间范围内，rgba四个通道叠加上对应的颜色。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.data = new egret3d.ColorGradients();
        }
        /*
        * @private
        */
        ParticleDataColorOffset.prototype.validate = function () {
            if (this.data.colors == null) {
                this.data.colors = [];
            }
            if (this.data.times == null) {
                this.data.times = [];
            }
        };
        return ParticleDataColorOffset;
    }(ParticleDataNode));
    egret3d.ParticleDataColorOffset = ParticleDataColorOffset;
    /**
    * @language zh_CN
    * @class egret3d.ParticleDataFollowTarget
    * @classdesc
    * 粒子跟随信息，如果绑定有跟随对象，该数据描述了跟随的详细情况，如是否跟随旋转/跟随缩放（位置为默认跟随）
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataFollowTarget = (function (_super) {
        __extends(ParticleDataFollowTarget, _super);
        /**
        * @language zh_CN
        * 构造函数，创建一个ParticleDataFollowTarget实例
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ParticleDataFollowTarget() {
            _super.call(this, ParticleDataNodeType.FollowTarget);
            /**
            * @language zh_CN
            * 是否跟随目标的旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.followRotation = true;
            /**
            * @language zh_CN
            * 是否跟随目标的缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.followScale = true;
        }
        /*
        * @private
        */
        ParticleDataFollowTarget.prototype.validate = function () {
        };
        return ParticleDataFollowTarget;
    }(ParticleDataNode));
    egret3d.ParticleDataFollowTarget = ParticleDataFollowTarget;
    /**
    * @language zh_CN
    * @class egret3d.ParticleDataTextureSheet
    * @classdesc
    * 粒子材质序列帧数据，指定粒子单元的在存活期内，采样贴图时，按照这个数据所指定的规则，进行uv更新变换。
    * @see egret3d.ParticleValueType
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleDataTextureSheet = (function (_super) {
        __extends(ParticleDataTextureSheet, _super);
        /**
       * @language zh_CN
       * 构造函数，创建一个ParticleDataTextureSheet对象
       * @version Egret 3.0
       * @platform Web,Native
       */
        function ParticleDataTextureSheet() {
            _super.call(this, ParticleDataNodeType.TextureSheet);
            /**
            * @language zh_CN
            * tileX 序列帧划分为多少列
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.tileX = 1;
            /**
            * @language zh_CN
            * tileY 序列帧划分为多少行
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.tileY = 1;
            /**
            * @language zh_CN
            * whole 范围是否为全部帧
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.whole = true;
            /**
            * @language zh_CN
            * frameType 帧控制类型，可以有单常量/限定范围取值常量/单贝塞尔曲线/双贝塞尔曲线，四种类型。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.frameType = ParticleValueType.Const;
            /**
            * @language zh_CN
            * randomRow 是否随机单行，如果为随机单行，则粒子单元会先使用随机取值到一个固定的行号，然后以这个行号作为范围，继续采样序列帧数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.randomRow = false;
            /**
            * @language zh_CN
            * row 指定锁定第几行播放，指定单行的条件下，uv序列帧只会在这个指定行内取值，采样序列帧数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.row = 0;
            /**
            * @language zh_CN
            * 类型为随机常量时，指定的最小值；如果类型为常量时，max和min相等
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.min = 0;
            /**
            * @language zh_CN
            * 类型为随机常量时，指定的最大值；如果类型为常量时，max和min相等
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.max = 0;
            /**
            * @language zh_CN
            * circles 循环播放次数，最小值为1。该数值越大，会导致uv序列帧跳动越快
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.circles = 1;
            /**
            * @language zh_CN
            * 类型为单贝塞尔曲线或者双贝塞尔曲线时，用到的贝塞尔曲线一
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.bezier1 = new egret3d.BezierData();
            /**
            * @language zh_CN
            * 类型为双贝塞尔曲线时，用到的贝塞尔曲线二
            */
            this.bezier2 = new egret3d.BezierData();
        }
        /*
        * @private
        */
        ParticleDataTextureSheet.prototype.validate = function () {
            //
            if (this.tileX < 0) {
                this.tileX = 1;
            }
            this.tileX = Math.floor(this.tileX);
            //
            if (this.tileY < 0) {
                this.tileY = 1;
            }
            this.tileY = Math.floor(this.tileY);
            //
            if (this.max < 0) {
                this.max = 0;
            }
            if (this.min > this.max) {
                this.min = this.max;
            }
            //
            if (this.frameType == ParticleValueType.OneBezier || this.frameType == ParticleValueType.TwoBezier) {
                if (this.bezier1 == null) {
                    this.bezier1 = new egret3d.BezierData();
                }
                this.bezier1.validate();
            }
            //
            if (this.frameType == ParticleValueType.TwoBezier) {
                if (this.bezier2 == null) {
                    this.bezier2 = new egret3d.BezierData();
                }
                this.bezier2.validate();
            }
            //
            if (this.circles < 1) {
                this.circles = 1;
            }
        };
        return ParticleDataTextureSheet;
    }(ParticleDataNode));
    egret3d.ParticleDataTextureSheet = ParticleDataTextureSheet;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.ParticleEmitter
    * @classdesc
    * 粒子发射器的主体，继承自Mesh，封装有粒子的各种动画节点在内。<p/>
    * 根据ParticleData中的包含的每个数据节点，初始化对应的AnimationNode，然后填充Geometry数据和拼装shader。<p/>
    * Egret3D的粒子是基于GPU的粒子，初始化完毕之后，不再使用CPU计算每个粒子的相关数据，如位置变化和颜色变化等。<p/>
    * 通过释放CPU的负担获得更高的运行效率，让你的程序有更多的可能性。
    * 在需要大量使用粒子的环境下，你需要考虑到的是渲染面积和drawcall的数量，从这2方面着手来优化你的程序。
    * @see egret3d.Mesh
    * @see egret3d.Geometry
    * @see egret3d.AnimationNode
    * @see egret3d.ParticleAnimation
    * @see egret3d.ParticleAnimationState
    * @includeExample particle/ParticleEmitter.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleEmitter = (function (_super) {
        __extends(ParticleEmitter, _super);
        /**
        * @language zh_CN
        * 构造函数，创建一个粒子对象，然后添加至场景中后，使用play函数即可。
        * @param data ParticleData 生成粒子的数据来源，该对象描述了该粒子的大部分信息。
        * @param material 粒子用到的材质球数据。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ParticleEmitter(data, material) {
            if (material === void 0) { material = null; }
            _super.call(this, null, material);
            this._isEmitterDirty = true;
            this._userNodes = [];
            // 粒子自动关闭depth写入
            this.material.depthWrite = false;
            //##FilterBegin## ##Particle##
            this.tag.name = "effect";
            this.type = egret3d.IRender.TYPE_PARTICLE_EMIT;
            this._data = data;
            this._externalGeometry = data.property.geometry;
            this.animation = this._particleAnimation = new egret3d.ParticleAnimation(this);
            this.animation.particleAnimationController = this._particleAnimation;
            this._particleState = this._particleAnimation.particleAnimationState;
            this._generator = new egret3d.ParticleLifeGenerator();
            this._particleAnimation.emit = this;
            this.buildParticle();
            this.animation.isLoop = this._data.life.loop;
            //##FilterEnd##
        }
        /**
        * @language zh_CN
        * 将每个粒子单元的出生位置设置为原结束位置。然后重新设置结束位置，以衔接更新追踪到一个新的目标位置。
        * @param fromCoords 粒子出生位置列表
        * @param endCoords 粒子目标位置列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.trackPosition = function (fromCoords, endCoords) {
            if (this._trackPositionNode) {
                this.animation.animTime = 0.0;
                this._trackPositionNode.trackPosition(fromCoords, endCoords);
            }
        };
        Object.defineProperty(ParticleEmitter.prototype, "trackEndCoords", {
            /**
            * @language zh_CN
            * 返回上一次跟踪目标点的列表
            * @returns 粒子目标位置列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._trackPositionNode) {
                    return this._trackPositionNode.endCoords;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleEmitter.prototype, "generator", {
            /**
            * @private
            */
            get: function () {
                return this._generator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleEmitter.prototype, "drawOrder", {
            /**
            * @language zh_CN
            * 渲染排序的参数，数值越大，先渲染。<p/>
            * 例如一个火焰的特效可能同时含有高亮部分和灰色烟雾部分，你可以通过修改它们这个数据强制让灰色烟雾部分获得优先绘制权。
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._data.property.sortingFudge;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * 添加子发射器
        */
        ParticleEmitter.prototype.addSubEmitter = function (phase, subEmitter) {
            //##FilterBegin## ##Particle##
            subEmitter.animation.stop();
            this._subEmitterNode.importSubEmitter(phase, subEmitter);
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * @private
        * 重新构建这个粒子
        * @param geo Geometry 几何数据
        * @param data ParticleData 生成粒子的数据来源
        * @param material 粒子的材质
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.buildParticle = function () {
            //##FilterBegin## ##Particle##
            if (this._externalGeometry == null) {
                this._geometryShape = this.createPlane();
            }
            else {
                this._geometryShape = this._externalGeometry;
            }
            var mode = this._data.property.renderMode;
            if (mode == egret3d.ParticleRenderModeType.Billboard) {
                this.billboard = egret3d.BillboardType.STANDARD;
            }
            else if (mode == egret3d.ParticleRenderModeType.VerticalBillboard || mode == egret3d.ParticleRenderModeType.StretchedBillboard) {
                this.billboard = egret3d.BillboardType.Y_AXIS;
            }
            else {
                //ParticleRenderModeType.HorizontalBillboard
                //ParticleRenderModeType.Mesh
                this.billboard = egret3d.BillboardType.DISABLE;
            }
            this.initialize();
            this.initBoudBox(this._data.property.bounds);
            this._isEmitterDirty = false;
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 根据粒子的配置信息，生成geometry
        * @returns Geometry
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.createPlane = function () {
            var geo;
            //##FilterBegin## ##Particle##
            var geomData = this._data.geometry;
            var defaultAxis = egret3d.Vector3D.Z_AXIS;
            var wCenter = true;
            var hCenter = true;
            if (this._data.property.renderMode == egret3d.ParticleRenderModeType.StretchedBillboard) {
                //需要偏移一半位置
                wCenter = false;
                hCenter = true;
            }
            geo = new egret3d.PlaneGeometry(geomData.planeW, geomData.planeH, 1, 1, 1, 1, defaultAxis, wCenter, hCenter);
            //##FilterEnd##
            return geo;
        };
        Object.defineProperty(ParticleEmitter.prototype, "data", {
            /**
            * @language zh_CN
            * 获取该粒子的描述数据
            * @returns ParticleData 初始化该粒子用到的数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleEmitter.prototype, "timeNode", {
            /**
            * @language zh_CN
            * 获取时间节点
            * @returns ParticleTime 时间节点
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._timeNode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleEmitter.prototype, "positionNode", {
            /**
            * @language zh_CN
            * 获取位置节点，该节点控制每个粒子单元的出生位置，并将数据写入顶点数据中。
            * @returns ParticlePosition 创建粒子单元出生位置的节点。
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._positionNode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ParticleEmitter.prototype, "followTarget", {
            /**
            * @language zh_CN
            * 获取跟随的目标，全局粒子可能会绑定有一个跟随的目标，获得该目标对象
            * @returns Object3D 跟随的目标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._particleState.followTarget;
            },
            /**
            * @language zh_CN
            * 设置跟随的目标，如果设置了，粒子发射器会跟随目标
            * @param o 粒子发射器会跟随目标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (o) {
                this._particleState.followTarget = o;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 给粒子发射器添加 粒子效果节点
        * @param node 粒子效果节点
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.addAnimNode = function (node) {
            //##FilterBegin## ##Particle##
            var index = this._userNodes.indexOf(node);
            if (index == -1) {
                this._userNodes.push(node);
                this._isEmitterDirty = true;
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 移除粒子发射器上的效果节点
        * @param node 粒子效果节点
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.removeAnimNode = function (node) {
            //##FilterBegin## ##Particle##
            var index = this._userNodes.indexOf(node);
            if (index != -1) {
                this._userNodes.slice(index);
                this._isEmitterDirty = true;
            }
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 播放粒子，你可以之后使用stop函数暂停该特效的动画播放
        * @param speed 粒子播放速度
        * @param reset 是否重置到0位置
        * @param prewarm 是否预热
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.play = function (speed, reset, prewarm) {
            if (speed === void 0) { speed = 1; }
            if (reset === void 0) { reset = false; }
            if (prewarm === void 0) { prewarm = false; }
            //##FilterBegin## ##Particle##
            this.animation.play("", speed, reset, prewarm);
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * 暂停播放粒子，你可以再次使用play函数继续该粒子特效播放。
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.stop = function () {
            this.animation.stop();
        };
        /**
        * @private
        */
        ParticleEmitter.prototype.initialize = function () {
            //##FilterBegin## ##Particle##
            //clean
            this._particleAnimation.particleAnimationState.clean();
            this._generator.generator(this._data);
            var count = this._generator.planes.length;
            this.geometry = new egret3d.Geometry();
            this.geometry.buildDefaultSubGeometry();
            this.geometry.subGeometrys[0].count = count * this._geometryShape.indexCount;
            //根据 模型形状初始化 
            var vertexIndex = 0;
            var vertexArray = new Array();
            //根据 动画功能节点初始化 着色器 并初始化粒子顶点结构
            var vf = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_UV0 | egret3d.VertexFormat.VF_COLOR | egret3d.VertexFormat.VF_NORMAL;
            this.geometry.vertexFormat = vf;
            //根据动画节点，预计算顶点信息，长度，字节总量
            this.initMainAnimNode();
            this.initUserAnimNode();
            this.initEndNode();
            this.geometry.vertexCount = count * this._geometryShape.vertexCount;
            this.geometry.indexCount = count * this._geometryShape.indexCount;
            this._geometryShape.getVertexForIndex(0, vf, vertexArray, this._geometryShape.vertexCount);
            for (var i = 0; i < count; ++i) {
                vertexIndex = i * this._geometryShape.vertexCount;
                this.geometry.setVerticesForIndex(vertexIndex, vf, vertexArray, this._geometryShape.vertexCount);
            }
            for (var i = 0; i < count; ++i) {
                for (var j = 0; j < this._geometryShape.indexArray.length; ++j) {
                    this.geometry.indexArray[i * this._geometryShape.indexArray.length + j] = this._geometryShape.indexArray[j] + i * this._geometryShape.vertexCount;
                }
            }
            //最后根据节点功能，填充模型
            this._particleAnimation.particleAnimationState.fill(this.geometry, count);
            //##FilterEnd##
        };
        /**
        * @private
        * 根据ParticleData中的数据初始化
        */
        ParticleEmitter.prototype.initMainAnimNode = function () {
            //##FilterBegin## ##Particle##
            var nodes = [];
            //time 
            this._timeNode = new egret3d.ParticleTime();
            this._timeNode.initNode(this._data.life);
            nodes.push(this._timeNode);
            //position
            this._positionNode = new egret3d.ParticlePosition();
            this._positionNode.initNode(this._data.shape, this._data.property);
            nodes.push(this._positionNode);
            //speed(依赖于position)
            var speedNode = new egret3d.ParticleVelocityNode();
            speedNode.initNode(this._data.moveSpeed);
            nodes.push(speedNode);
            //subEmitter
            this._subEmitterNode = new egret3d.ParticleSubEmitterNode();
            this._subEmitterNode.initNode(null, this);
            this._particleAnimation.particleAnimationState.addNode(this._subEmitterNode);
            //velocity
            var velocityOver = this._data.moveSpeed.velocityOver;
            if (velocityOver) {
                if (velocityOver.type == egret3d.ParticleValueType.Const || velocityOver.type == egret3d.ParticleValueType.RandomConst) {
                    var overConstNode = new egret3d.ParticleVelocityOverConstNode();
                    overConstNode.initNode(this._data.moveSpeed);
                    nodes.push(overConstNode);
                }
                else if (velocityOver.type == egret3d.ParticleValueType.OneBezier) {
                    var overOneBezierNode = new egret3d.ParticleVelocityOverOneBezierNode();
                    overOneBezierNode.initNode(this._data.moveSpeed);
                    nodes.push(overOneBezierNode);
                }
                else if (velocityOver.type == egret3d.ParticleValueType.TwoBezier) {
                    var overTwoBezierNode = new egret3d.ParticleVelocityOverTwoBezierNode();
                    overTwoBezierNode.initNode(this._data.moveSpeed);
                    nodes.push(overTwoBezierNode);
                }
            }
            var limit = this._data.moveSpeed.velocityLimit;
            if (limit) {
                if (limit.type == egret3d.ParticleValueType.Const || limit.type == egret3d.ParticleValueType.RandomConst) {
                    var limitConstNode = new egret3d.ParticleVelocityLimitConstNode();
                    limitConstNode.initNode(this._data.moveSpeed);
                    nodes.push(limitConstNode);
                }
                else if (limit.type == egret3d.ParticleValueType.OneBezier) {
                    var limitOneBezierNode = new egret3d.ParticleVelocityLimitOneBezierNode();
                    limitOneBezierNode.initNode(this._data.moveSpeed);
                    nodes.push(limitOneBezierNode);
                }
                else if (limit.type == egret3d.ParticleValueType.TwoBezier) {
                    var limitTwoBezierNode = new egret3d.ParticleVelocityLimitTwoBezierNode();
                    limitTwoBezierNode.initNode(this._data.moveSpeed);
                    nodes.push(limitTwoBezierNode);
                }
            }
            var velocityForce = this._data.moveSpeed.velocityForce;
            if (velocityForce) {
                if (velocityForce.type == egret3d.ParticleValueType.Const || velocityForce.type == egret3d.ParticleValueType.RandomConst) {
                    var forceConstNode = new egret3d.ParticleVelocityForceConstNode();
                    forceConstNode.initNode(this._data.moveSpeed);
                    nodes.push(forceConstNode);
                }
                else if (velocityForce.type == egret3d.ParticleValueType.OneBezier) {
                    var forceOneBezierNode = new egret3d.ParticleVelocityForceOneBezierNode();
                    forceOneBezierNode.initNode(this._data.moveSpeed);
                    nodes.push(forceOneBezierNode);
                }
                else if (velocityForce.type == egret3d.ParticleValueType.TwoBezier) {
                    var forceTwoBezierNode = new egret3d.ParticleVelocityForceTwoBezierNode();
                    forceTwoBezierNode.initNode(this._data.moveSpeed);
                    nodes.push(forceTwoBezierNode);
                }
            }
            //rotation
            var rotationNode = new egret3d.ParticleRotation();
            rotationNode.initNode(this._data.rotationBirth);
            nodes.push(rotationNode);
            //scale
            var scaleNode = new egret3d.ParticleScale();
            scaleNode.initNode(this._data.scaleBirth);
            nodes.push(scaleNode);
            var scaleSize = new egret3d.ParticleSizeGlobalNode();
            scaleSize.initNode(this._data.scaleSize);
            nodes.push(scaleSize);
            //start color
            var colorNode = new egret3d.ParticleStartColor();
            colorNode.initNode(this._data.property);
            nodes.push(colorNode);
            //follow
            if (this._data.followTarget) {
                var particleFollowNode = new egret3d.ParticleFollowNode();
                particleFollowNode.initNode(this._data.followTarget);
                nodes.push(particleFollowNode);
            }
            if (this._data.rotationSpeed) {
                if (this._data.rotationSpeed.rot3Axis) {
                    var rotateXYZConst = new egret3d.ParticleRotationXYZConstNode();
                    rotateXYZConst.initNode(this._data.rotationSpeed);
                    nodes.push(rotateXYZConst);
                }
                else {
                    if (this._data.rotationSpeed.type == egret3d.ParticleValueType.Const || this._data.rotationSpeed.type == egret3d.ParticleValueType.RandomConst) {
                        var rotateConst = new egret3d.ParticleRotationConstNode();
                        rotateConst.initNode(this._data.rotationSpeed);
                        nodes.push(rotateConst);
                    }
                    else if (this._data.rotationSpeed.type == egret3d.ParticleValueType.OneBezier) {
                        var rotateOneBezier = new egret3d.ParticleRotationOneBezierNode();
                        rotateOneBezier.initNode(this._data.rotationSpeed);
                        nodes.push(rotateOneBezier);
                    }
                    else if (this._data.rotationSpeed.type == egret3d.ParticleValueType.TwoBezier) {
                        var rotateTwoBezier = new egret3d.ParticleRotationTwoBezierNode();
                        rotateTwoBezier.initNode(this._data.rotationSpeed);
                        nodes.push(rotateTwoBezier);
                    }
                }
            }
            if (this._data.colorOffset) {
                var colorOffset = new egret3d.ParticleColorGlobalNode();
                colorOffset.initNode(this._data.colorOffset);
                nodes.push(colorOffset);
            }
            //materialData
            if (this._data.materialData) {
                //uvRoll
                var method;
                for (var _i = 0, _a = this._data.materialData.methods; _i < _a.length; _i++) {
                    method = _a[_i];
                    if (method.type == egret3d.UnitMatMethodData.methodType.lightmapMethod) {
                    }
                    else if (method.type == egret3d.UnitMatMethodData.methodType.uvRollMethod) {
                        var uvNode = new egret3d.ParticleUVRollNode();
                        uvNode.initNode(null, method);
                        nodes.push(uvNode);
                    }
                    else if (method.type == egret3d.UnitMatMethodData.methodType.alphaMaskMethod) {
                    }
                    else if (method.type == egret3d.UnitMatMethodData.methodType.streamerMethod) {
                    }
                }
            }
            //texture sheet
            if (this._data.textureSheet) {
                var textureSheet = new egret3d.ParticleTextureSheetNode();
                textureSheet.initNode(null, this._data.textureSheet);
                nodes.push(textureSheet);
            }
            //track
            if (this._data.property.trackPosition) {
                this._trackPositionNode = new egret3d.ParticleTrackPositionNode();
                this._trackPositionNode.initNode(null);
                nodes.push(this._trackPositionNode);
            }
            //
            for (var i = 0, count = nodes.length; i < count; i++) {
                this._particleAnimation.particleAnimationState.addNode(nodes[i]);
            }
            //##FilterEnd##
        };
        ParticleEmitter.prototype.initUserAnimNode = function () {
            //##FilterBegin## ##Particle##
            //加入自定义节点
            for (var i = 0; i < this._userNodes.length; i++) {
                this._particleAnimation.particleAnimationState.addNode(this._userNodes[i]);
            }
            //##FilterEnd##
        };
        ParticleEmitter.prototype.initEndNode = function () {
            //##FilterBegin## ##Particle##
            //永远是最后一个加入
            var endNode = new egret3d.ParticleEndNode();
            this._particleAnimation.particleAnimationState.addNode(endNode);
            //计算加入动画后，会获取的节点信息，重新计算 geometry 结构
            this._particleAnimation.particleAnimationState.calculate(this.geometry);
            //##FilterEnd##
        };
        /**
        * @language zh_CN
        * @private
        * 构建包围盒
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.initBoudBox = function (vector) {
            //##FilterBegin## ##Particle##
            var b = new egret3d.BoundBox(this);
            b.fillBox(new egret3d.Vector3D(-vector.x / 2, -vector.y / 2, -vector.z / 2), new egret3d.Vector3D(vector.x / 2, vector.y / 2, vector.z / 2));
            this.bound = b;
            this.initAABB();
            //##FilterEnd##
        };
        Object.defineProperty(ParticleEmitter.prototype, "loopProgress", {
            /**
            * @language zh_CN
            * 循环完毕的次数，用于检测是否单个循环结束
            * @returns number 获得这个粒子播放的进度，0-1之间。如果该粒子有循环播放属性，获得的数据无效。
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                var p;
                //##FilterBegin## ##Particle##
                p = this.animation.animTime / (this.animation.loopTime * 1000);
                //##FilterEnd##
                return p;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.update = function (time, delay, camera) {
            //##FilterBegin## ##Particle##
            if (this._isEmitterDirty) {
                this.buildParticle();
            }
            _super.prototype.update.call(this, time, delay, camera);
            //##FilterEnd##
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.copy = function (other) {
            _super.prototype.copy.call(this, other);
            var phaseList = [egret3d.ParticleDataSubEmitterPhase.BIRTH, egret3d.ParticleDataSubEmitterPhase.COLLISION, egret3d.ParticleDataSubEmitterPhase.DEATH];
            if (other._subEmitterNode) {
                for (var j = 0; j < phaseList.length; j++) {
                    var phase = phaseList[j];
                    var emitters = other._subEmitterNode.getSubEmitters(phase);
                    if (emitters && emitters.length > 0) {
                        for (var i = 0; i < emitters.length; i++) {
                            this.addSubEmitter(phase, emitters[i]);
                        }
                    }
                }
            }
        };
        /**
        * @language zh_CN
        * 克隆该粒子个粒子，播放信息需要外部去设置（Geometry为全新创建的，ParticleData和MaterialBase数据共享。）
        * @returns ParticleEmitter 克隆后的粒子特效
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.clone = function () {
            var newParticle;
            //##FilterBegin## ##Particle##
            newParticle = new ParticleEmitter(this.data, this.material);
            newParticle.copy(this);
            //##FilterEnd##
            return newParticle;
        };
        /**
        * @language zh_CN
        * 释放所有数据（ParticleData和MaterialBase数据在这个释放过程中，仅仅是移除引用）
        * @version Egret 3.0
        * @platform Web,Native
        */
        ParticleEmitter.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this._generator) {
                this._generator.dispose();
                this._generator = null;
            }
            this._timeNode = null;
            this._positionNode = null;
            if (this._geometryShape) {
                this._geometryShape.dispose();
                this._geometryShape = null;
            }
            if (this._externalGeometry) {
                this._externalGeometry.dispose();
                this._externalGeometry = null;
            }
            this._particleAnimation = null;
            if (this._particleState) {
                this._particleState.dispose();
                this._particleState = null;
            }
            this._subEmitterNode = null;
            this._userNodes = null;
            this._data = null;
        };
        return ParticleEmitter;
    }(egret3d.Mesh));
    egret3d.ParticleEmitter = ParticleEmitter;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.EffectGroup
    * @classdesc
    * 特效组，可以是粒子也可以是其他动画，如uv滚动等。通过加载特效配置文件，自动创建该对象。用于外部统一控制播放/暂停/以及速度控制。
    * @see egret3d.UnitLoader
    * @includeExample particle/EffectGroup.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EffectGroup = (function (_super) {
        __extends(EffectGroup, _super);
        function EffectGroup() {
            _super.apply(this, arguments);
            this._animations = [];
            this._proAnimations = [];
            this._animCount = 0;
            this._loopTime = 1;
            this._animTime = 0;
            this._speed = 1;
            this._noLoopAnims = [];
            /*
            * @private
            * 记录当前特效处于活动状态的时间,-1表示回收的状态
            */
            this.liveTime = -1;
            /*
            * @private
            * 是否原始的资源，而非拷贝出来的对象
            */
            this.isOriginal = true;
            //播放完毕事件
            this._event3D = new egret3d.AnimationEvent3D();
            this._lastAnimTime = 0;
        }
        /**
        * @language zh_CN
        * 初始化所有动画
        * 初始化之后才能调用播放
        * @param isLoop 是否需要自动循环播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        EffectGroup.prototype.init = function (isLoop) {
            if (isLoop === void 0) { isLoop = false; }
            this._animations = [];
            this._loop = isLoop;
            this.collectAnimations(this, this._animations);
            this._timeOffset = [];
            this._animCount = this._timeOffset.length = this._animations.length;
            for (var index = 0; index < this._animCount; index++) {
                this._timeOffset[index] = 0;
            }
        };
        EffectGroup.prototype.collectAnimations = function (object, animations) {
            var mesh;
            var animation;
            if (object instanceof egret3d.Mesh) {
                mesh = object;
                animation = mesh.animation;
                if (animation) {
                    animations.push(animation);
                    if (!animation.isLoop) {
                        this._noLoopAnims.push(animation);
                    }
                }
            }
            if (object.proAnimation) {
                this._proAnimations.push(object.proAnimation);
                if (!object.proAnimation.isLoop) {
                    this._noLoopAnims.push(object.proAnimation);
                }
            }
            var childCount = object.childs.length;
            for (var i = 0; i < childCount; i++) {
                this.collectAnimations(object.childs[i], animations);
            }
            //修改当前最大循环时间
            if (this._loop) {
                for (var _i = 0, _a = this._noLoopAnims; _i < _a.length; _i++) {
                    animation = _a[_i];
                    this._loopTime = Math.max(this._loopTime, animation.loopTime * 1000);
                }
            }
        };
        /**
        * @language zh_CN
        * 播放动画
        * @param speed 播放速度（默认为1）
        * @param reset 是否从头播放 默认为false
        * @param prewarm 是否预热  默认为false
        * @version Egret 3.0
        * @platform Web,Native
        */
        EffectGroup.prototype.play = function (speed, reset, prewarm) {
            speed = speed || 1;
            reset = reset || false;
            prewarm = prewarm || false;
            for (var index = 0; index < this._animCount; index++) {
                var animator = this._animations[index];
                animator.play("", speed, reset, prewarm);
            }
            for (var index = 0; index < this._proAnimations.length; index++) {
                var animator = this._proAnimations[index];
                animator.play("", speed, reset, prewarm);
            }
            this._isPlay = true;
            this._prewarm = prewarm;
            this._speed = speed;
            if (reset) {
                this._animTime = 0;
            }
        };
        /**
        * @language zh_CN
        * 设置动画当前的时间
        * @param offset
        * @version Egret 3.0
        * @platform Web,Native
        */
        EffectGroup.prototype.resetTime = function (offset) {
            if (offset === void 0) { offset = 0; }
            for (var index; index < this._animCount; index++) {
                var animator = this._animations[index];
                animator.animTime = this._timeOffset[index] + offset;
            }
            for (var index; index < this._proAnimations.length; index++) {
                var animator = this._proAnimations[index];
                animator.animTime = this._timeOffset[index] + offset;
            }
        };
        Object.defineProperty(EffectGroup.prototype, "speed", {
            /**
            * @language zh_CN
            * 设置动画当前的播放速度
            * @return 播放速度值，不能小于等于0
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._speed;
            },
            /**
            * @language zh_CN
            * 设置动画当前的播放速度
            * @param value 播放速度值，不能小于等于0
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (value < 0.0000001) {
                    value = 0.0000001;
                }
                this._speed = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 停止动画播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        EffectGroup.prototype.stop = function () {
            for (var index; index < this._animCount; index++) {
                this._animations[index].stop();
            }
            for (var index = 0; index < this._proAnimations.length; index++) {
                var animator = this._proAnimations[index];
                animator.stop();
            }
            this._isPlay = false;
        };
        /**
        * @language zh_CN
        * 是否正在播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        EffectGroup.prototype.isPlay = function () {
            return this._isPlay;
        };
        /**
        * @language zh_CN
        * 当前对象数据更新
        * @private
        * @param camera 当前渲染的摄相机
        * @param time 当前时间
        * @param delay 每帧时间间隔
        * @version Egret 3.0
        * @platform Web,Native
        */
        EffectGroup.prototype.update = function (time, delay, camera) {
            _super.prototype.update.call(this, time, delay, camera);
            if (this._loop && this._animTime > this._loopTime) {
                this._animTime -= this._loopTime;
                var anim;
                for (var _i = 0, _a = this._noLoopAnims; _i < _a.length; _i++) {
                    anim = _a[_i];
                    anim.play("", this._speed, true, this._prewarm);
                }
            }
            this._animTime += this._speed * delay;
            if (!this._loop) {
                var endTime = this._loopTime * 1000;
                if (this._lastAnimTime <= endTime && this._animTime > endTime) {
                    this._event3D.eventType = egret3d.AnimationEvent3D.COMPLETE;
                    this._event3D.target = this;
                    this.dispatchEvent(this._event3D);
                }
            }
            this._lastAnimTime = this._animTime;
        };
        /**
        * @language zh_CN
        * 销毁
        * @version Egret 3.0
        * @platform Web,Native
        */
        EffectGroup.prototype.dispose = function () {
            this.stop();
            if (this._animations) {
                this._animations.length = 0;
                delete this._animations;
            }
            if (this._noLoopAnims) {
                this._noLoopAnims.length = 0;
                delete this._noLoopAnims;
            }
        };
        /**
        * @language zh_CN
        * @private
        * @param other copy对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        EffectGroup.prototype.copy = function (other) {
            _super.prototype.copy.call(this, other);
        };
        /**
        * @language zh_CN
        * @private
        * 克隆当前EffectGroup
        * @returns EffectGroup 克隆后的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        EffectGroup.prototype.clone = function () {
            var cloneObject = new EffectGroup();
            cloneObject.copy(this);
            return cloneObject;
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        EffectGroup.prototype.deepClone = function () {
            var newObject = _super.prototype.deepClone.call(this);
            newObject.init(this._loop);
            return newObject;
        };
        return EffectGroup;
    }(egret3d.Object3D));
    egret3d.EffectGroup = EffectGroup;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PickSystem = (function () {
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        function PickSystem() {
            this.enablePick = false;
            //this.pickRender = new MultiRender(PassType.PickPass);
            //this.pickRender.setRenderToTexture(512, 512, FrameBufferFormat.UNSIGNED_BYTE_RGBA);
            //this.pickRender.drawOver = (entityCollect: EntityCollect, camera: Camera3D, time: number, delay: number, viewPort: Rectangle) => this.drawOver(entityCollect, camera, time, delay, viewPort);
            //this.piexs = new Uint8Array(this.pickRender.renderTexture.width * this.pickRender.renderTexture.height * 4);
        }
        Object.defineProperty(PickSystem, "instance", {
            /**
            * @language zh_CN
            * 单例
            * @returns PickSystem 实例返回
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (!PickSystem._instance) {
                    PickSystem._instance = new PickSystem();
                }
                return PickSystem._instance;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        PickSystem.prototype.update = function (entityCollect, camera, time, delay, viewPort) {
            egret3d.Egret3DCanvas.context3DProxy.clearColor(1.0, 1.0, 1.0, 1.0);
            egret3d.Egret3DCanvas.context3DProxy.clear(egret3d.Context3DProxy.gl.COLOR_BUFFER_BIT | egret3d.Context3DProxy.gl.DEPTH_BUFFER_BIT);
            //this.pickRender.draw(time, delay, Egret3DCanvas.context3DProxy, entityCollect, camera, viewPort);
        };
        PickSystem.prototype.drawOver = function (entityCollect, camera, time, delay, viewPort) {
            egret3d.Context3DProxy.gl.readPixels(0, 0, this.pickRender.renderTexture.width, this.pickRender.renderTexture.height, egret3d.Context3DProxy.gl.RGBA, egret3d.Context3DProxy.gl.UNSIGNED_BYTE, this.piexs);
            var i = 0;
        };
        PickSystem.prototype.getObjectId = function (x, y, cavans, view) {
            var vx = x - view.x;
            var vy = y - view.y;
            vy = view.height - vy;
            var xx = Math.floor(vx / view.width * this.pickRender.renderTexture.width);
            var yy = Math.floor(vy / view.height * this.pickRender.renderTexture.height);
            var index = yy * this.pickRender.renderTexture.width + xx;
            return (this.piexs[index * 4 + 0] << 16) | (this.piexs[index * 4 + 1] << 8) | this.piexs[index * 4 + 2];
        };
        return PickSystem;
    }());
    egret3d.PickSystem = PickSystem;
    /**
    * @private
    * @language zh_CN
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EyePick = (function (_super) {
        __extends(EyePick, _super);
        function EyePick() {
            _super.call(this);
            this.useDelay = 1000;
            this._select = false;
            this._selectSure = false;
            this._count = 0;
            this._pickProgressEvent = new egret3d.PickEvent3D("pick_Progress");
            this._pickSureEvent = new egret3d.PickEvent3D("pick_Sure");
            this._pickCancleEvent = new egret3d.PickEvent3D("pick_cancle");
            this._sceneRay = new egret3d.Ray();
        }
        EyePick.prototype.update = function (view, time, delay) {
            this._sceneRay.CalculateAndTransformRay(view.width, view.height, view.camera3D.modelMatrix, view.camera3D.projectMatrix, view.width * 0.5, view.height * 0.5);
            var pickList = view.entityCollect.specialCastItem[egret3d.SpecialCast.Pick];
            var bound;
            var minDis = egret3d.MathUtil.MAX_VALUE;
            if (this._selection)
                minDis = egret3d.Vector3D.distance(view.camera3D.position, this._selection.position);
            ;
            var dis = 0;
            this._select = false;
            for (var i = 0; i < pickList.length; i++) {
                bound = pickList[i].bound;
                //bound.visible = false;
                if (this._sceneRay.IntersectMesh(bound.vexData, bound.indexData, bound.vexLength, bound.indexData.length / 3, 0, pickList[i].modelMatrix, pickList[i].pickResult)) {
                    //bound.visible = true;
                    this._select = true;
                    dis = egret3d.Vector3D.distance(view.camera3D.position, pickList[i].position);
                    if (dis < minDis) {
                        this._count = 0;
                        minDis = dis;
                        if (this._selection) {
                            this._pickCancleEvent.pickTarget = this._selection;
                            this.dispatchEvent(this._pickCancleEvent);
                        }
                        this._selection = pickList[i];
                    }
                }
            }
            if (this._select && this._selection) {
                this._count++;
                this._pickProgressEvent.pickTarget = this._selection;
                this._pickProgressEvent.delay = this._count;
                this.dispatchEvent(this._pickProgressEvent);
                if (this._count > this.useDelay && !this._selectSure) {
                    this._selectSure = true;
                    this._pickSureEvent.pickTarget = this._selection;
                    this.dispatchEvent(this._pickSureEvent);
                }
            }
            else if (this._selection) {
                this._pickCancleEvent.pickTarget = this._selection;
                this.dispatchEvent(this._pickCancleEvent);
                this._selectSure = false;
                this._selection = null;
                this._select = false;
                this._count = 0;
            }
        };
        EyePick.PICK_PROGRESS = "pick_Progress";
        EyePick.PICK_SURE = "pick_Sure";
        EyePick.PICK_CANCLE = "pick_cancle";
        return EyePick;
    }(egret3d.EventDispatcher));
    egret3d.EyePick = EyePick;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Scene3D
    * @classdesc
    * 场景的根节点对象
    * 创建场景后会将场景树中的静态物体进行四叉树空间划分
    * 然后会根据 划分好的的空间进行裁剪
    * 在View3D 中的场景节点为 Scene3D
    * @see egret3d.Object3D
    * @see egret3d.Scene3D
    * @includeExample scene/Scene3D.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Scene3D = (function (_super) {
        __extends(Scene3D, _super);
        function Scene3D() {
            _super.call(this);
            this._tree = new egret3d.TreeBase(this);
        }
        Object.defineProperty(Scene3D.prototype, "quad", {
            /**
            * @language zh_CN
            * 返回剖分场景四叉树根信息
            * @returns QuadRoot
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._quad;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        Scene3D.prototype.infrustumList = function (camera) {
            return this._tree.infrustumList(camera);
        };
        /**
        * @private
        * @language zh_CN
        * 根据当前场景的节点分布情况，生成四叉树
        * @version Egret 3.0
        * @platform Web,Native
        */
        Scene3D.prototype.createQuadTree = function () {
            this._quad = new egret3d.QuadRoot(16, 2500);
            var nodes = new Array();
            this.collectQuadList(nodes, this);
            this._quad.createQuadTree(nodes);
        };
        /**
        * @private
        * @language zh_CN
        * 遍历一个Object3D及其child节点，如果能够进入视锥体，则放入返回的列表中
        * @param  nodes 用于返回Quad元素结果
        * @param  obj   待遍历的对象
        * @returns Array<IQuadNode>
        * @version Egret 3.0
        * @platform Web,Native
        */
        Scene3D.prototype.collectQuadList = function (nodes, obj) {
            nodes = nodes || new Array();
            var mesh;
            if (obj instanceof egret3d.Mesh) {
                mesh = obj;
                if (mesh.aabb) {
                    nodes.push(mesh);
                }
            }
            var child;
            if (obj.childs && obj.childs.length > 0) {
                for (var _i = 0, _a = obj.childs; _i < _a.length; _i++) {
                    child = _a[_i];
                    this.collectQuadList(nodes, child);
                }
            }
            return nodes;
        };
        /**
        * @language zh_CN
        * 克隆当前Role
        * @returns Role 克隆后的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Scene3D.prototype.clone = function () {
            var cloneObject = new Scene3D();
            cloneObject.copy(this);
            return cloneObject;
        };
        return Scene3D;
    }(egret3d.Object3D));
    egret3d.Scene3D = Scene3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.TreeBase
    * @classdesc
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TreeBase = (function () {
        function TreeBase(object3D) {
            this._searchList = new Array();
            this._root = object3D;
        }
        TreeBase.prototype.infrustumList = function (camera) {
            this._searchList.length = 0;
            return this._searchList;
        };
        return TreeBase;
    }());
    egret3d.TreeBase = TreeBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.ITexture
    * @classdesc
    * 贴图的接口、
    * 贴图的基类对象 包括各类贴图的公共数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ITexture = (function () {
        function ITexture() {
            /**
            * @language zh_CN
            * 贴图是否使用 mipmap , mipmap为一个贴图的LOD层级贴图。例如（1024*1024的贴图，往下就会自动生成 512* 512,256*256,128*128,64*64,32*32,16*16,8*8,4*4,2*2,1*1）
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.useMipmap = true;
            /**
            * @language zh_CN
            * 是否平滑插值
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.smooth = true;
            /**
            * @language zh_CN
            * 贴图采样重复方式
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.repeat = false;
            /**
            * @language zh_CN
            * 是否预乘alpha
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.premultiply_alpha = 0;
            /**
            * @language zh_CN
            * filp_y
            * Context3DProxy.gl.filp_y
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.filp_y = 0;
            /**
            * @private
            * @language zh_CN
            * 上传贴图数据给GPU
            * @param context3D
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.hasMipmap = false;
            /**
            * @language zh_CN
            * 贴图 是否需要按照U的方向镜像
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.mirroredU = false;
            /**
            * @language zh_CN
            * 贴图 是否需要按照V的方向镜像
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.mirroredV = false;
            this.ready = false;
        }
        /**
       * @language zh_CN
       * 从父级贴图对象中，拷贝一个贴图对象出来
       * @param texture 父级贴图对象
       * @param x 贴图在父级贴图中的x坐标偏移值
       * @param y 贴图在父级贴图中的y坐标偏移值
       * @param width 贴图宽度
       * @param height 贴图高度
       * @version Egret 3.0
       * @platform Web,Native
       */
        ITexture.prototype.copyFromTexture = function (texture, x, y, width, height) {
            this.parentTexture = texture;
            texture.width = width;
            texture.height = height;
            this.guiIndex = texture.guiIndex;
            this.texture2D = texture.texture2D;
            this.uvRectangle = this.uvRectangle || new egret3d.Rectangle();
            this.uvRectangle.x = x;
            this.uvRectangle.y = y;
            this.uvRectangle.width = width;
            this.uvRectangle.height = height;
        };
        /**
        * @language zh_CN
        * 上传贴图数据给GPU
        * @param context3D 图形绘制上下文
        * @version Egret 3.0
        * @platform Web,Native
        */
        ITexture.prototype.upload = function (context3D) {
        };
        /**
        * @private
        * @language zh_CN
        * 强制上传贴图数据给GPU，强制要求贴图更新。
        * 在video 贴图类型需要立即改变显卡中的贴图内存
        * @param context3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        ITexture.prototype.uploadForcing = function (context3D) {
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        ITexture.prototype.activeState = function (context3D) {
            if (this.ready)
                return;
            this.ready = true;
            if (!this.premultiply_alpha) {
                egret3d.Context3DProxy.gl.pixelStorei(egret3d.Context3DProxy.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
            }
            if (this.useMipmap && !this.hasMipmap) {
                egret3d.Context3DProxy.gl.generateMipmap(egret3d.Context3DProxy.gl.TEXTURE_2D);
                this.hasMipmap = true;
            }
            if (this.smooth) {
                if (this.hasMipmap) {
                    context3D.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_MIN_FILTER, egret3d.Context3DProxy.gl.LINEAR_MIPMAP_LINEAR);
                    context3D.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_MAG_FILTER, egret3d.Context3DProxy.gl.LINEAR);
                }
                else {
                    context3D.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_MIN_FILTER, egret3d.Context3DProxy.gl.LINEAR);
                    context3D.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_MAG_FILTER, egret3d.Context3DProxy.gl.LINEAR);
                }
            }
            else {
                context3D.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_MIN_FILTER, egret3d.Context3DProxy.gl.NEAREST);
                context3D.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_MAG_FILTER, egret3d.Context3DProxy.gl.NEAREST);
            }
            if (this.repeat) {
                if (this.mirroredU) {
                    egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_WRAP_S, egret3d.Context3DProxy.gl.MIRRORED_REPEAT);
                }
                else if (this.mirroredV) {
                    egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_WRAP_T, egret3d.Context3DProxy.gl.MIRRORED_REPEAT);
                }
                else {
                    context3D.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_WRAP_S, egret3d.Context3DProxy.gl.REPEAT);
                    context3D.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_WRAP_T, egret3d.Context3DProxy.gl.REPEAT);
                }
            }
            else {
                context3D.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_WRAP_S, egret3d.Context3DProxy.gl.CLAMP_TO_EDGE);
                context3D.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_WRAP_T, egret3d.Context3DProxy.gl.CLAMP_TO_EDGE);
            }
            if (this.filp_y) {
                egret3d.Context3DProxy.gl.pixelStorei(egret3d.Context3DProxy.gl.UNPACK_FLIP_Y_WEBGL, this.filp_y);
            }
        };
        /**
        * @language zh_CN
        * 释放接口
        * @version Egret 3.0
        * @platform Web,Native
        */
        ITexture.prototype.dispose = function () {
            if (this.texture2D) {
                this.texture2D.dispose();
            }
            this.texture2D = null;
            if (this.texture3D) {
                this.texture3D.dispose();
            }
            this.texture3D = null;
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        ITexture.prototype.readPixels = function (x, y, width, height, format, type, pixels) {
            if (format === void 0) { format = egret3d.ContextConfig.ColorFormat_RGBA8888; }
            if (type === void 0) { type = egret3d.ContextConfig.UNSIGNED_BYTE; }
            if (pixels === void 0) { pixels = null; }
            if (!pixels) {
                switch (type) {
                    case egret3d.ContextConfig.UNSIGNED_BYTE:
                        if (format == egret3d.ContextConfig.ColorFormat_RGBA8888) {
                            pixels = new Uint8Array(width * height * 4);
                        }
                        else if (format == egret3d.ContextConfig.ColorFormat_RGB888) {
                            pixels = new Uint8Array(width * height * 3);
                        }
                        break;
                    case egret3d.ContextConfig.FLOAT:
                        if (format == egret3d.ContextConfig.ColorFormat_RGBA8888) {
                            pixels = new Float32Array(width * height * 4);
                        }
                        else if (format == egret3d.ContextConfig.ColorFormat_RGB888) {
                            pixels = new Float32Array(width * height * 3);
                        }
                        break;
                }
            }
            return pixels;
        };
        return ITexture;
    }());
    egret3d.ITexture = ITexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.ImageTexture
    * @classdesc
    * ImageTexture 类为 图像贴图
    * 加载png、jpg 会返回此对象
    *
    * 图像贴图用于封装 HTMLImageElement（网页图像元素）到引擎内部可使用的Texture2D对象, </p>
    * HTMLImageElement 可通过内嵌HTML文件中获取。</p>
    *
    *
    * 示例：
    * 假设html中已有 &lt;img id="t1" src="xxx.png" /&gt;
    * <pre>
    * var img: HTMLImageElement = <HTMLImageElement>document.getElementById("t1");
    * var imageTexture: egret3d.ImageTexture = new egret3d.ImageTexture(img);
    * </pre>
    * @includeExample texture/ImageTexture.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ImageTexture = (function (_super) {
        __extends(ImageTexture, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param img HTMLImageElement（网页图像元素）
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ImageTexture(img) {
            _super.call(this);
            this.imageData = img;
            this.texture2D = new egret3d.ContextTexture2D();
            this.texture2D.imageData = img;
        }
        Object.defineProperty(ImageTexture.prototype, "width", {
            /**
            * @language zh_CN
            * 获取贴图像素宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.imageData.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ImageTexture.prototype, "height", {
            /**
           * @language zh_CN
           * 获取贴图像素高度
           * @version Egret 3.0
           * @platform Web,Native
           */
            get: function () {
                return this.imageData.height;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 上传贴图数据给GPU
        * @param context3D 呈现几何定义图形的上下文
        * @version Egret 3.0
        * @platform Web,Native
        */
        ImageTexture.prototype.upload = function (context3D) {
            if (!this.texture2D.textureBuffer) {
                this.texture2D.textureBuffer = this.texture2D.textureBuffer || context3D.creatTexture();
                this.texture2D.internalFormat = egret3d.InternalFormat.ImageData;
                this.texture2D.imageData = this.imageData;
                this.texture2D.dataFormat = egret3d.Context3DProxy.gl.UNSIGNED_BYTE;
                this.texture2D.colorFormat = egret3d.ContextConfig.ColorFormat_RGBA8888;
                context3D.upLoadTextureData(0, this);
            }
        };
        /**
        * @private
        * @language zh_CN
        * 强制上传贴图数据给GPU，强制要求贴图更新。
        * 在video 贴图类型需要立即改变显卡中的贴图内存
        * @param context3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        ImageTexture.prototype.uploadForcing = function (context3D) {
            context3D.upLoadTextureData(0, this);
        };
        /**
        * @language zh_CN
        * 释放接口
        * @version Egret 3.0
        * @platform Web,Native
        */
        ImageTexture.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.imageData) {
                delete this.imageData;
                this.imageData = null;
            }
        };
        /**
        * @private
        * @language zh_CN
        * 读取image的byteArray数据
        * @param x 读取的x偏移值
        * @param y 读取的y偏移值
        * @param width  读取的宽度
        * @param height 读取的高度
        * @version Egret 3.0
        * @platform Web,Native
        */
        ImageTexture.prototype.readPixels = function (x, y, width, height, format, type, pixels) {
            if (format === void 0) { format = egret3d.ContextConfig.ColorFormat_RGBA8888; }
            if (type === void 0) { type = egret3d.ContextConfig.UNSIGNED_BYTE; }
            if (pixels === void 0) { pixels = null; }
            return egret3d.Egret3DCanvas.draw2DImage(this.imageData, x, y, width, height);
        };
        return ImageTexture;
    }(egret3d.ITexture));
    egret3d.ImageTexture = ImageTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.MimapTexture
    * @classdesc
    * Texture 贴图对象
    * dds tga hdr 几种贴图的格式加载后会生成的对象
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        /**
        * @language zh_CN
        * 构造函数
        * 默认是平滑采样
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Texture() {
            _super.call(this);
            this.smooth = true;
            this.texture2D = new egret3d.ContextTexture2D();
        }
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        Texture.prototype.upload = function (context3D) {
            if (!this.texture2D.textureBuffer) {
                this.texture2D.textureBuffer = this.texture2D.textureBuffer || context3D.creatTexture();
                this.texture2D.internalFormat = this.internalFormat;
                this.texture2D.colorFormat = this.colorFormat;
                this.texture2D.mimapData = this.mimapData;
                this.texture2D.dataFormat = egret3d.Context3DProxy.gl.UNSIGNED_BYTE;
                if (this.mimapData && this.mimapData.length > 0) {
                    for (var i = 0; i < this.mimapData.length; i++) {
                        context3D.upLoadTextureData(i, this);
                    }
                }
                else {
                    context3D.upLoadTextureData(0, this);
                }
                if (this.parentTexture) {
                    if (!this.parentTexture.texture2D) {
                        this.parentTexture.upload(context3D);
                    }
                    this.texture2D = this.parentTexture.texture2D;
                    this.texture2D.internalFormat = this.parentTexture.internalFormat;
                    this.texture2D.colorFormat = this.parentTexture.colorFormat;
                    this.texture2D.mimapData = this.parentTexture.mimapData;
                }
            }
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        Texture.prototype.uploadForcing = function (context3D) {
            context3D.upLoadTextureData(0, this);
        };
        return Texture;
    }(egret3d.ITexture));
    egret3d.Texture = Texture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.CubeTexture
    * @classdesc
    * CubeTexture 类为天空贴图
    *
    * 天空贴图用于Sky类使用，其内部是将6张HTMLImageElement（网页图片元素）封装到CubeTexture对象，CubeTexture为引擎内部使用对象。</p>
    *
    * 示例：</p>
    * 假设html中已有</p>
    <pre>
    <img id="t1" src="image_front.png" />
    <img id="t2" src="image_back.png" />
    <img id="t3" src="image_left.png" />
    <img id="t4" src="image_right.png" />
    <img id="t5" src="image_up.png" />
    <img id="t6" src="image_down.png" />
    </pre>
    使用示例：</p>
    <pre>
    var cubeTexture: CubeTexture = CubeTexture.createCubeTexture(
    <HTMLImageElement>document.getElementById("t1"),
    <HTMLImageElement>document.getElementById("t2"),
    <HTMLImageElement>document.getElementById("t3"),
    <HTMLImageElement>document.getElementById("t4"),
    <HTMLImageElement>document.getElementById("t5"),
    <HTMLImageElement>document.getElementById("t6")
    );
    </pre>
    * @see egret3d.Sky
    * @includeExample texture/CubeTexture.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CubeTexture = (function (_super) {
        __extends(CubeTexture, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param image_front 默认参为null 前部HTMLImageElement图片元素
        * @param image_back 默认参为null 背部HTMLImageElement图片元素
        * @param image_left 默认参为null 左部HTMLImageElement图片元素
        * @param image_right 默认参为null 右部HTMLImageElement图片元素
        * @param image_up 默认参为null 顶部HTMLImageElement图片元素
        * @param image_down 默认参为null 底部HTMLImageElement图片元素
        */
        function CubeTexture(image_front, image_back, image_left, image_right, image_up, image_down) {
            if (image_front === void 0) { image_front = null; }
            if (image_back === void 0) { image_back = null; }
            if (image_left === void 0) { image_left = null; }
            if (image_right === void 0) { image_right = null; }
            if (image_up === void 0) { image_up = null; }
            if (image_down === void 0) { image_down = null; }
            _super.call(this);
            this.image_front = image_front;
            this.image_back = image_back;
            this.image_left = image_left;
            this.image_right = image_right;
            this.image_up = image_up;
            this.image_down = image_down;
            this.texture3D = new egret3d.ContextTexture3D();
        }
        /**
        * @language zh_CN
        * 创建CubuTexture
        * @param image_front 前部HTMLImageElement图片元素
        * @param image_back 背部HTMLImageElement图片元素
        * @param image_left 左部HTMLImageElement图片元素
        * @param image_right 右部HTMLImageElement图片元素
        * @param image_up 顶部HTMLImageElement图片元素
        * @param image_down 底部HTMLImageElement图片元素
        * @version Egret 3.0
        * @platform Web,Native
        */
        CubeTexture.createCubeTexture = function (image_front, image_back, image_left, image_right, image_up, image_down) {
            var front = new egret3d.ContextTexture2D();
            front.imageData = image_front;
            var back = new egret3d.ContextTexture2D();
            back.imageData = image_back;
            var left = new egret3d.ContextTexture2D();
            left.imageData = image_left;
            var right = new egret3d.ContextTexture2D();
            right.imageData = image_right;
            var up = new egret3d.ContextTexture2D();
            up.imageData = image_up;
            var down = new egret3d.ContextTexture2D();
            down.imageData = image_down;
            var cubeTexture = new CubeTexture(front, back, left, right, up, down);
            return cubeTexture;
        };
        /**
        * @language zh_CN
        * 创建CubuTexture
        * @param image_front 前部ITexture图片元素
        * @param image_back 背部ITexture图片元素
        * @param image_left 左部ITexture图片元素
        * @param image_right 右部ITexture图片元素
        * @param image_up 顶部ITexture图片元素
        * @param image_down 底部ITexture图片元素
        * @version Egret 3.0
        * @platform Web,Native
        */
        CubeTexture.createCubeTextureByImageTexture = function (image_front, image_back, image_left, image_right, image_up, image_down) {
            return new CubeTexture(image_front.texture2D, image_back.texture2D, image_left.texture2D, image_right.texture2D, image_up.texture2D, image_down.texture2D);
        };
        /**
        * @language zh_CN
        * 设置CubuTexture
        * @param cubeTexture 源CubuTexture
        * @param image_front 前部ITexture图片元素
        * @param image_back 背部ITexture图片元素
        * @param image_left 左部ITexture图片元素
        * @param image_right 右部ITexture图片元素
        * @param image_up 顶部ITexture图片元素
        * @param image_down 底部ITexture图片元素
        * @version Egret 3.0
        * @platform Web,Native
        */
        CubeTexture.setCubeTexture = function (cubeTexture, image_front, image_back, image_left, image_right, image_up, image_down) {
            cubeTexture.image_front = image_front.texture2D;
            cubeTexture.image_back = image_back.texture2D;
            cubeTexture.image_left = image_left.texture2D;
            cubeTexture.image_right = image_right.texture2D;
            cubeTexture.image_up = image_up.texture2D;
            cubeTexture.image_down = image_down.texture2D;
        };
        /**
        * @private
        * @language zh_CN
        * 上传贴图数据给GPU
        * 更新上传 cube 贴图纹理到GPU 现存中缓存起来
        * @param context3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        CubeTexture.prototype.upload = function (context3D) {
            if (!this.image_front ||
                !this.image_back ||
                !this.image_left ||
                !this.image_right ||
                !this.image_up ||
                !this.image_down) {
                return;
            }
            if (!this.texture3D.texture) {
                this.texture3D.texture = this.texture3D.texture || context3D.creatTexture();
                this.texture3D.border = 0;
                this.texture3D.image_front = this.image_front;
                this.texture3D.image_back = this.image_back;
                this.texture3D.image_left = this.image_left;
                this.texture3D.image_right = this.image_right;
                this.texture3D.image_up = this.image_up;
                this.texture3D.image_down = this.image_down;
                context3D.uploadCubetexture(this.texture3D);
            }
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        CubeTexture.prototype.uploadForcing = function (context3D) {
        };
        return CubeTexture;
    }(egret3d.ITexture));
    egret3d.CubeTexture = CubeTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.CheckerboardTexture
    * @classdesc
    * CheckerboardTexture 类为 棋盘格纹理类</p>
    *
    * 棋盘格纹理为黑白间隔色块组成的一张纹理，主要用于判别模型UV的正确性，若某模型UV值不正确，其纹理表现必定乱序不规整。</p>
    * 使用示例:</p>
    <pre>
    var material: egret3d.TextureMaterial = new egret3d.TextureMaterial(egret3d.CheckerboardTexture.texture );
    var mesh: egret3d.Mesh = new egret3d.Mesh(new egret3d.CubeGeometry(), material);
    </pre>
    *
    * @includeExample texture/CheckerboardTexture.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CheckerboardTexture = (function (_super) {
        __extends(CheckerboardTexture, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        function CheckerboardTexture() {
            _super.call(this);
            this.width = 32;
            this.height = 32;
            this.uvRectangle = new egret3d.Rectangle(0, 0, 1, 1);
            this.buildCheckerboard();
            this.texture2D = new egret3d.ContextTexture2D();
        }
        /**
        * @language zh_CN
        * 上传贴图数据给GPU
        * @param context3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        CheckerboardTexture.prototype.upload = function (context3D) {
            if (!this.texture2D.textureBuffer) {
                this.texture2D.textureBuffer = this.texture2D.textureBuffer || context3D.creatTexture();
                this.texture2D.border = 0;
                this.texture2D.internalFormat = egret3d.InternalFormat.PixelArray;
                this.texture2D.colorFormat = egret3d.Context3DProxy.gl.RGBA;
                this.texture2D.mimapData = new Array();
                this.texture2D.mimapData.push(new egret3d.MipmapData(this._pixelArray, this.width, this.height));
                this.texture2D.width = this.width;
                this.texture2D.height = this.height;
                this.useMipmap = false;
                this.texture2D.dataFormat = egret3d.Context3DProxy.gl.UNSIGNED_BYTE;
                context3D.upLoadTextureData(0, this);
            }
        };
        CheckerboardTexture.prototype.buildCheckerboard = function () {
            if (!this._pixelArray) {
                this._pixelArray = new Uint8Array(this.width * this.height * 4);
                //var colors: egret3d.Color[] = [egret3d.Color.white(), egret3d.Color.black()];
                var colors = [egret3d.Color.white(), egret3d.Color.black()];
                var colorIndex = 0;
                var blockSize = 4;
                for (var y = 0; y < this.height; y++) {
                    for (var x = 0; x < this.width; x++) {
                        if ((x % blockSize) == 0) {
                            colorIndex = (colorIndex + 1) % 2;
                        }
                        if ((y % blockSize) == 0 && x == 0) {
                            var tmp = colors[0];
                            colors[0] = colors[1];
                            colors[1] = tmp;
                            colorIndex = 0;
                        }
                        this._pixelArray[(y * (this.width * 4) + x * 4) + 0] = colors[colorIndex].r;
                        this._pixelArray[(y * (this.width * 4) + x * 4) + 1] = colors[colorIndex].g;
                        this._pixelArray[(y * (this.width * 4) + x * 4) + 2] = colors[colorIndex].b;
                        this._pixelArray[(y * (this.width * 4) + x * 4) + 3] = colors[colorIndex].a;
                    }
                }
            }
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        CheckerboardTexture.prototype.uploadForcing = function (context3D) {
        };
        /**
        * @language zh_CN
        * 释放接口
        * @version Egret 3.0
        * @platform Web,Native
        */
        CheckerboardTexture.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this._pixelArray) {
                delete this._pixelArray;
            }
            this._pixelArray = null;
        };
        /**
        * @language zh_CN
        * 公用棋盘格实例对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        CheckerboardTexture.texture = new CheckerboardTexture();
        return CheckerboardTexture;
    }(egret3d.ITexture));
    egret3d.CheckerboardTexture = CheckerboardTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @class egret3d.VideoTexture
     * @classdesc
     * VideoTexture 使用 Video 标签采集 video 视频 </p>
     * VideoTexture 仅且暂时只能在pc上正常使用，移动端需要直接与用户交互才可正常生成播放</p>
     * 需要设置贴图的宽度和高度。必须为2的N次</p>
     * @version Egret 3.0
     * @platform Web,Native
     */
    var VideoTexture = (function (_super) {
        __extends(VideoTexture, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param width 贴图宽度 默认参数 256
        * @param height 贴图高度 默认参数 256
        * @version Egret 3.0
        * @platform Web,Native
        */
        function VideoTexture(width, height) {
            var _this = this;
            if (width === void 0) { width = 256; }
            if (height === void 0) { height = 256; }
            _super.call(this);
            this.canUpdataTexture = false;
            this.width = width;
            this.height = height;
            this.texture2D = new egret3d.ContextTexture2D();
            this.tmpCanvas = document.createElement("canvas");
            this.tmpCanvas.width = width;
            this.tmpCanvas.height = height;
            this.context = this.tmpCanvas.getContext('2d');
            this.video = document.createElement("video");
            this.video.msZoom = true;
            this.video.width = width;
            this.video.height = height;
            this.video.controls = false;
            this.video.autoplay = true;
            this.video.addEventListener("canplaythrough", function () { return _this.loadReady(); }, true);
            this.tmpCanvas.hidden = true;
        }
        VideoTexture.prototype.loadReady = function () {
            this.canUpdataTexture = true;
        };
        Object.defineProperty(VideoTexture.prototype, "source", {
            /**
            * @language zh_CN
            * 返回 视频链接
            * 视频的链接地址，只要是h5 支持的格式都支持， 例如:ogv,mp4,avi
            * warning chrom need use url = http://127.0.0.1/resource/video/xxx.mp4
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.video.src;
            },
            /*
            * @language zh_CN
            * 设置 视频链接
            * 设置 视频的链接地址，只要是h5 支持的格式都支持， 例如: ogv,mp4,avi
            * warning chrom need use url = http://127.0.0.1/resource/video/xxx.mp4
            * @param src 视频格式的链接地址
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (src) {
                this.video.src = src;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 播放视频
        * 当视频缓冲好之后才能正常播放视频
        * @version Egret 3.0
        * @platform Web,Native
        */
        VideoTexture.prototype.play = function () {
            this.video.play();
        };
        /**
        * @language zh_CN
        * 暂停视频
        * 控制视频的播放暂停状态
        * @version Egret 3.0
        * @platform Web,Native
        */
        VideoTexture.prototype.pause = function () {
            this.video.pause();
        };
        /**
        * @private
        * @language zh_CN
        * 上传贴图数据给GPU
        * 将video的视频数据实时传输到GPU上
        * @param context3D
        */
        VideoTexture.prototype.upload = function (context3D) {
            if (!this.texture2D.textureBuffer) {
                this.texture2D.textureBuffer = this.texture2D.textureBuffer || context3D.creatTexture();
                this.context.drawImage(this.video, 0, 0, this.width, this.height);
                egret3d.Context3DProxy.gl.pixelStorei(egret3d.Context3DProxy.gl.UNPACK_ALIGNMENT, 1);
                egret3d.Context3DProxy.gl.bindTexture(egret3d.Context3DProxy.gl.TEXTURE_2D, this.texture2D.textureBuffer);
                egret3d.Context3DProxy.gl.texImage2D(egret3d.Context3DProxy.gl.TEXTURE_2D, 0, egret3d.Context3DProxy.gl.RGB, egret3d.Context3DProxy.gl.RGB, egret3d.Context3DProxy.gl.UNSIGNED_BYTE, this.tmpCanvas);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_MIN_FILTER, egret3d.Context3DProxy.gl.LINEAR);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_MAG_FILTER, egret3d.Context3DProxy.gl.LINEAR);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_WRAP_S, egret3d.Context3DProxy.gl.CLAMP_TO_EDGE);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_WRAP_T, egret3d.Context3DProxy.gl.CLAMP_TO_EDGE);
            }
            if (this.canUpdataTexture) {
                this.context.drawImage(this.video, 0, 0, this.width, this.height);
                egret3d.Context3DProxy.gl.pixelStorei(egret3d.Context3DProxy.gl.UNPACK_ALIGNMENT, 1);
                egret3d.Context3DProxy.gl.bindTexture(egret3d.Context3DProxy.gl.TEXTURE_2D, this.texture2D.textureBuffer);
                egret3d.Context3DProxy.gl.texImage2D(egret3d.Context3DProxy.gl.TEXTURE_2D, 0, egret3d.Context3DProxy.gl.RGB, egret3d.Context3DProxy.gl.RGB, egret3d.Context3DProxy.gl.UNSIGNED_BYTE, this.tmpCanvas);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_MIN_FILTER, egret3d.Context3DProxy.gl.LINEAR);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_MAG_FILTER, egret3d.Context3DProxy.gl.LINEAR);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_WRAP_S, egret3d.Context3DProxy.gl.CLAMP_TO_EDGE);
                egret3d.Context3DProxy.gl.texParameteri(egret3d.Context3DProxy.gl.TEXTURE_2D, egret3d.Context3DProxy.gl.TEXTURE_WRAP_T, egret3d.Context3DProxy.gl.CLAMP_TO_EDGE);
            }
        };
        /**
        * @private
        */
        VideoTexture.prototype.uploadForcing = function (context3D) {
        };
        return VideoTexture;
    }(egret3d.ITexture));
    egret3d.VideoTexture = VideoTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.RenderTexture
    * @classdesc
    * 渲染目标贴图
    * @see egret3d.ITexture
    * @version Egret 3.0
    * @platform Web,Native
    */
    var RenderTexture = (function (_super) {
        __extends(RenderTexture, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param width  贴图的宽度 默认参数 默认为512
        * @param height 贴图的高度 默认参数 默认为512
        * @param frameBufferFormat 帧buffer的格式 默认参数 FrameBufferFormat.UNSIGNED_BYTE_RGB
        * @version Egret 3.0
        * @platform Web,Native
        */
        function RenderTexture(width, height, frameBufferFormat) {
            if (width === void 0) { width = 512; }
            if (height === void 0) { height = 512; }
            if (frameBufferFormat === void 0) { frameBufferFormat = egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB; }
            _super.call(this);
            /**
            * @language zh_CN
            * 帧buffer的格式
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.frameBufferFormat = egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB;
            this.useMipmap = false;
            this.smooth = false;
            this.width = width;
            this.height = height;
            this.frameBufferFormat = frameBufferFormat;
            this.uvRectangle = new egret3d.Rectangle(0, 0, 1.0, 1.0);
            switch (this.frameBufferFormat) {
                case egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGBA:
                    this.colorFormat = egret3d.ContextConfig.UNSIGNED_BYTE;
                    break;
                case egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB:
                    this.colorFormat = egret3d.ContextConfig.UNSIGNED_BYTE;
                    break;
                case egret3d.FrameBufferFormat.FLOAT_RGBA:
                    this.colorFormat = egret3d.ContextConfig.FLOAT;
                    break;
                case egret3d.FrameBufferFormat.FLOAT_RGB:
                    this.colorFormat = egret3d.ContextConfig.FLOAT;
                    break;
            }
        }
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        RenderTexture.prototype.upload = function (context3D) {
            if (!this.texture2D) {
                this.texture2D = context3D.createFramebuffer(this.width, this.height, this.frameBufferFormat);
            }
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        RenderTexture.prototype.uploadForcing = function (context3D) {
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        RenderTexture.prototype.fillPixels = function () {
            if (this.texture2D) {
                var pixels;
                if (!this.texture2D.mimapData) {
                    this.texture2D.mimapData = [];
                    switch (this.frameBufferFormat) {
                        case egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGBA:
                            pixels = new Uint8Array(this.width * this.height * 4);
                            break;
                        case egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB:
                            pixels = new Uint8Array(this.width * this.height * 3);
                            break;
                        case egret3d.FrameBufferFormat.FLOAT_RGBA:
                            pixels = new Float32Array(this.width * this.height * 4);
                            break;
                        case egret3d.FrameBufferFormat.FLOAT_RGB:
                            pixels = new Float32Array(this.width * this.height * 3);
                            break;
                    }
                    var mipmapData = new egret3d.MipmapData(pixels, this.width, this.height);
                    this.texture2D.mimapData.push(mipmapData);
                }
                else {
                    var mipmapData = this.texture2D.mimapData[0];
                    pixels = mipmapData.data;
                }
                egret3d.Context3DProxy.gl.readPixels(0, 0, this.width, this.height, this.colorFormat, egret3d.ContextConfig.UNSIGNED_BYTE, pixels);
            }
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        RenderTexture.prototype.readPixels = function (x, y, width, height, format, type, pixels) {
            if (format === void 0) { format = egret3d.ContextConfig.ColorFormat_RGBA8888; }
            if (type === void 0) { type = egret3d.ContextConfig.UNSIGNED_BYTE; }
            if (pixels === void 0) { pixels = null; }
            pixels = _super.prototype.readPixels.call(this, x, y, width, height, format, type, pixels);
            if (this.texture2D && this.texture2D.mimapData) {
                var mipmapData = this.texture2D.mimapData[0];
                var data = mipmapData.data;
                var count = 4;
                switch (this.frameBufferFormat) {
                    case egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGBA:
                    case egret3d.FrameBufferFormat.FLOAT_RGBA:
                        count = 4;
                        break;
                    case egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB:
                    case egret3d.FrameBufferFormat.FLOAT_RGB:
                        count = 3;
                        break;
                }
                for (var i = 0; i < height; ++i) {
                    for (var j = 0; j < width; ++j) {
                        for (var k = 0; k < count; ++k) {
                            pixels[(i * width + j) * 4 + k] = data[((y + i) * this.width + (x + j)) * 4 + k];
                        }
                    }
                }
            }
            return pixels;
        };
        return RenderTexture;
    }(egret3d.ITexture));
    egret3d.RenderTexture = RenderTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * 实时阴影渲染需要提供的数据接口。
    * 基于shadow mapping 的阴影算法,
    * 当前阴影只支持方向光,
    * 默认灯光方向是 Vector3D(1, -1, 0), 阴影摄像机为此灯光的子节点,
    * 阴影渲染摄像机的位置为Vector3D(-707, 707, 0),
    * 摄像机 near 1 far 3000  width 2048 height 2048 ,
    * 当渲染阴影的物体超出阴影摄像机的范围阴影将不会渲染阴影,
    * 可以进行调节阴影摄像机的 位置 和 其它参数来进行处理,
    * this.directLight 当前渲染阴影的灯光,
    * this.shadowCamera 当前渲染阴影的摄像机
    * @includeExample shadow/Shadow.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ShadowCast = (function () {
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ShadowCast(view) {
            this._boundBox = new egret3d.BoundBox();
            /**
            * @language zh_CN
            * 开启阴影渲染
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.enableShadow = false;
            /**
            * @language zh_CN
            * @private
            * 阴影贴图的宽
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.textureSizeWidth = 1024;
            /**
            * @language zh_CN
            * @private
            * 阴影贴图的高
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.textureSizeHeight = 1024;
            this.shadowCamera = new egret3d.Camera3D(egret3d.CameraType.orthogonal);
            this.shadowRender = new egret3d.MultiRender(egret3d.PassType.shadowPass);
            this.shadowRender.name = egret3d.PassType.shadowPass.toString();
            this.shadowRender.camera = this.shadowCamera;
            this.shadowRender.setRenderToTexture(this.textureSizeWidth, this.textureSizeHeight, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGBA);
            this.castShadowLight(view.sunLight);
            var v = egret3d.MathUtil.CALCULATION_VECTOR3D;
            v.copyFrom(this.directLight.dir);
            v.negate();
            v.scaleBy(1000);
            this.shadowCamera.globalPosition = v;
            view.renderQuen.addRender(this.shadowRender);
        }
        /**
        * @language zh_CN
        * 设置阴影贴图的宽度和高度
        * @param width 宽度
        * @param height 高度
        * @version Egret 3.0
        * @platform Web,Native
        */
        ShadowCast.prototype.setTextureSize = function (width, height) {
            this.textureSizeWidth = width;
            this.textureSizeHeight = height;
            this.shadowRender.setRenderToTexture(this.textureSizeWidth, this.textureSizeHeight, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGBA);
        };
        /**
        * @language zh_CN
        * 如需要渲染阴影必须先设置当前阴影灯光，暂支持方向光
        * 灯光中的变换会用于阴影像机的变换
        * 注意:在阴影摄像机视锥中的物体,阴影才会渲染.
        * @param light 阴影灯光
        * @version Egret 3.0
        * @platform Web,Native
        */
        ShadowCast.prototype.castShadowLight = function (light) {
            this.directLight = light;
            this.shadowCamera.updateViewport(0, 0, 2048, 2048);
            this.shadowCamera.near = 1;
            this.shadowCamera.far = 3000;
            light.addChild(this.shadowCamera);
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        ShadowCast.prototype.update = function (entityCollect, time, delay) {
            this.calculateBoundBox(entityCollect);
            //Egret3DCanvas.context3DProxy.clearColor(1.0,1.0,1.0,1.0);
            //Egret3DCanvas.context3DProxy.clear(Context3DProxy.gl.COLOR_BUFFER_BIT | Context3DProxy.gl.DEPTH_BUFFER_BIT);
            //this.shadowRender.camera = this.shadowCamera;
            //this.shadowRender.draw(time, delay, Egret3DCanvas.context3DProxy, entityCollect);
        };
        ShadowCast.prototype.calculateBoundBox = function (entityCollect) {
            this._boundBox.min.copyFrom(new egret3d.Vector3D(egret3d.MathUtil.MAX_VALUE, egret3d.MathUtil.MAX_VALUE, egret3d.MathUtil.MAX_VALUE));
            this._boundBox.max.copyFrom(new egret3d.Vector3D(-egret3d.MathUtil.MAX_VALUE, -egret3d.MathUtil.MAX_VALUE, -egret3d.MathUtil.MAX_VALUE));
            for (var i = 0; i < entityCollect.specialCastItem[egret3d.SpecialCast.Shadow].length; i++) {
                var item = entityCollect.specialCastItem[egret3d.SpecialCast.Shadow][i];
                var boundBox = item.bound;
                if (this._boundBox.max.x < boundBox.max.x + item.globalX) {
                    this._boundBox.max.x = boundBox.max.x + item.globalX;
                }
                if (this._boundBox.max.y < boundBox.max.y + item.globalY) {
                    this._boundBox.max.y = boundBox.max.y + item.globalY;
                }
                if (this._boundBox.max.z < boundBox.max.z + item.globalZ) {
                    this._boundBox.max.z = boundBox.max.z + item.globalZ;
                }
                if (this._boundBox.min.x > boundBox.min.x + item.globalX) {
                    this._boundBox.min.x = boundBox.min.x + item.globalX;
                }
                if (this._boundBox.min.y > boundBox.min.y + item.globalY) {
                    this._boundBox.min.y = boundBox.min.y + item.globalY;
                }
                if (this._boundBox.min.z > boundBox.min.z + item.globalZ) {
                    this._boundBox.min.z = boundBox.min.z + item.globalZ;
                }
            }
            this._boundBox.fillBox(this._boundBox.min, this._boundBox.max);
            var v = egret3d.MathUtil.CALCULATION_VECTOR3D;
            v.copyFrom(this.directLight.dir);
            v.negate();
            v.scaleBy(this._boundBox.radius);
            v.add(this._boundBox.center, v);
            this.shadowCamera.globalPosition = v;
            this.shadowCamera.updateViewport(0, 0, this._boundBox.radius * 2, this._boundBox.radius * 2);
            this.shadowCamera.far = this._boundBox.radius * 2;
        };
        return ShadowCast;
    }());
    egret3d.ShadowCast = ShadowCast;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.CameraAnimationManager
    * @classdesc
    * 摄像机管理器
    * 管理所有摄像机动画
    * @see egret3d.Camera3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CameraManager = (function () {
        /**
        * @language zh_CN
        * 构建一个摄像机管理对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function CameraManager() {
            this.cameras = new Array();
        }
        CameraManager.prototype.addCamera = function (camera) {
            this.cameras.push(camera);
        };
        CameraManager.prototype.removeCamera = function (camera) {
            var idx = this.cameras.indexOf(camera);
            if (idx >= 0) {
                this.cameras.splice(idx, 1);
            }
        };
        /**
        * @language zh_CN
        * 更新所有的摄像机
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraManager.prototype.update = function (time, delay) {
            //for (var i: number = 0; i < this.cameras.length; ++i) {
            //    this.cameras[i].update(time, delay, this.cameras[i]);
            //}
        };
        CameraManager.instance = new CameraManager();
        return CameraManager;
    }());
    egret3d.CameraManager = CameraManager;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.CameraType
    * @classdesc
    * 摄像机类型</p>
    * 不同的摄像机类型，会产生不同的渲染视觉效果。</p>
    * 透视投影 是从某个投射中心将物体投射到单一投影面上所得到的图形。</p>
    * 正交投影 投影线垂直于投影面的投影。</p>
    * orthogonal 和 orthogonalToCenter都是正交投影，只是使用不同的方式创建</p>
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (CameraType) {
        /**
        * @language zh_CN
        * 透视投影
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraType[CameraType["perspective"] = 0] = "perspective";
        /**
        * @language zh_CN
        * 正交投影
        * @see egret3d.Matrix4_4.ortho
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraType[CameraType["orthogonal"] = 1] = "orthogonal";
        /**
        * @language zh_CN
        * 正交投影
        * @see egret3d.Matrix4_4.orthoOffCenter
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraType[CameraType["orthogonalToCenter"] = 2] = "orthogonalToCenter";
    })(egret3d.CameraType || (egret3d.CameraType = {}));
    var CameraType = egret3d.CameraType;
    ;
    /**
    * @class egret3d.Camera3D
    * @classdesc
    * 相机数据处理，生成3D摄相机。</p>
    * 渲染场景从摄像机视点到缓冲区。</p>
    * 相机分为透视摄像机、正交摄像机。</p>
    * 默认相机朝向是(0, 0, 1) 头朝向是(0, 1, 0)
    *
    * @see egret3d.Matrix4_4
    * @see egret3d.Object3D
    *
    * @includeExample camera/Camera3D.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Camera3D = (function (_super) {
        __extends(Camera3D, _super);
        /**
        * @language zh_CN
        * constructor
        * @param cameraType 相机类型 默认为 CameraType.perspective 透视相机
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Camera3D(cameraType) {
            if (cameraType === void 0) { cameraType = CameraType.perspective; }
            _super.call(this);
            /**
            * @language zh_CN
            * 相机投影矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.projectMatrix = new egret3d.Matrix4_4();
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._orthProjectMatrix = new egret3d.Matrix4_4();
            this._viewPort = new egret3d.Rectangle();
            this._scissorRect = new egret3d.Rectangle();
            this._aspectRatio = 1.0;
            this._fovY = 45.0;
            this._near = 1;
            this._far = 10000.0;
            this.temp = new egret3d.Matrix4_4();
            this._lookAtPosition = new egret3d.Vector3D();
            this._up = new egret3d.Vector3D(0, 1, 0);
            this._cameraType = 0;
            this._cameraMatrixChange = false;
            this._viewMatrix = new egret3d.Matrix4_4();
            this._tempQuat = new egret3d.Quaternion();
            this._normalMatrix = new egret3d.Matrix4_4();
            this._unprojection = new egret3d.Matrix4_4();
            this._animation = [];
            this.orthProjectChange = true;
            this._mat = new egret3d.Matrix4_4();
            this._maxBest = false;
            this._maxBestPoint = new egret3d.Point();
            this._angleVector = new egret3d.Vector3D();
            /*
            * @private
            */
            this.billboardX = new egret3d.Matrix4_4();
            /*
            * @private
            */
            this.billboardY = new egret3d.Matrix4_4();
            /*
            * @private
            */
            this.billboardZ = new egret3d.Matrix4_4();
            /*
            * @private
            */
            this.billboardXYZ = new egret3d.Matrix4_4();
            this.raw = new Float32Array(16);
            this.v = new egret3d.Vector3D();
            this.p = new egret3d.Vector3D();
            this.frustum = new egret3d.Frustum(this);
            this._orthProjectMatrix.ortho(this._viewPort.width, this._viewPort.height, this._near, this._far);
            this.cameraType = cameraType;
            egret3d.CameraManager.instance.addCamera(this);
            this._viewMatrix.identity();
        }
        Object.defineProperty(Camera3D.prototype, "cameraType", {
            /**
            * @language zh_CN
            * 获取相机类型
            * @returns CameraType 相机类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._cameraType;
            },
            /**
             * @language zh_CN
             * 设置相机类型
             * @param cameraType 相机类型
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (cameraType) {
                this._cameraType = cameraType;
                switch (cameraType) {
                    case CameraType.orthogonal:
                        this.projectMatrix.ortho(this._viewPort.width, this._viewPort.height, this._near, this._far);
                        break;
                    case CameraType.orthogonalToCenter:
                        this.projectMatrix.orthoOffCenter(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height, this._near, this._far);
                        break;
                    case CameraType.perspective:
                        this.projectMatrix.perspective(this._fovY, this._aspectRatio, this._near, this._far);
                        break;
                }
                this._orthProjectMatrix.ortho(this._viewPort.width, this._viewPort.height, this._near, this._far);
                this.frustum.updateFrustum();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "maxWidthAndHeight", {
            get: function () {
                if (!this._maxBest) {
                    this._maxBest = true;
                    this._maxBestPoint.x = egret3d.sizeUtil.getBestPowerOf2(this.viewPort.width);
                    this._maxBestPoint.y = egret3d.sizeUtil.getBestPowerOf2(this.viewPort.height);
                }
                return this._maxBestPoint;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "aspectRatio", {
            /**
            * @language zh_CN
            * 返回相机横纵比
            *
            * @returns number 横纵比
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._aspectRatio;
            },
            /**
            * @private
            * @language zh_CN
            * 打开VR相机
            * @param cameraType 相机类型
            * @param vrType VR类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            //public tap(cameraType: CameraType, vrType: VRType = null) {
            //    if (cameraType == CameraType.VR) {
            //        this.eyeMatrix.update(this);
            //        this.orthProjectChange = true;
            //        if (vrType == VRType.left) {
            //            this.viewMatrix.copyFrom(this.eyeMatrix.leftEyeMatrix);
            //        } else if (vrType == VRType.right) {
            //            this.viewMatrix.copyFrom(this.eyeMatrix.rightEyeMatrix);
            //        }
            //        this.viewMatrix.invert();
            //    }
            //}
            /**
            * @language zh_CN
            * 设置相机横纵比
            *
            * @param value 横纵比
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._aspectRatio != value) {
                    this._aspectRatio = value;
                    this.cameraType = this._cameraType;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "fieldOfView", {
            /**
            * @language zh_CN
            * 返回相机fovY
            *
            * @returns number fovY
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._fovY;
            },
            /**
            * @language zh_CN
            * 设置相机fovY
            *
            * @param value fovY
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._fovY != value) {
                    this._fovY = value;
                    this.cameraType = this._cameraType;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "near", {
            /**
            * @language zh_CN
            * 返回相机近截面
            *
            * @returns 近截面
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._near;
            },
            /**
            * @language zh_CN
            * 设置相机近截面
            *
            * @param value 近截面
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._near != value) {
                    this._near = value;
                    this.cameraType = this._cameraType;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "far", {
            /**
            * @language zh_CN
            * 返回相机远截面
            *
            * @returns 远截面
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._far;
            },
            /**
            * @language zh_CN
            * 设置相机远截面
            *
            * @param value 远截面
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._far != value) {
                    this._far = value;
                    this.cameraType = this._cameraType;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "viewPort", {
            /**
            * @language zh_CN
            * 返回viewPort
            *
            * @returns Rectangle
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._viewPort;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "viewProjectionMatrix", {
            /**
            * @language zh_CN
            * 返回相机视图投影矩阵
            *
            * @returns 视图投影矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                this.temp.copyFrom(this.viewMatrix);
                this.temp.multiply(this.projectMatrix);
                return this.temp;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "orthProjectionMatrix", {
            get: function () {
                //this.updataOrth(this._orthProjectMatrix);
                if (this.orthProjectChange) {
                    this.orthProjectChange = false;
                    this._orthProjectMatrix.ortho(this._viewPort.width, this._viewPort.height, this._near, this._far);
                }
                return this._orthProjectMatrix;
            },
            enumerable: true,
            configurable: true
        });
        ///**
        //* @language zh_CN
        //* 视图noormal矩阵
        //* normal 矩阵用来纠正透视相机影响视图变形，所影响的法线轴变形，一般用 modeviewMatrix 的逆举证的转置矩阵。
        //* @version Egret 3.0
        //* @platform Web,Native
        //*/
        //public get normalMatrix(): Matrix4_4 {
        //    this._normalMatrix.copyFrom(this.viewMatrix);
        //    this._normalMatrix.multiply(this.projectMatrix);
        //    return this._normalMatrix; 
        //}
        /**
         * @private
         * @language zh_CN
         * @param x number
         * @param y number
         * @param width number
         * @param height number
         * @version Egret 3.0
         * @platform Web,Native
         */
        Camera3D.prototype.updateScissorRect = function (x, y, width, height) {
            this._scissorRect.x = x;
            this._scissorRect.y = y;
            this._scissorRect.width = width;
            this._scissorRect.height = height;
        };
        /**
        * @language zh_CN
        * 更新视口
        * @param x number
        * @param y number
        * @param width number
        * @param height number
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.updateViewport = function (x, y, width, height) {
            if (x == this._viewPort.x && y == this._viewPort.y &&
                width == this._viewPort.width && height == this._viewPort.height) {
                return;
            }
            this.orthProjectChange = true;
            this._viewPort.x = x;
            this._viewPort.y = y;
            this._viewPort.width = width;
            this._viewPort.height = height;
            switch (this.cameraType) {
                case CameraType.orthogonal:
                case CameraType.orthogonalToCenter:
                    this.cameraType = this.cameraType;
                    break;
            }
        };
        /**
        * @language zh_CN
        * 当前对象对视位置 (全局坐标) (修改的是自身的全局变换)
        * @param pos 相机的位置     (全局坐标)
        * @param target 目标的位置  (全局坐标)
        * @param up 向上的方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.lookAt = function (pos, target, up) {
            if (up === void 0) { up = egret3d.Vector3D.Y_AXIS; }
            this.globalPosition = pos;
            this._lookAtPosition.copyFrom(target);
            this._up.copyFrom(up);
            this._viewMatrix.lookAt(pos, target, up);
            this._mat.copyFrom(this._viewMatrix);
            this._mat.invert();
            var prs = this._mat.decompose(egret3d.Orientation3D.QUATERNION);
            this._tempQuat.x = prs[1].x;
            this._tempQuat.y = prs[1].y;
            this._tempQuat.z = prs[1].z;
            this._tempQuat.w = prs[1].w;
            this.globalOrientation = this._tempQuat;
        };
        /**
        * @language zh_CN
        * 当前对象对视位置 (本地坐标) (修改的是自身的本地变换)
        * @param pos 相机的位置     (本地坐标)
        * @param target 目标的位置  (本地坐标)
        * @param up 向上的方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.lookAtLocal = function (pos, target, up) {
            if (up === void 0) { up = egret3d.Vector3D.Y_AXIS; }
            this.position = pos;
            this._lookAtPosition.copyFrom(target);
            this._up.copyFrom(up);
            this._viewMatrix.lookAt(pos, target, up);
            this._mat.copyFrom(this._viewMatrix);
            this._mat.invert();
            var prs = this._mat.decompose(egret3d.Orientation3D.QUATERNION);
            this._tempQuat.x = prs[1].x;
            this._tempQuat.y = prs[1].y;
            this._tempQuat.z = prs[1].z;
            this._tempQuat.w = prs[1].w;
            this.orientation = this._tempQuat;
        };
        Camera3D.prototype.onMakeTransform = function () {
            egret3d.Vector3D.HELP_1.setTo(1, 1, 1, 1);
            egret3d.Vector3D.HELP_0.setTo(0, 0, 0, 1);
            this._modelMatrix3D.makeTransform(this._pos, egret3d.Vector3D.HELP_1, this._orientation);
            this._modelMatrix3D.makeTransform(this._globalPos, egret3d.Vector3D.HELP_1, this._globalOrientation);
            egret3d.MathUtil.calcDegree(this._globalOrientation, this._angleVector);
            //this.billboardX.identity();
            //this.billboardX.appendRotation(this._angleVector.x, Vector3D.X_AXIS);
            this.billboardY.identity();
            this.billboardY.createByRotation(this._angleVector.y, egret3d.Vector3D.Y_AXIS);
            //this.billboardZ.identity();
            //this.billboardZ.appendRotation(this._angleVector.z, Vector3D.Z_AXIS);
            this.billboardXYZ.makeTransform(egret3d.Vector3D.HELP_0, egret3d.Vector3D.HELP_1, this._globalOrientation);
        };
        Camera3D.prototype.onUpdateTransform = function () {
            this._viewMatrix.copyFrom(this._modelMatrix3D);
            this._viewMatrix.invert();
            this.frustum.update();
        };
        Object.defineProperty(Camera3D.prototype, "viewMatrix", {
            /**
             * @language zh_CN
             *
             * 相机视图矩阵
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._viewMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "lookAtPosition", {
            /**
             * @language zh_CN
             *
             * 相机目标点
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._lookAtPosition;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * 更新正交矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.updataOrth = function (target) {
            var _projectionHeight = 2000;
            var _yMax = _projectionHeight * .5;
            var _xMax = _yMax * this._aspectRatio;
            var left, right, top, bottom;
            ///return 
            if (this._scissorRect.x == 0 && this._scissorRect.y == 0 && this._scissorRect.width == this._viewPort.width && this._scissorRect.height == this._viewPort.height) {
                /// assume symmetric frustum
                left = -_xMax;
                right = _xMax;
                top = -_yMax;
                bottom = _yMax;
                this.raw[0] = 2 / (_projectionHeight * this._aspectRatio);
                this.raw[5] = 2 / _projectionHeight;
                this.raw[10] = 1 / (this._far - this._near);
                this.raw[14] = this._near / (this._near - this._far);
                this.raw[1] = this.raw[2] = this.raw[3] = this.raw[4] =
                    this.raw[6] = this.raw[7] = this.raw[8] = this.raw[9] =
                        this.raw[11] = this.raw[12] = this.raw[13] = 0;
                this.raw[15] = 1;
            }
            else {
                var xWidth = _xMax * (this._viewPort.width / this._scissorRect.width);
                var yHgt = _yMax * (this._viewPort.height / this._scissorRect.height);
                var center = _xMax * (this._scissorRect.x * 2 - this._viewPort.width) / this._scissorRect.width + _xMax;
                var middle = -_yMax * (this._scissorRect.y * 2 - this._viewPort.height) / this._scissorRect.height - _yMax;
                left = center - xWidth;
                right = center + xWidth;
                top = middle - yHgt;
                bottom = middle + yHgt;
                this.raw[0] = 2 * 1 / (right - left);
                this.raw[5] = -2 * 1 / (top - bottom);
                this.raw[10] = 1 / (this._far - this._near);
                this.raw[12] = (right + left) / (right - left);
                this.raw[13] = (bottom + top) / (bottom - top);
                this.raw[14] = this._near / (this.near - this.far);
                this.raw[1] = this.raw[2] = this.raw[3] = this.raw[4] =
                    this.raw[6] = this.raw[7] = this.raw[8] = this.raw[9] = this.raw[11] = 0;
                this.raw[15] = 1;
            }
            target.copyRawDataFrom(this.raw);
        };
        /**
         * @language zh_CN
         * 检测对象是否在相机视椎体内
         * @param renderItem 需要体测的对象
         * @returns 成功返回true
         * @version Egret 3.0
         * @platform Web,Native
         */
        Camera3D.prototype.isVisibleToCamera = function (renderItem) {
            //尝试刷新modelMatrix的值，有可能changed为true
            renderItem.modelMatrix;
            this.modelMatrix;
            //添加 手动让当前单位一直处于不剔除状态
            var bool = true;
            if (renderItem.bound) {
                bool = renderItem.bound.inBound(this.frustum) || !renderItem.enableCulling;
            }
            renderItem.inFrustum = bool;
            return bool;
        };
        /**
        * @private
        * @language zh_CN
        * 增加相机动画
        * @param name 相机动画名字
        * @param ani 相机动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.addAnimation = function (name, ani) {
            this._animation[name] = ani;
        };
        /**
        * @private
        * @language zh_CN
        * 播放某个动画
        * 根据动画名字来播放，指定摄像机，并且控制动画是否循环播放
        * @param name 动画名
        * @param isLoop 是否循环
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.play = function (name, isLoop) {
            if (isLoop === void 0) { isLoop = false; }
            if (this._animation[name]) {
                this._animation[name].bindCamera(this);
                this._animation[name].play(isLoop);
            }
        };
        /**
        * @private
        * @language zh_CN
        * 当前对象数据更新
        * @param time 当前时间
        * @param delay 每帧时间间隔
        * @param camera 当前渲染的摄相机
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.update = function (time, delay, camera) {
            _super.prototype.update.call(this, time, delay, camera);
            for (var key in this._animation) {
                this._animation[key].update(time, delay);
            }
        };
        /**
        * @language zh_CN
        * 3维坐标转2维屏幕坐标
        * @param n 3维坐标
        * @param target 2维屏幕坐标 默认为null 为null会返回一个新的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.object3DToScreenRay = function (n, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new egret3d.Vector3D();
            }
            this._halfw = this.viewPort.width * 0.5;
            this._halfh = this.viewPort.height * 0.5;
            target = this.viewMatrix.transformVector(n, target);
            this.project(target, target);
            target.x = this._halfw + target.x * this._halfw;
            target.y = this.viewPort.height - (this._halfh - target.y * this._halfh);
            return target;
        };
        /**
        * @language zh_CN
        * 2维屏幕坐标转3维坐标
        * @param n 2维屏幕坐标
        * @param target 3维坐标 默认为null 为null会返回一个新的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.ScreenRayToObject3D = function (n, target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new egret3d.Vector3D();
            }
            this._halfw = this.viewPort.width * 0.5;
            this._halfh = this.viewPort.height * 0.5;
            target.x = (n.x - this._halfw) / this._halfw;
            target.y = (this._halfh - (this.viewPort.height - n.y)) / this._halfh;
            this.unproject(target.x, target.y, n.z, target);
            this.modelMatrix.transformVector(target, target);
            return target;
        };
        Camera3D.prototype.unproject = function (nX, nY, sZ, target) {
            target.x = nX;
            target.y = -nY;
            target.z = sZ;
            target.w = 1.0;
            target.x *= sZ;
            target.y *= sZ;
            this._unprojection.copyFrom(this.projectMatrix);
            this._unprojection.invert();
            this._unprojection.transformVector(target, target);
            target.z = sZ;
            return target;
        };
        Camera3D.prototype.project = function (n, target) {
            target = this.projectMatrix.transformVector(n, target);
            target.x = target.x / target.w;
            target.y = -target.y / target.w;
            target.z = n.z;
            return target;
        };
        /**
        * @language zh_CN
        * 释放所有数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.dispose = function () {
            egret3d.CameraManager.instance.removeCamera(this);
            _super.prototype.dispose.call(this);
            if (this.frustum) {
                this.frustum.dispose();
            }
            this.frustum = null;
        };
        /**
        * @language zh_CN
        * 克隆当前Camera3D
        * @returns Camera3D 克隆后的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Camera3D.prototype.clone = function () {
            var cloneObject = new Camera3D();
            cloneObject.copy(this);
            return cloneObject;
        };
        return Camera3D;
    }(egret3d.Object3D));
    egret3d.Camera3D = Camera3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.QuadAABB
    * @classdesc
    * 用于四叉树的包围盒抽象
    * @version Egret 3.0
    * @platform Web,Native
    */
    var QuadAABB = (function () {
        /**
        * @language zh_CN
        * constructor
        * @version Egret 3.0
        * @platform Web,Native
        */
        function QuadAABB() {
            /**
            * @language zh_CN
            * 最小x位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.minPosX = 0;
            /**
            * @language zh_CN
            * 最小y位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.minPosY = 0;
            /**
            * @language zh_CN
            * 最大x位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.maxPosX = 0;
            /**
            * @language zh_CN
            * 最大y位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.maxPosY = 0;
            /**
            * @language zh_CN
            * 用于记录quad框选批次
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.testID = 0;
            this.points = new Array();
            this.offsetPosition = new egret3d.Vector3D(0, 0, 0, 0);
            this.clear();
        }
        /**
        * @language zh_CN
        * 将该包围盒设定到以中心点(cx,cy)，纵横距离(sideY,sidex)的范围内
        * @param cx         中心x
        * @param cy         中心y
        * @param sidex      横向范围
        * @param sidey      纵向范围
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.setAABox = function (cx, cy, sideX, sideY) {
            this.minPosX = cx - sideX / 2 - QuadAABB.TINY;
            this.maxPosX = cx + sideX / 2 + QuadAABB.TINY;
            this.minPosY = cy - sideY / 2 - QuadAABB.TINY;
            this.maxPosY = cy + sideY / 2 + QuadAABB.TINY;
            this.offsetPosition.setTo(0, 0, 0);
        };
        /**
        * @language zh_CN
        * 设置偏移量
        * @param vec        偏移坐标
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.setOffset = function (vec) {
            this.maxPosX += vec.x - this.offsetPosition.x;
            this.minPosX += vec.x - this.offsetPosition.x;
            this.minPosY += vec.z - this.offsetPosition.z;
            this.maxPosY += vec.z - this.offsetPosition.z;
            this.offsetPosition.copyFrom(vec);
        };
        /**
        * @language zh_CN
        * 设定包含某个范围
        * @param minX         中心x
        * @param minY         中心y
        * @param maxX      横向范围
        * @param maxY      纵向范围
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.setContainRect = function (minX, minY, maxX, maxY) {
            if (this.minPosX > minX)
                this.minPosX = minX;
            if (this.minPosY > minY)
                this.minPosY = minY;
            if (this.maxPosX < maxX)
                this.maxPosX = maxX;
            if (this.maxPosY < maxY)
                this.maxPosY = maxY;
        };
        /**
        * @language zh_CN
        * 重置包围盒
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.clear = function () {
            var huge = 1000000000;
            this.minPosX = this.minPosY = huge;
            this.maxPosX = this.maxPosY = -huge;
            this.points.length = 0;
            this.testID = 0;
            this.offsetPosition.setTo(0, 0, 0);
        };
        /**
        * @language zh_CN
        * 添加一个点
        * @param pos         点坐标
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.addPoint = function (pos) {
            if (this.points.indexOf(pos) == -1) {
                if (pos.x < this.minPosX)
                    this.minPosX = pos.x - QuadAABB.TINY;
                if (pos.x > this.maxPosX)
                    this.maxPosX = pos.x + QuadAABB.TINY;
                if (pos.z < this.minPosY)
                    this.minPosY = pos.z - QuadAABB.TINY;
                if (pos.z > this.maxPosY)
                    this.maxPosY = pos.z + QuadAABB.TINY;
                this.points.push(pos);
            }
        };
        /**
        * @language zh_CN
        * 获得该对象克隆
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.clone = function () {
            var aabb = new QuadAABB();
            aabb.minPosX = this.minPosX;
            aabb.minPosY = this.minPosY;
            aabb.maxPosX = this.maxPosX;
            aabb.maxPosY = this.maxPosY;
            return aabb;
        };
        Object.defineProperty(QuadAABB.prototype, "radius", {
            /**
            * @language zh_CN
            * 获得对角线长
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return Math.sqrt((this.maxPosY - this.minPosY) * (this.maxPosY - this.minPosY) + (this.maxPosX - this.minPosX) * (this.maxPosX - this.minPosX));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuadAABB.prototype, "sideX", {
            /**
            * @language zh_CN
            * 获得宽
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.maxPosX - this.minPosX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuadAABB.prototype, "sideY", {
            /**
            * @language zh_CN
            * 获得高
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.maxPosY - this.minPosY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuadAABB.prototype, "centreX", {
            /**
            * @language zh_CN
            * 获得中心点x
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return (this.maxPosX - this.minPosX) * 0.5 + this.minPosX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuadAABB.prototype, "centreY", {
            /**
            * @language zh_CN
            * 获得中心点y
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return (this.maxPosY - this.minPosY) * 0.5 + this.minPosY;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 与另外一个包围盒碰撞测试
        * @param box        测试的碰撞对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.overlapTest = function (box) {
            return ((this.minPosY >= box.maxPosY) ||
                (this.maxPosY <= box.minPosY) ||
                (this.minPosX >= box.maxPosX) ||
                (this.maxPosX <= box.minPosX)) ? false : true;
        };
        /**
        * @language zh_CN
        * 判定某个点在包围盒内
        * @param box        测试的点
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.isPointInside = function (pos) {
            return ((pos.x >= this.minPosX) &&
                (pos.x <= this.maxPosX) &&
                (pos.z >= this.minPosY) &&
                (pos.z <= this.maxPosY));
        };
        /**
        * @language zh_CN
        * 与一条线段碰撞测试
        * @param p1x        线段起点x
        * @param p1y        线段起点y
        * @param p2x        线段终点x
        * @param p2y        线段终点y
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.prototype.isIntersectLineSegment = function (p1x, p1y, p2x, p2y) {
            var isIntersect = false;
            // 直线方程p1-p2
            var A1 = p1y - p2y;
            var B1 = p2x - p1x;
            var C1 = p1x * p2y - p2x * p1y;
            // 与AABox
            var LineIntersectY = (-C1 - A1 * this.minPosX) / B1;
            if (LineIntersectY <= this.maxPosY && LineIntersectY >= this.minPosY)
                isIntersect = true;
            LineIntersectY = (-C1 - A1 * this.maxPosX) / B1;
            if (LineIntersectY <= this.maxPosY && LineIntersectY >= this.minPosY)
                isIntersect = true;
            var LineIntersectX = (-C1 - B1 * this.minPosY) / A1;
            if (LineIntersectX <= this.maxPosX && LineIntersectX >= this.minPosX)
                isIntersect = true;
            LineIntersectX = (-C1 - B1 * this.maxPosY) / A1;
            if (LineIntersectX <= this.maxPosX && LineIntersectX >= this.minPosX)
                isIntersect = true;
            return isIntersect;
        };
        /**
        * @language zh_CN
        * @private
        * 设定一个微小的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadAABB.TINY = 0.000001;
        return QuadAABB;
    }());
    egret3d.QuadAABB = QuadAABB;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.QuadTree
    * @classdesc
    * 四叉树
    * @version Egret 3.0
    * @platform Web,Native
    */
    var QuadTree = (function () {
        /**
        * @language zh_CN
        * constructor
        * @version Egret 3.0
        * @platform Web,Native
        */
        function QuadTree() {
            /**
            * @language zh_CN
            * 显示quadtree结构
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.logDeep = 0;
            this._testID = 0;
            this._cells = new Array();
            this._quadNodes = new Array();
            this._cellsToTest = new Array();
            this._aabb = new egret3d.QuadAABB();
        }
        /**
        * @language zh_CN
        * 根据下标获取node对象
        * @param    idx     下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.getQuadNode = function (idx) {
            return this._quadNodes[idx];
        };
        /**
        * @language zh_CN
        * 清理
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.clear = function () {
            this._cells.length = 0;
            this._quadNodes.length = 0;
        };
        /**
        * @language zh_CN
        * 插入一系列node到树中,不build
        * @param    nodes     待初始化的节点列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.initNodes = function (nodes) {
            this.clear();
            var i = 0;
            var count = nodes.length;
            while (i < count) {
                nodes[i].calcGlobalQuadAABB();
                this._quadNodes.push(nodes[i]);
                i++;
            }
        };
        /**
        * @language zh_CN
        * 构建四叉树
        * @param    maxNodesPerCell     一个Cell中最多几个三角
        * @param    minCellSize         一个cell单元最小划分到多小
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.buildQuadTree = function (maxNodesPerCell, minCellSize) {
            this._aabb.clear();
            for (var _i = 0, _a = this._quadNodes; _i < _a.length; _i++) {
                var node = _a[_i];
                if (node.isTriangle) {
                    for (var _b = 0, _c = node.aabb.points; _b < _c.length; _b++) {
                        var vt = _c[_b];
                        this._aabb.addPoint(vt);
                    }
                }
                else {
                    this._aabb.setContainRect(node.aabb.minPosX, node.aabb.minPosY, node.aabb.maxPosX, node.aabb.maxPosY);
                }
            }
            this._cells.length = 0;
            this._rootCell = new egret3d.QuadTreeCell(this._aabb); // 创建根节点
            this._cells.push(this._rootCell);
            var numTriangles = this._quadNodes.length;
            for (var i = 0; i < numTriangles; i++) {
                this._cells[0].nodeIndices[i] = i; // 先把所有的三角面放到根节点上
            }
            var cellsToProcess = new Array();
            cellsToProcess.push(0);
            var iTri;
            var cellIndex;
            var childCell;
            while (cellsToProcess.length != 0) {
                cellIndex = cellsToProcess.pop();
                if (this._cells[cellIndex].nodeIndices.length <= maxNodesPerCell
                    || this._cells[cellIndex].aabb.radius < minCellSize) {
                    continue; // 该cell中还可以放三角面
                }
                for (i = 0; i < egret3d.QuadTreeCell.NUM_CHILDREN; i++) {
                    this._cells[cellIndex].childCellIndices[i] = this._cells.length;
                    cellsToProcess.push(this._cells.length);
                    this._cells.push(new egret3d.QuadTreeCell(this.createAABox(this._cells[cellIndex].aabb, i)));
                    childCell = this._cells[this._cells.length - 1];
                    // 父节点上的三角型往子节点中放
                    numTriangles = this._cells[cellIndex].nodeIndices.length;
                    var pushCount = 0;
                    for (var j = 0; j < numTriangles; j++) {
                        iTri = this._cells[cellIndex].nodeIndices[j];
                        if (this.doesNodeIntersectCell(this._quadNodes[iTri], childCell)) {
                            pushCount++;
                            childCell.nodeIndices.push(iTri);
                        }
                    }
                }
                this._cells[cellIndex].nodeIndices.length = 0;
            }
            //logTree(0);
        };
        /**
        * @language zh_CN
        * 创建子节点的AABox
        * @param    aabb     包围盒
        * @param    id      象限
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.createAABox = function (aabb, id) {
            var centerX = aabb.centreX;
            var centerY = aabb.centreY;
            var dimX = aabb.sideX;
            var dimY = aabb.sideY;
            var result = new egret3d.QuadAABB();
            switch (id) {
                case 0:
                    result.setAABox(centerX + dimX / 4, centerY + dimY / 4, dimX / 2, dimY / 2);
                    break;
                case 1:
                    result.setAABox(centerX - dimX / 4, centerY + dimY / 4, dimX / 2, dimY / 2);
                    break;
                case 2:
                    result.setAABox(centerX - dimX / 4, centerY - dimY / 4, dimX / 2, dimY / 2);
                    break;
                case 3:
                    result.setAABox(centerX + dimX / 4, centerY - dimY / 4, dimX / 2, dimY / 2);
                    break;
                default:
                    result.setAABox(centerX + dimX / 4, centerY - dimY / 4, dimX / 2, dimY / 2);
                    break;
            }
            return result;
        };
        /**
        * @language zh_CN
        * 如果三角型和Cell相交,返回True
        * @param    node     节点
        * @param    cell     四叉树叶子
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.doesNodeIntersectCell = function (node, cell) {
            // boundingbox要重叠
            var box = node.aabb;
            if (!box.overlapTest(cell.aabb)) {
                return false;
            }
            //如果不是三角形，则只需要检测aabb的相交
            if (!node.isTriangle)
                return true;
            var points = box.points;
            var p1 = points[0];
            var p2 = points[1];
            var p3 = points[2];
            if (cell.aabb.isPointInside(p1) ||
                cell.aabb.isPointInside(p2) ||
                cell.aabb.isPointInside(p3)) {
                return true;
            }
            // cell的顶点在三角型中
            var isIntersect = this.pointInTriangle(cell.aabb.minPosX, cell.aabb.minPosY, p1, p2, p3) ||
                this.pointInTriangle(cell.aabb.minPosX, cell.aabb.maxPosY, p1, p2, p3) ||
                this.pointInTriangle(cell.aabb.maxPosX, cell.aabb.maxPosY, p1, p2, p3) ||
                this.pointInTriangle(cell.aabb.maxPosX, cell.aabb.minPosY, p1, p2, p3);
            if (isIntersect)
                return true;
            // 三角形的边是否与AABB的边相交
            isIntersect = cell.aabb.isIntersectLineSegment(p1.x, p1.z, p2.x, p2.z) ||
                cell.aabb.isIntersectLineSegment(p1.x, p1.z, p3.x, p3.z) ||
                cell.aabb.isIntersectLineSegment(p2.x, p2.z, p3.x, p3.z);
            return isIntersect;
        };
        /**
        * @language zh_CN
        * 寻找在某位置上的三角面
        * @param    result     存储节点的数组
        * @param    aabb       包围盒
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.getNodesIntersectingtAABox = function (result, aabb) {
            if (this._cells.length == 0)
                return 0;
            this._cellsToTest.length = 0;
            this._cellsToTest.push(0);
            this.incrementTestCounter();
            var cellIndex, nTris, cell;
            var nodeBox;
            var i = 0;
            while (this._cellsToTest.length != 0) {
                cellIndex = this._cellsToTest.pop();
                cell = this._cells[cellIndex];
                if (!aabb.overlapTest(cell.aabb)) {
                    continue;
                }
                if (cell.isLeaf()) {
                    nTris = cell.nodeIndices.length;
                    for (i = 0; i < nTris; i++) {
                        nodeBox = this.getQuadNode(cell.nodeIndices[i]).aabb;
                        if (nodeBox.testID != this._testID) {
                            nodeBox.testID = this._testID;
                            if (aabb.overlapTest(nodeBox)) {
                                result.push(cell.nodeIndices[i]);
                            }
                        }
                    }
                }
                else {
                    for (i = 0; i < egret3d.QuadTreeCell.NUM_CHILDREN; i++) {
                        this._cellsToTest.push(cell.childCellIndices[i]);
                    }
                }
            }
            return result.length;
        };
        /**
        * @language zh_CN
        * 判断点在三角型中
        * @param    x           指定点坐标x
        * @param    y           指定点坐标y
        * @param    triPi1      三角形顶点1
        * @param    triPi2      三角形顶点2
        * @param    triPi3      三角形顶点3
        * @returns  是否包含
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.pointInTriangle = function (x, y, triP1, triP2, triP3) {
            var p1 = triP1;
            var p2 = triP2;
            var p3 = triP3;
            // 直线方程p1-p2
            var A1 = p1.z - p2.z;
            var B1 = p2.x - p1.x;
            var C1 = p1.x * p2.z - p2.x * p1.z;
            // 直线方程p2-p3
            var A2 = p2.z - p3.z;
            var B2 = p3.x - p2.x;
            var C2 = p2.x * p3.z - p3.x * p2.z;
            // 直线方程p3-p1
            var A3 = p3.z - p1.z;
            var B3 = p1.x - p3.x;
            var C3 = p3.x * p1.z - p1.x * p3.z;
            var isInTri = false;
            var D1 = A1 * x + B1 * y + C1;
            var D2 = A2 * x + B2 * y + C2;
            var D3 = A3 * x + B3 * y + C3;
            var Tiny = 0.01;
            if ((D1 >= -Tiny && D2 >= -Tiny && D3 >= -Tiny) || (D1 <= Tiny && D2 <= Tiny && D3 <= Tiny))
                isInTri = true;
            return isInTri;
        };
        /**
        * @language zh_CN
        * 递增批次
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTree.prototype.incrementTestCounter = function () {
            ++this._testID;
            if (this._testID == 0) {
                var numTriangles = this._quadNodes.length;
                for (var i = 0; i < numTriangles; i++) {
                    this._quadNodes[i].aabb.testID = 0;
                }
                this._testID = 1;
            }
        };
        QuadTree.prototype.logTree = function (cellIndex) {
            if (cellIndex < 0)
                return;
            this.logDeep++;
            var cell = this._cells[cellIndex];
            var spaces = "";
            for (var si = 0; si < (this.logDeep - 1); si++)
                spaces += "-|";
            console.log(spaces + "i=" + cellIndex + " " +
                cell.aabb.minPosX.toFixed(2) + " " + cell.aabb.maxPosX.toFixed(2) + " "
                + cell.aabb.minPosY.toFixed(2) + " " + cell.aabb.maxPosY.toFixed(2));
            var i;
            for (i = 0; i < cell.nodeIndices.length; i++) {
                if (cell.nodeIndices[i] >= 0) {
                    var tri = this._quadNodes[cell.nodeIndices[i]];
                    console.log(spaces + " t=" + cell.nodeIndices[i] + " " +
                        tri.aabb.minPosX.toFixed(2) + " " + tri.aabb.maxPosX.toFixed(2) + " "
                        + tri.aabb.minPosY.toFixed(2) + " " + tri.aabb.maxPosY.toFixed(2));
                }
            }
            for (i = 0; i < cell.childCellIndices.length; i++) {
                if (cell.childCellIndices[i] >= 0) {
                    this.logTree(cell.childCellIndices[i]);
                }
            }
            this.logDeep--;
        };
        return QuadTree;
    }());
    egret3d.QuadTree = QuadTree;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.QuadRoot
    * @classdesc
    * 创建四叉树的根对象。当前只能用于管理场景中静态的Object，
    * @version Egret 3.0
    * @platform Web,Native
    */
    var QuadRoot = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param maxNodesPerCell 一个Cell中最多几个节点
        * @param minCellSize 一个cell单元最小划分到多小
        */
        function QuadRoot(maxNodesPerCell, minCellSize) {
            if (maxNodesPerCell === void 0) { maxNodesPerCell = 10; }
            if (minCellSize === void 0) { minCellSize = 500; }
            this._maxNodesPerCell = maxNodesPerCell;
            this._minCellSize = minCellSize;
            this._segBox = new egret3d.QuadAABB;
            this._collisionNodesIdx = new Array();
            this._collisionNodes = new Array();
        }
        /**
        * @language zh_CN
        * 创建并构造四叉树
        * @param nodes 需要插入到四叉树中的节点列表
        */
        QuadRoot.prototype.createQuadTree = function (nodes) {
            this._quadTree = new egret3d.QuadTree();
            this._quadTree.initNodes(nodes);
            this._quadTree.buildQuadTree(this._maxNodesPerCell, this._minCellSize);
        };
        /**
        * @language zh_CN
        * 在设定范围内，框选出一批节点
        * @param minX 框选范围最小x值
        * @param minY 框选范围最小y值
        * @param maxX 框选范围最大x值
        * @param maxY 框选范围最大y值
        * @returns Array<IQuadNode>
        */
        QuadRoot.prototype.getNodesByAABB = function (minX, minY, maxX, maxY) {
            // 创建一个射线的boundingbox
            this._segBox.clear();
            this._segBox.maxPosX = maxX;
            this._segBox.maxPosY = maxY;
            this._segBox.minPosX = minX;
            this._segBox.minPosY = minY;
            // 获取Boundingbox中的nodes
            this._collisionNodesIdx.length = 0;
            this._collisionNodes.length = 0;
            var numNodes = this._quadTree.getNodesIntersectingtAABox(this._collisionNodesIdx, this._segBox);
            var quadNode;
            for (var i = 0; i < this._collisionNodesIdx.length; i++) {
                quadNode = this._quadTree.getQuadNode(this._collisionNodesIdx[i]);
                this._collisionNodes.push(quadNode);
            }
            return this._collisionNodes;
        };
        /**
        * @language zh_CN
        * 给定一个三维坐标点，获取节点中最为接近的一个三角形
        * @param point 给定的点
        * @param threshold 设定的阈值，超出这个距离则视为放弃
        * @returns IQuadNode
        */
        QuadRoot.prototype.getTriangleAtPoint = function (point, threshold) {
            if (threshold === void 0) { threshold = 5; }
            // 创建一个射线的boundingbox
            this._segBox.clear();
            this._segBox.setAABox(point.x, point.z, 1, 1);
            this._collisionNodesIdx.length = 0;
            this._collisionNodes.length = 0;
            // 获取Boundingbox中的node的ID
            var numTriangles = this._quadTree.getNodesIntersectingtAABox(this._collisionNodesIdx, this._segBox);
            // 检查那个三角与点(x,y)相交
            var minDistance = 0xffffffff;
            var curDistance = 0;
            var minTriangle;
            var quadNode;
            var triangle;
            var box;
            for (var i = 0; i < this._collisionNodesIdx.length; i++) {
                quadNode = this._quadTree.getQuadNode(this._collisionNodesIdx[i]);
                box = quadNode.aabb;
                if (!egret3d.PointUtils.pointInsideTriangle(point, box.points[0], box.points[1], box.points[2])) {
                    continue;
                }
                triangle = quadNode;
                curDistance = Math.abs(triangle.plane.distance(point));
                if (curDistance > threshold)
                    continue;
                if (quadNode == null || curDistance <= minDistance) {
                    minTriangle = triangle;
                    minDistance = curDistance;
                }
            }
            return minTriangle;
        };
        return QuadRoot;
    }());
    egret3d.QuadRoot = QuadRoot;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.QuadTreeCell
    * @classdesc
    * 四叉树叶子节点
    * @version Egret 3.0
    * @platform Web,Native
    */
    var QuadTreeCell = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param aabox 该叶子的包围盒
        * @version Egret 3.0
        * @platform Web,Native
        */
        function QuadTreeCell(aabox) {
            this.childCellIndices = new Array();
            this.childCellIndices.length = QuadTreeCell.NUM_CHILDREN;
            this.nodeIndices = new Array();
            this.clear();
            if (aabox) {
                this.aabb = aabox.clone();
            }
            else {
                this.aabb = new egret3d.QuadAABB();
            }
        }
        /**
        * @language zh_CN
        * Indicates if we contain triangles (if not then we should/might have children)
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTreeCell.prototype.isLeaf = function () {
            return this.childCellIndices[0] == -1;
        };
        /**
        * @language zh_CN
        * 重置该叶子
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTreeCell.prototype.clear = function () {
            for (var i = 0; i < QuadTreeCell.NUM_CHILDREN; i++) {
                this.childCellIndices[i] = -1;
            }
            this.nodeIndices.splice(0, this.nodeIndices.length);
        };
        /**
        * @language zh_CN
        * 一个叶子单元最多包含子叶子树4个
        * @version Egret 3.0
        * @platform Web,Native
        */
        QuadTreeCell.NUM_CHILDREN = 4;
        return QuadTreeCell;
    }());
    egret3d.QuadTreeCell = QuadTreeCell;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.DoubleArray
    * @classdesc
    * 利用2个数组实现键值对的数组
    * @version Egret 3.0
    * @platform Web,Native
    */
    var DoubleArray = (function () {
        /**
        * @language zh_CN
        * constructor
        * @version Egret 3.0
        * @platform Web,Native
        */
        function DoubleArray() {
            /**
            * @language zh_CN
            * 键队列
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._keys = new Array();
            /**
            * @language zh_CN
            * 值队列
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._values = new Array();
        }
        /**
        * @language zh_CN
        * 根据键获得下标
        * @param  key（键）
        * @returns 下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        DoubleArray.prototype.getIndexByKey = function (key) {
            return this._keys.indexOf(key);
        };
        /**
        * @language zh_CN
        * 根据键获得值
        * @param    key（键）
        * @returns 值
        * @version Egret 3.0
        * @platform Web,Native
        */
        DoubleArray.prototype.getValueByKey = function (key) {
            var index = this.getIndexByKey(key);
            if (index > -1) {
                return this._values[index];
            }
            return null;
        };
        /**
        * @language zh_CN
        * 放入一个键值对
        * @param    key     键
        * @param    value   值
        * @returns           原来的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        DoubleArray.prototype.put = function (key, value) {
            if (key == null)
                return null;
            var old = this.remove(key);
            this._keys.push(key);
            this._values.push(value);
            return old;
        };
        /**
        * @language zh_CN
        * 移除一个键值对
        * @param    key     键
        * @returns          移除的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        DoubleArray.prototype.remove = function (key) {
            var index = this._keys.indexOf(key);
            var item;
            if (index > -1) {
                item = this._values[index];
                this._keys.splice(index, 1);
                this._values.splice(index, 1);
            }
            return item;
        };
        /**
        * @language zh_CN
        * 获取值的队列
        * @returns          值的队列
        * @version Egret 3.0
        * @platform Web,Native
        */
        DoubleArray.prototype.getValues = function () {
            return this._values;
        };
        /**
        * @language zh_CN
        * 获取键的队列
        * @returns          键的队列
        * @version Egret 3.0
        * @platform Web,Native
        */
        DoubleArray.prototype.getKeys = function () {
            return this._keys;
        };
        /**
        * @language zh_CN
        * 重置该哈希表
        * @version Egret 3.0
        * @platform Web,Native
        */
        DoubleArray.prototype.clear = function () {
            this._values.length = 0;
            this._keys.length = 0;
        };
        return DoubleArray;
    }());
    egret3d.DoubleArray = DoubleArray;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var StaticMergeUtil = (function () {
        function StaticMergeUtil() {
        }
        StaticMergeUtil.bacthingMesh = function (configPasser) {
            var nodes = configPasser.nodeList;
            var mats = configPasser.matDict;
            //收集 帅选条件的mesh集合
            var arr_staticMesh = StaticMergeUtil.collectStaticMesh(nodes);
            var i = 0;
            var preBacthingList = [];
            var finalBacthingList = [];
            var matID;
            var mesh;
            //按材质 来 pack
            for (var key in arr_staticMesh) {
                matID = Number(key);
                preBacthingList = arr_staticMesh[matID];
                //this.checkMaxBacthing(key, preBacthingList) 来检查最大能pack的顶点数量
                finalBacthingList = finalBacthingList.concat(this.batching(matID, this.checkMaxBacthing(matID, preBacthingList)));
            }
            for (var key in arr_staticMesh) {
                preBacthingList = arr_staticMesh[key];
                for (var f in preBacthingList) {
                    mesh = preBacthingList[f].object3d;
                    if (mesh.parent) {
                        mesh.parent.removeChild(mesh);
                    }
                }
            }
            preBacthingList.length = 0;
            return finalBacthingList;
        };
        StaticMergeUtil.checkMaxBacthing = function (matID, preNodes) {
            var maxVerticeIndex = 10000;
            var packs = [];
            var geometry;
            var indexCount = 0;
            var listCount = 0;
            var geometryMatID;
            for (var i = 0; i < preNodes.length; i++) {
                geometry = preNodes[i].object3d.geometry;
                for (var j = 0; j < geometry.subGeometrys.length; j++) {
                    //geometryMatID = preNodes[i]["geometryMatID" + matID.toString()];
                    if (preNodes[i].materialIDs[j] == matID) {
                        if (indexCount + geometry.subGeometrys[j].count < maxVerticeIndex) {
                            packs[listCount] = packs[listCount] || [];
                            packs[listCount].push(preNodes[i]);
                            indexCount = indexCount + geometry.subGeometrys[j].count;
                        }
                        else {
                            listCount++;
                            indexCount = 0;
                            packs[listCount] = packs[listCount] || [];
                            packs[listCount].push(preNodes[i]);
                            indexCount = indexCount + geometry.subGeometrys[j].count;
                        }
                    }
                }
            }
            return packs;
        };
        //过滤 静态的mesh
        StaticMergeUtil.collectStaticMesh = function (nodes) {
            var arr_staticMesh = {};
            var len = 0;
            var mesh;
            var matID;
            for (var i = 0; i < nodes.length; i++) {
                //Mesh
                //static 
                if (nodes[i].type == "Mesh" && nodes[i].staticType == "Batching") {
                    mesh = nodes[i].object3d;
                    len = mesh.geometry.subGeometrys.length;
                    for (var j = 0; j < len; j++) {
                        matID = nodes[i].materialIDs[mesh.geometry.subGeometrys[j].matID];
                        //nodes[i]["geometryMatID"+ matID.toString()] = mesh.geometry.subGeometrys[j].matID;
                        arr_staticMesh[matID] = arr_staticMesh[matID] || [];
                        arr_staticMesh[matID].push(nodes[i]);
                    }
                }
            }
            return arr_staticMesh;
        };
        StaticMergeUtil.sortByZ = function (a, b) {
            return a.z - b.z;
        };
        //合并一个材质列表的物体
        StaticMergeUtil.batching = function (matID, nodes) {
            var _this = this;
            var modelMatrix = egret3d.Matrix4_4.helpMatrix;
            var normalMatrix = egret3d.Matrix4_4.helpMatrix2;
            var mesh;
            var vertexLenth;
            var pos = egret3d.Vector3D.HELP_0;
            var normal = new egret3d.Vector3D();
            var i, count, vertexOffset = 0, indexOffset = 0;
            var totalVertexLength = 0;
            var totalIndexLength = 0;
            var meshs;
            var shareMat;
            var subGeometry;
            var geometryMatID;
            var final = [];
            var indexValue = 0;
            var currentVertexOffset = 0;
            var currentIndexOffset = 0;
            var quaternion = egret3d.Quaternion.HELP_0;
            //当前材质 如果超过最大值就需要分pack
            for (var packIndex = 0; packIndex < nodes.length; packIndex++) {
                meshs = nodes[packIndex];
                totalVertexLength = 0;
                totalIndexLength = 0;
                meshs = meshs.sort(function (a, b) { return _this.sortByZ(a, b); });
                for (i = 0; i < meshs.length; i++) {
                    mesh = meshs[i].object3d;
                    vertexLenth = mesh.geometry.vertexAttLength;
                    for (var g = 0; g < mesh.geometry.subGeometrys.length; g++) {
                        subGeometry = mesh.geometry.subGeometrys[g];
                        if (meshs[i].materialIDs[g] == matID) {
                            geometryMatID = g;
                            //totalVertexLength += subGeometry.count * vertexLenth ;
                            totalVertexLength += subGeometry.count;
                            totalIndexLength += subGeometry.count;
                        }
                    }
                }
                var geometry = new egret3d.Geometry();
                geometry.vertexFormat = meshs[0].object3d.geometry.vertexFormat;
                geometry.vertexCount = totalVertexLength;
                geometry.indexCount = totalIndexLength;
                geometry.buildDefaultSubGeometry();
                var vertexs = geometry.vertexArray;
                var indexs = geometry.indexArray;
                vertexOffset = 0;
                indexOffset = 0;
                //模型 拼接
                for (count = 0; count < meshs.length; count++) {
                    mesh = meshs[count].object3d;
                    var vq = modelMatrix.decompose()[1];
                    quaternion.x = vq.x;
                    quaternion.y = vq.y;
                    quaternion.z = vq.z;
                    quaternion.w = vq.w;
                    modelMatrix.makeTransform(mesh.globalPosition, mesh.globalScale, mesh.globalOrientation);
                    normalMatrix.makeTransform(new egret3d.Vector3D(), mesh.globalScale, mesh.globalOrientation);
                    vertexLenth = mesh.geometry.vertexAttLength;
                    //var subVertexArray: Float32Array;
                    //var subIndexArray: Uint16Array;
                    var vertexBuffer;
                    var indexBuffer;
                    for (var g = 0; g < mesh.geometry.subGeometrys.length; g++) {
                        subGeometry = mesh.geometry.subGeometrys[g];
                        if (meshs[count].materialIDs[g] == matID) {
                            geometryMatID = g;
                            vertexBuffer = mesh.geometry.vertexArray;
                            indexBuffer = mesh.geometry.indexArray;
                            //geomety 顶点拼接
                            for (var i = 0; i < subGeometry.count; ++i) {
                                indexValue = indexBuffer[subGeometry.start + i];
                                currentVertexOffset = vertexOffset + i;
                                pos.x = vertexBuffer[indexValue * vertexLenth];
                                pos.y = vertexBuffer[indexValue * vertexLenth + 1];
                                pos.z = vertexBuffer[indexValue * vertexLenth + 2];
                                normal.x = vertexBuffer[indexValue * vertexLenth + 3];
                                normal.y = vertexBuffer[indexValue * vertexLenth + 4];
                                normal.z = vertexBuffer[indexValue * vertexLenth + 5];
                                modelMatrix.transformVector(pos, egret3d.Vector3D.HELP_1);
                                normalMatrix.transformVector(normal, egret3d.Vector3D.HELP_2);
                                //quaternion.transformVector(normal, Vector3D.HELP_2);
                                vertexs[currentVertexOffset * vertexLenth + 0] = egret3d.Vector3D.HELP_1.x;
                                vertexs[currentVertexOffset * vertexLenth + 1] = egret3d.Vector3D.HELP_1.y;
                                vertexs[currentVertexOffset * vertexLenth + 2] = egret3d.Vector3D.HELP_1.z;
                                vertexs[currentVertexOffset * vertexLenth + 3] = egret3d.Vector3D.HELP_2.x;
                                vertexs[currentVertexOffset * vertexLenth + 4] = egret3d.Vector3D.HELP_2.y;
                                vertexs[currentVertexOffset * vertexLenth + 5] = egret3d.Vector3D.HELP_2.z;
                                for (var j = 6; j < vertexLenth; ++j) {
                                    vertexs[currentVertexOffset * vertexLenth + j] = vertexBuffer[indexValue * vertexLenth + j];
                                }
                            }
                            for (var i = 0; i < subGeometry.count; ++i) {
                                currentIndexOffset = vertexOffset + i;
                                indexs[currentIndexOffset] = currentIndexOffset;
                            }
                            vertexOffset += subGeometry.count;
                            indexOffset += subGeometry.count;
                        }
                    }
                }
                //取共享的材质球
                shareMat = mesh.getMaterial(geometryMatID);
                final.push(new egret3d.Mesh(geometry, shareMat));
            }
            return final;
        };
        return StaticMergeUtil;
    }());
    egret3d.StaticMergeUtil = StaticMergeUtil;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.HUD
    * @classdesc
    * HUD直接渲染在屏幕上的一张贴图</p>
    * 可直接指定2维坐标，贴图的宽度和高度。</p>
    * 其底层渲染也是由4个顶点构成，顶点数据结构有位置信息和uv信息。</p>
    * 其所有的HUD对象的顶点信息数据都是共用的。</p>
    * @version Egret 3.0
    * @platform Web,Native
    */
    var HUD = (function () {
        /**
        * @language zh_CN
        * 创建一个HUD对象
        * @param x 屏幕x坐标 默认值 0
        * @param y 屏幕y坐标 默认值 0
        * @param width hud宽度 默认值 100
        * @param height hud高度 默认值 100
        * @version Egret 3.0
        * @platform Web,Native
        */
        function HUD(x, y, width, height) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (width === void 0) { width = 100; }
            if (height === void 0) { height = 100; }
            this._rectangle = new egret3d.Rectangle();
            this._transformMatrix = new egret3d.Matrix4_4();
            this._change = false;
            this._rotation = new egret3d.Vector3D();
            this._scale = new egret3d.Vector3D(1, 1, 1);
            this._position = new egret3d.Vector3D();
            this._transformComponents = [];
            this._changeTexture = false;
            this._textureStage = false;
            this._vertexFormat = egret3d.VertexFormat.VF_POSITION | egret3d.VertexFormat.VF_UV0;
            this._uv_scale = new Float32Array(2);
            /**
            * @language zh_CN
            * 名字
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.name = "";
            /**
            * @language zh_CN
            * 显示双面的开关。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.bothside = false;
            /**
            * @language zh_CN
            * cull模式。 正面可见ContextConfig.BACK 背面可见ContextConfig.FRONT
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cullMode = egret3d.ContextConfig.BACK;
            /**
            * @language zh_CN
            * 是否可见
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.visible = true;
            this.vsShader = "hud_vs";
            this.fsShader = "hud_V_fs";
            this._passUsage = new egret3d.PassUsage();
            this._attList = new Array();
            this.uniformData = {};
            this._transformComponents.push(this._position);
            this._transformComponents.push(this._rotation);
            this._transformComponents.push(this._scale);
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this._uv_scale[0] = 1.0;
            this._uv_scale[1] = 1.0;
        }
        Object.defineProperty(HUD.prototype, "diffuseTexture", {
            /**
            * @language zh_CN
            * 返回HUD的漫反射贴图。
            * @returns ITexture 漫反射贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._diffuseTexture;
            },
            /**
             * @language zh_CN
             * 设置HUD的漫反射贴图。
             * @param texture ITexture
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                this._changeTexture = true;
                this._diffuseTexture = texture;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "x", {
            /**
            * @language zh_CN
            * 得到x坐标
            * @returns number x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rectangle.x;
            },
            /**
            * @language zh_CN
            * 设置x坐标
            * @param value x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._change = true;
                this._rectangle.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "y", {
            /**
            * @language zh_CN
            * 得到y坐标
            * @returns number y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rectangle.y;
            },
            /**
            * @language zh_CN
            * 设置y坐标
            * @param value y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._change = true;
                this._rectangle.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "width", {
            /**
            * @language zh_CN
            *  得到HUD的宽度
            * @returns number HUD的宽度宽
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rectangle.width;
            },
            /**
            * @language zh_CN
            * 设置HUD的宽度
            * @param value HUD宽
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._change = true;
                this._rectangle.width = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "height", {
            /**
            * @language zh_CN
            * 得到HUD的高度
            * @returns number HUD的高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rectangle.height;
            },
            /**
            * @language zh_CN
            * 设置HUD的高度
            * @param value HUD高
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._change = true;
                this._rectangle.height = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "rotationX", {
            /**
            * @language zh_CN
            * 返回x旋转
            * @returns x旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rotation.x;
            },
            /**
            * @language zh_CN
            * 设置x轴旋转。</p>
            * @param value x轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._change = true;
                if (this._rotation.x == value)
                    return;
                this._rotation.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "rotationY", {
            /**
            * @language zh_CN
            * 返回y旋转
            * @returns y旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rotation.y;
            },
            /**
            * @language zh_CN
            * 设置y轴旋转。</p>
            * @param value y轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._change = true;
                if (this._rotation.y == value)
                    return;
                this._rotation.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "rotationZ", {
            /**
            * @language zh_CN
            * 返回z旋转
            * @returns z旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rotation.z;
            },
            /**
            * @language zh_CN
            * 设置z轴旋转。</p>
            * @param value z轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._change = true;
                if (this._rotation.z == value)
                    return;
                this._rotation.z = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "viewPort", {
            /**
            * @private
            */
            set: function (viewPort) {
                this._viewPort = viewPort;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "uScale", {
            /**
            * @private
            */
            get: function () {
                return this._uv_scale[0];
            },
            /**
            * @private
            */
            set: function (u) {
                //this._change = true;
                this._uv_scale[0] = u;
                if (this._uv_scale[0] > 1.0) {
                    this._uv_scale[0] = 1.0;
                }
                if (this._uv_scale[0] < 0.0) {
                    this._uv_scale[0] = 0.0;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "vScale", {
            /**
            * @private
            */
            get: function () {
                return this._uv_scale[1];
            },
            /**
            * @private
            */
            set: function (v) {
                //this._change = true;
                this._uv_scale[1] = v;
                if (this._uv_scale[1] > 1.0) {
                    this._uv_scale[1] = 1.0;
                }
                if (this._uv_scale[1] < 0.0) {
                    this._uv_scale[1] = 0.0;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "transformMatrix", {
            /**
            * @private
            */
            get: function () {
                if (!this._viewPort) {
                    return this._transformMatrix;
                }
                if (this._change) {
                    //this._scale.x = this._rectangle.width / this._viewPort.width * 2.0;
                    //this._scale.y = this._rectangle.height / this._viewPort.height * 2.0;
                    //this._position.x = -(this._viewPort.width - (this._rectangle.x + this._viewPort.x + this._rectangle.width / 2) * 2.0) * (1 / this._viewPort.width);
                    //this._position.y = (this._viewPort.height - (this._rectangle.y + this._viewPort.y + this._rectangle.height / 2) * 2.0) * (1 / this._viewPort.height);;
                    this._scale.x = this._rectangle.width / this._viewPort.width;
                    this._scale.y = this._rectangle.height / this._viewPort.height;
                    this._position.x = egret3d.MathUtil.ScreenToPosition(this._rectangle.x, this._rectangle.width, this._viewPort.width);
                    this._position.y = -egret3d.MathUtil.ScreenToPosition(this._rectangle.y, this._rectangle.height, this._viewPort.height);
                    this._transformMatrix.recompose(this._transformComponents);
                    this._change = false;
                }
                return this._transformMatrix;
            },
            enumerable: true,
            configurable: true
        });
        HUD.prototype.updateTexture = function (context) {
            var sampler2D;
            for (var index in this._passUsage.sampler2DList) {
                sampler2D = this._passUsage.sampler2DList[index];
                sampler2D.uniformIndex = context.getUniformLocation(this._passUsage.program3D, sampler2D.varName);
                sampler2D.texture = this[sampler2D.varName];
            }
            this._changeTexture = false;
        };
        /**
        * @private
        */
        HUD.prototype.upload = function (context) {
            var self = this;
            if (!self._vertexBuffer3D) {
                self._vertexBuffer3D = context.creatVertexBuffer(HUD.singleQuadData);
            }
            if (!self._indexBuffer3D) {
                self._indexBuffer3D = context.creatIndexBuffer(HUD.singleQuadIndex);
            }
            self._passUsage.vertexShader.shaderType = egret3d.Shader.vertex;
            self._passUsage.fragmentShader.shaderType = egret3d.Shader.fragment;
            self._passUsage.vertexShader.addUseShaderName(self.vsShader);
            self._passUsage.fragmentShader.addUseShaderName(self.fsShader);
            self._passUsage.vertexShader.shader = self._passUsage.vertexShader.getShader(self._passUsage);
            self._passUsage.fragmentShader.shader = self._passUsage.fragmentShader.getShader(self._passUsage);
            self._passUsage.program3D = egret3d.ShaderPool.getProgram(self._passUsage.vertexShader.shader.id, self._passUsage.fragmentShader.shader.id);
            for (var property in self._passUsage) {
                if (property.indexOf("uniform") != -1) {
                    if (self._passUsage[property]) {
                        self._passUsage[property].uniformIndex = context.getUniformLocation(self._passUsage.program3D, property);
                    }
                }
            }
            for (var uniformName in self.uniformData) {
                var uniform = self.uniformData[uniformName];
                uniform.uniformIndex = context.getUniformLocation(self._passUsage.program3D, uniformName);
            }
            self._attList.length = 0;
            var offset = 0;
            if (self._passUsage.attribute_position) {
                if (!self._passUsage.attribute_position.uniformIndex) {
                    self._passUsage.attribute_position.uniformIndex = context.getShaderAttribLocation(self._passUsage.program3D, self._passUsage.attribute_position.varName);
                }
                self._attList.push(self._passUsage.attribute_position);
                self._passUsage.attribute_position.size = egret3d.Geometry.positionSize;
                self._passUsage.attribute_position.dataType = egret3d.ContextConfig.FLOAT;
                self._passUsage.attribute_position.normalized = false;
                self._passUsage.attribute_position.stride = HUD.vertexBytes;
                self._passUsage.attribute_position.offset = offset;
                offset += egret3d.Geometry.positionSize * Float32Array.BYTES_PER_ELEMENT;
            }
            if (self._passUsage.attribute_uv0) {
                if (!self._passUsage.attribute_uv0.uniformIndex) {
                    self._passUsage.attribute_uv0.uniformIndex = context.getShaderAttribLocation(self._passUsage.program3D, self._passUsage.attribute_uv0.varName);
                }
                self._attList.push(self._passUsage.attribute_uv0);
                self._passUsage.attribute_uv0.size = egret3d.Geometry.uvSize;
                self._passUsage.attribute_uv0.dataType = egret3d.ContextConfig.FLOAT;
                self._passUsage.attribute_uv0.normalized = false;
                self._passUsage.attribute_uv0.stride = HUD.vertexBytes;
                self._passUsage.attribute_uv0.offset = offset;
                offset += egret3d.Geometry.uvSize * Float32Array.BYTES_PER_ELEMENT;
            }
            self._passUsage["uv_scale"] = context.getUniformLocation(self._passUsage.program3D, "uv_scale");
        };
        /**
        * @private
        */
        HUD.prototype.draw = function (contextProxy, camera) {
            if (camera === void 0) { camera = null; }
            var self = this;
            if (!self.visible) {
                return;
            }
            if (!self._passUsage.program3D) {
                self.upload(contextProxy);
            }
            contextProxy.setProgram(self._passUsage.program3D);
            contextProxy.bindVertexBuffer(self._vertexBuffer3D);
            contextProxy.bindIndexBuffer(self._indexBuffer3D);
            for (var i = 0; i < self._attList.length; ++i) {
                var attribute = self._attList[i];
                if (attribute.uniformIndex >= 0) {
                    contextProxy.vertexAttribPointer(attribute.uniformIndex, attribute.size, attribute.dataType, attribute.normalized, attribute.stride, attribute.offset);
                }
            }
            if (self._changeTexture) {
                self.updateTexture(contextProxy);
            }
            for (var uniformName in self.uniformData) {
                var uniform = self.uniformData[uniformName];
                switch (uniform.type) {
                    case egret3d.UniformType.uniform1f:
                        contextProxy.uniform1f(uniform.uniformIndex, uniform.data[0]);
                        break;
                    case egret3d.UniformType.uniform1fv:
                        contextProxy.uniform1fv(uniform.uniformIndex, uniform.data);
                        break;
                    case egret3d.UniformType.uniform2f:
                        contextProxy.uniform2f(uniform.uniformIndex, uniform.data[0], uniform.data[1]);
                        break;
                    case egret3d.UniformType.uniform2fv:
                        contextProxy.uniform2fv(uniform.uniformIndex, uniform.data);
                        break;
                    case egret3d.UniformType.uniform3f:
                        contextProxy.uniform3f(uniform.uniformIndex, uniform.data[0], uniform.data[1], uniform.data[2]);
                        break;
                    case egret3d.UniformType.uniform3fv:
                        contextProxy.uniform3fv(uniform.uniformIndex, uniform.data);
                        break;
                    case egret3d.UniformType.uniform4f:
                        contextProxy.uniform4f(uniform.uniformIndex, uniform.data[0], uniform.data[1], uniform.data[2], uniform.data[3]);
                        break;
                    case egret3d.UniformType.uniform4fv:
                        contextProxy.uniform4fv(uniform.uniformIndex, uniform.data);
                        break;
                }
            }
            //texture 2D
            var sampler2D;
            for (var index in self._passUsage.sampler2DList) {
                sampler2D = self._passUsage.sampler2DList[index];
                if (!sampler2D.texture) {
                    continue;
                }
                sampler2D.texture.upload(contextProxy);
                contextProxy.setTexture2DAt(sampler2D.activeTextureIndex, sampler2D.uniformIndex, sampler2D.index, sampler2D.texture.texture2D);
                sampler2D.texture.activeState(contextProxy);
                self._textureStage = false;
            }
            if (self._passUsage.uniform_ViewProjectionMatrix) {
                contextProxy.uniformMatrix4fv(self._passUsage.uniform_ViewProjectionMatrix.uniformIndex, false, self.transformMatrix.rawData);
            }
            if (self._passUsage.uniform_ViewMatrix && camera) {
                contextProxy.uniformMatrix4fv(self._passUsage.uniform_ViewMatrix.uniformIndex, false, camera.viewMatrix.rawData);
            }
            if (self._passUsage.uniform_ProjectionMatrix && camera) {
                contextProxy.uniformMatrix4fv(self._passUsage.uniform_ProjectionMatrix.uniformIndex, false, camera.projectMatrix.rawData);
            }
            if (self._passUsage["uv_scale"] && this._passUsage["uv_scale"] != -1) {
                contextProxy.uniform2f(self._passUsage["uv_scale"], self._uv_scale[0], self._uv_scale[1]);
            }
            contextProxy.setCulling(self.cullMode);
            if (self.bothside) {
                contextProxy.disableCullFace();
            }
            else
                contextProxy.enableCullFace();
            contextProxy.enableBlend();
            contextProxy.setBlendFactors(egret3d.ContextConfig.SRC_ALPHA, egret3d.ContextConfig.ONE_MINUS_SRC_ALPHA);
            contextProxy.drawElement(egret3d.DrawMode.TRIANGLES, 0, 6);
            contextProxy.clear(egret3d.ContextConfig.DEPTH_BUFFER_BIT);
        };
        HUD.singleQuadData = new Float32Array([
            -1.0, -1.0, 0.0, 0.0, 1.0,
            1.0, -1.0, 0.0, 1.0, 1.0,
            1.0, 1.0, 0.0, 1.0, 0.0,
            -1.0, 1.0, 0.0, 0.0, 0.0
        ]);
        HUD.singleQuadIndex = new Uint16Array([0, 1, 2, 0, 2, 3]);
        HUD.vertexBytes = 20;
        return HUD;
    }());
    egret3d.HUD = HUD;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var Egret3DPerformance = (function () {
        function Egret3DPerformance() {
            this._entities = {};
            this.enable = false;
            this.prefix = "";
        }
        Object.defineProperty(Egret3DPerformance.prototype, "entities", {
            get: function () {
                return this._entities;
            },
            enumerable: true,
            configurable: true
        });
        Egret3DPerformance.prototype.getFps = function () {
            var entity = this.getEntity("fps");
            return (entity && entity.averageDelta) ? Math.floor(1000 / entity.averageDelta) : 0;
        };
        Egret3DPerformance.prototype.updateFps = function () {
            if (!this.enable) {
                return;
            }
            this.endCounter("fps");
            this.startCounter("fps", 60);
        };
        Egret3DPerformance.prototype.getNow = function () {
            if (window.performance) {
                return window.performance.now();
            }
            return new Date().getTime();
        };
        Egret3DPerformance.prototype.getEntity = function (key) {
            key = this.prefix + key;
            return this._entities[key];
        };
        Egret3DPerformance.prototype.startCounter = function (key, averageRange) {
            if (!this.enable) {
                return;
            }
            key = this.prefix + key;
            var entity = this._entities[key];
            if (!entity) {
                entity = {
                    start: 0,
                    end: 0,
                    delta: 0,
                    _cache: [],
                    averageRange: 1,
                    averageDelta: 0
                };
                this._entities[key] = entity;
            }
            entity.start = this.getNow();
            entity.averageRange = averageRange || 1;
        };
        Egret3DPerformance.prototype.endCounter = function (key) {
            if (!this.enable) {
                return;
            }
            key = this.prefix + key;
            var entity = this._entities[key];
            if (entity) {
                entity.end = this.getNow();
                entity.delta = entity.end - entity.start;
                if (entity.averageRange > 1) {
                    entity._cache.push(entity.delta);
                    var length = entity._cache.length;
                    if (length >= entity.averageRange) {
                        if (length > entity.averageRange) {
                            entity._cache.shift();
                            length--;
                        }
                        var sum = 0;
                        for (var i = 0; i < length; i++) {
                            sum += entity._cache[i];
                        }
                        entity.averageDelta = sum / length;
                    }
                }
            }
        };
        return Egret3DPerformance;
    }());
    egret3d.Egret3DPerformance = Egret3DPerformance;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Egret3DInspector = (function () {
        function Egret3DInspector() {
            this.updateTime = 1000;
            this.time = 0;
        }
        Egret3DInspector.prototype.show = function (delay, performance, canvas) {
            this.time += delay;
            if (this.time < this.updateTime) {
                return;
            }
            this.showPerformancePanel(performance);
            this.showCollectionPanel(canvas);
            this.time = 0;
        };
        Egret3DInspector.prototype._createPerformancePanel = function () {
            var panel = document.createElement('div');
            panel.style.position = 'absolute';
            panel.style.background = 'rgba(0,0,0,0.5)';
            panel.style.left = '0px';
            panel.style.top = '0px';
            panel.style.pointerEvents = 'none';
            panel.style.color = 'white';
            document.body.appendChild(panel);
            return panel;
        };
        Egret3DInspector.prototype._createCollectionPanel = function () {
            var panel = document.createElement('div');
            panel.style.position = 'absolute';
            panel.style.background = 'rgba(0,0,0,0.5)';
            panel.style.left = '0px';
            panel.style.top = '300px';
            panel.style.pointerEvents = 'none';
            panel.style.color = 'white';
            document.body.appendChild(panel);
            return panel;
        };
        Egret3DInspector.prototype.showPerformancePanel = function (performance) {
            if (!this.performancePanel) {
                this.performancePanel = this._createPerformancePanel();
                performance.enable = true;
            }
            var html = "<span>Performance: </span><br/>";
            var fps = performance.getFps();
            html += "<span>fps: </span>" + (fps || "--") + "<br/>";
            for (var key in performance.entities) {
                if (key === "fps") {
                    continue;
                }
                if (performance.entities[key]) {
                    var entity = performance.entities[key];
                    html += "<span>" + key + ": </span>" + Math.round(entity.averageDelta) + "ms<br/>";
                }
            }
            this.performancePanel.innerHTML = html;
        };
        Egret3DInspector.prototype.showCollectionPanel = function (canvas) {
            if (!this.collectionPanel) {
                this.collectionPanel = this._createCollectionPanel();
            }
            var html = "<span>Collection: </span><br/>";
            for (var i = 0, view3Ds = canvas.view3Ds, l = canvas.view3Ds.length; i < l; i++) {
                // collection debug
                var collection = view3Ds[i].entityCollect;
                html += "<span>view" + i + "-drawCall: </span>" + collection.numberDraw.toString() + "<br/>";
                html += "<span>view" + i + "-vertex  : </span>" + collection.numberVertex.toString() + "<br/>";
                html += "<span>view" + i + "-tris    : </span>" + collection.numberFace.toString() + "<br/>";
                html += "<span>view" + i + "-skin    : </span>" + collection.numberSkin.toString() + "<br/>";
                html += "<span>view" + i + "-proAnim : </span>" + collection.numberAnimation.toString() + "<br/>";
                html += "<span>view" + i + "-particleEmiter: </span>" + collection.numberParticle.toString() + "<br/>";
                var len;
                for (var j = 0; j < egret3d.Layer.layerType.length; j++) {
                    html += "<span>view" + i + "-" + egret3d.Layer.layerType[j] + " layer: </span>" + collection.softLayerRenderItems[egret3d.Layer.layerType[j]].length.toString() + "<br/>";
                }
            }
            this.collectionPanel.innerHTML = html;
        };
        return Egret3DInspector;
    }());
    egret3d.Egret3DInspector = Egret3DInspector;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @class egret3d.View3D
     * @classdesc
     * 渲染视图。</p>
     * view3D 是整个3D引擎的渲染视口，可以控制渲染窗口的大小，渲染的方式。</p>
     * 可以设置不同的相机 Camera3D。</p>
     * 交换不同的场景元素 Scene3D 。</p>
     * 当前的View3D中会有一个Scene3D的节点和一个Camera3D来进行场景中的渲染。
     * 整个渲染的主循环通过 update  。</p>
     * Engre3DCanvas 中的View3D列表会主动调用View3D的update,加入了Engre3DCanvas中的View3D列表后不需要使用者update
     * @includeExample View3D.ts
     * @see egret3d.Camera3D
     * @see egret3d.Scene3D
     * @see egret3d.Egret3DCanvas
     * @version Egret 3.0
     * @platform Web,Native
     */
    var View3D = (function () {
        /**
        * @language zh_CN
        * 构建一个view3d对象 如果不给摄像机 内部会创建一个默认的摄像机
        * @param x 视口的屏幕x坐标
        * @param y 视口的屏幕y坐标
        * @param width 视口的屏幕宽度
        * @param height 视口的屏幕高度
        * @param camera 摄像机 默认参数为null，会在内部新建一个CameraType.perspective 类型的Camera3D
        * @version Egret 3.0
        * @platform Web,Native
        */
        function View3D(x, y, width, height, camera) {
            if (camera === void 0) { camera = null; }
            this.scissorRect = new egret3d.Rectangle();
            this._viewPort = new egret3d.Rectangle();
            this._backColor = new egret3d.Vector3D(0.3, 0.3, 0.6, 1.0);
            this._cleanParmerts = egret3d.Context3DProxy.gl.COLOR_BUFFER_BIT | egret3d.Context3DProxy.gl.DEPTH_BUFFER_BIT;
            this._scene = new egret3d.Scene3D();
            this._huds = new Array();
            this._postList = [];
            this.sunLight = new egret3d.DirectLight(new egret3d.Vector3D(0, -1, 1));
            this._entityCollect = new egret3d.EntityCollect();
            this._entityCollect.root = this._scene;
            this._camera = camera || new egret3d.Camera3D(egret3d.CameraType.perspective);
            this._camera.name = "MainCamera";
            this._scene.addChild(this._camera);
            this._renderQuen = new egret3d.RenderQuen();
            this._renderQuen.mainRender.camera = this._camera;
            this._viewPort.x = x;
            this._viewPort.y = y;
            this._viewPort.width = width;
            this._viewPort.height = height;
            this._camera.aspectRatio = width / height;
            this._camera.updateViewport(x, y, width, height);
            if (this._backImg) {
                this._backImg.x = x;
                this._backImg.y = y;
                this._backImg.width = width;
                this._backImg.height = height;
            }
            this.scissorRect.x = x;
            this.scissorRect.y = y;
            this.scissorRect.width = width;
            this.scissorRect.height = height;
            this._shadowCast = new egret3d.ShadowCast(this);
        }
        Object.defineProperty(View3D.prototype, "renderQuen", {
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._renderQuen;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "shadowCast", {
            /**
            * @language zh_CN
            * 获取控制阴影实例对象
            * @returns ShadowCast 控制阴影实例对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._shadowCast;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "post", {
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (list) {
                this._postList = list;
                if (list.length > 0) {
                    this._postProcessing = this._postProcessing || new egret3d.PostProcessing(this._renderQuen);
                    this._postHUD = this._postHUD || new egret3d.HUD(0, 0, 512, 512);
                    this._postHUD.fsShader = "hud_H_fs";
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 设置是否清除背景缓冲颜色 和 深度
        * @param cleanColor 是否清除背景缓冲颜色
        * @param cleanDepth 是否清除背景缓冲深度
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.blender = function (cleanColor, cleanDepth) {
            this._cleanParmerts = (cleanColor ? egret3d.Context3DProxy.gl.COLOR_BUFFER_BIT : 0) | (cleanDepth ? egret3d.Context3DProxy.gl.DEPTH_BUFFER_BIT : 0);
        };
        Object.defineProperty(View3D.prototype, "backColor", {
            /**
            * @language zh_CN
            * 获取view3d背景颜色
            * @returns number 颜色值 a r g b
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return (this._backColor.w * 255 << 24) | (this._backColor.x * 255 << 16) | (this._backColor.y * 255 << 8) | (this._backColor.z * 255);
            },
            /**
            * @language zh_CN
            * 设置view3d背景颜色
            * @param value  颜色值 a r g b
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._backColor.w = (value >> 24 & 0xff) / 255;
                this._backColor.x = (value >> 16 & 0xff) / 255;
                this._backColor.y = (value >> 8 & 0xff) / 255;
                this._backColor.z = (value & 0xff) / 255;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "backImage", {
            /**
            * @language zh_CN
            * 获取view3d背景贴图
            * @returns ITexture 背景贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._backImg.diffuseTexture;
            },
            /**
            * @language zh_CN
            * 设置view3d背景贴图
            * @param tex 背景贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (tex) {
                if (tex) {
                    this._backImg = this._backImg || new egret3d.HUD();
                    this._backImg.diffuseTexture = tex;
                    this._backImg.x = this.x;
                    this._backImg.y = this.y;
                    this._backImg.width = this.width;
                    this._backImg.height = this.height;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "camera3D", {
            /**
            * @language zh_CN
            * 获取View3d中的渲染摄像机
            * @returns Camera3D 当前View3D的摄像机
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._camera;
            },
            /**
            * @language zh_CN
            * 设置View3d中的渲染摄像机
            * @param value 当前View3D的摄像机
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._camera = value;
                this._camera.aspectRatio = this._viewPort.width / this._viewPort.height;
                this._camera.updateViewport(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
                if (this._quadStage) {
                    this._quadStage.changeCamera();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "scene", {
            /**
            * @language zh_CN
            * 获取View3d中的场景对象
            * @returns Scene3D 场景对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._scene;
            },
            /**
            * @language zh_CN
            * 设置View3d中的场景对象
            * 当前scene 会被替换  你需要你原来的主摄像机加入当前场景中
            * @param sc 当前View3D的场景对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (sc) {
                this._scene = sc;
                this._entityCollect.root = this._scene;
                if (this.camera3D.parent) {
                    this.addChild3D(this._camera);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "x", {
            /**
            * @language zh_CN
            * 获得当前视口的屏幕x坐标
            * @returns number 视口的屏幕x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._viewPort.x;
            },
            /**
            * @language zh_CN
            * 设置当前视口的屏幕x坐标
            * @param x 视口的屏幕x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._viewPort.x = value; // * window.devicePixelRatio;
                this._camera.updateViewport(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
                if (this._backImg) {
                    this._backImg.x = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "y", {
            /**
            * @language zh_CN
            * 获得当前视口的屏幕y坐标
            * @returns number 视口的屏幕y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._viewPort.y;
            },
            /**
            * @language zh_CN
            * 设置当前视口的屏幕y坐标
            * @param y 视口的屏幕y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._viewPort.y = value; //* window.devicePixelRatio ;
                this._camera.updateViewport(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
                if (this._backImg) {
                    this._backImg.y = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "width", {
            /**
            * @language zh_CN
            * 获取视口的屏幕宽度
            * @returns number 视口的屏幕宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._viewPort.width;
            },
            /**
            * @language zh_CN
            * 设置视口的屏幕宽度
            * @param width 视口的屏幕宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._viewPort.width = value; // * window.devicePixelRatio ;
                this._camera.aspectRatio = this._viewPort.width / this._viewPort.height;
                this._camera.updateViewport(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
                if (this._backImg) {
                    this._backImg.width = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "height", {
            /**
            * @language zh_CN
            * 获取视口的屏幕高度
            * @returns number 视口的屏幕高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._viewPort.height;
            },
            /**
            * @language zh_CN
            * 设置视口的屏幕高度
            * @param width 视口的屏幕高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._viewPort.height = value; //* window.devicePixelRatio;
                this._camera.aspectRatio = this._viewPort.width / this._viewPort.height;
                this._camera.updateViewport(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
                if (this._backImg) {
                    this._backImg.height = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "viewPort", {
            /**
            * @language zh_CN
            * 获取视口数据 x y width height
            * @returns Rectangle 视口数据
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._viewPort;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "entityCollect", {
            /**
            * @private
            * @language zh_CN
            * 获取View3D的数据收集对象
            * @returns EntityCollect 数据收集对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._entityCollect;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @private
        * @language zh_CN
        * 获取gui stage
        * @returns QuadStage
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.getGUIStage = function () {
            if (!this._quadStage) {
                this._quadStage = new egret3d.QuadStage(this);
            }
            return this._quadStage;
        };
        /**
        * @language zh_CN
        * 添加一个gui对象
        * @param displayObject displayObject显示对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.addGUI = function (displayObject) {
            if (!this._quadStage) {
                this._quadStage = new egret3d.QuadStage(this);
            }
            this._quadStage.addChild(displayObject);
        };
        /**
        * @language zh_CN
        * 从场景根节点中移除一个gui quad对象
        * @param displayObject displayObject显示对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.removeGUI = function (displayObject) {
            this._quadStage.removeChild(displayObject);
        };
        /**
        * @language zh_CN
        * 添加一个Object3D对象进场景根节点
        * @param child3d Object3D需要添加的对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.addChild3D = function (child3d) {
            this._scene.addChild(child3d);
        };
        /**
        * @language zh_CN
        * 从场景根节点中移除一个Object3D对象
        * @param child3d 需要移除的Object3D对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.removeChild3D = function (child3d) {
            this._scene.removeChild(child3d);
        };
        /**
        * @language zh_CN
        * 检测x y 是否在当前视口内
        * @param x  x 坐标。
        * @param y  y 坐标。
        */
        View3D.prototype.inView3D = function (x, y) {
            return this._viewPort.inner(x, y);
        };
        /**
        * @language zh_CN
        * 添加 HUD 到渲染列表中
        * @param hud 需要增加的HUD
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.addHUD = function (hud) {
            if (this._huds.indexOf(hud) == -1) {
                hud.viewPort = this._viewPort;
                this._huds.push(hud);
            }
        };
        /**
        * @language zh_CN
        * 查找HUD
        * @param name hud 名字
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.findHud = function (name) {
            for (var i = 0; i < this._huds.length; ++i) {
                if (this._huds[i].name == name) {
                    return this._huds[i];
                }
            }
            return null;
        };
        /**
        * @language zh_CN
        * 在渲染列表中删除一个HUD
        * @param hud 需要删除的HUD
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.delHUD = function (hud) {
            var index = this._huds.indexOf(hud);
            if (index >= 0 && index < this._huds.length) {
                this._huds.splice(index, 1);
            }
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.update = function (time, delay) {
            if (egret3d.Egret3DEngine.instance.debug) {
                egret3d.Egret3DEngine.instance.performance.startCounter("updateObject3D", 60);
            }
            this.updateObject3D(this._scene, time, delay);
            if (egret3d.Egret3DEngine.instance.debug) {
                egret3d.Egret3DEngine.instance.performance.endCounter("updateObject3D");
            }
            egret3d.Egret3DCanvas.context3DProxy.viewPort(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
            egret3d.Egret3DCanvas.context3DProxy.setScissorRectangle(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
            if (egret3d.Egret3DEngine.instance.debug) {
                egret3d.Egret3DEngine.instance.performance.startCounter("entityCollect", 60);
            }
            //收集器做物体检测,分类
            this._entityCollect.update(this._camera);
            //检测阴影是否存在接收者，如果有就需要渲染阴影，没有就暂停
            this._shadowCast.shadowRender.enabled = false;
            if (this._entityCollect.numberAcceptShadow > 0) {
                this._shadowCast.shadowRender.enabled = true;
                this._shadowCast.update(this._entityCollect, time, delay);
            }
            if (egret3d.Egret3DEngine.instance.debug) {
                egret3d.Egret3DEngine.instance.performance.endCounter("entityCollect");
            }
            // background
            if (this._cleanParmerts & egret3d.Context3DProxy.gl.COLOR_BUFFER_BIT) {
                egret3d.Egret3DCanvas.context3DProxy.clearColor(this._backColor.x, this._backColor.y, this._backColor.z, this._backColor.w);
            }
            egret3d.Egret3DCanvas.context3DProxy.clear(this._cleanParmerts);
            if (this._backImg) {
                this._backImg.draw(egret3d.Egret3DCanvas.context3DProxy);
            }
            // render quen
            if (egret3d.Egret3DEngine.instance.debug) {
                egret3d.Egret3DEngine.instance.performance.startCounter("draw", 60);
            }
            this._renderQuen.mainRender.camera = this.camera3D;
            this._renderQuen.draw(time, delay, egret3d.Egret3DCanvas.context3DProxy, this._entityCollect, this._viewPort);
            if (egret3d.Egret3DEngine.instance.debug) {
                egret3d.Egret3DEngine.instance.performance.endCounter("draw");
            }
            // post processing
            if (this._postList.length > 0) {
                if (egret3d.Egret3DEngine.instance.debug) {
                    egret3d.Egret3DEngine.instance.performance.startCounter("post", 60);
                }
                this._postProcessing.postArray = this._postList;
                this._postProcessing.draw(time, delay, egret3d.Egret3DCanvas.context3DProxy, this._entityCollect, this.camera3D, this._viewPort);
                if (egret3d.Egret3DEngine.instance.debug) {
                    egret3d.Egret3DEngine.instance.performance.endCounter("post");
                }
            }
            // hud
            for (var i = 0; i < this._huds.length; ++i) {
                this._huds[i].draw(egret3d.Egret3DCanvas.context3DProxy);
            }
            // quad
            if (this._quadStage) {
                if (egret3d.Egret3DEngine.instance.debug) {
                    egret3d.Egret3DEngine.instance.performance.startCounter("GUI", 60);
                }
                this._quadStage.update(time, delay, egret3d.Egret3DCanvas.context3DProxy, this);
                if (egret3d.Egret3DEngine.instance.debug) {
                    egret3d.Egret3DEngine.instance.performance.endCounter("GUI");
                }
            }
        };
        View3D.prototype.updateObject3D = function (object3d, time, delay) {
            if (object3d && object3d.visible) {
                object3d.update(time, delay, this.camera3D);
                for (var i = 0; i < object3d.childs.length; ++i) {
                    this.updateObject3D(object3d.childs[i], time, delay);
                }
            }
        };
        return View3D;
    }());
    egret3d.View3D = View3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var EyesCamera = (function () {
        function EyesCamera(camera, fov, eyeCross) {
            if (fov === void 0) { fov = 55; }
            if (eyeCross === void 0) { eyeCross = 70; }
            this.eyeCross = 70;
            this.eyeRay = new egret3d.Vector3D();
            this.dir = new egret3d.Vector3D();
            this.mainCamera = camera;
            this.leftCamera = new egret3d.Camera3D();
            this.rightCamera = new egret3d.Camera3D();
        }
        EyesCamera.prototype.update = function () {
            this.mainCamera.globalOrientation.transformVector(egret3d.Vector3D.X_AXIS, this.dir);
            this.dir.normalize();
            this.leftCamera.modelMatrix = this.mainCamera.modelMatrix;
            this.rightCamera.modelMatrix = this.mainCamera.modelMatrix;
            var space = this.eyeCross * 0.5;
            this.leftCamera.x += -this.dir.x * space;
            this.leftCamera.y += -this.dir.y * space;
            this.leftCamera.z += -this.dir.z * space;
            this.rightCamera.x += this.dir.x * space;
            this.rightCamera.y += this.dir.y * space;
            this.rightCamera.z += this.dir.z * space;
        };
        return EyesCamera;
    }());
    egret3d.EyesCamera = EyesCamera;
    /**
    * @class egret3d.View3D
    * @classdesc
    * VRView3D 会把场景渲染成两个视口。
    * 两个视口是由不同的摄像机渲染出来的结果，也相当由左右眼。
    * @see egret3d.Camera3D
    * @see egret3d.Scene3D
    * @see egret3d.Egret3DCanvas
    * @version Egret 3.0
    * @platform Web,Native
    */
    var VRView3D = (function (_super) {
        __extends(VRView3D, _super);
        /**
        * @language zh_CN
        * 构建一个view3d对象
        * @param x 视口的屏幕x坐标
        * @param y 视口的屏幕y坐标
        * @param width 视口的屏幕宽度
        * @param height 视口的屏幕高度
        * @version Egret 3.0
        * @platform Web,Native
        */
        function VRView3D(x, y, width, height) {
            _super.call(this, x, y, width, height, new egret3d.Camera3D(egret3d.CameraType.perspective));
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.w = 0;
            /**
            * @private
            * @language zh_CN
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.h = 0;
            this.w = width;
            this.h = height;
            this.init();
        }
        VRView3D.prototype.init = function () {
            this.eyesCamera = new EyesCamera(this.camera3D);
            //this.leftRender = new MultiRender(PassType.diffusePass);
            //this.rightRender = new MultiRender(PassType.diffusePass);
            //this.leftRender.setRenderToTexture(512, 512);
            //this.rightRender.setRenderToTexture(512, 512);
            //this.leftRender.name = "VR_left";
            //this.rightRender.name = "VR_right";
            //this.leftRender.camera = this.eyesCamera.leftCamera;
            //this.rightRender.camera = this.eyesCamera.rightCamera;
            //this._renderQuen.mainRender.enabled = false;
            //this._renderQuen.addRender(this.leftRender);
            //this._renderQuen.addRender(this.rightRender);
            //this._leftHUD = new HUD();
            //this._rightHUD = new HUD();
            //this._leftHUD.vsShader = "hud_vs";
            //this._leftHUD.fsShader = "hud_H_fs";
            //this._rightHUD.vsShader = "hud_vs";
            //this._rightHUD.fsShader = "hud_H_fs";
        };
        /**
        * @private
        * @language zh_CN
        * @version Egret 3.0
        * @platform Web,Native
        */
        VRView3D.prototype.update = function (time, delay) {
            this.eyesCamera.update();
            this.viewPort.width = this.w * 0.5;
            this.viewPort.height = this.h;
            this.viewPort.x = this.w * 0.5 - this.viewPort.width - 10;
            this.viewPort.y = this.h * 0.5 - this.viewPort.height * 0.5;
            this.camera3D = this.eyesCamera.leftCamera;
            _super.prototype.update.call(this, time, delay);
            this.viewPort.width = this.w * 0.5;
            this.viewPort.height = this.h;
            this.viewPort.x = this.w * 0.5 + 10;
            this.viewPort.y = this.h * 0.5 - this.viewPort.height * 0.5;
            this.camera3D = this.eyesCamera.rightCamera;
            _super.prototype.update.call(this, time, delay);
            //this._leftHUD.width = this.width * 0.5;
            //this._leftHUD.height = this.height;
            //this._leftHUD.x = this.width * 0.5 - this._leftHUD.width - 10;//- this.eyesCamera.eyeCross * 0.5;
            //this._leftHUD.y = this.height * 0.5 - this._leftHUD.height * 0.5;
            //this._rightHUD.width = this.width * 0.5;
            //this._rightHUD.height = this.height;
            //this._rightHUD.x = this.width * 0.5 + 10;//this.eyesCamera.eyeCross * 0.5;
            //this._rightHUD.y = this.height * 0.5 - this._rightHUD.height * 0.5;
            //Egret3DCanvas.context3DProxy.viewPort(this._leftHUD.x, this._leftHUD.y, this._leftHUD.width, this._leftHUD.height);
            //Egret3DCanvas.context3DProxy.setScissorRectangle(this._leftHUD.x, this._leftHUD.y, this._leftHUD.width, this._leftHUD.height);
            //this._leftHUD.diffuseTexture = this.leftRender.renderTexture;
            //this._rightHUD.diffuseTexture = this.rightRender.renderTexture;
            //Egret3DCanvas.context3DProxy.viewPort(this._leftHUD.x, this._leftHUD.y, this._leftHUD.width, this._leftHUD.height);
            //Egret3DCanvas.context3DProxy.setScissorRectangle(this._leftHUD.x, this._leftHUD.y, this._leftHUD.width, this._leftHUD.height);
            //this._leftHUD.draw(Egret3DCanvas.context3DProxy, this.camera3D);
            //Egret3DCanvas.context3DProxy.viewPort(this._rightHUD.x, this._rightHUD.y, this._rightHUD.width, this._rightHUD.height);
            //Egret3DCanvas.context3DProxy.setScissorRectangle(this._rightHUD.x, this._rightHUD.y, this._rightHUD.width, this._rightHUD.height);
            //this._rightHUD.draw(Egret3DCanvas.context3DProxy, this.camera3D);
        };
        return VRView3D;
    }(egret3d.View3D));
    egret3d.VRView3D = VRView3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * 注册GUI使用的Texture
    * GUI 使用的贴图只能是公用型的材质,为了提高渲染效率，减少提交次数，gui使用的材质均需要pack起来进行注册
    * @version Egret 3.0
    * @platform Web,Native
    */
    egret3d.registGUITexture = function (texture) {
        texture.upload(Egret3DCanvas.context3DProxy);
        for (var _i = 0, _a = Egret3DCanvas._instance.view3Ds; _i < _a.length; _i++) {
            var v = _a[_i];
            v.getGUIStage().registerTexture(texture);
        }
    };
    /**
    * @class egret3d.Egret3DCanvas
    * @classdesc
    * 3dCanvas 是一个3d渲染画布 它继承EventDispatcher 可以监听部分事件。
    * 如：Event3D.ENTER_FRAME 每帧响应回调事件
    * 一个3d渲染画布里面有多个view3d ，
    * 多个view3d进行渲染
    * @includeExample Egret3DCanvas.ts
    * @see egret3d.EventDispatcher
    * @see egret3d.View3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Egret3DCanvas = (function (_super) {
        __extends(Egret3DCanvas, _super);
        /**
        * @language zh_CN
        * 构造一个Egret3DCanvas对象
        * @param stage2D 从外部注入stage2D，可选
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Egret3DCanvas(stage2D) {
            _super.call(this);
            /**
            * @private
            */
            this.canvas3DRectangle = new egret3d.Rectangle();
            this._view3DS = new Array();
            this.sizeDiry = true;
            this._time = 0;
            this._delay = 0;
            this._renderer = 0;
            //     /**
            //     * @private
            //     */
            //     public static Performance_GPU: number = 0;//优：5.0 中：15
            //     /**
            //     * @private
            //     */
            //     public static Performance_CPU: number = 0;//优：0.5 中：3
            //    /**
            //    * @private
            //    */
            //     public static Performance_Enable: boolean = false;
            /**
            * @language zh_CN
            * Egret3DCanvas X 偏移
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.offsetX = 0;
            /**
            * @language zh_CN
            * Egret3DCanvas Y 偏移
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.offsetY = 0;
            this._start = false;
            this.blend2D = false;
            if (Egret3DCanvas._instance)
                throw new Error("不能重复实例化这个类!");
            Egret3DCanvas._instance = this;
            egret3d.ShaderUtil.instance.load();
            this._envetManager = new egret3d.EventManager(this);
            this.stage2D = stage2D;
            this.blend2D = !!stage2D;
            if (this.blend2D) {
                this.canvas = stage2D.$screen.canvas;
            }
            else {
                this.canvas = document.createElement("canvas");
                this.canvas.style.position = "absolute";
                this.canvas.style.zIndex = "-1";
                // this.canvas.style.transform = "rotate(90deg)";
                // this.canvas.style["-ms-transform"] = "rotate(90deg)";
                // this.canvas.style["-moz-transform"] = "rotate(90deg)";
                // this.canvas.style["-webkit-transform"] = "rotate(90deg)";
                // this.canvas.style["-o-transform"] = "rotate(90deg)" ;
                if (document.getElementsByClassName("egret-player").length > 0) {
                    document.getElementsByClassName("egret-player")[0].appendChild(this.canvas);
                }
                else {
                    document.body.appendChild(this.canvas);
                }
                this.canvas.id = "egret3D";
            }
            this.canvas.oncontextmenu = function () {
                return false;
            };
            Egret3DCanvas.context3DProxy = new egret3d.Context3DProxy();
            egret3d.Context3DProxy.gl = this.canvas.getContext("webgl");
            if (!egret3d.Context3DProxy.gl)
                egret3d.Context3DProxy.gl = this.canvas.getContext("experimental-webgl");
            if (!egret3d.Context3DProxy.gl)
                alert("you drivers not suport webgl");
            //getExtension
            //this.getExtension("WEBGL_draw_buffers"); 
            //this.getExtension("OES_element_index_uint"); 
            //this.getExtension("OES_texture_float"); 
            //this.getExtension("OES_texture_half_float"); 
            //this.getExtension("OES_texture_half_float_linear"); 
            //this.getExtension("WEBGL_depth_texture");
            //this.getExtension("WEBKIT_WEBGL_depth_texture");
            //this.getExtension("MOZ_WEBGL_depth_texture");
            this.create2dContext();
            Egret3DCanvas.context3DProxy.register();
            console.log("this.context3D ==>", egret3d.Context3DProxy.gl);
            egret3d.Input.canvas = this;
            if (this.blend2D) {
                egret3d.Input["instance"].init(this.canvas);
                this.resizeBlend2D();
            }
            this.initEvent();
        }
        Egret3DCanvas.prototype.getExtension = function (name) {
            var ext = egret3d.Context3DProxy.gl.getExtension(name);
            if (!ext) {
                alert("you drivers not suport " + name);
            }
            return ext;
        };
        Egret3DCanvas.prototype.initEvent = function () {
            this._enterFrameEvent3D = new egret3d.Event3D(egret3d.Event3D.ENTER_FRAME);
            this._enterFrameEvent3D.target = this;
        };
        Egret3DCanvas.prototype.create2dContext = function () {
            Egret3DCanvas._canvas2D = document.createElement("canvas");
            Egret3DCanvas._canvas2D.hidden = true;
            Egret3DCanvas._ctx2D = Egret3DCanvas._canvas2D.getContext("2d");
        };
        /**
       * @language zh_CN
       * 获得一张图片的像素值
       * @param imageElement图片数据
       * @param offsetX x方向偏移
       * @param offsetY y方向偏移
       * @param width 获取像素宽度
       * @param height 获取像素高度
       * @version Egret 3.0
       * @platform Web,Native
       */
        Egret3DCanvas.draw2DImage = function (imageElement, offsetX, offsetY, width, height) {
            if (offsetX === void 0) { offsetX = 0; }
            if (offsetY === void 0) { offsetY = 0; }
            if (width === void 0) { width = 1; }
            if (height === void 0) { height = 1; }
            document.body.appendChild(this._canvas2D);
            this._canvas2D.width = imageElement.width;
            this._canvas2D.height = imageElement.height;
            this._ctx2D.drawImage(imageElement, offsetX, offsetX, width, height);
            var imageData = this._ctx2D.getImageData(0, 0, width, height);
            document.body.removeChild(this._canvas2D);
            return imageData;
        };
        Object.defineProperty(Egret3DCanvas.prototype, "x", {
            /**
            * @language zh_CN
            * 获取 Egret3DCanvas 的x坐标
            * @returns number 返回x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.canvas3DRectangle.x;
            },
            /**
            * @language zh_CN
            * 设置 Egret3DCanvas 的x坐标
            * @param x x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this.canvas3DRectangle.x != value && !this.blend2D)
                    this.resize(value, this.canvas3DRectangle.y, this.canvas3DRectangle.width, this.canvas3DRectangle.height);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Egret3DCanvas.prototype, "y", {
            /**
            * @language zh_CN
            * 获取 Egret3DCanvas 的y坐标
            * @returns number 返回y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.canvas3DRectangle.y;
            },
            /**
            * @language zh_CN
            * 设置 Egret3DCanvas 的y坐标
            * @param y y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this.canvas3DRectangle.y != value && !this.blend2D)
                    this.resize(this.canvas3DRectangle.x, value, this.canvas3DRectangle.width, this.canvas3DRectangle.height);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Egret3DCanvas.prototype, "width", {
            /**
            * @language zh_CN
            * 获取 Egret3DCanvas 的宽度
            * @returns number 返回Egret3DCanvas 的宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.canvas3DRectangle.width;
            },
            /**
            * @language zh_CN
            * 设置 Egret3DCanvas 的宽度
            * @param value Egret3DCanvas 的宽度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this.canvas3DRectangle.width != value && !this.blend2D)
                    this.resize(this.canvas3DRectangle.x, this.canvas3DRectangle.y, value, this.canvas3DRectangle.height);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Egret3DCanvas.prototype, "height", {
            /**
            * @language zh_CN
            * 获取 Egret3DCanvas 的高度
            * @returns number 返回Egret3DCanvas 的高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.canvas3DRectangle.height;
            },
            /**
            * @language zh_CN
            * 设置 Egret3DCanvas 的高度
            * @param value Egret3DCanvas 的高度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this.canvas3DRectangle.height != value && !this.blend2D)
                    this.resize(this.canvas3DRectangle.x, this.canvas3DRectangle.y, this.canvas3DRectangle.width, value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Egret3DCanvas.prototype, "view3Ds", {
            /**
            * @language zh_CN
            * 获取 Egret3DCanvas 所有的view3d
            * @returns Array<View3D> 返回Egret3DCanvas view3ds列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._view3DS;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * Egret3DCanvas 中 增加一个view3d
        * @param view3D 增加的渲染视口
        * @version Egret 3.0
        * @platform Web,Native
        */
        Egret3DCanvas.prototype.addView3D = function (view3D) {
            var index = this._view3DS.indexOf(view3D);
            if (index == -1)
                this._view3DS.push(view3D);
        };
        /**
        * @language zh_CN
        * Egret3DCanvas 中 移除一个view3d
        * @param view3D 移除的渲染视口
        * @version Egret 3.0
        * @platform Web,Native
        */
        Egret3DCanvas.prototype.removeView3D = function (view3D) {
            var index = this._view3DS.indexOf(view3D);
            if (index != -1)
                this._view3DS.splice(index, 1);
        };
        Egret3DCanvas.prototype.$render = function () {
            var now = egret3d.Egret3DEngine.instance.performance.getNow();
            // TODO 第一帧可能会有异常
            this._delay = now - this._time;
            this._time = now;
            if (egret3d.Egret3DEngine.instance.debug) {
                egret3d.Egret3DEngine.instance.performance.startCounter("renderer", 60);
            }
            // 处理 enter frame
            this._enterFrameEvent3D.time = this._time;
            this._enterFrameEvent3D.delay = this._delay;
            this.dispatchEvent(this._enterFrameEvent3D);
            // 更新相机
            egret3d.CameraManager.instance.update(this._time, this._delay);
            // 更新views
            for (var i = 0; i < this._view3DS.length; i++) {
                if (egret3d.Egret3DEngine.instance.debug) {
                    egret3d.Egret3DEngine.instance.performance.startCounter("view3D-" + i.toString(), 60);
                    egret3d.Egret3DEngine.instance.performance.prefix = "view3D-" + i.toString() + "-";
                }
                this._view3DS[i].update(this._time, this._delay);
                if (egret3d.Egret3DEngine.instance.debug) {
                    egret3d.Egret3DEngine.instance.performance.prefix = "";
                    egret3d.Egret3DEngine.instance.performance.endCounter("view3D-" + i.toString());
                }
            }
            if (egret3d.Egret3DEngine.instance.debug) {
                egret3d.Egret3DEngine.instance.performance.updateFps();
                egret3d.Egret3DEngine.instance.performance.endCounter("renderer");
                // 这里显示更新inspector
                egret3d.Egret3DEngine.instance.inspector.show(this._delay, egret3d.Egret3DEngine.instance.performance, this);
            }
            if (this.afterRender) {
                this.afterRender();
            }
        };
        /**
         * @language zh_CN
         * Egret3DCanvas 调用一次渲染
         * @version Egret 4.0
         * @platform Web,Native
         */
        Egret3DCanvas.prototype.render = function () {
            if (!this.blend2D) {
                return;
            }
            var context3DProxy = Egret3DCanvas.context3DProxy;
            var gl = egret3d.Context3DProxy.gl;
            context3DProxy.reset();
            context3DProxy.enableDepth();
            context3DProxy.enableCullFace();
            context3DProxy.enableBlend();
            this.$render();
            // 恢复2D上下文
            context3DProxy.disableDepth();
            context3DProxy.disableCullFace();
        };
        Egret3DCanvas.prototype.resizeBlend2D = function () {
            if (this.blend2D) {
                egret3d.Input.scaleX = this.stage2D.$screen["webTouchHandler"].scaleX;
                egret3d.Input.scaleY = this.stage2D.$screen["webTouchHandler"].scaleY;
                this.resize(0, 0, this.canvas.width, this.canvas.height);
                var bouding = this.canvas.getBoundingClientRect();
                this.offsetX = -bouding.left;
                this.offsetY = -bouding.top;
            }
        };
        /**
        * @language zh_CN
        * Egret3DCanvas 开始启动
        * @version Egret 3.0
        * @platform Web,Native
        */
        Egret3DCanvas.prototype.start = function () {
            if (this.blend2D) {
                return;
            }
            this._start = true;
            this.update(0);
            Egret3DCanvas.context3DProxy.enableBlend();
            Egret3DCanvas.context3DProxy.enableCullFace();
            egret3d.Context3DProxy.gl.enable(egret3d.Context3DProxy.gl.SCISSOR_TEST);
            //Context3DProxy.gl.enableVertexAttribArray(0);
            //Context3DProxy.gl.enableVertexAttribArray(1);
            //Context3DProxy.gl.enableVertexAttribArray(2);
            //Context3DProxy.gl.enableVertexAttribArray(3);
            //Context3DProxy.gl.enableVertexAttribArray(4);
            //Context3DProxy.gl.enableVertexAttribArray(5);
            //Context3DProxy.gl.enableVertexAttribArray(6);
            //for (var j: number = 0; j < 8; j++) {
            //    Context3DProxy.gl.disableVertexAttribArray(j);
            //}
        };
        /**
        * @language zh_CN
        * Egret3DCanvas 停止启动
        * @version Egret 3.0
        * @platform Web,Native
        */
        Egret3DCanvas.prototype.stop = function () {
            this._start = false;
        };
        /**
        * @language zh_CN
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        Egret3DCanvas.prototype.update = function (delay) {
            var _this = this;
            if (!this._start) {
                return;
            }
            this.$render();
            egret3d.Context3DProxy.gl.flush();
            requestAnimationFrame(function (delay) { return _this.update(delay); });
        };
        /**
        * @language zh_CN
        * 初始化,并创建显示区域的后台缓冲大小。
        * @param GPU_CONFIG
        * @param canvasRec
        * @event call
        */
        Egret3DCanvas.prototype.resize = function (x, y, width, height) {
            //var meta: HTMLMetaElement = <HTMLMetaElement>document.getElementById("view");
            //meta.content = "width=device-width, initial-scale=" + 1.0 / 2.0 + ", maximum-scale=" + 1.0 / 2.0+ ", user-scalable=no";
            this.canvas3DRectangle.x = x;
            this.canvas3DRectangle.y = y;
            this.canvas3DRectangle.width = width;
            this.canvas3DRectangle.height = height;
            egret3d.ContextConfig.canvasRectangle = this.canvas3DRectangle;
            if (!this.blend2D) {
                this.canvas.style.left = this.canvas3DRectangle.x.toString() + "px";
                this.canvas.style.top = this.canvas3DRectangle.y.toString() + "px";
                this.canvas.width = this.canvas3DRectangle.width;
                this.canvas.height = this.canvas3DRectangle.height;
            }
            else {
                egret3d.Input.scaleX = this.stage2D.$screen["webTouchHandler"].scaleX;
                egret3d.Input.scaleY = this.stage2D.$screen["webTouchHandler"].scaleY;
            }
        };
        // custom context implement
        Egret3DCanvas.prototype.onStart = function (egret2dContext) {
            egret2dContext.setAutoClear(false);
        };
        Egret3DCanvas.prototype.onRender = function (egret2dContext) {
            egret2dContext.save();
            this.render();
            egret2dContext.restore();
        };
        Egret3DCanvas.prototype.onStop = function () {
        };
        Egret3DCanvas.prototype.onResize = function () {
            this.resizeBlend2D();
        };
        return Egret3DCanvas;
    }(egret3d.EventDispatcher));
    egret3d.Egret3DCanvas = Egret3DCanvas;
    egret3d.Stage3D = Egret3DCanvas;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @class egret3D.Egret3DPolicy
     * @classdesc
     */
    var Egret3DPolicy = (function () {
        function Egret3DPolicy() {
        }
        Egret3DPolicy.engineVersion = "4.0.0";
        Egret3DPolicy.exportToolsVersion = ["4.0.0", "3.2.6"];
        Egret3DPolicy.useParticle = true;
        Egret3DPolicy.useAnimEffect = true;
        Egret3DPolicy.useEffect = true;
        Egret3DPolicy.useRibbon = true;
        Egret3DPolicy.useAnimPoseInterpolation = true;
        Egret3DPolicy.useAnimMixInterpolation = true;
        Egret3DPolicy.useAnimCache = false;
        Egret3DPolicy.useLowLoop = false;
        Egret3DPolicy.useLight = true;
        Egret3DPolicy.usePost = true;
        Egret3DPolicy.useCompress = false;
        Egret3DPolicy.useLowLOD = false;
        return Egret3DPolicy;
    }());
    egret3d.Egret3DPolicy = Egret3DPolicy;
    /**
    * @private
    * @language zh_CN
    * 请求全屏
    */
    function requestFullScreen() {
        var dom = document.documentElement;
        if (dom.requestFullscreen) {
            dom.requestFullscreen();
        }
        else if (dom.webkitRequestFullScreen) {
            dom.webkitRequestFullScreen();
        }
    }
    egret3d.requestFullScreen = requestFullScreen;
    /**
    * @private
    * @language zh_CN
    * 退出全屏
    */
    function exitFullscreen() {
        var de = document;
        if (de.exitFullscreen) {
            de.exitFullscreen();
        }
        else if (de.webkitCancelFullScreen) {
            de.webkitCancelFullScreen();
        }
    }
    egret3d.exitFullscreen = exitFullscreen;
    /**
    * @private
    * @language zh_CN
    */
    function setObjectSrceenPos(x, y, target, camera) {
        camera.object3DToScreenRay(new egret3d.Vector3D(), egret3d.Vector3D.HELP_0);
        egret3d.Vector3D.HELP_0.setTo(x, y, egret3d.Vector3D.HELP_0.z);
        camera.ScreenRayToObject3D(egret3d.Vector3D.HELP_0, egret3d.Vector3D.HELP_1);
        target.globalPosition = egret3d.Vector3D.HELP_1;
    }
    egret3d.setObjectSrceenPos = setObjectSrceenPos;
    /**
     * @private
     * @class egret3D.Egret3DEngine
     * @classdesc
     * 引擎库文件加载
     * 引擎库前期加载设置，开发中加载未压缩的编译引擎
     */
    var Egret3DEngine = (function () {
        function Egret3DEngine() {
            /**
             * @private
             **/
            this.performance = new egret3d.Egret3DPerformance();
            /**
             * @private
             **/
            this.inspector = new egret3d.Egret3DInspector();
            this.version = "4.0.0";
            this.jsPath = "js/";
            this.debug = false;
            this._tsconfigs = [];
            this.importList = [];
            this._tsconfigs.push("Egret3D/tsconfig.json");
        }
        //public static get instance(): Egret3DEngine {
        //    return Egret3DEngine._instance;
        //}
        Egret3DEngine.getXHR = function () {
            var xhr = null;
            if (window["XMLHttpRequest"]) {
                xhr = new window["XMLHttpRequest"]();
            }
            else {
                xhr = new ActiveXObject("MSXML2.XMLHTTP");
            }
            return xhr;
        };
        Egret3DEngine.prototype.useDevicePOLICY = function (lv) {
            if (lv === void 0) { lv = 0; }
            switch (lv) {
                case 0:
                    if (this.isWeiXin()) {
                        Egret3DPolicy.useAnimPoseInterpolation = false;
                        Egret3DPolicy.useAnimMixInterpolation = false;
                    }
                    if (this.isAndroid()) {
                        Egret3DPolicy.useAnimPoseInterpolation = false;
                        Egret3DPolicy.useAnimMixInterpolation = false;
                        Egret3DPolicy.useParticle = false;
                    }
                    break;
                default:
                    break;
            }
        };
        Egret3DEngine.prototype.isWeiXin = function () {
            var ua = self.navigator.userAgent.toLowerCase();
            var index = ua.indexOf("micromessenger");
            if (index != -1) {
                return true;
            }
            else {
                return false;
            }
        };
        Egret3DEngine.prototype.isAndroid = function () {
            var ua = self.navigator.userAgent.toLowerCase();
            var index = ua.indexOf("android");
            if (index != -1) {
                return true;
            }
            else {
                return false;
            }
        };
        Egret3DEngine.prototype.addTsconfig = function (path) {
            this._tsconfigs.push(path);
        };
        Egret3DEngine.prototype.setTsconfig = function (index, path) {
            this._tsconfigs[index] = path;
        };
        Egret3DEngine.prototype.clearTsconfig = function () {
            this._tsconfigs.length = 0;
        };
        Egret3DEngine.prototype.preload = function (complete, thisObject) {
            if (thisObject === void 0) { thisObject = null; }
            this._complete = complete;
            this._thisObject = thisObject;
            if (this._tsconfigs.length > 0) {
                this.doLoader(this._tsconfigs[0]);
            }
            else {
                this.onAllLoadComplete();
            }
        };
        Egret3DEngine.prototype.addImportScript = function (path) {
            this.importList.push(path);
        };
        Egret3DEngine.prototype.doLoader = function (path) {
            var _this = this;
            this._currentConfig = path;
            if (this._xhr == null) {
                this._xhr = Egret3DEngine.getXHR();
            }
            if (this._xhr == null) {
                alert("Your browser does not support XMLHTTP.");
                return;
            }
            if (this._xhr.readyState > 0) {
                this._xhr.abort();
            }
            this._xhr.open("GET", path + "?" + Math.random() * 100000, true);
            this._xhr.addEventListener("progress", function (e) { return _this.onProgress(e); }, false);
            this._xhr.addEventListener("readystatechange", function (e) { return _this.onReadyStateChange(e); }, false);
            this._xhr.addEventListener("error", function (e) { return _this.onError(e); }, false);
            this._xhr.responseType = "text";
            this._xhr.send();
        };
        Egret3DEngine.prototype.onProgress = function (event) {
            var e = event.loaded.toString() + event.total;
            //console.log("progress event```" + e);
        };
        Egret3DEngine.prototype.onReadyStateChange = function (event) {
            if (this._xhr.readyState == 4) {
                if (this._xhr.status >= 400 || this._xhr.status == 0) {
                    console.log(this._currentConfig, "load fail");
                }
                else {
                    this.onLoadComplete(this._xhr.responseText);
                }
            }
        };
        Egret3DEngine.prototype.onLoadComplete = function (source) {
            var s_pos = this._currentConfig.lastIndexOf('/');
            var dir = this._currentConfig.substr(0, s_pos + 1);
            var obj = eval("(" + source + ")");
            var importName;
            for (var i = 0; i < obj.files.length; ++i) {
                importName = this.jsPath + dir;
                importName += obj.files[i];
                importName = importName.replace(".ts", ".js");
                this.importList.push(importName);
            }
            var index = this._tsconfigs.indexOf(this._currentConfig);
            if (index == this._tsconfigs.length - 1) {
                this.onAllLoadTsconfigComplete();
            }
            else {
                this._xhr = null;
                this.doLoader(this._tsconfigs[++index]);
            }
        };
        Egret3DEngine.prototype.onError = function (event) {
        };
        Egret3DEngine.prototype.onAllLoadTsconfigComplete = function () {
            if (this.onTsconfig) {
                this.onTsconfig();
            }
            this.startLoadScript(null);
        };
        Egret3DEngine.prototype.onAllLoadComplete = function () {
            if (this._complete) {
                if (this._thisObject) {
                    this._complete.call(this._thisObject);
                }
                else {
                    this._complete();
                }
            }
        };
        Egret3DEngine.prototype.startLoadScript = function (e) {
            var _this = this;
            if (this.importList.length > 0) {
                var egret3DScript = document.createElement("script");
                egret3DScript.src = this.importList.shift();
                egret3DScript.onload = function (e) { return _this.startLoadScript(e); };
                egret3DScript.onerror = function (e) { return _this.loadScriptError(e); };
                document.head.appendChild(egret3DScript);
            }
            else {
                console.log("all complete");
                this.onAllLoadComplete();
            }
        };
        Egret3DEngine.prototype.loadScriptError = function (e) {
            var error = "load Script Error \r\n no file:" + e.srcElement.src;
            alert(error);
            this.startLoadScript(null);
        };
        Egret3DEngine.instance = new Egret3DEngine();
        return Egret3DEngine;
    }());
    egret3d.Egret3DEngine = Egret3DEngine;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var GaussPost = (function () {
        function GaussPost() {
            this._debugHud = new egret3d.HUD();
            this._h_postRender = new egret3d.PostRender("hud_vs", "gaussian_H_fs");
            this._h_postRender.setRenderToTexture(2048, 2048, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB);
            this._v_postRender = new egret3d.PostRender("hud_vs", "gaussian_V_fs"); //"gaussian_V_fs");
        }
        GaussPost.prototype.setRenderTexture = function (width, height) {
            this._v_postRender.setRenderToTexture(width, height, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB);
        };
        GaussPost.prototype.draw = function (time, delay, context3D, collect, camera, backViewPort, posList) {
            this._h_postRender.camera = camera;
            this._h_postRender.needClean = true;
            this._h_postRender.draw(time, delay, context3D, collect, backViewPort, posList);
            posList["final"] = this._h_postRender.renderTexture;
            this._v_postRender.camera = camera;
            this._v_postRender.needClean = true;
            this._v_postRender.draw(time, delay, context3D, collect, backViewPort, posList);
            this._v_postRender["color"] = posList["source"];
            posList["final"] = this._v_postRender.renderTexture;
            //posList["bloomPass"] = this._v_postRender.renderTexture;
            //this._debugHud.viewPort = camera.viewPort;
            //this._debugHud.diffuseTexture = this._v_postRender.renderTexture;
            //this._debugHud.draw(context3D);
        };
        return GaussPost;
    }());
    egret3d.GaussPost = GaussPost;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var BloomPost = (function () {
        function BloomPost(bloom_amount) {
            if (bloom_amount === void 0) { bloom_amount = 0.15; }
            this._debugHud = new egret3d.HUD();
            this.bloom_amount = bloom_amount;
            this.postRender = new egret3d.PostRender("hud_vs", "bloom_fs");
            this.postRender.hud.uniformData["bloom_amount"] = { uniformIndex: -1, type: egret3d.UniformType.uniform1f, data: [bloom_amount] };
        }
        BloomPost.prototype.setRenderTexture = function (width, height, change) {
            if (!this.postRender.renderTexture || change) {
                this.postRender.setRenderToTexture(width, height, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGBA);
            }
        };
        BloomPost.prototype.draw = function (time, delay, context3D, collect, camera, backViewPort, posList) {
            var self = this;
            self.postRender.camera = camera;
            self.postRender.needClean = true;
            this.postRender.hud.uniformData["bloom_amount"].data[0] = self.bloom_amount;
            self.postRender.draw(time, delay, context3D, collect, backViewPort, posList);
            posList["final"] = this.postRender.renderTexture;
        };
        return BloomPost;
    }());
    egret3d.BloomPost = BloomPost;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var Gbuffer = (function () {
        function Gbuffer() {
            this._debugHud = new egret3d.HUD();
            this.postRender = new egret3d.PostRender("hud_vs", "gaussian_H_fs");
        }
        Gbuffer.prototype.setRenderTexture = function (width, height) {
            this.postRender.setRenderToTexture(width, height);
        };
        Gbuffer.prototype.draw = function (time, delay, context3D, collect, camera, backViewPort, posList) {
            this.postRender.camera = camera;
            this.postRender.needClean = true;
            this.postRender.draw(time, delay, context3D, collect, backViewPort, posList);
            posList["final"] = this.postRender.renderTexture;
        };
        return Gbuffer;
    }());
    egret3d.Gbuffer = Gbuffer;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var SizeUtil = (function () {
        function SizeUtil() {
        }
        SizeUtil.prototype.isDimensionValid = function (d) {
            return d >= 1 && d <= SizeUtil.MAX_SIZE && this.isPowerOfTwo(d);
        };
        SizeUtil.prototype.isPowerOfTwo = function (value) {
            return value ? ((value & -value) == value) : false;
        };
        SizeUtil.prototype.getBestPowerOf2 = function (value) {
            var p = 1;
            while (p < value)
                p <<= 1;
            if (p > SizeUtil.MAX_SIZE)
                p = SizeUtil.MAX_SIZE;
            return p;
        };
        SizeUtil.MAX_SIZE = 2048;
        return SizeUtil;
    }());
    egret3d.SizeUtil = SizeUtil;
    /*
    * @private
    */
    egret3d.sizeUtil = new SizeUtil();
    /*
    * @private
    */
    var PostProcessing = (function () {
        function PostProcessing(renderQuen) {
            this.posTex = {};
            this.hud = new egret3d.HUD();
            this._sizeChange = false;
            this._renderQuen = renderQuen;
            this.postArray = [];
        }
        PostProcessing.prototype.draw = function (time, delay, contextProxy, collect, camera, backViewPort) {
            var self = this;
            var post;
            var po;
            if (!self._renderQuen.mainRender.renderTexture) {
                po = camera.maxWidthAndHeight;
                this._renderQuen.mainRender.setRenderToTexture(po.x, po.y, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB);
            }
            self.finalTexture = self.posTex["final"] = self.posTex["source"] = self._renderQuen.mainRender.renderTexture;
            if (self.postArray.length > 2) {
                for (var i = 0; i < self.postArray.length - 1; i++) {
                    post = self.postArray[i];
                    post.renderQuen = self._renderQuen;
                    post.setRenderTexture(po.x, po.y);
                    post.draw(time, delay, contextProxy, collect, camera, backViewPort, self.posTex);
                    self.finalTexture = self.posTex["final"];
                }
            }
            post = self.postArray[self.postArray.length - 1];
            post.renderQuen = self._renderQuen;
            post.draw(time, delay, contextProxy, collect, camera, backViewPort, self.posTex);
        };
        return PostProcessing;
    }());
    egret3d.PostProcessing = PostProcessing;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /*
    * @private
    */
    var ColorCorrectionPost = (function () {
        function ColorCorrectionPost() {
            this.postRender = new egret3d.PostRender("hud_vs", "colorCorrection_fs");
            //this.postRender.setRenderToTexture(2048, 2048, FrameBufferFormat.UNSIGNED_BYTE_RGB);
        }
        ColorCorrectionPost.prototype.setRenderTexture = function (width, height) {
            this.postRender.setRenderToTexture(width, height);
        };
        Object.defineProperty(ColorCorrectionPost.prototype, "lutTexture", {
            get: function () {
                return this._lutTexture;
            },
            set: function (tex) {
                this._lutTexture = tex;
                this.postRender.hud["lutTexture"] = tex;
            },
            enumerable: true,
            configurable: true
        });
        ColorCorrectionPost.prototype.draw = function (time, delay, context3D, collect, camera, backViewPort, posList) {
            this.postRender.camera = camera;
            this.postRender.needClean = true;
            this.postRender.draw(time, delay, context3D, collect, backViewPort, posList);
            posList["final"] = this.postRender.renderTexture;
        };
        return ColorCorrectionPost;
    }());
    egret3d.ColorCorrectionPost = ColorCorrectionPost;
})(egret3d || (egret3d = {}));
